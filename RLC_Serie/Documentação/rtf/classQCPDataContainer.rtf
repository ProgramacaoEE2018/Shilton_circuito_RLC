{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência do <em>Template</em> da Classe QCPDataContainer< DataType >\par \pard\plain 
{\tc\tcl2 \v QCPDataContainer< DataType >}
{\xe \v QCPDataContainer< DataType >}
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The generic data container for one-dimensional plottables. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef QVector< DataType >::{\b const_iterator} {\b const_iterator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef QVector< DataType >::{\b iterator} {\b iterator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataContainer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b autoSqueeze} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAutoSqueeze} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b QCPDataContainer}< DataType > &data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const QVector< DataType > &data, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add} (const {\b QCPDataContainer}< DataType > &data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add} (const QVector< DataType > &data, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add} (const DataType &data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeBefore} (double sortKey)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAfter} (double sortKey)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b remove} (double sortKeyFrom, double sortKeyTo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b remove} (double sortKey)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sort} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b squeeze} (bool preAllocation=true, bool postAllocation=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b constBegin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b constEnd} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b findBegin} (double sortKey, bool expandedRange=true) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b findEnd} (double sortKey, bool expandedRange=true) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b at} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b keyRange} (bool &foundRange, {\b QCP::SignDomain} signDomain={\b QCP::sdBoth})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b valueRange} (bool &foundRange, {\b QCP::SignDomain} signDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b dataRange} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b limitIteratorsToDataRange} ({\b const_iterator} &{\b begin}, {\b const_iterator} &{\b end}, const {\b QCPDataRange} &{\b dataRange}) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b preallocateGrow} (int minimumPreallocSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b performAutoSqueeze} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAutoSqueeze}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< DataType > {\b mData}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mPreallocSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mPreallocIteration}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções Relacionadas\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Note que estas não são funções membros.) \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class DataType > bool {\b qcpLessThanSortKey} (const DataType &a, const DataType &b)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class DataType>\par
class QCPDataContainer< DataType >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The generic data container for one-dimensional plottables. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class template provides a fast container for data storage of one-dimensional data. The data type is specified as template parameter (called {\i DataType}  in the following) and must provide some methods as described in the {\b next section}.\par
The data is stored in a sorted fashion, which allows very quick lookups by the sorted key as well as retrieval of ranges (see {\b findBegin}, {\b findEnd}, {\b keyRange}) using binary search. The container uses a preallocation and a postallocation scheme, such that appending and prepending data (with respect to the sort key) is very fast and minimizes reallocations. If data is added which needs to be inserted between existing keys, the merge usually can be done quickly too, using the fact that existing data is always sorted. The user can further improve performance by specifying that added data is already itself sorted by key, if he can guarantee that this is the case (see for example {\b add(const QVector<DataType> &data, bool alreadySorted)}).\par
The data can be accessed with the provided const iterators ({\b constBegin}, {\b constEnd}). If it is necessary to alter existing data in-place, the non-const iterators can be used ({\b begin}, {\b end}). Changing data members that are not the sort key (for most data types called {\i key} ) is safe from the container's perspective.\par
Great care must be taken however if the sort key is modified through the non-const iterators. For performance reasons, the iterators don't automatically cause a re-sorting upon their manipulation. It is thus the responsibility of the user to leave the container in a sorted state when finished with the data manipulation, before calling any other methods on the container. A complete re-sort (e.g. after finishing all sort key manipulation) can be done by calling {\b sort}. Failing to do so can not be detected by the container efficiently and will cause both rendering artifacts and potential data loss.\par
Implementing one-dimensional plottables that make use of a {\b QCPDataContainer<T>} is usually done by subclassing from {\b QCPAbstractPlottable1D<T>}, which introduces an according {\i mDataContainer}  member and some convenience methods.\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Requirements for the DataType template parameter
\par}
{\tc\tcl2 \v Requirements for the DataType template parameter}
The template parameter {\f2 DataType}  is the type of the stored data points. It must be trivially copyable and have the following public methods, preferably inline:\par
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 double sortKey() const} \par
 Returns the member variable of this data point that is the sort key, defining the ordering in the container. Often this variable is simply called {\i key} .\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 static DataType fromSortKey(double sortKey)} \par
 Returns a new instance of the data type initialized with its sort key set to {\i sortKey} .\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 static bool sortKeyIsMainKey()} \par
 Returns true if the sort key is equal to the main key (see method {\f2 mainKey}  below). For most plottables this is the case. It is not the case for example for {\b QCPCurve}, which uses {\i t}  as sort key and {\i key}  as main key. This is the reason why {\b QCPCurve} unlike {\b QCPGraph} can display parametric curves with loops.\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 double mainKey() const} \par
 Returns the variable of this data point considered the main key. This is commonly the variable that is used as the coordinate of this data point on the key axis of the plottable. This method is used for example when determining the automatic axis rescaling of key axes ({\b QCPAxis::rescale}).\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 double mainValue() const} \par
 Returns the variable of this data point considered the main value. This is commonly the variable that is used as the coordinate of this data point on the value axis of the plottable.\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 {\b QCPRange} valueRange() const} \par
 Returns the range this data point spans in the value axis coordinate. If the data is single-valued (e.g. {\b QCPGraphData}), this is simply a range with both lower and upper set to the main data point value. However if the data points can represent multiple values at once (e.g {\b QCPFinancialData} with its {\i high} , {\i low} , {\i open}  and {\i close}  values at each {\i key} ) this method should return the range those values span. This method is used for example when determining the automatic axis rescaling of value axes ({\b QCPAxis::rescale}). \par
}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definições de tipos\par
\pard\plain 
{\xe \v const_iterator\:QCPDataContainer}
{\xe \v QCPDataContainer\:const_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> typedef QVector<DataType>::{\b const_iterator} {\b QCPDataContainer}< DataType >::{\b const_iterator}}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iterator\:QCPDataContainer}
{\xe \v QCPDataContainer\:iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> typedef QVector<DataType>::{\b iterator} {\b QCPDataContainer}< DataType >::{\b iterator}}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v QCPDataContainer\:QCPDataContainer}
{\xe \v QCPDataContainer\:QCPDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPDataContainer}< DataType >::{\b QCPDataContainer} ()}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b QCPDataContainer} used for plottable classes that represent a series of key-sorted data \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2599                                              :\par
 2600   mAutoSqueeze(true),\par
 2601   mPreallocSize(0),\par
 2602   mPreallocIteration(0)\par
 2603 \{\par
 2604 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções membros\par
\pard\plain 
{\xe \v add\:QCPDataContainer}
{\xe \v QCPDataContainer\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::add (const {\b QCPDataContainer}< DataType > &  {\i data})}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Adds the provided {\i data}  to the current data in this container.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b set}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2665 \{\par
 2666   if (data.isEmpty())\par
 2667     return;\par
 2668   \par
 2669   const int n = data.size();\par
 2670   const int oldSize = size();\par
 2671   \par
 2672   if (oldSize > 0 && !qcpLessThanSortKey<DataType>(*constBegin(), *(data.constEnd()-1))) // prepend if new data keys are all smaller than or equal to existing ones\par
 2673   \{\par
 2674     if (mPreallocSize < n)\par
 2675       preallocateGrow(n);\par
 2676     mPreallocSize -= n;\par
 2677     std::copy(data.constBegin(), data.constEnd(), begin());\par
 2678   \} else // don't need to prepend, so append and merge if necessary\par
 2679   \{\par
 2680     mData.resize(mData.size()+n);\par
 2681     std::copy(data.constBegin(), data.constEnd(), end()-n);\par
 2682     if (oldSize > 0 && !qcpLessThanSortKey<DataType>(*(constEnd()-n-1), *(constEnd()-n))) // if appended range keys aren't all greater than existing ones, merge the two partitions\par
 2683       std::inplace_merge(begin(), end()-n, end(), qcpLessThanSortKey<DataType>);\par
 2684   \}\par
 2685 \}\par
}
}
{\xe \v add\:QCPDataContainer}
{\xe \v QCPDataContainer\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::add (const QVector< DataType > &  {\i data}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the provided data points in {\i data}  to the current data.\par
If you can guarantee that the data points in {\i data}  have ascending order with respect to the DataType's sort key, set {\i alreadySorted}  to true to avoid an unnecessary sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b set}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2697 \{\par
 2698   if (data.isEmpty())\par
 2699     return;\par
 2700   if (isEmpty())\par
 2701   \{\par
 2702     set(data, alreadySorted);\par
 2703     return;\par
 2704   \}\par
 2705   \par
 2706   const int n = data.size();\par
 2707   const int oldSize = size();\par
 2708   \par
 2709   if (alreadySorted && oldSize > 0 && !qcpLessThanSortKey<DataType>(*constBegin(), *(data.constEnd()-1))) // prepend if new data is sorted and keys are all smaller than or equal to existing ones\par
 2710   \{\par
 2711     if (mPreallocSize < n)\par
 2712       preallocateGrow(n);\par
 2713     mPreallocSize -= n;\par
 2714     std::copy(data.constBegin(), data.constEnd(), begin());\par
 2715   \} else // don't need to prepend, so append and then sort and merge if necessary\par
 2716   \{\par
 2717     mData.resize(mData.size()+n);\par
 2718     std::copy(data.constBegin(), data.constEnd(), end()-n);\par
 2719     if (!alreadySorted) // sort appended subrange if it wasn't already sorted\par
 2720       std::sort(end()-n, end(), qcpLessThanSortKey<DataType>);\par
 2721     if (oldSize > 0 && !qcpLessThanSortKey<DataType>(*(constEnd()-n-1), *(constEnd()-n))) // if appended range keys aren't all greater than existing ones, merge the two partitions\par
 2722       std::inplace_merge(begin(), end()-n, end(), qcpLessThanSortKey<DataType>);\par
 2723   \}\par
 2724 \}\par
}
}
{\xe \v add\:QCPDataContainer}
{\xe \v QCPDataContainer\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::add (const DataType &  {\i data})}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Adds the provided single data point to the current data.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2734 \{\par
 2735   if (isEmpty() || !qcpLessThanSortKey<DataType>(data, *(constEnd()-1))) // quickly handle appends if new data key is greater or equal to existing ones\par
 2736   \{\par
 2737     mData.append(data);\par
 2738   \} else if (qcpLessThanSortKey<DataType>(data, *constBegin()))  // quickly handle prepends using preallocated space\par
 2739   \{\par
 2740     if (mPreallocSize < 1)\par
 2741       preallocateGrow(1);\par
 2742     --mPreallocSize;\par
 2743     *begin() = data;\par
 2744   \} else // handle inserts, maintaining sorted keys\par
 2745   \{\par
 2746     QCPDataContainer<DataType>::iterator insertionPoint = std::lower_bound(begin(), end(), data, qcpLessThanSortKey<DataType>);\par
 2747     mData.insert(insertionPoint, data);\par
 2748   \}\par
 2749 \}\par
}
}
{\xe \v at\:QCPDataContainer}
{\xe \v QCPDataContainer\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::const_iterator} {\b QCPDataContainer}< DataType >::at (int  {\i index}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the element with the specified {\i index} . If {\i index}  points beyond the available elements in this container, returns {\b constEnd}, i.e. an iterator past the last valid element.\par
You can use this method to easily obtain iterators from a {\b QCPDataRange}, see the data selection page for an example. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2440 \{ return constBegin()+qBound(0, index, size()); \}\par
}
}
{\xe \v autoSqueeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:autoSqueeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> bool {\b QCPDataContainer}< DataType >::autoSqueeze () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2415 \{ return mAutoSqueeze; \}\par
}
}
{\xe \v begin\:QCPDataContainer}
{\xe \v QCPDataContainer\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::iterator} {\b QCPDataContainer}< DataType >::begin (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a non-const iterator to the first data point in this container.\par
You can manipulate the data points in-place through the non-const iterators, but great care must be taken when manipulating the sort key of a data point, see {\b sort}, or the detailed description of this class. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2436 \{ return mData.begin()+mPreallocSize; \}\par
}
}
{\xe \v clear\:QCPDataContainer}
{\xe \v QCPDataContainer\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::clear ()}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data points.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b remove}, {\b removeAfter}, {\b removeBefore} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2832 \{\par
 2833   mData.clear();\par
 2834   mPreallocIteration = 0;\par
 2835   mPreallocSize = 0;\par
 2836 \}\par
}
}
{\xe \v constBegin\:QCPDataContainer}
{\xe \v QCPDataContainer\:constBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::const_iterator} {\b QCPDataContainer}< DataType >::constBegin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the first data point in this container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2434 \{ return mData.constBegin()+mPreallocSize; \}\par
}
}
{\xe \v constEnd\:QCPDataContainer}
{\xe \v QCPDataContainer\:constEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::const_iterator} {\b QCPDataContainer}< DataType >::constEnd () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the element past the last data point in this container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2435 \{ return mData.constEnd(); \}\par
}
}
{\xe \v dataRange\:QCPDataContainer}
{\xe \v QCPDataContainer\:dataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataRange} {\b QCPDataContainer}< DataType >::dataRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPDataRange} encompassing the entire data set of this container. This means the begin index of the returned range is 0, and the end index is {\b size}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2443 \{ return QCPDataRange(0, size()); \}\par
}
}
{\xe \v end\:QCPDataContainer}
{\xe \v QCPDataContainer\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::iterator} {\b QCPDataContainer}< DataType >::end (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a non-const iterator to the element past the last data point in this container.\par
You can manipulate the data points in-place through the non-const iterators, but great care must be taken when manipulating the sort key of a data point, see {\b sort}, or the detailed description of this class. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2437 \{ return mData.end(); \}\par
}
}
{\xe \v findBegin\:QCPDataContainer}
{\xe \v QCPDataContainer\:findBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPDataContainer}< DataType >::{\b const_iterator} {\b QCPDataContainer}< DataType >::findBegin (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an iterator to the data point with a (sort-)key that is equal to, just below, or just above {\i sortKey} . If {\i expandedRange}  is true, the data point just below {\i sortKey}  will be considered, otherwise the one just above.\par
This can be used in conjunction with {\b findEnd} to iterate over data points within a given key range, including or excluding the bounding data points that are just beyond the specified range.\par
If {\i expandedRange}  is true but there are no data points below {\i sortKey} , {\b constBegin} is returned.\par
If the container is empty, returns {\b constEnd}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findEnd}, {\b QCPPlottableInterface1D::findBegin} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2899 \{\par
 2900   if (isEmpty())\par
 2901     return constEnd();\par
 2902   \par
 2903   QCPDataContainer<DataType>::const_iterator it = std::lower_bound(constBegin(), constEnd(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2904   if (expandedRange && it != constBegin()) // also covers it == constEnd case, and we know --constEnd is valid because mData isn't empty\par
 2905     --it;\par
 2906   return it;\par
 2907 \}\par
}
}
{\xe \v findEnd\:QCPDataContainer}
{\xe \v QCPDataContainer\:findEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPDataContainer}< DataType >::{\b const_iterator} {\b QCPDataContainer}< DataType >::findEnd (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an iterator to the element after the data point with a (sort-)key that is equal to, just above or just below {\i sortKey} . If {\i expandedRange}  is true, the data point just above {\i sortKey}  will be considered, otherwise the one just below.\par
This can be used in conjunction with {\b findBegin} to iterate over data points within a given key range, including the bounding data points that are just below and above the specified range.\par
If {\i expandedRange}  is true but there are no data points above {\i sortKey} , {\b constEnd} is returned.\par
If the container is empty, {\b constEnd} is returned.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findBegin}, {\b QCPPlottableInterface1D::findEnd} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2926 \{\par
 2927   if (isEmpty())\par
 2928     return constEnd();\par
 2929   \par
 2930   QCPDataContainer<DataType>::const_iterator it = std::upper_bound(constBegin(), constEnd(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2931   if (expandedRange && it != constEnd())\par
 2932     ++it;\par
 2933   return it;\par
 2934 \}\par
}
}
{\xe \v isEmpty\:QCPDataContainer}
{\xe \v QCPDataContainer\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> bool {\b QCPDataContainer}< DataType >::isEmpty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this container holds no data points. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2414 \{ return size() == 0; \}\par
}
}
{\xe \v keyRange\:QCPDataContainer}
{\xe \v QCPDataContainer\:keyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPRange} {\b QCPDataContainer}< DataType >::keyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i signDomain} = {\f2 {\b QCP::sdBoth}})}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range encompassed by the (main-)key coordinate of all data points. The output parameter {\i foundRange}  indicates whether a sensible range was found. If this is false, you should not use the returned {\b QCPRange} (e.g. the data container is empty or all points have the same key).\par
Use {\i signDomain}  to control which sign of the key coordinates should be considered. This is relevant e.g. for logarithmic plots which can mathematically only display one sign domain at a time.\par
If the DataType reports that its main key is equal to the sort key ({\i sortKeyIsMainKey} ), as is the case for most plottables, this method uses this fact and finds the range very quickly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b valueRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2953 \{\par
 2954   if (isEmpty())\par
 2955   \{\par
 2956     foundRange = false;\par
 2957     return QCPRange();\par
 2958   \}\par
 2959   QCPRange range;\par
 2960   bool haveLower = false;\par
 2961   bool haveUpper = false;\par
 2962   double current;\par
 2963   \par
 2964   QCPDataContainer<DataType>::const_iterator it = constBegin();\par
 2965   QCPDataContainer<DataType>::const_iterator itEnd = constEnd();\par
 2966   if (signDomain == QCP::sdBoth) // range may be anywhere\par
 2967   \{\par
 2968     if (DataType::sortKeyIsMainKey()) // if DataType is sorted by main key (e.g. QCPGraph, but not QCPCurve), use faster algorithm by finding just first and last key with non-NaN value\par
 2969     \{\par
 2970       while (it != itEnd) // find first non-nan going up from left\par
 2971       \{\par
 2972         if (!qIsNaN(it->mainValue()))\par
 2973         \{\par
 2974           range.lower = it->mainKey();\par
 2975           haveLower = true;\par
 2976           break;\par
 2977         \}\par
 2978         ++it;\par
 2979       \}\par
 2980       it = itEnd;\par
 2981       while (it != constBegin()) // find first non-nan going down from right\par
 2982       \{\par
 2983         --it;\par
 2984         if (!qIsNaN(it->mainValue()))\par
 2985         \{\par
 2986           range.upper = it->mainKey();\par
 2987           haveUpper = true;\par
 2988           break;\par
 2989         \}\par
 2990       \}\par
 2991     \} else // DataType is not sorted by main key, go through all data points and accordingly expand range\par
 2992     \{\par
 2993       while (it != itEnd)\par
 2994       \{\par
 2995         if (!qIsNaN(it->mainValue()))\par
 2996         \{\par
 2997           current = it->mainKey();\par
 2998           if (current < range.lower || !haveLower)\par
 2999           \{\par
 3000             range.lower = current;\par
 3001             haveLower = true;\par
 3002           \}\par
 3003           if (current > range.upper || !haveUpper)\par
 3004           \{\par
 3005             range.upper = current;\par
 3006             haveUpper = true;\par
 3007           \}\par
 3008         \}\par
 3009         ++it;\par
 3010       \}\par
 3011     \}\par
 3012   \} else if (signDomain == QCP::sdNegative) // range may only be in the negative sign domain\par
 3013   \{\par
 3014     while (it != itEnd)\par
 3015     \{\par
 3016       if (!qIsNaN(it->mainValue()))\par
 3017       \{\par
 3018         current = it->mainKey();\par
 3019         if ((current < range.lower || !haveLower) && current < 0)\par
 3020         \{\par
 3021           range.lower = current;\par
 3022           haveLower = true;\par
 3023         \}\par
 3024         if ((current > range.upper || !haveUpper) && current < 0)\par
 3025         \{\par
 3026           range.upper = current;\par
 3027           haveUpper = true;\par
 3028         \}\par
 3029       \}\par
 3030       ++it;\par
 3031     \}\par
 3032   \} else if (signDomain == QCP::sdPositive) // range may only be in the positive sign domain\par
 3033   \{\par
 3034     while (it != itEnd)\par
 3035     \{\par
 3036       if (!qIsNaN(it->mainValue()))\par
 3037       \{\par
 3038         current = it->mainKey();\par
 3039         if ((current < range.lower || !haveLower) && current > 0)\par
 3040         \{\par
 3041           range.lower = current;\par
 3042           haveLower = true;\par
 3043         \}\par
 3044         if ((current > range.upper || !haveUpper) && current > 0)\par
 3045         \{\par
 3046           range.upper = current;\par
 3047           haveUpper = true;\par
 3048         \}\par
 3049       \}\par
 3050       ++it;\par
 3051     \}\par
 3052   \}\par
 3053   \par
 3054   foundRange = haveLower && haveUpper;\par
 3055   return range;\par
 3056 \}\par
}
}
{\xe \v limitIteratorsToDataRange\:QCPDataContainer}
{\xe \v QCPDataContainer\:limitIteratorsToDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::limitIteratorsToDataRange ({\b const_iterator} &  {\i begin}, {\b const_iterator} &  {\i end}, const {\b QCPDataRange} &  {\i dataRange}) const}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes sure {\i begin}  and {\i end}  mark a data range that is both within the bounds of this data container's data, as well as within the specified {\i dataRange} . The initial range described by the passed iterators {\i begin}  and {\i end}  is never expanded, only contracted if necessary.\par
This function doesn't require for {\i dataRange}  to be within the bounds of this data container's valid range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3164 \{\par
 3165   QCPDataRange iteratorRange(begin-constBegin(), end-constBegin());\par
 3166   iteratorRange = iteratorRange.bounded(dataRange.bounded(this->dataRange()));\par
 3167   begin = constBegin()+iteratorRange.begin();\par
 3168   end = constBegin()+iteratorRange.end();\par
 3169 \}\par
}
}
{\xe \v performAutoSqueeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:performAutoSqueeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::performAutoSqueeze (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3212 \{\par
 3213   const int totalAlloc = mData.capacity();\par
 3214   const int postAllocSize = totalAlloc-mData.size();\par
 3215   const int usedSize = size();\par
 3216   bool shrinkPostAllocation = false;\par
 3217   bool shrinkPreAllocation = false;\par
 3218   if (totalAlloc > 650000) // if allocation is larger, shrink earlier with respect to total used size\par
 3219   \{\par
 3220     shrinkPostAllocation = postAllocSize > usedSize*1.5; // QVector grow strategy is 2^n for static data. Watch out not to oscillate!\par
 3221     shrinkPreAllocation = mPreallocSize*10 > usedSize;\par
 3222   \} else if (totalAlloc > 1000) // below 10 MiB raw data be generous with preallocated memory, below 1k points don't even bother\par
 3223   \{\par
 3224     shrinkPostAllocation = postAllocSize > usedSize*5;\par
 3225     shrinkPreAllocation = mPreallocSize > usedSize*1.5; // preallocation can grow into postallocation, so can be smaller\par
 3226   \}\par
 3227   \par
 3228   if (shrinkPreAllocation || shrinkPostAllocation)\par
 3229     squeeze(shrinkPreAllocation, shrinkPostAllocation);\par
 3230 \}\par
}
}
{\xe \v preallocateGrow\:QCPDataContainer}
{\xe \v QCPDataContainer\:preallocateGrow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::preallocateGrow (int  {\i minimumPreallocSize}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3182 \{\par
 3183   if (minimumPreallocSize <= mPreallocSize)\par
 3184     return;\par
 3185   \par
 3186   int newPreallocSize = minimumPreallocSize;\par
 3187   newPreallocSize += (1u<<qBound(4, mPreallocIteration+4, 15)) - 12; // do 4 up to 32768-12 preallocation, doubling in each intermediate iteration\par
 3188   ++mPreallocIteration;\par
 3189   \par
 3190   int sizeDifference = newPreallocSize-mPreallocSize;\par
 3191   mData.resize(mData.size()+sizeDifference);\par
 3192   std::copy_backward(mData.begin()+mPreallocSize, mData.end()-sizeDifference, mData.end());\par
 3193   mPreallocSize = newPreallocSize;\par
 3194 \}\par
}
}
{\xe \v remove\:QCPDataContainer}
{\xe \v QCPDataContainer\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::remove (double  {\i sortKeyFrom}, double  {\i sortKeyTo})}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data points with (sort-)keys between {\i sortKeyFrom}  and {\i sortKeyTo} . if {\i sortKeyFrom}  is greater or equal to {\i sortKeyTo} , the function does nothing. To remove a single data point with known (sort-)key, use {\b remove(double sortKey)}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeBefore}, {\b removeAfter}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2790 \{\par
 2791   if (sortKeyFrom >= sortKeyTo || isEmpty())\par
 2792     return;\par
 2793   \par
 2794   QCPDataContainer<DataType>::iterator it = std::lower_bound(begin(), end(), DataType::fromSortKey(sortKeyFrom), qcpLessThanSortKey<DataType>);\par
 2795   QCPDataContainer<DataType>::iterator itEnd = std::upper_bound(it, end(), DataType::fromSortKey(sortKeyTo), qcpLessThanSortKey<DataType>);\par
 2796   mData.erase(it, itEnd);\par
 2797   if (mAutoSqueeze)\par
 2798     performAutoSqueeze();\par
 2799 \}\par
}
}
{\xe \v remove\:QCPDataContainer}
{\xe \v QCPDataContainer\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::remove (double  {\i sortKey})}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Removes a single data point at {\i sortKey} . If the position is not known with absolute (binary) precision, consider using {\b remove(double sortKeyFrom, double sortKeyTo)} with a small fuzziness interval around the suspected position, depeding on the precision with which the (sort-)key is known.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeBefore}, {\b removeAfter}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2812 \{\par
 2813   QCPDataContainer::iterator it = std::lower_bound(begin(), end(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2814   if (it != end() && it->sortKey() == sortKey)\par
 2815   \{\par
 2816     if (it == begin())\par
 2817       ++mPreallocSize; // don't actually delete, just add it to the preallocated block (if it gets too large, squeeze will take care of it)\par
 2818     else\par
 2819       mData.erase(it);\par
 2820   \}\par
 2821   if (mAutoSqueeze)\par
 2822     performAutoSqueeze();\par
 2823 \}\par
}
}
{\xe \v removeAfter\:QCPDataContainer}
{\xe \v QCPDataContainer\:removeAfter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::removeAfter (double  {\i sortKey})}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data points with (sort-)keys greater than or equal to {\i sortKey} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeBefore}, {\b remove}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2773 \{\par
 2774   QCPDataContainer<DataType>::iterator it = std::upper_bound(begin(), end(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2775   QCPDataContainer<DataType>::iterator itEnd = end();\par
 2776   mData.erase(it, itEnd); // typically adds it to the postallocated block\par
 2777   if (mAutoSqueeze)\par
 2778     performAutoSqueeze();\par
 2779 \}\par
}
}
{\xe \v removeBefore\:QCPDataContainer}
{\xe \v QCPDataContainer\:removeBefore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::removeBefore (double  {\i sortKey})}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data points with (sort-)keys smaller than or equal to {\i sortKey} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeAfter}, {\b remove}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2758 \{\par
 2759   QCPDataContainer<DataType>::iterator it = begin();\par
 2760   QCPDataContainer<DataType>::iterator itEnd = std::lower_bound(begin(), end(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2761   mPreallocSize += itEnd-it; // don't actually delete, just add it to the preallocated block (if it gets too large, squeeze will take care of it)\par
 2762   if (mAutoSqueeze)\par
 2763     performAutoSqueeze();\par
 2764 \}\par
}
}
{\xe \v set\:QCPDataContainer}
{\xe \v QCPDataContainer\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::set (const {\b QCPDataContainer}< DataType > &  {\i data})}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Replaces the current data in this container with the provided {\i data} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b add}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2633 \{\par
 2634   clear();\par
 2635   add(data);\par
 2636 \}\par
}
}
{\xe \v set\:QCPDataContainer}
{\xe \v QCPDataContainer\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::set (const QVector< DataType > &  {\i data}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Replaces the current data in this container with the provided {\i data}  \par
If you can guarantee that the data points in {\i data}  have ascending order with respect to the DataType's sort key, set {\i alreadySorted}  to true to avoid an unnecessary sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b add}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2649 \{\par
 2650   mData = data;\par
 2651   mPreallocSize = 0;\par
 2652   mPreallocIteration = 0;\par
 2653   if (!alreadySorted)\par
 2654     sort();\par
 2655 \}\par
}
}
{\xe \v setAutoSqueeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:setAutoSqueeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::setAutoSqueeze (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the container automatically decides when to release memory from its post- and preallocation pools when data points are removed. By default this is enabled and for typical applications shouldn't be changed.\par
If auto squeeze is disabled, you can manually decide when to release pre-/postallocation with {\b squeeze}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2616 \{\par
 2617   if (mAutoSqueeze != enabled)\par
 2618   \{\par
 2619     mAutoSqueeze = enabled;\par
 2620     if (mAutoSqueeze)\par
 2621       performAutoSqueeze();\par
 2622   \}\par
 2623 \}\par
}
}
{\xe \v size\:QCPDataContainer}
{\xe \v QCPDataContainer\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> int {\b QCPDataContainer}< DataType >::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data points in the container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2413 \{ return mData.size()-mPreallocSize; \}\par
}
}
{\xe \v sort\:QCPDataContainer}
{\xe \v QCPDataContainer\:sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::sort ()}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Re-sorts all data points in the container by their sort key.\par
When setting, adding or removing points using the {\b QCPDataContainer} interface ({\b set}, {\b add}, {\b remove}, etc.), the container makes sure to always stay in a sorted state such that a full resort is never necessary. However, if you choose to directly manipulate the sort key on data points by accessing and modifying it through the non-const iterators ({\b begin}, {\b end}), it is your responsibility to bring the container back into a sorted state before any other methods are called on it. This can be achieved by calling this method immediately after finishing the sort key manipulation. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2851 \{\par
 2852   std::sort(begin(), end(), qcpLessThanSortKey<DataType>);\par
 2853 \}\par
}
}
{\xe \v squeeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:squeeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::squeeze (bool  {\i preAllocation} = {\f2 true}, bool  {\i postAllocation} = {\f2 true})}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees all unused memory that is currently in the preallocation and postallocation pools.\par
Note that {\b QCPDataContainer} automatically decides whether squeezing is necessary, if {\b setAutoSqueeze} is left enabled. It should thus not be necessary to use this method for typical applications.\par
The parameters {\i preAllocation}  and {\i postAllocation}  control whether pre- and/or post allocation should be freed, respectively. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2867 \{\par
 2868   if (preAllocation)\par
 2869   \{\par
 2870     if (mPreallocSize > 0)\par
 2871     \{\par
 2872       std::copy(begin(), end(), mData.begin());\par
 2873       mData.resize(size());\par
 2874       mPreallocSize = 0;\par
 2875     \}\par
 2876     mPreallocIteration = 0;\par
 2877   \}\par
 2878   if (postAllocation)\par
 2879     mData.squeeze();\par
 2880 \}\par
}
}
{\xe \v valueRange\:QCPDataContainer}
{\xe \v QCPDataContainer\:valueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPRange} {\b QCPDataContainer}< DataType >::valueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i signDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()})}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range encompassed by the value coordinates of the data points in the specified key range ({\i inKeyRange} ), using the full {\i DataType::valueRange}  reported by the data points. The output parameter {\i foundRange}  indicates whether a sensible range was found. If this is false, you should not use the returned {\b QCPRange} (e.g. the data container is empty or all points have the same value).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Use {\i signDomain}  to control which sign of the value coordinates should be considered. This is relevant e.g. for logarithmic plots which can mathematically only display one sign domain at a time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b keyRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3076 \{\par
 3077   if (isEmpty())\par
 3078   \{\par
 3079     foundRange = false;\par
 3080     return QCPRange();\par
 3081   \}\par
 3082   QCPRange range;\par
 3083   const bool restrictKeyRange = inKeyRange != QCPRange();\par
 3084   bool haveLower = false;\par
 3085   bool haveUpper = false;\par
 3086   QCPRange current;\par
 3087   QCPDataContainer<DataType>::const_iterator itBegin = constBegin();\par
 3088   QCPDataContainer<DataType>::const_iterator itEnd = constEnd();\par
 3089   if (DataType::sortKeyIsMainKey() && restrictKeyRange)\par
 3090   \{\par
 3091     itBegin = findBegin(inKeyRange.lower);\par
 3092     itEnd = findEnd(inKeyRange.upper);\par
 3093   \}\par
 3094   if (signDomain == QCP::sdBoth) // range may be anywhere\par
 3095   \{\par
 3096     for (QCPDataContainer<DataType>::const_iterator it = itBegin; it != itEnd; ++it)\par
 3097     \{\par
 3098       if (restrictKeyRange && (it->mainKey() < inKeyRange.lower || it->mainKey() > inKeyRange.upper))\par
 3099         continue;\par
 3100       current = it->valueRange();\par
 3101       if ((current.lower < range.lower || !haveLower) && !qIsNaN(current.lower))\par
 3102       \{\par
 3103         range.lower = current.lower;\par
 3104         haveLower = true;\par
 3105       \}\par
 3106       if ((current.upper > range.upper || !haveUpper) && !qIsNaN(current.upper))\par
 3107       \{\par
 3108         range.upper = current.upper;\par
 3109         haveUpper = true;\par
 3110       \}\par
 3111     \}\par
 3112   \} else if (signDomain == QCP::sdNegative) // range may only be in the negative sign domain\par
 3113   \{\par
 3114     for (QCPDataContainer<DataType>::const_iterator it = itBegin; it != itEnd; ++it)\par
 3115     \{\par
 3116       if (restrictKeyRange && (it->mainKey() < inKeyRange.lower || it->mainKey() > inKeyRange.upper))\par
 3117         continue;\par
 3118       current = it->valueRange();\par
 3119       if ((current.lower < range.lower || !haveLower) && current.lower < 0 && !qIsNaN(current.lower))\par
 3120       \{\par
 3121         range.lower = current.lower;\par
 3122         haveLower = true;\par
 3123       \}\par
 3124       if ((current.upper > range.upper || !haveUpper) && current.upper < 0 && !qIsNaN(current.upper))\par
 3125       \{\par
 3126         range.upper = current.upper;\par
 3127         haveUpper = true;\par
 3128       \}\par
 3129     \}\par
 3130   \} else if (signDomain == QCP::sdPositive) // range may only be in the positive sign domain\par
 3131   \{\par
 3132     for (QCPDataContainer<DataType>::const_iterator it = itBegin; it != itEnd; ++it)\par
 3133     \{\par
 3134       if (restrictKeyRange && (it->mainKey() < inKeyRange.lower || it->mainKey() > inKeyRange.upper))\par
 3135         continue;\par
 3136       current = it->valueRange();\par
 3137       if ((current.lower < range.lower || !haveLower) && current.lower > 0 && !qIsNaN(current.lower))\par
 3138       \{\par
 3139         range.lower = current.lower;\par
 3140         haveLower = true;\par
 3141       \}\par
 3142       if ((current.upper > range.upper || !haveUpper) && current.upper > 0 && !qIsNaN(current.upper))\par
 3143       \{\par
 3144         range.upper = current.upper;\par
 3145         haveUpper = true;\par
 3146       \}\par
 3147     \}\par
 3148   \}\par
 3149   \par
 3150   foundRange = haveLower && haveUpper;\par
 3151   return range;\par
 3152 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas e Funções Relacionadas\par
\pard\plain 
{\xe \v qcpLessThanSortKey\:QCPDataContainer}
{\xe \v QCPDataContainer\:qcpLessThanSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > bool qcpLessThanSortKey (const DataType &  {\i a}, const DataType &  {\i b}){\f2 [related]}}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the sort key of {\i a}  is less than the sort key of {\i b} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPDataContainer::sort} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2401 \{ return a.sortKey() < b.sortKey(); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mAutoSqueeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:mAutoSqueeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> bool {\b QCPDataContainer}< DataType >::mAutoSqueeze{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mData\:QCPDataContainer}
{\xe \v QCPDataContainer\:mData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> QVector<DataType> {\b QCPDataContainer}< DataType >::mData{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPreallocIteration\:QCPDataContainer}
{\xe \v QCPDataContainer\:mPreallocIteration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> int {\b QCPDataContainer}< DataType >::mPreallocIteration{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPreallocSize\:QCPDataContainer}
{\xe \v QCPDataContainer\:mPreallocSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> int {\b QCPDataContainer}< DataType >::mPreallocSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documentação para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
}}