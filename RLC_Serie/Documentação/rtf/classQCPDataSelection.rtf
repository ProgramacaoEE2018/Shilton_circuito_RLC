{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência da Classe QCPDataSelection\par \pard\plain 
{\tc\tcl2 \v QCPDataSelection}
{\xe \v QCPDataSelection}
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data set by holding multiple {\b QCPDataRange} instances. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} (const {\b QCPDataRange} &range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b QCPDataSelection} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b QCPDataSelection} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} & {\b operator+=} (const {\b QCPDataSelection} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} & {\b operator+=} (const {\b QCPDataRange} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} & {\b operator-=} (const {\b QCPDataSelection} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} & {\b operator-=} (const {\b QCPDataRange} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dataRangeCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dataPointCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b dataRange} (int index=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPDataRange} > {\b dataRanges} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b span} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addDataRange} (const {\b QCPDataRange} &{\b dataRange}, bool {\b simplify}=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b simplify} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enforceType} ({\b QCP::SelectionType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contains} (const {\b QCPDataSelection} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b intersection} (const {\b QCPDataRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b intersection} (const {\b QCPDataSelection} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b inverse} (const {\b QCPDataRange} &outerRange) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Privados Estáticos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b lessThanDataRangeBegin} (const {\b QCPDataRange} &a, const {\b QCPDataRange} &b)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Privados\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPDataRange} > {\b mDataRanges}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataSelection} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataRange} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataSelection} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataRange} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataSelection} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataRange} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataSelection} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataRange} &a, const {\b QCPDataRange} &b)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções Relacionadas\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Note que estas não são funções membros.) \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QDebug {\b operator<<} (QDebug d, const {\b QCPDataSelection} &selection)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data set by holding multiple {\b QCPDataRange} instances. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b QCPDataSelection} manages multiple instances of {\b QCPDataRange} in order to represent any (possibly disjoint) set of data selection.\par
The data selection can be modified with addition and subtraction operators which take {\b QCPDataSelection} and {\b QCPDataRange} instances, as well as methods such as {\b addDataRange} and {\b clear}. Read access is provided by {\b dataRange}, {\b dataRanges}, {\b dataRangeCount}, etc.\par
The method {\b simplify} is used to join directly adjacent or even overlapping {\b QCPDataRange} instances. {\b QCPDataSelection} automatically simplifies when using the addition/subtraction operators. The only case when {\b simplify} is left to the user, is when calling {\b addDataRange}, with the parameter {\i simplify}  explicitly set to false. This is useful if many data ranges will be added to the selection successively and the overhead for simplifying after each iteration shall be avoided. In this case, you should make sure to call {\b simplify} after completing the operation.\par
Use {\b enforceType} to bring the data selection into a state complying with the constraints for selections defined in {\b QCP::SelectionType}.\par
QCustomPlot's data selection mechanism is based on {\b QCPDataSelection} and {\b QCPDataRange}.\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Iterating over a data selection
\par}
{\tc\tcl2 \v Iterating over a data selection}
As an example, the following code snippet calculates the average value of a graph's data {\b selection}:\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v QCPDataSelection\:QCPDataSelection}
{\xe \v QCPDataSelection\:QCPDataSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPDataSelection::QCPDataSelection (){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an empty {\b QCPDataSelection}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2384 \{\par
 2385 \}\par
}
}
{\xe \v QCPDataSelection\:QCPDataSelection}
{\xe \v QCPDataSelection\:QCPDataSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPDataSelection::QCPDataSelection (const {\b QCPDataRange} &  {\i range}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPDataSelection} containing the provided {\i range} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2391 \{\par
 2392   mDataRanges.append(range);\par
 2393 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções membros\par
\pard\plain 
{\xe \v addDataRange\:QCPDataSelection}
{\xe \v QCPDataSelection\:addDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataSelection::addDataRange (const {\b QCPDataRange} &  {\i dataRange}, bool  {\i simplify} = {\f2 true})}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the given {\i dataRange}  to this data selection. This is equivalent to the += operator but allows disabling immediate simplification by setting {\i simplify}  to false. This can improve performance if adding a very large amount of data ranges successively. In this case, make sure to call {\b simplify} manually, after the operation. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2543 \{\par
 2544   mDataRanges.append(dataRange);\par
 2545   if (simplify)\par
 2546     this->simplify();\par
 2547 \}\par
}
}
{\xe \v clear\:QCPDataSelection}
{\xe \v QCPDataSelection\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataSelection::clear ()}}
\par
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data ranges. The data selection then contains no data points.\par
{\b isEmpty} \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2555 \{\par
 2556   mDataRanges.clear();\par
 2557 \}\par
}
}
{\xe \v contains\:QCPDataSelection}
{\xe \v QCPDataSelection\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataSelection::contains (const {\b QCPDataSelection} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the data selection {\i other}  is contained entirely in this data selection, i.e. all data point indices that are in {\i other}  are also in this data selection.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPDataRange::contains} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2652 \{\par
 2653   if (other.isEmpty()) return false;\par
 2654   \par
 2655   int otherIndex = 0;\par
 2656   int thisIndex = 0;\par
 2657   while (thisIndex < mDataRanges.size() && otherIndex < other.mDataRanges.size())\par
 2658   \{\par
 2659     if (mDataRanges.at(thisIndex).contains(other.mDataRanges.at(otherIndex)))\par
 2660       ++otherIndex;\par
 2661     else\par
 2662       ++thisIndex;\par
 2663   \}\par
 2664   return thisIndex < mDataRanges.size(); // if thisIndex ran all the way to the end to find a containing range for the current otherIndex, other is not contained in this\par
 2665 \}\par
}
}
{\xe \v dataPointCount\:QCPDataSelection}
{\xe \v QCPDataSelection\:dataPointCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPDataSelection::dataPointCount () const}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total number of data points contained in all data ranges that make up this data selection. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2497 \{\par
 2498   int result = 0;\par
 2499   for (int i=0; i<mDataRanges.size(); ++i)\par
 2500     result += mDataRanges.at(i).length();\par
 2501   return result;\par
 2502 \}\par
}
}
{\xe \v dataRange\:QCPDataSelection}
{\xe \v QCPDataSelection\:dataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataRange} QCPDataSelection::dataRange (int  {\i index} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the data range with the specified {\i index} .\par
If the data selection is simplified (the usual state of the selection, see {\b simplify}), the ranges are sorted by ascending data point index.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b dataRangeCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2513 \{\par
 2514   if (index >= 0 && index < mDataRanges.size())\par
 2515   \{\par
 2516     return mDataRanges.at(index);\par
 2517   \} else\par
 2518   \{\par
 2519     qDebug() << Q_FUNC_INFO << "index out of range:" << index;\par
 2520     return QCPDataRange();\par
 2521   \}\par
 2522 \}\par
}
}
{\xe \v dataRangeCount\:QCPDataSelection}
{\xe \v QCPDataSelection\:dataRangeCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPDataSelection::dataRangeCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of ranges that make up the data selection. The ranges can be accessed by {\b dataRange} via their index.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b dataRange}, {\b dataPointCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   949 \{ return mDataRanges.size(); \}\par
}
}
{\xe \v dataRanges\:QCPDataSelection}
{\xe \v QCPDataSelection\:dataRanges}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPDataRange} > QCPDataSelection::dataRanges () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all data ranges that make up the data selection. If the data selection is simplified (the usual state of the selection, see {\b simplify}), the ranges are sorted by ascending data point index.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b dataRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   952 \{ return mDataRanges; \}\par
}
}
{\xe \v enforceType\:QCPDataSelection}
{\xe \v QCPDataSelection\:enforceType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataSelection::enforceType ({\b QCP::SelectionType}  {\i type})}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes sure this data selection conforms to the specified {\i type}  selection type. Before the type is enforced, {\b simplify} is called.\par
Depending on {\i type} , enforcing means adding new data points that were previously not part of the selection, or removing data points from the selection. If the current selection already conforms to {\i type} , the data selection is not changed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCP::SelectionType} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2606 \{\par
 2607   simplify();\par
 2608   switch (type)\par
 2609   \{\par
 2610     case QCP::stNone:\par
 2611     \{\par
 2612       mDataRanges.clear();\par
 2613       break;\par
 2614     \}\par
 2615     case QCP::stWhole:\par
 2616     \{\par
 2617       // whole selection isn't defined by data range, so don't change anything (is handled in plottable methods)\par
 2618       break;\par
 2619     \}\par
 2620     case QCP::stSingleData:\par
 2621     \{\par
 2622       // reduce all data ranges to the single first data point:\par
 2623       if (!mDataRanges.isEmpty())\par
 2624       \{\par
 2625         if (mDataRanges.size() > 1)\par
 2626           mDataRanges = QList<QCPDataRange>() << mDataRanges.first();\par
 2627         if (mDataRanges.first().length() > 1)\par
 2628           mDataRanges.first().setEnd(mDataRanges.first().begin()+1);\par
 2629       \}\par
 2630       break;\par
 2631     \}\par
 2632     case QCP::stDataRange:\par
 2633     \{\par
 2634       mDataRanges = QList<QCPDataRange>() << span();\par
 2635       break;\par
 2636     \}\par
 2637     case QCP::stMultipleDataRanges:\par
 2638     \{\par
 2639       // this is the selection type that allows all concievable combinations of ranges, so do nothing\par
 2640       break;\par
 2641     \}\par
 2642   \}\par
 2643 \}\par
}
}
{\xe \v intersection\:QCPDataSelection}
{\xe \v QCPDataSelection\:intersection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPDataSelection::intersection (const {\b QCPDataRange} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection containing the points which are both in this data selection and in the data range {\i other} .\par
A common use case is to limit an unknown data selection to the valid range of a data container, using {\b QCPDataContainer::dataRange} as {\i other} . One can then safely iterate over the returned data selection without exceeding the data container's bounds. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2676 \{\par
 2677   QCPDataSelection result;\par
 2678   for (int i=0; i<mDataRanges.size(); ++i)\par
 2679     result.addDataRange(mDataRanges.at(i).intersection(other), false);\par
 2680   result.simplify();\par
 2681   return result;\par
 2682 \}\par
}
}
{\xe \v intersection\:QCPDataSelection}
{\xe \v QCPDataSelection\:intersection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPDataSelection::intersection (const {\b QCPDataSelection} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection containing the points which are both in this data selection and in the data selection {\i other} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2689 \{\par
 2690   QCPDataSelection result;\par
 2691   for (int i=0; i<other.dataRangeCount(); ++i)\par
 2692     result += intersection(other.dataRange(i));\par
 2693   result.simplify();\par
 2694   return result;\par
 2695 \}\par
}
}
{\xe \v inverse\:QCPDataSelection}
{\xe \v QCPDataSelection\:inverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPDataSelection::inverse (const {\b QCPDataRange} &  {\i outerRange}) const}}
\par
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection which is the exact inverse of this data selection, with {\i outerRange}  defining the base range on which to invert. If {\i outerRange}  is smaller than the {\b span} of this data selection, it is expanded accordingly.\par
For example, this method can be used to retrieve all unselected segments by setting {\i outerRange}  to the full data range of the plottable, and calling this method on a data selection holding the selected segments. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2707 \{\par
 2708   if (isEmpty())\par
 2709     return QCPDataSelection(outerRange);\par
 2710   QCPDataRange fullRange = outerRange.expanded(span());\par
 2711   \par
 2712   QCPDataSelection result;\par
 2713   // first unselected segment:\par
 2714   if (mDataRanges.first().begin() != fullRange.begin())\par
 2715     result.addDataRange(QCPDataRange(fullRange.begin(), mDataRanges.first().begin()), false);\par
 2716   // intermediate unselected segments:\par
 2717   for (int i=1; i<mDataRanges.size(); ++i)\par
 2718     result.addDataRange(QCPDataRange(mDataRanges.at(i-1).end(), mDataRanges.at(i).begin()), false);\par
 2719   // last unselected segment:\par
 2720   if (mDataRanges.last().end() != fullRange.end())\par
 2721     result.addDataRange(QCPDataRange(mDataRanges.last().end(), fullRange.end()), false);\par
 2722   result.simplify();\par
 2723   return result;\par
 2724 \}\par
}
}
{\xe \v isEmpty\:QCPDataSelection}
{\xe \v QCPDataSelection\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataSelection::isEmpty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if there are no data ranges, and thus no data points, in this {\b QCPDataSelection} instance.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b dataRangeCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   958 \{ return mDataRanges.isEmpty(); \}\par
}
}
{\xe \v lessThanDataRangeBegin\:QCPDataSelection}
{\xe \v QCPDataSelection\:lessThanDataRangeBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool QCPDataSelection::lessThanDataRangeBegin (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [inline]}, {\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   970 \{ return a.begin() < b.begin(); \}\par
}
}
{\xe \v operator!=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataSelection::operator!= (const {\b QCPDataSelection} &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   934 \{ return !(*this == other); \}\par
}
}
{\xe \v operator+=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} & QCPDataSelection::operator+= (const {\b QCPDataSelection} &  {\i other})}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the data selection of {\i other}  to this data selection, and then simplifies this data selection (see {\b simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2419 \{\par
 2420   mDataRanges << other.mDataRanges;\par
 2421   simplify();\par
 2422   return *this;\par
 2423 \}\par
}
}
{\xe \v operator+=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} & QCPDataSelection::operator+= (const {\b QCPDataRange} &  {\i other})}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the data range {\i other}  to this data selection, and then simplifies this data selection (see {\b simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2430 \{\par
 2431   addDataRange(other);\par
 2432   return *this;\par
 2433 \}\par
}
}
{\xe \v operator-=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} & QCPDataSelection::operator-= (const {\b QCPDataSelection} &  {\i other})}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data point indices that are described by {\i other}  from this data selection. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2439 \{\par
 2440   for (int i=0; i<other.dataRangeCount(); ++i)\par
 2441     *this -= other.dataRange(i);\par
 2442   \par
 2443   return *this;\par
 2444 \}\par
}
}
{\xe \v operator-=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} & QCPDataSelection::operator-= (const {\b QCPDataRange} &  {\i other})}}
\par
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data point indices that are described by {\i other}  from this data selection. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2450 \{\par
 2451   if (other.isEmpty() || isEmpty())\par
 2452     return *this;\par
 2453   \par
 2454   simplify();\par
 2455   int i=0;\par
 2456   while (i < mDataRanges.size())\par
 2457   \{\par
 2458     const int thisBegin = mDataRanges.at(i).begin();\par
 2459     const int thisEnd = mDataRanges.at(i).end();\par
 2460     if (thisBegin >= other.end())\par
 2461       break; // since data ranges are sorted after the simplify() call, no ranges which contain other will come after this\par
 2462     \par
 2463     if (thisEnd > other.begin()) // ranges which don't fulfill this are entirely before other and can be ignored\par
 2464     \{\par
 2465       if (thisBegin >= other.begin()) // range leading segment is encompassed\par
 2466       \{\par
 2467         if (thisEnd <= other.end()) // range fully encompassed, remove completely\par
 2468         \{\par
 2469           mDataRanges.removeAt(i);\par
 2470           continue;\par
 2471         \} else // only leading segment is encompassed, trim accordingly\par
 2472           mDataRanges[i].setBegin(other.end());\par
 2473       \} else // leading segment is not encompassed\par
 2474       \{\par
 2475         if (thisEnd <= other.end()) // only trailing segment is encompassed, trim accordingly\par
 2476         \{\par
 2477           mDataRanges[i].setEnd(other.begin());\par
 2478         \} else // other lies inside this range, so split range\par
 2479         \{\par
 2480           mDataRanges[i].setEnd(other.begin());\par
 2481           mDataRanges.insert(i+1, QCPDataRange(other.end(), thisEnd));\par
 2482           break; // since data ranges are sorted (and don't overlap) after simplify() call, we're done here\par
 2483         \}\par
 2484       \}\par
 2485     \}\par
 2486     ++i;\par
 2487   \}\par
 2488   \par
 2489   return *this;\par
 2490 \}\par
}
}
{\xe \v operator==\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataSelection::operator== (const {\b QCPDataSelection} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this selection is identical (contains the same data ranges with the same begin and end indices) to {\i other} .\par
Note that both data selections must be in simplified state (the usual state of the selection, see {\b simplify}) for this operator to return correct results. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2403 \{\par
 2404   if (mDataRanges.size() != other.mDataRanges.size())\par
 2405     return false;\par
 2406   for (int i=0; i<mDataRanges.size(); ++i)\par
 2407   \{\par
 2408     if (mDataRanges.at(i) != other.mDataRanges.at(i))\par
 2409       return false;\par
 2410   \}\par
 2411   return true;\par
 2412 \}\par
}
}
{\xe \v simplify\:QCPDataSelection}
{\xe \v QCPDataSelection\:simplify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataSelection::simplify ()}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sorts all data ranges by range begin index in ascending order, and then joins directly adjacent or overlapping ranges. This can reduce the number of individual data ranges in the selection, and prevents possible double-counting when iterating over the data points held by the data ranges.\par
This method is automatically called when using the addition/subtraction operators. The only case when {\b simplify} is left to the user, is when calling {\b addDataRange}, with the parameter {\i simplify}  explicitly set to false. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2569 \{\par
 2570   // remove any empty ranges:\par
 2571   for (int i=mDataRanges.size()-1; i>=0; --i)\par
 2572   \{\par
 2573     if (mDataRanges.at(i).isEmpty())\par
 2574       mDataRanges.removeAt(i);\par
 2575   \}\par
 2576   if (mDataRanges.isEmpty())\par
 2577     return;\par
 2578   \par
 2579   // sort ranges by starting value, ascending:\par
 2580   std::sort(mDataRanges.begin(), mDataRanges.end(), lessThanDataRangeBegin);\par
 2581   \par
 2582   // join overlapping/contiguous ranges:\par
 2583   int i = 1;\par
 2584   while (i < mDataRanges.size())\par
 2585   \{\par
 2586     if (mDataRanges.at(i-1).end() >= mDataRanges.at(i).begin()) // range i overlaps/joins with i-1, so expand range i-1 appropriately and remove range i from list\par
 2587     \{\par
 2588       mDataRanges[i-1].setEnd(qMax(mDataRanges.at(i-1).end(), mDataRanges.at(i).end()));\par
 2589       mDataRanges.removeAt(i);\par
 2590     \} else\par
 2591       ++i;\par
 2592   \}\par
 2593 \}\par
}
}
{\xe \v span\:QCPDataSelection}
{\xe \v QCPDataSelection\:span}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataRange} QCPDataSelection::span () const}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPDataRange} which spans the entire data selection, including possible intermediate segments which are not part of the original data selection. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2529 \{\par
 2530   if (isEmpty())\par
 2531     return QCPDataRange();\par
 2532   else\par
 2533     return QCPDataRange(mDataRanges.first().begin(), mDataRanges.last().end());\par
 2534 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas e Funções Relacionadas\par
\pard\plain 
{\xe \v operator+\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   980 \{\par
  981   QCPDataSelection result(a);\par
  982   result += b;\par
  983   return result;\par
  984 \}\par
}
}
{\xe \v operator+\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   991 \{\par
  992   QCPDataSelection result(a);\par
  993   result += b;\par
  994   return result;\par
  995 \}\par
}
}
{\xe \v operator+\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1002 \{\par
 1003   QCPDataSelection result(a);\par
 1004   result += b;\par
 1005   return result;\par
 1006 \}\par
}
}
{\xe \v operator+\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1013 \{\par
 1014   QCPDataSelection result(a);\par
 1015   result += b;\par
 1016   return result;\par
 1017 \}\par
}
}
{\xe \v operator-\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1023 \{\par
 1024   QCPDataSelection result(a);\par
 1025   result -= b;\par
 1026   return result;\par
 1027 \}\par
}
}
{\xe \v operator-\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1033 \{\par
 1034   QCPDataSelection result(a);\par
 1035   result -= b;\par
 1036   return result;\par
 1037 \}\par
}
}
{\xe \v operator-\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1043 \{\par
 1044   QCPDataSelection result(a);\par
 1045   result -= b;\par
 1046   return result;\par
 1047 \}\par
}
}
{\xe \v operator-\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1053 \{\par
 1054   QCPDataSelection result(a);\par
 1055   result -= b;\par
 1056   return result;\par
 1057 \}\par
}
}
{\xe \v operator<<\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QDebug operator<< (QDebug  {\i d}, const {\b QCPDataSelection} &  {\i selection}){\f2 [related]}}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints {\i selection}  in a human readable format to the qDebug output. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1074 \{\par
 1075     d.nospace() << "QCPDataSelection(";\par
 1076     for (int i=0; i<selection.dataRangeCount(); ++i)\par
 1077     \{\par
 1078       if (i != 0)\par
 1079         d << ", ";\par
 1080       d << selection.dataRange(i);\par
 1081     \}\par
 1082     d << ")";\par
 1083     return d.space();\par
 1084 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mDataRanges\:QCPDataSelection}
{\xe \v QCPDataSelection\:mDataRanges}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPDataRange}> QCPDataSelection::mDataRanges{\f2 [private]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documentação para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}}