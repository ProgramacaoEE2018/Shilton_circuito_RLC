{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência da Classe QCustomPlot\par \pard\plain 
{\tc\tcl2 \v QCustomPlot}
{\xe \v QCustomPlot}
{\bkmkstart AAAAAAADSU}
{\bkmkend AAAAAAADSU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The central class of the library. This is the QWidget which displays the plot and interacts with the user. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Diagrama de hierarquia para QCustomPlot:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classQCustomPlot__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LayerInsertMode} \{ {\b limBelow}, 
{\b limAbove}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b RefreshPriority} \{ {\b rpImmediateRefresh}, 
{\b rpQueuedRefresh}, 
{\b rpRefreshHint}, 
{\b rpQueuedReplot}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Sinais\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseDoubleClick} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mousePress} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseMove} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseRelease} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseWheel} (QWheelEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b plottableClick} ({\b QCPAbstractPlottable} *{\b plottable}, int dataIndex, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b plottableDoubleClick} ({\b QCPAbstractPlottable} *{\b plottable}, int dataIndex, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b itemClick} ({\b QCPAbstractItem} *{\b item}, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b itemDoubleClick} ({\b QCPAbstractItem} *{\b item}, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b axisClick} ({\b QCPAxis} *axis, {\b QCPAxis::SelectablePart} part, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b axisDoubleClick} ({\b QCPAxis} *axis, {\b QCPAxis::SelectablePart} part, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b legendClick} ({\b QCPLegend} *{\b legend}, {\b QCPAbstractLegendItem} *{\b item}, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b legendDoubleClick} ({\b QCPLegend} *{\b legend}, {\b QCPAbstractLegendItem} *{\b item}, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChangedByUser} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b beforeReplot} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b afterReplot} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} (QWidget *parent=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCustomPlot} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b viewport} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b bufferDevicePixelRatio} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b background} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b backgroundScaled} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b backgroundScaledMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutGrid} * {\b plotLayout} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b antialiasedElements} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b notAntialiasedElements} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b autoAddPlottableToLegend} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QCP::Interactions {\b interactions} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b selectionTolerance} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b noAntialiasingOnDrag} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::PlottingHints {\b plottingHints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::KeyboardModifier {\b multiSelectModifier} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionRectMode} {\b selectionRectMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionRect} * {\b selectionRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b openGl} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setViewport} (const QRect &rect)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBufferDevicePixelRatio} (double ratio)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QPixmap &pm)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode=Qt::KeepAspectRatioByExpanding)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QBrush &brush)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackgroundScaled} (bool scaled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackgroundScaledMode} (Qt::AspectRatioMode mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedElements} (const QCP::AntialiasedElements &{\b antialiasedElements})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedElement} ({\b QCP::AntialiasedElement} antialiasedElement, bool enabled=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNotAntialiasedElements} (const QCP::AntialiasedElements &{\b notAntialiasedElements})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNotAntialiasedElement} ({\b QCP::AntialiasedElement} notAntialiasedElement, bool enabled=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAutoAddPlottableToLegend} (bool on)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInteractions} (const QCP::Interactions &{\b interactions})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInteraction} (const {\b QCP::Interaction} &interaction, bool enabled=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectionTolerance} (int pixels)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNoAntialiasingOnDrag} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPlottingHints} (const QCP::PlottingHints &hints)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPlottingHint} ({\b QCP::PlottingHint} hint, bool enabled=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMultiSelectModifier} (Qt::KeyboardModifier modifier)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectionRectMode} ({\b QCP::SelectionRectMode} mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectionRect} ({\b QCPSelectionRect} *{\b selectionRect})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOpenGl} (bool enabled, int multisampling=16)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b plottable} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b plottable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removePlottable} ({\b QCPAbstractPlottable} *{\b plottable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removePlottable} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b clearPlottables} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b plottableCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractPlottable} * > {\b selectedPlottables} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b plottableAt} (const QPointF &pos, bool onlySelectable=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasPlottable} ({\b QCPAbstractPlottable} *{\b plottable}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b graph} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b graph} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b addGraph} ({\b QCPAxis} *keyAxis=0, {\b QCPAxis} *valueAxis=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeGraph} ({\b QCPGraph} *{\b graph})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeGraph} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b clearGraphs} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b graphCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPGraph} * > {\b selectedGraphs} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractItem} * {\b item} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractItem} * {\b item} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeItem} ({\b QCPAbstractItem} *{\b item})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeItem} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b clearItems} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b itemCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractItem} * > {\b selectedItems} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractItem} * {\b itemAt} (const QPointF &pos, bool onlySelectable=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasItem} ({\b QCPAbstractItem} *{\b item}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b layer} (const QString &name) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b layer} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b currentLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setCurrentLayer} (const QString &name)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setCurrentLayer} ({\b QCPLayer} *{\b layer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b layerCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addLayer} (const QString &name, {\b QCPLayer} *otherLayer=0, {\b LayerInsertMode} insertMode={\b limAbove})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeLayer} ({\b QCPLayer} *{\b layer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveLayer} ({\b QCPLayer} *{\b layer}, {\b QCPLayer} *otherLayer, {\b LayerInsertMode} insertMode={\b limAbove})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b axisRectCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b axisRect} (int index=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxisRect} * > {\b axisRects} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutElement} * {\b layoutElementAt} (const QPointF &pos) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b axisRectAt} (const QPointF &pos) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b rescaleAxes} (bool onlyVisiblePlottables=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b selectedAxes} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLegend} * > {\b selectedLegends} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b deselectAll} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b savePdf} (const QString &fileName, int width=0, int height=0, {\b QCP::ExportPen} exportPen={\b QCP::epAllowCosmetic}, const QString &pdfCreator=QString(), const QString &pdfTitle=QString())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b savePng} (const QString &fileName, int width=0, int height=0, double scale=1.0, int quality=-1, int resolution=96, {\b QCP::ResolutionUnit} resolutionUnit={\b QCP::ruDotsPerInch})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveJpg} (const QString &fileName, int width=0, int height=0, double scale=1.0, int quality=-1, int resolution=96, {\b QCP::ResolutionUnit} resolutionUnit={\b QCP::ruDotsPerInch})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveBmp} (const QString &fileName, int width=0, int height=0, double scale=1.0, int resolution=96, {\b QCP::ResolutionUnit} resolutionUnit={\b QCP::ruDotsPerInch})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveRastered} (const QString &fileName, int width, int height, double scale, const char *format, int quality=-1, int resolution=96, {\b QCP::ResolutionUnit} resolutionUnit={\b QCP::ruDotsPerInch})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b toPixmap} (int width=0, int height=0, double scale=1.0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toPainter} ({\b QCPPainter} *painter, int width=0, int height=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b replot} ({\b QCustomPlot::RefreshPriority} refreshPriority={\b QCustomPlot::rpRefreshHint})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b xAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b yAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b xAxis2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b yAxis2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLegend} * {\b legend}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b minimumSizeHint} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b sizeHint} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b paintEvent} (QPaintEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b resizeEvent} (QResizeEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseDoubleClickEvent} (QMouseEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateLayout} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b axisRemoved} ({\b QCPAxis} *axis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b legendRemoved} ({\b QCPLegend} *{\b legend})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual Q_SLOT void {\b processRectSelection} (QRect rect, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual Q_SLOT void {\b processRectZoom} (QRect rect, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual Q_SLOT void {\b processPointSelection} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b registerPlottable} ({\b QCPAbstractPlottable} *{\b plottable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b registerGraph} ({\b QCPGraph} *{\b graph})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b registerItem} ({\b QCPAbstractItem} *{\b item})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateLayerIndices} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayerable} * {\b layerableAt} (const QPointF &pos, bool onlySelectable, QVariant *selectionDetails=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLayerable} * > {\b layerableListAt} (const QPointF &pos, bool onlySelectable, QList< QVariant > *selectionDetails=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawBackground} ({\b QCPPainter} *painter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupPaintBuffers} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPaintBuffer} * {\b createPaintBuffer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasInvalidatedPaintBuffers} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setupOpenGl} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b freeOpenGl} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mViewport}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mBufferDevicePixelRatio}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutGrid} * {\b mPlotLayout}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAutoAddPlottableToLegend}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractPlottable} * > {\b mPlottables}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPGraph} * > {\b mGraphs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractItem} * > {\b mItems}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLayer} * > {\b mLayers}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mAntialiasedElements}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mNotAntialiasedElements}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::Interactions {\b mInteractions}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mSelectionTolerance}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mNoAntialiasingOnDrag}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBackgroundBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mBackgroundPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mScaledBackgroundPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mBackgroundScaled}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b mBackgroundScaledMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b mCurrentLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::PlottingHints {\b mPlottingHints}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::KeyboardModifier {\b mMultiSelectModifier}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionRectMode} {\b mSelectionRectMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionRect} * {\b mSelectionRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mOpenGl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QSharedPointer< {\b QCPAbstractPaintBuffer} > > {\b mPaintBuffers}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b mMousePressPos}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mMouseHasMoved}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPLayerable} > {\b mMouseEventLayerable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPLayerable} > {\b mMouseSignalLayerable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b mMouseEventLayerableDetails}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b mMouseSignalLayerableDetails}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mReplotting}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mReplotQueued}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mOpenGlMultisamples}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mOpenGlAntialiasedElementsBackup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mOpenGlCacheLabelsBackup}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractPlottable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPGraph}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractItem}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The central class of the library. This is the QWidget which displays the plot and interacts with the user. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For tutorials on how to use {\b QCustomPlot}, see the website\par
{\f2 http://www.qcustomplot.com/} \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerações\par
\pard\plain 
{\xe \v LayerInsertMode\:QCustomPlot}
{\xe \v QCustomPlot\:LayerInsertMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCustomPlot::LayerInsertMode}}}
\par
{\bkmkstart AAAAAAADSV}
{\bkmkend AAAAAAADSV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines how a layer should be inserted relative to an other layer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v limBelow\:QCustomPlot}
{\xe \v QCustomPlot\:limBelow}
{\qr limBelow{\bkmkstart AAAAAAADSW}
{\bkmkend AAAAAAADSW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layer is inserted below other layer. \par
}\cell }{\row }
{\xe \v limAbove\:QCustomPlot}
{\xe \v QCustomPlot\:limAbove}
{\qr limAbove{\bkmkstart AAAAAAADSX}
{\bkmkend AAAAAAADSX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layer is inserted above other layer. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3603                        \{ limBelow  \par
 3604                          ,limAbove \par
 3605                        \};\par
}
}
{\xe \v RefreshPriority\:QCustomPlot}
{\xe \v QCustomPlot\:RefreshPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCustomPlot::RefreshPriority}}}
\par
{\bkmkstart AAAAAAADSY}
{\bkmkend AAAAAAADSY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines with what timing the {\b QCustomPlot} surface is refreshed after a replot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b replot} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v rpImmediateRefresh\:QCustomPlot}
{\xe \v QCustomPlot\:rpImmediateRefresh}
{\qr rpImmediateRefresh{\bkmkstart AAAAAAADSZ}
{\bkmkend AAAAAAADSZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replots immediately and repaints the widget immediately by calling QWidget::repaint() after the replot. \par
}\cell }{\row }
{\xe \v rpQueuedRefresh\:QCustomPlot}
{\xe \v QCustomPlot\:rpQueuedRefresh}
{\qr rpQueuedRefresh{\bkmkstart AAAAAAADTA}
{\bkmkend AAAAAAADTA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replots immediately, but queues the widget repaint, by calling QWidget::update() after the replot. This way multiple redundant widget repaints can be avoided. \par
}\cell }{\row }
{\xe \v rpRefreshHint\:QCustomPlot}
{\xe \v QCustomPlot\:rpRefreshHint}
{\qr rpRefreshHint{\bkmkstart AAAAAAADTB}
{\bkmkend AAAAAAADTB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether to use immediate or queued refresh depends on whether the plotting hint {\b QCP::phImmediateRefresh} is set, see {\b setPlottingHints}. \par
}\cell }{\row }
{\xe \v rpQueuedReplot\:QCustomPlot}
{\xe \v QCustomPlot\:rpQueuedReplot}
{\qr rpQueuedReplot{\bkmkstart AAAAAAADTC}
{\bkmkend AAAAAAADTC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queues the entire replot for the next event loop iteration. This way multiple redundant replots can be avoided. The actual replot is then done with {\b rpRefreshHint} priority. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3613                        \{ rpImmediateRefresh \par
 3614                          ,rpQueuedRefresh   \par
 3615                          ,rpRefreshHint     \par
 3616                          ,rpQueuedReplot    \par
 3617                        \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v QCustomPlot\:QCustomPlot}
{\xe \v QCustomPlot\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCustomPlot::QCustomPlot (QWidget *  {\i parent} = {\f2 0}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAADTD}
{\bkmkend AAAAAAADTD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b QCustomPlot} and sets reasonable default values. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12848                                         :\par
12849   QWidget(parent),\par
12850   xAxis(0),\par
12851   yAxis(0),\par
12852   xAxis2(0),\par
12853   yAxis2(0),\par
12854   legend(0),\par
12855   mBufferDevicePixelRatio(1.0), // will be adapted to primary screen below\par
12856   mPlotLayout(0),\par
12857   mAutoAddPlottableToLegend(true),\par
12858   mAntialiasedElements(QCP::aeNone),\par
12859   mNotAntialiasedElements(QCP::aeNone),\par
12860   mInteractions(0),\par
12861   mSelectionTolerance(8),\par
12862   mNoAntialiasingOnDrag(false),\par
12863   mBackgroundBrush(Qt::white, Qt::SolidPattern),\par
12864   mBackgroundScaled(true),\par
12865   mBackgroundScaledMode(Qt::KeepAspectRatioByExpanding),\par
12866   mCurrentLayer(0),\par
12867   mPlottingHints(QCP::phCacheLabels|QCP::phImmediateRefresh),\par
12868   mMultiSelectModifier(Qt::ControlModifier),\par
12869   mSelectionRectMode(QCP::srmNone),\par
12870   mSelectionRect(0),\par
12871   mOpenGl(false),\par
12872   mMouseHasMoved(false),\par
12873   mMouseEventLayerable(0),\par
12874   mMouseSignalLayerable(0),\par
12875   mReplotting(false),\par
12876   mReplotQueued(false),\par
12877   mOpenGlMultisamples(16),\par
12878   mOpenGlAntialiasedElementsBackup(QCP::aeNone),\par
12879   mOpenGlCacheLabelsBackup(true)\par
12880 \{\par
12881   setAttribute(Qt::WA_NoMousePropagation);\par
12882   setAttribute(Qt::WA_OpaquePaintEvent);\par
12883   setFocusPolicy(Qt::ClickFocus);\par
12884   setMouseTracking(true);\par
12885   QLocale currentLocale = locale();\par
12886   currentLocale.setNumberOptions(QLocale::OmitGroupSeparator);\par
12887   setLocale(currentLocale);\par
12888 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
12889 #  ifdef QCP_DEVICEPIXELRATIO_FLOAT\par
12890   setBufferDevicePixelRatio(QWidget::devicePixelRatioF());\par
12891 #  else\par
12892   setBufferDevicePixelRatio(QWidget::devicePixelRatio());\par
12893 #  endif\par
12894 #endif\par
12895   \par
12896   mOpenGlAntialiasedElementsBackup = mAntialiasedElements;\par
12897   mOpenGlCacheLabelsBackup = mPlottingHints.testFlag(QCP::phCacheLabels);\par
12898   // create initial layers:\par
12899   mLayers.append(new QCPLayer(this, QLatin1String("background")));\par
12900   mLayers.append(new QCPLayer(this, QLatin1String("grid")));\par
12901   mLayers.append(new QCPLayer(this, QLatin1String("main")));\par
12902   mLayers.append(new QCPLayer(this, QLatin1String("axes")));\par
12903   mLayers.append(new QCPLayer(this, QLatin1String("legend")));\par
12904   mLayers.append(new QCPLayer(this, QLatin1String("overlay")));\par
12905   updateLayerIndices();\par
12906   setCurrentLayer(QLatin1String("main"));\par
12907   layer(QLatin1String("overlay"))->setMode(QCPLayer::lmBuffered);\par
12908   \par
12909   // create initial layout, axis rect and legend:\par
12910   mPlotLayout = new QCPLayoutGrid;\par
12911   mPlotLayout->initializeParentPlot(this);\par
12912   mPlotLayout->setParent(this); // important because if parent is QWidget, QCPLayout::sizeConstraintsChanged will call QWidget::updateGeometry\par
12913   mPlotLayout->setLayer(QLatin1String("main"));\par
12914   QCPAxisRect *defaultAxisRect = new QCPAxisRect(this, true);\par
12915   mPlotLayout->addElement(0, 0, defaultAxisRect);\par
12916   xAxis = defaultAxisRect->axis(QCPAxis::atBottom);\par
12917   yAxis = defaultAxisRect->axis(QCPAxis::atLeft);\par
12918   xAxis2 = defaultAxisRect->axis(QCPAxis::atTop);\par
12919   yAxis2 = defaultAxisRect->axis(QCPAxis::atRight);\par
12920   legend = new QCPLegend;\par
12921   legend->setVisible(false);\par
12922   defaultAxisRect->insetLayout()->addElement(legend, Qt::AlignRight|Qt::AlignTop);\par
12923   defaultAxisRect->insetLayout()->setMargins(QMargins(12, 12, 12, 12));\par
12924   \par
12925   defaultAxisRect->setLayer(QLatin1String("background"));\par
12926   xAxis->setLayer(QLatin1String("axes"));\par
12927   yAxis->setLayer(QLatin1String("axes"));\par
12928   xAxis2->setLayer(QLatin1String("axes"));\par
12929   yAxis2->setLayer(QLatin1String("axes"));\par
12930   xAxis->grid()->setLayer(QLatin1String("grid"));\par
12931   yAxis->grid()->setLayer(QLatin1String("grid"));\par
12932   xAxis2->grid()->setLayer(QLatin1String("grid"));\par
12933   yAxis2->grid()->setLayer(QLatin1String("grid"));\par
12934   legend->setLayer(QLatin1String("legend"));\par
12935   \par
12936   // create selection rect instance:\par
12937   mSelectionRect = new QCPSelectionRect(this);\par
12938   mSelectionRect->setLayer(QLatin1String("overlay"));\par
12939   \par
12940   setViewport(rect()); // needs to be called after mPlotLayout has been created\par
12941   \par
12942   replot(rpQueuedReplot);\par
12943 \}\par
}
}
{\xe \v ~QCustomPlot\:QCustomPlot}
{\xe \v QCustomPlot\:~QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCustomPlot::~QCustomPlot (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADTE}
{\bkmkend AAAAAAADTE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12946 \{\par
12947   clearPlottables();\par
12948   clearItems();\par
12949 \par
12950   if (mPlotLayout)\par
12951   \{\par
12952     delete mPlotLayout;\par
12953     mPlotLayout = 0;\par
12954   \}\par
12955   \par
12956   mCurrentLayer = 0;\par
12957   qDeleteAll(mLayers); // don't use removeLayer, because it would prevent the last layer to be removed\par
12958   mLayers.clear();\par
12959 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções membros\par
\pard\plain 
{\xe \v addGraph\:QCustomPlot}
{\xe \v QCustomPlot\:addGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph} * QCustomPlot::addGraph ({\b QCPAxis} *  {\i keyAxis} = {\f2 0}, {\b QCPAxis} *  {\i valueAxis} = {\f2 0})}}
\par
{\bkmkstart AAAAAAADTF}
{\bkmkend AAAAAAADTF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new graph inside the plot. If {\i keyAxis}  and {\i valueAxis}  are left unspecified (0), the bottom (xAxis) is used as key and the left (yAxis) is used as value axis. If specified, {\i keyAxis}  and {\i valueAxis}  must reside in this {\b QCustomPlot}.\par
{\i keyAxis}  will be used as key axis (typically "x") and {\i valueAxis}  as value axis (typically "y") for the graph.\par
Returns a pointer to the newly created graph, or 0 if adding the graph failed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graph}, {\b graphCount}, {\b removeGraph}, {\b clearGraphs} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13699 \{\par
13700   if (!keyAxis) keyAxis = xAxis;\par
13701   if (!valueAxis) valueAxis = yAxis;\par
13702   if (!keyAxis || !valueAxis)\par
13703   \{\par
13704     qDebug() << Q_FUNC_INFO << "can't use default QCustomPlot xAxis or yAxis, because at least one is invalid (has been deleted)";\par
13705     return 0;\par
13706   \}\par
13707   if (keyAxis->parentPlot() != this || valueAxis->parentPlot() != this)\par
13708   \{\par
13709     qDebug() << Q_FUNC_INFO << "passed keyAxis or valueAxis doesn't have this QCustomPlot as parent";\par
13710     return 0;\par
13711   \}\par
13712   \par
13713   QCPGraph *newGraph = new QCPGraph(keyAxis, valueAxis);\par
13714   newGraph->setName(QLatin1String("Graph ")+QString::number(mGraphs.size()));\par
13715   return newGraph;\par
13716 \}\par
}
}
{\xe \v addLayer\:QCustomPlot}
{\xe \v QCustomPlot\:addLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::addLayer (const QString &  {\i name}, {\b QCPLayer} *  {\i otherLayer} = {\f2 0}, {\b QCustomPlot::LayerInsertMode}  {\i insertMode} = {\f2 {\b limAbove}})}}
\par
{\bkmkstart AAAAAAADTG}
{\bkmkend AAAAAAADTG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new layer to this {\b QCustomPlot} instance. The new layer will have the name {\i name} , which must be unique. Depending on {\i insertMode} , it is positioned either below or above {\i otherLayer} .\par
Returns true on success, i.e. if there is no other layer named {\i name}  and {\i otherLayer}  is a valid layer inside this {\b QCustomPlot}.\par
If {\i otherLayer}  is 0, the highest layer in the {\b QCustomPlot} will be used.\par
For an explanation of what layers are in {\b QCustomPlot}, see the documentation of {\b QCPLayer}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layer}, {\b moveLayer}, {\b removeLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14059 \{\par
14060   if (!otherLayer)\par
14061     otherLayer = mLayers.last();\par
14062   if (!mLayers.contains(otherLayer))\par
14063   \{\par
14064     qDebug() << Q_FUNC_INFO << "otherLayer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(otherLayer);\par
14065     return false;\par
14066   \}\par
14067   if (layer(name))\par
14068   \{\par
14069     qDebug() << Q_FUNC_INFO << "A layer exists already with the name" << name;\par
14070     return false;\par
14071   \}\par
14072     \par
14073   QCPLayer *newLayer = new QCPLayer(this, name);\par
14074   mLayers.insert(otherLayer->index() + (insertMode==limAbove ? 1:0), newLayer);\par
14075   updateLayerIndices();\par
14076   setupPaintBuffers(); // associates new layer with the appropriate paint buffer\par
14077   return true;\par
14078 \}\par
}
}
{\xe \v afterReplot\:QCustomPlot}
{\xe \v QCustomPlot\:afterReplot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::afterReplot (){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADTH}
{\bkmkend AAAAAAADTH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted immediately after a replot has taken place (caused by a call to the slot {\b replot}).\par
It is safe to mutually connect the replot slot with this signal on two QCustomPlots to make them replot synchronously, it won't cause an infinite recursion.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b replot}, {\b beforeReplot} \par
}}}
{\xe \v antialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:antialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::antialiasedElements () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTI}
{\bkmkend AAAAAAADTI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3630 \{ return mAntialiasedElements; \}\par
}
}
{\xe \v autoAddPlottableToLegend\:QCustomPlot}
{\xe \v QCustomPlot\:autoAddPlottableToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::autoAddPlottableToLegend () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTJ}
{\bkmkend AAAAAAADTJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3632 \{ return mAutoAddPlottableToLegend; \}\par
}
}
{\xe \v axisClick\:QCustomPlot}
{\xe \v QCustomPlot\:axisClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::axisClick ({\b QCPAxis} *  {\i axis}, {\b QCPAxis::SelectablePart}  {\i part}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADTK}
{\bkmkend AAAAAAADTK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when an axis is clicked.\par
{\i event}  is the mouse event that caused the click, {\i axis}  is the axis that received the click and {\i part}  indicates the part of the axis that was clicked.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisDoubleClick} \par
}}}
{\xe \v axisDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:axisDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::axisDoubleClick ({\b QCPAxis} *  {\i axis}, {\b QCPAxis::SelectablePart}  {\i part}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADTL}
{\bkmkend AAAAAAADTL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when an axis is double clicked.\par
{\i event}  is the mouse event that caused the click, {\i axis}  is the axis that received the click and {\i part}  indicates the part of the axis that was clicked.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisClick} \par
}}}
{\xe \v axisRect\:QCustomPlot}
{\xe \v QCustomPlot\:axisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect} * QCustomPlot::axisRect (int  {\i index} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAADTM}
{\bkmkend AAAAAAADTM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the axis rect with {\i index} .\par
Initially, only one axis rect (with index 0) exists in the plot. If multiple axis rects were added, all of them may be accessed with this function in a linear fashion (even when they are nested in a layout hierarchy or inside other axis rects via {\b QCPAxisRect::insetLayout}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisRectCount}, {\b axisRects} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14195 \{\par
14196   const QList<QCPAxisRect*> rectList = axisRects();\par
14197   if (index >= 0 && index < rectList.size())\par
14198   \{\par
14199     return rectList.at(index);\par
14200   \} else\par
14201   \{\par
14202     qDebug() << Q_FUNC_INFO << "invalid axis rect index" << index;\par
14203     return 0;\par
14204   \}\par
14205 \}\par
}
}
{\xe \v axisRectAt\:QCustomPlot}
{\xe \v QCustomPlot\:axisRectAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect} * QCustomPlot::axisRectAt (const QPointF &  {\i pos}) const}}
\par
{\bkmkstart AAAAAAADTN}
{\bkmkend AAAAAAADTN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the layout element of type {\b QCPAxisRect} at pixel position {\i pos} . This method ignores other layout elements even if they are visually in front of the axis rect (e.g. a {\b QCPLegend}). If there is no axis rect at that position, returns 0.\par
Only visible axis rects are used. If {\b QCPLayoutElement::setVisible} on the axis rect itself or on any of its parent elements is set to false, it will not be considered.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layoutElementAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14275 \{\par
14276   QCPAxisRect *result = 0;\par
14277   QCPLayoutElement *currentElement = mPlotLayout;\par
14278   bool searchSubElements = true;\par
14279   while (searchSubElements && currentElement)\par
14280   \{\par
14281     searchSubElements = false;\par
14282     foreach (QCPLayoutElement *subElement, currentElement->elements(false))\par
14283     \{\par
14284       if (subElement && subElement->realVisibility() && subElement->selectTest(pos, false) >= 0)\par
14285       \{\par
14286         currentElement = subElement;\par
14287         searchSubElements = true;\par
14288         if (QCPAxisRect *ar = qobject_cast<QCPAxisRect*>(currentElement))\par
14289           result = ar;\par
14290         break;\par
14291       \}\par
14292     \}\par
14293   \}\par
14294   return result;\par
14295 \}\par
}
}
{\xe \v axisRectCount\:QCustomPlot}
{\xe \v QCustomPlot\:axisRectCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::axisRectCount () const}}
\par
{\bkmkstart AAAAAAADTO}
{\bkmkend AAAAAAADTO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of axis rects in the plot.\par
All axis rects can be accessed via {\b QCustomPlot::axisRect()}.\par
Initially, only one axis rect exists in the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisRect}, {\b axisRects} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14181 \{\par
14182   return axisRects().size();\par
14183 \}\par
}
}
{\xe \v axisRects\:QCustomPlot}
{\xe \v QCustomPlot\:axisRects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxisRect} * > QCustomPlot::axisRects () const}}
\par
{\bkmkstart AAAAAAADTP}
{\bkmkend AAAAAAADTP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all axis rects in the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisRectCount}, {\b axisRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14213 \{\par
14214   QList<QCPAxisRect*> result;\par
14215   QStack<QCPLayoutElement*> elementStack;\par
14216   if (mPlotLayout)\par
14217     elementStack.push(mPlotLayout);\par
14218   \par
14219   while (!elementStack.isEmpty())\par
14220   \{\par
14221     foreach (QCPLayoutElement *element, elementStack.pop()->elements(false))\par
14222     \{\par
14223       if (element)\par
14224       \{\par
14225         elementStack.push(element);\par
14226         if (QCPAxisRect *ar = qobject_cast<QCPAxisRect*>(element))\par
14227           result.append(ar);\par
14228       \}\par
14229     \}\par
14230   \}\par
14231   \par
14232   return result;\par
14233 \}\par
}
}
{\xe \v axisRemoved\:QCustomPlot}
{\xe \v QCustomPlot\:axisRemoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::axisRemoved ({\b QCPAxis} *  {\i axis}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADTQ}
{\bkmkend AAAAAAADTQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15231 \{\par
15232   if (xAxis == axis)\par
15233     xAxis = 0;\par
15234   if (xAxis2 == axis)\par
15235     xAxis2 = 0;\par
15236   if (yAxis == axis)\par
15237     yAxis = 0;\par
15238   if (yAxis2 == axis)\par
15239     yAxis2 = 0;\par
15240   \par
15241   // Note: No need to take care of range drag axes and range zoom axes, because they are stored in smart pointers\par
15242 \}\par
}
}
{\xe \v background\:QCustomPlot}
{\xe \v QCustomPlot\:background}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCustomPlot::background () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTR}
{\bkmkend AAAAAAADTR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3626 \{ return mBackgroundPixmap; \}\par
}
}
{\xe \v backgroundScaled\:QCustomPlot}
{\xe \v QCustomPlot\:backgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::backgroundScaled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTS}
{\bkmkend AAAAAAADTS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3627 \{ return mBackgroundScaled; \}\par
}
}
{\xe \v backgroundScaledMode\:QCustomPlot}
{\xe \v QCustomPlot\:backgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCustomPlot::backgroundScaledMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTT}
{\bkmkend AAAAAAADTT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3628 \{ return mBackgroundScaledMode; \}\par
}
}
{\xe \v beforeReplot\:QCustomPlot}
{\xe \v QCustomPlot\:beforeReplot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::beforeReplot (){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADTU}
{\bkmkend AAAAAAADTU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted immediately before a replot takes place (caused by a call to the slot {\b replot}).\par
It is safe to mutually connect the replot slot with this signal on two QCustomPlots to make them replot synchronously, it won't cause an infinite recursion.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b replot}, {\b afterReplot} \par
}}}
{\xe \v bufferDevicePixelRatio\:QCustomPlot}
{\xe \v QCustomPlot\:bufferDevicePixelRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCustomPlot::bufferDevicePixelRatio () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTV}
{\bkmkend AAAAAAADTV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3625 \{ return mBufferDevicePixelRatio; \}\par
}
}
{\xe \v clearGraphs\:QCustomPlot}
{\xe \v QCustomPlot\:clearGraphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::clearGraphs ()}}
\par
{\bkmkstart AAAAAAADTW}
{\bkmkend AAAAAAADTW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all graphs from the plot and deletes them. Corresponding legend items are also removed from the default legend ({\b QCustomPlot::legend}).\par
Returns the number of graphs removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeGraph} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13754 \{\par
13755   int c = mGraphs.size();\par
13756   for (int i=c-1; i >= 0; --i)\par
13757     removeGraph(mGraphs[i]);\par
13758   return c;\par
13759 \}\par
}
}
{\xe \v clearItems\:QCustomPlot}
{\xe \v QCustomPlot\:clearItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::clearItems ()}}
\par
{\bkmkstart AAAAAAADTX}
{\bkmkend AAAAAAADTX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all items from the plot and deletes them.\par
Returns the number of items removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13870 \{\par
13871   int c = mItems.size();\par
13872   for (int i=c-1; i >= 0; --i)\par
13873     removeItem(mItems[i]);\par
13874   return c;\par
13875 \}\par
}
}
{\xe \v clearPlottables\:QCustomPlot}
{\xe \v QCustomPlot\:clearPlottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::clearPlottables ()}}
\par
{\bkmkstart AAAAAAADTY}
{\bkmkend AAAAAAADTY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all plottables from the plot and deletes them. Corresponding legend items are also removed from the default legend ({\b QCustomPlot::legend}).\par
Returns the number of plottables removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removePlottable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13572 \{\par
13573   int c = mPlottables.size();\par
13574   for (int i=c-1; i >= 0; --i)\par
13575     removePlottable(mPlottables[i]);\par
13576   return c;\par
13577 \}\par
}
}
{\xe \v createPaintBuffer\:QCustomPlot}
{\xe \v QCustomPlot\:createPaintBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPaintBuffer} * QCustomPlot::createPaintBuffer (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADTZ}
{\bkmkend AAAAAAADTZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15109 \{\par
15110   if (mOpenGl)\par
15111   \{\par
15112 #if defined(QCP_OPENGL_FBO)\par
15113     return new QCPPaintBufferGlFbo(viewport().size(), mBufferDevicePixelRatio, mGlContext, mGlPaintDevice);\par
15114 #elif defined(QCP_OPENGL_PBUFFER)\par
15115     return new QCPPaintBufferGlPbuffer(viewport().size(), mBufferDevicePixelRatio, mOpenGlMultisamples);\par
15116 #else\par
15117     qDebug() << Q_FUNC_INFO << "OpenGL enabled even though no support for it compiled in, this shouldn't have happened. Falling back to pixmap paint buffer.";\par
15118     return new QCPPaintBufferPixmap(viewport().size(), mBufferDevicePixelRatio);\par
15119 #endif\par
15120   \} else\par
15121     return new QCPPaintBufferPixmap(viewport().size(), mBufferDevicePixelRatio);\par
15122 \}\par
}
}
{\xe \v currentLayer\:QCustomPlot}
{\xe \v QCustomPlot\:currentLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer} * QCustomPlot::currentLayer () const}}
\par
{\bkmkstart AAAAAAADUA}
{\bkmkend AAAAAAADUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the layer that is set as current layer (see {\b setCurrentLayer}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13989 \{\par
13990   return mCurrentLayer;\par
13991 \}\par
}
}
{\xe \v deselectAll\:QCustomPlot}
{\xe \v QCustomPlot\:deselectAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::deselectAll ()}}
\par
{\bkmkstart AAAAAAADUB}
{\bkmkend AAAAAAADUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deselects all layerables (plottables, items, axes, legends,...) of the {\b QCustomPlot}.\par
Since calling this function is not a user interaction, this does not emit the {\b selectionChangedByUser} signal. The individual selectionChanged signals are emitted though, if the objects were previously selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b selectedPlottables}, {\b selectedItems}, {\b selectedAxes}, {\b selectedLegends} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14363 \{\par
14364   foreach (QCPLayer *layer, mLayers)\par
14365   \{\par
14366     foreach (QCPLayerable *layerable, layer->children())\par
14367       layerable->deselectEvent(0);\par
14368   \}\par
14369 \}\par
}
}
{\xe \v draw\:QCustomPlot}
{\xe \v QCustomPlot\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADUC}
{\bkmkend AAAAAAADUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14966 \{\par
14967   updateLayout();\par
14968   \par
14969   // draw viewport background pixmap:\par
14970   drawBackground(painter);\par
14971 \par
14972   // draw all layered objects (grid, axes, plottables, items, legend,...):\par
14973   foreach (QCPLayer *layer, mLayers)\par
14974     layer->draw(painter);\par
14975   \par
14976   /* Debug code to draw all layout element rects\par
14977   foreach (QCPLayoutElement* el, findChildren<QCPLayoutElement*>())\par
14978   \{\par
14979     painter->setBrush(Qt::NoBrush);\par
14980     painter->setPen(QPen(QColor(0, 0, 0, 100), 0, Qt::DashLine));\par
14981     painter->drawRect(el->rect());\par
14982     painter->setPen(QPen(QColor(255, 0, 0, 100), 0, Qt::DashLine));\par
14983     painter->drawRect(el->outerRect());\par
14984   \}\par
14985   */\par
14986 \}\par
}
}
{\xe \v drawBackground\:QCustomPlot}
{\xe \v QCustomPlot\:drawBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::drawBackground ({\b QCPPainter} *  {\i painter}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADUD}
{\bkmkend AAAAAAADUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15022 \{\par
15023   // Note: background color is handled in individual replot/save functions\par
15024 \par
15025   // draw background pixmap (on top of fill, if brush specified):\par
15026   if (!mBackgroundPixmap.isNull())\par
15027   \{\par
15028     if (mBackgroundScaled)\par
15029     \{\par
15030       // check whether mScaledBackground needs to be updated:\par
15031       QSize scaledSize(mBackgroundPixmap.size());\par
15032       scaledSize.scale(mViewport.size(), mBackgroundScaledMode);\par
15033       if (mScaledBackgroundPixmap.size() != scaledSize)\par
15034         mScaledBackgroundPixmap = mBackgroundPixmap.scaled(mViewport.size(), mBackgroundScaledMode, Qt::SmoothTransformation);\par
15035       painter->drawPixmap(mViewport.topLeft(), mScaledBackgroundPixmap, QRect(0, 0, mViewport.width(), mViewport.height()) & mScaledBackgroundPixmap.rect());\par
15036     \} else\par
15037     \{\par
15038       painter->drawPixmap(mViewport.topLeft(), mBackgroundPixmap, QRect(0, 0, mViewport.width(), mViewport.height()));\par
15039     \}\par
15040   \}\par
15041 \}\par
}
}
{\xe \v freeOpenGl\:QCustomPlot}
{\xe \v QCustomPlot\:freeOpenGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::freeOpenGl (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADUE}
{\bkmkend AAAAAAADUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15217 \{\par
15218 #ifdef QCP_OPENGL_FBO\par
15219   mGlPaintDevice.clear();\par
15220   mGlContext.clear();\par
15221   mGlSurface.clear();\par
15222 #endif\par
15223 \}\par
}
}
{\xe \v graph\:QCustomPlot}
{\xe \v QCustomPlot\:graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph} * QCustomPlot::graph (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAADUF}
{\bkmkend AAAAAAADUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the graph with {\i index} . If the index is invalid, returns 0.\par
There is an overloaded version of this function with no parameter which returns the last created graph, see {\b QCustomPlot::graph()}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graphCount}, {\b addGraph} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13659 \{\par
13660   if (index >= 0 && index < mGraphs.size())\par
13661   \{\par
13662     return mGraphs.at(index);\par
13663   \} else\par
13664   \{\par
13665     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13666     return 0;\par
13667   \}\par
13668 \}\par
}
}
{\xe \v graph\:QCustomPlot}
{\xe \v QCustomPlot\:graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph} * QCustomPlot::graph () const}}
\par
{\bkmkstart AAAAAAADUG}
{\bkmkend AAAAAAADUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Returns the last graph, that was created with {\b addGraph}. If there are no graphs in the plot, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graphCount}, {\b addGraph} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13678 \{\par
13679   if (!mGraphs.isEmpty())\par
13680   \{\par
13681     return mGraphs.last();\par
13682   \} else\par
13683     return 0;\par
13684 \}\par
}
}
{\xe \v graphCount\:QCustomPlot}
{\xe \v QCustomPlot\:graphCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::graphCount () const}}
\par
{\bkmkstart AAAAAAADUH}
{\bkmkend AAAAAAADUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of currently existing graphs in the plot\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graph}, {\b addGraph} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13767 \{\par
13768   return mGraphs.size();\par
13769 \}\par
}
}
{\xe \v hasInvalidatedPaintBuffers\:QCustomPlot}
{\xe \v QCustomPlot\:hasInvalidatedPaintBuffers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::hasInvalidatedPaintBuffers (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADUI}
{\bkmkend AAAAAAADUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method returns whether any of the paint buffers held by this {\b QCustomPlot} instance are invalidated.\par
If any buffer is invalidated, a partial replot ({\b QCPLayer::replot}) is not allowed and always causes a full replot ({\b QCustomPlot::replot}) of all layers. This is the case when for example the layer order has changed, new layers were added, layers were removed, or layer modes were changed ({\b QCPLayer::setMode}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractPaintBuffer::setInvalidated} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15136 \{\par
15137   for (int i=0; i<mPaintBuffers.size(); ++i)\par
15138   \{\par
15139     if (mPaintBuffers.at(i)->invalidated())\par
15140       return true;\par
15141   \}\par
15142   return false;\par
15143 \}\par
}
}
{\xe \v hasItem\:QCustomPlot}
{\xe \v QCustomPlot\:hasItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::hasItem ({\b QCPAbstractItem} *  {\i item}) const}}
\par
{\bkmkstart AAAAAAADUJ}
{\bkmkend AAAAAAADUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this {\b QCustomPlot} contains the {\i item} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b item} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13945 \{\par
13946   return mItems.contains(item);\par
13947 \}\par
}
}
{\xe \v hasPlottable\:QCustomPlot}
{\xe \v QCustomPlot\:hasPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::hasPlottable ({\b QCPAbstractPlottable} *  {\i plottable}) const}}
\par
{\bkmkstart AAAAAAADUK}
{\bkmkend AAAAAAADUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this {\b QCustomPlot} instance contains the {\i plottable} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13646 \{\par
13647   return mPlottables.contains(plottable);\par
13648 \}\par
}
}
{\xe \v interactions\:QCustomPlot}
{\xe \v QCustomPlot\:interactions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QCP::Interactions QCustomPlot::interactions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADUL}
{\bkmkend AAAAAAADUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3633 \{ return mInteractions; \}\par
}
}
{\xe \v item\:QCustomPlot}
{\xe \v QCustomPlot\:item}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractItem} * QCustomPlot::item (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAADUM}
{\bkmkend AAAAAAADUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the item with {\i index} . If the index is invalid, returns 0.\par
There is an overloaded version of this function with no parameter which returns the last added item, see {\b QCustomPlot::item()}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13799 \{\par
13800   if (index >= 0 && index < mItems.size())\par
13801   \{\par
13802     return mItems.at(index);\par
13803   \} else\par
13804   \{\par
13805     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13806     return 0;\par
13807   \}\par
13808 \}\par
}
}
{\xe \v item\:QCustomPlot}
{\xe \v QCustomPlot\:item}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractItem} * QCustomPlot::item () const}}
\par
{\bkmkstart AAAAAAADUN}
{\bkmkend AAAAAAADUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Returns the last item that was added to this plot. If there are no items in the plot, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13818 \{\par
13819   if (!mItems.isEmpty())\par
13820   \{\par
13821     return mItems.last();\par
13822   \} else\par
13823     return 0;\par
13824 \}\par
}
}
{\xe \v itemAt\:QCustomPlot}
{\xe \v QCustomPlot\:itemAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractItem} * QCustomPlot::itemAt (const QPointF &  {\i pos}, bool  {\i onlySelectable} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAADUO}
{\bkmkend AAAAAAADUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the item at the pixel position {\i pos} . Items that only consist of single lines (e.g. {\b QCPItemLine} or {\b QCPItemCurve}) have a tolerance band around them, see {\b setSelectionTolerance}. If multiple items come into consideration, the one closest to {\i pos}  is returned.\par
If {\i onlySelectable}  is true, only items that are selectable ({\b QCPAbstractItem::setSelectable}) are considered.\par
If there is no item at {\i pos} , the return value is 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableAt}, {\b layoutElementAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13917 \{\par
13918   QCPAbstractItem *resultItem = 0;\par
13919   double resultDistance = mSelectionTolerance; // only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value\par
13920   \par
13921   foreach (QCPAbstractItem *item, mItems)\par
13922   \{\par
13923     if (onlySelectable && !item->selectable()) // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPAbstractItem::selectable\par
13924       continue;\par
13925     if (!item->clipToAxisRect() || item->clipRect().contains(pos.toPoint())) // only consider clicks inside axis cliprect of the item if actually clipped to it\par
13926     \{\par
13927       double currentDistance = item->selectTest(pos, false);\par
13928       if (currentDistance >= 0 && currentDistance < resultDistance)\par
13929       \{\par
13930         resultItem = item;\par
13931         resultDistance = currentDistance;\par
13932       \}\par
13933     \}\par
13934   \}\par
13935   \par
13936   return resultItem;\par
13937 \}\par
}
}
{\xe \v itemClick\:QCustomPlot}
{\xe \v QCustomPlot\:itemClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::itemClick ({\b QCPAbstractItem} *  {\i item}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADUP}
{\bkmkend AAAAAAADUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when an item is clicked.\par
{\i event}  is the mouse event that caused the click and {\i item}  is the item that received the click.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemDoubleClick} \par
}}}
{\xe \v itemCount\:QCustomPlot}
{\xe \v QCustomPlot\:itemCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::itemCount () const}}
\par
{\bkmkstart AAAAAAADUQ}
{\bkmkend AAAAAAADUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of currently existing items in the plot\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b item} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13883 \{\par
13884   return mItems.size();\par
13885 \}\par
}
}
{\xe \v itemDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:itemDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::itemDoubleClick ({\b QCPAbstractItem} *  {\i item}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADUR}
{\bkmkend AAAAAAADUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when an item is double clicked.\par
{\i event}  is the mouse event that caused the click and {\i item}  is the item that received the click.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemClick} \par
}}}
{\xe \v layer\:QCustomPlot}
{\xe \v QCustomPlot\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer} * QCustomPlot::layer (const QString &  {\i name}) const}}
\par
{\bkmkstart AAAAAAADUS}
{\bkmkend AAAAAAADUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the layer with the specified {\i name} . If there is no layer with the specified name, 0 is returned.\par
Layer names are case-sensitive.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer}, {\b removeLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13958 \{\par
13959   foreach (QCPLayer *layer, mLayers)\par
13960   \{\par
13961     if (layer->name() == name)\par
13962       return layer;\par
13963   \}\par
13964   return 0;\par
13965 \}\par
}
}
{\xe \v layer\:QCustomPlot}
{\xe \v QCustomPlot\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer} * QCustomPlot::layer (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAADUT}
{\bkmkend AAAAAAADUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Returns the layer by {\i index} . If the index is invalid, 0 is returned.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer}, {\b removeLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13974 \{\par
13975   if (index >= 0 && index < mLayers.size())\par
13976   \{\par
13977     return mLayers.at(index);\par
13978   \} else\par
13979   \{\par
13980     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13981     return 0;\par
13982   \}\par
13983 \}\par
}
}
{\xe \v layerableAt\:QCustomPlot}
{\xe \v QCustomPlot\:layerableAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayerable} * QCustomPlot::layerableAt (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i selectionDetails} = {\f2 0}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADUU}
{\bkmkend AAAAAAADUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15538 \{\par
15539   QList<QVariant> details;\par
15540   QList<QCPLayerable*> candidates = layerableListAt(pos, onlySelectable, selectionDetails ? &details : 0);\par
15541   if (selectionDetails && !details.isEmpty())\par
15542     *selectionDetails = details.first();\par
15543   if (!candidates.isEmpty())\par
15544     return candidates.first();\par
15545   else\par
15546     return 0;\par
15547 \}\par
}
}
{\xe \v layerableListAt\:QCustomPlot}
{\xe \v QCustomPlot\:layerableListAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLayerable} * > QCustomPlot::layerableListAt (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QList< QVariant > *  {\i selectionDetails} = {\f2 0}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADUV}
{\bkmkend AAAAAAADUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15568 \{\par
15569   QList<QCPLayerable*> result;\par
15570   for (int layerIndex=mLayers.size()-1; layerIndex>=0; --layerIndex)\par
15571   \{\par
15572     const QList<QCPLayerable*> layerables = mLayers.at(layerIndex)->children();\par
15573     for (int i=layerables.size()-1; i>=0; --i)\par
15574     \{\par
15575       if (!layerables.at(i)->realVisibility())\par
15576         continue;\par
15577       QVariant details;\par
15578       double dist = layerables.at(i)->selectTest(pos, onlySelectable, selectionDetails ? &details : 0);\par
15579       if (dist >= 0 && dist < selectionTolerance())\par
15580       \{\par
15581         result.append(layerables.at(i));\par
15582         if (selectionDetails)\par
15583           selectionDetails->append(details);\par
15584       \}\par
15585     \}\par
15586   \}\par
15587   return result;\par
15588 \}\par
}
}
{\xe \v layerCount\:QCustomPlot}
{\xe \v QCustomPlot\:layerCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::layerCount () const}}
\par
{\bkmkstart AAAAAAADUW}
{\bkmkend AAAAAAADUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of currently existing layers in the plot\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layer}, {\b addLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14041 \{\par
14042   return mLayers.size();\par
14043 \}\par
}
}
{\xe \v layoutElementAt\:QCustomPlot}
{\xe \v QCustomPlot\:layoutElementAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutElement} * QCustomPlot::layoutElementAt (const QPointF &  {\i pos}) const}}
\par
{\bkmkstart AAAAAAADUX}
{\bkmkend AAAAAAADUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the layout element at pixel position {\i pos} . If there is no element at that position, returns 0.\par
Only visible elements are used. If {\b QCPLayoutElement::setVisible} on the element itself or on any of its parent elements is set to false, it will not be considered.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemAt}, {\b plottableAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14245 \{\par
14246   QCPLayoutElement *currentElement = mPlotLayout;\par
14247   bool searchSubElements = true;\par
14248   while (searchSubElements && currentElement)\par
14249   \{\par
14250     searchSubElements = false;\par
14251     foreach (QCPLayoutElement *subElement, currentElement->elements(false))\par
14252     \{\par
14253       if (subElement && subElement->realVisibility() && subElement->selectTest(pos, false) >= 0)\par
14254       \{\par
14255         currentElement = subElement;\par
14256         searchSubElements = true;\par
14257         break;\par
14258       \}\par
14259     \}\par
14260   \}\par
14261   return currentElement;\par
14262 \}\par
}
}
{\xe \v legendClick\:QCustomPlot}
{\xe \v QCustomPlot\:legendClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::legendClick ({\b QCPLegend} *  {\i legend}, {\b QCPAbstractLegendItem} *  {\i item}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADUY}
{\bkmkend AAAAAAADUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when a legend (item) is clicked.\par
{\i event}  is the mouse event that caused the click, {\i legend}  is the legend that received the click and {\i item}  is the legend item that received the click. If only the legend and no item is clicked, {\i item}  is 0. This happens for a click inside the legend padding or the space between two items.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b legendDoubleClick} \par
}}}
{\xe \v legendDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:legendDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::legendDoubleClick ({\b QCPLegend} *  {\i legend}, {\b QCPAbstractLegendItem} *  {\i item}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADUZ}
{\bkmkend AAAAAAADUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when a legend (item) is double clicked.\par
{\i event}  is the mouse event that caused the click, {\i legend}  is the legend that received the click and {\i item}  is the legend item that received the click. If only the legend and no item is clicked, {\i item}  is 0. This happens for a click inside the legend padding or the space between two items.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b legendClick} \par
}}}
{\xe \v legendRemoved\:QCustomPlot}
{\xe \v QCustomPlot\:legendRemoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::legendRemoved ({\b QCPLegend} *  {\i legend}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVA}
{\bkmkend AAAAAAADVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15250 \{\par
15251   if (this->legend == legend)\par
15252     this->legend = 0;\par
15253 \}\par
}
}
{\xe \v minimumSizeHint\:QCustomPlot}
{\xe \v QCustomPlot\:minimumSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCustomPlot::minimumSizeHint () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVB}
{\bkmkend AAAAAAADVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14699 \{\par
14700   return mPlotLayout->minimumOuterSizeHint();\par
14701 \}\par
}
}
{\xe \v mouseDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:mouseDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseDoubleClick (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADVC}
{\bkmkend AAAAAAADVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse double click event. \par
}}
{\xe \v mouseDoubleClickEvent\:QCustomPlot}
{\xe \v QCustomPlot\:mouseDoubleClickEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseDoubleClickEvent (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVD}
{\bkmkend AAAAAAADVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14756 \{\par
14757   emit mouseDoubleClick(event);\par
14758   mMouseHasMoved = false;\par
14759   mMousePressPos = event->pos();\par
14760   \par
14761   // determine layerable under the cursor (this event is called instead of the second press event in a double-click):\par
14762   QList<QVariant> details;\par
14763   QList<QCPLayerable*> candidates = layerableListAt(mMousePressPos, false, &details);\par
14764   for (int i=0; i<candidates.size(); ++i)\par
14765   \{\par
14766     event->accept(); // default impl of QCPLayerable's mouse events ignore the event, in that case propagate to next candidate in list\par
14767     candidates.at(i)->mouseDoubleClickEvent(event, details.at(i));\par
14768     if (event->isAccepted())\par
14769     \{\par
14770       mMouseEventLayerable = candidates.at(i);\par
14771       mMouseEventLayerableDetails = details.at(i);\par
14772       break;\par
14773     \}\par
14774   \}\par
14775   \par
14776   // emit specialized object double click signals:\par
14777   if (!candidates.isEmpty())\par
14778   \{\par
14779     if (QCPAbstractPlottable *ap = qobject_cast<QCPAbstractPlottable*>(candidates.first()))\par
14780     \{\par
14781       int dataIndex = 0;\par
14782       if (!details.first().value<QCPDataSelection>().isEmpty())\par
14783         dataIndex = details.first().value<QCPDataSelection>().dataRange().begin();\par
14784       emit plottableDoubleClick(ap, dataIndex, event);\par
14785     \} else if (QCPAxis *ax = qobject_cast<QCPAxis*>(candidates.first()))\par
14786       emit axisDoubleClick(ax, details.first().value<QCPAxis::SelectablePart>(), event);\par
14787     else if (QCPAbstractItem *ai = qobject_cast<QCPAbstractItem*>(candidates.first()))\par
14788       emit itemDoubleClick(ai, event);\par
14789     else if (QCPLegend *lg = qobject_cast<QCPLegend*>(candidates.first()))\par
14790       emit legendDoubleClick(lg, 0, event);\par
14791     else if (QCPAbstractLegendItem *li = qobject_cast<QCPAbstractLegendItem*>(candidates.first()))\par
14792       emit legendDoubleClick(li->parentLegend(), li, event);\par
14793   \}\par
14794   \par
14795   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14796 \}\par
}
}
{\xe \v mouseMove\:QCustomPlot}
{\xe \v QCustomPlot\:mouseMove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseMove (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADVE}
{\bkmkend AAAAAAADVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse move event.\par
It is emitted before {\b QCustomPlot} handles any other mechanism like range dragging. So a slot connected to this signal can still influence the behaviour e.g. with {\b QCPAxisRect::setRangeDrag} or {\b QCPAxisRect::setRangeDragAxes}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Aviso:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid It is discouraged to change the drag-axes with {\b QCPAxisRect::setRangeDragAxes} here, because the dragging starting point was saved the moment the mouse was pressed. Thus it only has a meaning for the range drag axes that were set at that moment. If you want to change the drag axes, consider doing this in the {\b mousePress} signal instead. \par
}}}
{\xe \v mouseMoveEvent\:QCustomPlot}
{\xe \v QCustomPlot\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseMoveEvent (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVF}
{\bkmkend AAAAAAADVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14858 \{\par
14859   emit mouseMove(event);\par
14860   \par
14861   if (!mMouseHasMoved && (mMousePressPos-event->pos()).manhattanLength() > 3)\par
14862     mMouseHasMoved = true; // moved too far from mouse press position, don't handle as click on mouse release\par
14863   \par
14864   if (mSelectionRect && mSelectionRect->isActive())\par
14865     mSelectionRect->moveSelection(event);\par
14866   else if (mMouseEventLayerable) // call event of affected layerable:\par
14867     mMouseEventLayerable->mouseMoveEvent(event, mMousePressPos);\par
14868   \par
14869   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14870 \}\par
}
}
{\xe \v mousePress\:QCustomPlot}
{\xe \v QCustomPlot\:mousePress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mousePress (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADVG}
{\bkmkend AAAAAAADVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse press event.\par
It is emitted before {\b QCustomPlot} handles any other mechanism like range dragging. So a slot connected to this signal can still influence the behaviour e.g. with {\b QCPAxisRect::setRangeDrag} or {\b QCPAxisRect::setRangeDragAxes}. \par
}}
{\xe \v mousePressEvent\:QCustomPlot}
{\xe \v QCustomPlot\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mousePressEvent (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVH}
{\bkmkend AAAAAAADVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14808 \{\par
14809   emit mousePress(event);\par
14810   // save some state to tell in releaseEvent whether it was a click:\par
14811   mMouseHasMoved = false;\par
14812   mMousePressPos = event->pos();\par
14813   \par
14814   if (mSelectionRect && mSelectionRectMode != QCP::srmNone)\par
14815   \{\par
14816     if (mSelectionRectMode != QCP::srmZoom || qobject_cast<QCPAxisRect*>(axisRectAt(mMousePressPos))) // in zoom mode only activate selection rect if on an axis rect\par
14817       mSelectionRect->startSelection(event);\par
14818   \} else\par
14819   \{\par
14820     // no selection rect interaction, prepare for click signal emission and forward event to layerable under the cursor:\par
14821     QList<QVariant> details;\par
14822     QList<QCPLayerable*> candidates = layerableListAt(mMousePressPos, false, &details);\par
14823     if (!candidates.isEmpty())\par
14824     \{\par
14825       mMouseSignalLayerable = candidates.first(); // candidate for signal emission is always topmost hit layerable (signal emitted in release event)\par
14826       mMouseSignalLayerableDetails = details.first();\par
14827     \}\par
14828     // forward event to topmost candidate which accepts the event:\par
14829     for (int i=0; i<candidates.size(); ++i)\par
14830     \{\par
14831       event->accept(); // default impl of QCPLayerable's mouse events call ignore() on the event, in that case propagate to next candidate in list\par
14832       candidates.at(i)->mousePressEvent(event, details.at(i));\par
14833       if (event->isAccepted())\par
14834       \{\par
14835         mMouseEventLayerable = candidates.at(i);\par
14836         mMouseEventLayerableDetails = details.at(i);\par
14837         break;\par
14838       \}\par
14839     \}\par
14840   \}\par
14841   \par
14842   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14843 \}\par
}
}
{\xe \v mouseRelease\:QCustomPlot}
{\xe \v QCustomPlot\:mouseRelease}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseRelease (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADVI}
{\bkmkend AAAAAAADVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse release event.\par
It is emitted before {\b QCustomPlot} handles any other mechanisms like object selection. So a slot connected to this signal can still influence the behaviour e.g. with {\b setInteractions} or {\b QCPAbstractPlottable::setSelectable}. \par
}}
{\xe \v mouseReleaseEvent\:QCustomPlot}
{\xe \v QCustomPlot\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseReleaseEvent (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVJ}
{\bkmkend AAAAAAADVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14887 \{\par
14888   emit mouseRelease(event);\par
14889   \par
14890   if (!mMouseHasMoved) // mouse hasn't moved (much) between press and release, so handle as click\par
14891   \{\par
14892     if (mSelectionRect && mSelectionRect->isActive()) // a simple click shouldn't successfully finish a selection rect, so cancel it here\par
14893       mSelectionRect->cancel();\par
14894     if (event->button() == Qt::LeftButton)\par
14895       processPointSelection(event);\par
14896     \par
14897     // emit specialized click signals of QCustomPlot instance:\par
14898     if (QCPAbstractPlottable *ap = qobject_cast<QCPAbstractPlottable*>(mMouseSignalLayerable))\par
14899     \{\par
14900       int dataIndex = 0;\par
14901       if (!mMouseSignalLayerableDetails.value<QCPDataSelection>().isEmpty())\par
14902         dataIndex = mMouseSignalLayerableDetails.value<QCPDataSelection>().dataRange().begin();\par
14903       emit plottableClick(ap, dataIndex, event);\par
14904     \} else if (QCPAxis *ax = qobject_cast<QCPAxis*>(mMouseSignalLayerable))\par
14905       emit axisClick(ax, mMouseSignalLayerableDetails.value<QCPAxis::SelectablePart>(), event);\par
14906     else if (QCPAbstractItem *ai = qobject_cast<QCPAbstractItem*>(mMouseSignalLayerable))\par
14907       emit itemClick(ai, event);\par
14908     else if (QCPLegend *lg = qobject_cast<QCPLegend*>(mMouseSignalLayerable))\par
14909       emit legendClick(lg, 0, event);\par
14910     else if (QCPAbstractLegendItem *li = qobject_cast<QCPAbstractLegendItem*>(mMouseSignalLayerable))\par
14911       emit legendClick(li->parentLegend(), li, event);\par
14912     mMouseSignalLayerable = 0;\par
14913   \}\par
14914   \par
14915   if (mSelectionRect && mSelectionRect->isActive()) // Note: if a click was detected above, the selection rect is canceled there\par
14916   \{\par
14917     // finish selection rect, the appropriate action will be taken via signal-slot connection:\par
14918     mSelectionRect->endSelection(event);\par
14919   \} else\par
14920   \{\par
14921     // call event of affected layerable:\par
14922     if (mMouseEventLayerable)\par
14923     \{\par
14924       mMouseEventLayerable->mouseReleaseEvent(event, mMousePressPos);\par
14925       mMouseEventLayerable = 0;\par
14926     \}\par
14927   \}\par
14928   \par
14929   if (noAntialiasingOnDrag())\par
14930     replot(rpQueuedReplot);\par
14931   \par
14932   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14933 \}\par
}
}
{\xe \v mouseWheel\:QCustomPlot}
{\xe \v QCustomPlot\:mouseWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseWheel (QWheelEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADVK}
{\bkmkend AAAAAAADVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse wheel event.\par
It is emitted before {\b QCustomPlot} handles any other mechanisms like range zooming. So a slot connected to this signal can still influence the behaviour e.g. with {\b QCPAxisRect::setRangeZoom}, {\b QCPAxisRect::setRangeZoomAxes} or {\b QCPAxisRect::setRangeZoomFactor}. \par
}}
{\xe \v moveLayer\:QCustomPlot}
{\xe \v QCustomPlot\:moveLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::moveLayer ({\b QCPLayer} *  {\i layer}, {\b QCPLayer} *  {\i otherLayer}, {\b QCustomPlot::LayerInsertMode}  {\i insertMode} = {\f2 {\b limAbove}})}}
\par
{\bkmkstart AAAAAAADVL}
{\bkmkend AAAAAAADVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the specified {\i layer}  either above or below {\i otherLayer} . Whether it's placed above or below is controlled with {\i insertMode} .\par
Returns true on success, i.e. when both {\i layer}  and {\i otherLayer}  are valid layers in the {\b QCustomPlot}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layer}, {\b addLayer}, {\b moveLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14144 \{\par
14145   if (!mLayers.contains(layer))\par
14146   \{\par
14147     qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);\par
14148     return false;\par
14149   \}\par
14150   if (!mLayers.contains(otherLayer))\par
14151   \{\par
14152     qDebug() << Q_FUNC_INFO << "otherLayer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(otherLayer);\par
14153     return false;\par
14154   \}\par
14155   \par
14156   if (layer->index() > otherLayer->index())\par
14157     mLayers.move(layer->index(), otherLayer->index() + (insertMode==limAbove ? 1:0));\par
14158   else if (layer->index() < otherLayer->index())\par
14159     mLayers.move(layer->index(), otherLayer->index() + (insertMode==limAbove ? 0:-1));\par
14160   \par
14161   // invalidate the paint buffers that are responsible for the layers:\par
14162   if (!layer->mPaintBuffer.isNull())\par
14163     layer->mPaintBuffer.data()->setInvalidated();\par
14164   if (!otherLayer->mPaintBuffer.isNull())\par
14165     otherLayer->mPaintBuffer.data()->setInvalidated();\par
14166   \par
14167   updateLayerIndices();\par
14168   return true;\par
14169 \}\par
}
}
{\xe \v multiSelectModifier\:QCustomPlot}
{\xe \v QCustomPlot\:multiSelectModifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::KeyboardModifier QCustomPlot::multiSelectModifier () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADVM}
{\bkmkend AAAAAAADVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3637 \{ return mMultiSelectModifier; \}\par
}
}
{\xe \v noAntialiasingOnDrag\:QCustomPlot}
{\xe \v QCustomPlot\:noAntialiasingOnDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::noAntialiasingOnDrag () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADVN}
{\bkmkend AAAAAAADVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3635 \{ return mNoAntialiasingOnDrag; \}\par
}
}
{\xe \v notAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:notAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::notAntialiasedElements () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADVO}
{\bkmkend AAAAAAADVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3631 \{ return mNotAntialiasedElements; \}\par
}
}
{\xe \v openGl\:QCustomPlot}
{\xe \v QCustomPlot\:openGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::openGl () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADVP}
{\bkmkend AAAAAAADVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3640 \{ return mOpenGl; \}\par
}
}
{\xe \v paintEvent\:QCustomPlot}
{\xe \v QCustomPlot\:paintEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::paintEvent (QPaintEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVQ}
{\bkmkend AAAAAAADVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14719 \{\par
14720   Q_UNUSED(event);\par
14721   QCPPainter painter(this);\par
14722   if (painter.isActive())\par
14723   \{\par
14724     painter.setRenderHint(QPainter::HighQualityAntialiasing); // to make Antialiasing look good if using the OpenGL graphicssystem\par
14725     if (mBackgroundBrush.style() != Qt::NoBrush)\par
14726       painter.fillRect(mViewport, mBackgroundBrush);\par
14727     drawBackground(&painter);\par
14728     for (int bufferIndex = 0; bufferIndex < mPaintBuffers.size(); ++bufferIndex)\par
14729       mPaintBuffers.at(bufferIndex)->draw(&painter);\par
14730   \}\par
14731 \}\par
}
}
{\xe \v plotLayout\:QCustomPlot}
{\xe \v QCustomPlot\:plotLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutGrid} * QCustomPlot::plotLayout () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADVR}
{\bkmkend AAAAAAADVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the top level layout of this {\b QCustomPlot} instance. It is a {\b QCPLayoutGrid}, initially containing just one cell with the main {\b QCPAxisRect} inside. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3629 \{ return mPlotLayout; \}\par
}
}
{\xe \v plottable\:QCustomPlot}
{\xe \v QCustomPlot\:plottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable} * QCustomPlot::plottable (int  {\i index})}}
\par
{\bkmkstart AAAAAAADVS}
{\bkmkend AAAAAAADVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the plottable with {\i index} . If the index is invalid, returns 0.\par
There is an overloaded version of this function with no parameter which returns the last added plottable, see {\b QCustomPlot::plottable()}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13494 \{\par
13495   if (index >= 0 && index < mPlottables.size())\par
13496   \{\par
13497     return mPlottables.at(index);\par
13498   \} else\par
13499   \{\par
13500     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13501     return 0;\par
13502   \}\par
13503 \}\par
}
}
{\xe \v plottable\:QCustomPlot}
{\xe \v QCustomPlot\:plottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable} * QCustomPlot::plottable ()}}
\par
{\bkmkstart AAAAAAADVT}
{\bkmkend AAAAAAADVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Returns the last plottable that was added to the plot. If there are no plottables in the plot, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13513 \{\par
13514   if (!mPlottables.isEmpty())\par
13515   \{\par
13516     return mPlottables.last();\par
13517   \} else\par
13518     return 0;\par
13519 \}\par
}
}
{\xe \v plottableAt\:QCustomPlot}
{\xe \v QCustomPlot\:plottableAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable} * QCustomPlot::plottableAt (const QPointF &  {\i pos}, bool  {\i onlySelectable} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAADVU}
{\bkmkend AAAAAAADVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the plottable at the pixel position {\i pos} . Plottables that only consist of single lines (like graphs) have a tolerance band around them, see {\b setSelectionTolerance}. If multiple plottables come into consideration, the one closest to {\i pos}  is returned.\par
If {\i onlySelectable}  is true, only plottables that are selectable ({\b QCPAbstractPlottable::setSelectable}) are considered.\par
If there is no plottable at {\i pos} , the return value is 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemAt}, {\b layoutElementAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13620 \{\par
13621   QCPAbstractPlottable *resultPlottable = 0;\par
13622   double resultDistance = mSelectionTolerance; // only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value\par
13623   \par
13624   foreach (QCPAbstractPlottable *plottable, mPlottables)\par
13625   \{\par
13626     if (onlySelectable && !plottable->selectable()) // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPabstractPlottable::selectable\par
13627       continue;\par
13628     if ((plottable->keyAxis()->axisRect()->rect() & plottable->valueAxis()->axisRect()->rect()).contains(pos.toPoint())) // only consider clicks inside the rect that is spanned by the plottable's key/value axes\par
13629     \{\par
13630       double currentDistance = plottable->selectTest(pos, false);\par
13631       if (currentDistance >= 0 && currentDistance < resultDistance)\par
13632       \{\par
13633         resultPlottable = plottable;\par
13634         resultDistance = currentDistance;\par
13635       \}\par
13636     \}\par
13637   \}\par
13638   \par
13639   return resultPlottable;\par
13640 \}\par
}
}
{\xe \v plottableClick\:QCustomPlot}
{\xe \v QCustomPlot\:plottableClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::plottableClick ({\b QCPAbstractPlottable} *  {\i plottable}, int  {\i dataIndex}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADVV}
{\bkmkend AAAAAAADVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when a plottable is clicked.\par
{\i event}  is the mouse event that caused the click and {\i plottable}  is the plottable that received the click. The parameter {\i dataIndex}  indicates the data point that was closest to the click position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableDoubleClick} \par
}}}
{\xe \v plottableCount\:QCustomPlot}
{\xe \v QCustomPlot\:plottableCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::plottableCount () const}}
\par
{\bkmkstart AAAAAAADVW}
{\bkmkend AAAAAAADVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of currently existing plottables in the plot\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13585 \{\par
13586   return mPlottables.size();\par
13587 \}\par
}
}
{\xe \v plottableDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:plottableDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::plottableDoubleClick ({\b QCPAbstractPlottable} *  {\i plottable}, int  {\i dataIndex}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADVX}
{\bkmkend AAAAAAADVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when a plottable is double clicked.\par
{\i event}  is the mouse event that caused the click and {\i plottable}  is the plottable that received the click. The parameter {\i dataIndex}  indicates the data point that was closest to the click position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableClick} \par
}}}
{\xe \v plottingHints\:QCustomPlot}
{\xe \v QCustomPlot\:plottingHints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::PlottingHints QCustomPlot::plottingHints () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADVY}
{\bkmkend AAAAAAADVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3636 \{ return mPlottingHints; \}\par
}
}
{\xe \v processPointSelection\:QCustomPlot}
{\xe \v QCustomPlot\:processPointSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::processPointSelection (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVZ}
{\bkmkend AAAAAAADVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15387 \{\par
15388   QVariant details;\par
15389   QCPLayerable *clickedLayerable = layerableAt(event->pos(), true, &details);\par
15390   bool selectionStateChanged = false;\par
15391   bool additive = mInteractions.testFlag(QCP::iMultiSelect) && event->modifiers().testFlag(mMultiSelectModifier);\par
15392   // deselect all other layerables if not additive selection:\par
15393   if (!additive)\par
15394   \{\par
15395     foreach (QCPLayer *layer, mLayers)\par
15396     \{\par
15397       foreach (QCPLayerable *layerable, layer->children())\par
15398       \{\par
15399         if (layerable != clickedLayerable && mInteractions.testFlag(layerable->selectionCategory()))\par
15400         \{\par
15401           bool selChanged = false;\par
15402           layerable->deselectEvent(&selChanged);\par
15403           selectionStateChanged |= selChanged;\par
15404         \}\par
15405       \}\par
15406     \}\par
15407   \}\par
15408   if (clickedLayerable && mInteractions.testFlag(clickedLayerable->selectionCategory()))\par
15409   \{\par
15410     // a layerable was actually clicked, call its selectEvent:\par
15411     bool selChanged = false;\par
15412     clickedLayerable->selectEvent(event, additive, details, &selChanged);\par
15413     selectionStateChanged |= selChanged;\par
15414   \}\par
15415   if (selectionStateChanged)\par
15416   \{\par
15417     emit selectionChangedByUser();\par
15418     replot(rpQueuedReplot);\par
15419   \}\par
15420 \}\par
}
}
{\xe \v processRectSelection\:QCustomPlot}
{\xe \v QCustomPlot\:processRectSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::processRectSelection (QRect  {\i rect}, QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADWA}
{\bkmkend AAAAAAADWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15273 \{\par
15274   bool selectionStateChanged = false;\par
15275   \par
15276   if (mInteractions.testFlag(QCP::iSelectPlottables))\par
15277   \{\par
15278     QMap<int, QPair<QCPAbstractPlottable*, QCPDataSelection> > potentialSelections; // map key is number of selected data points, so we have selections sorted by size\par
15279     QRectF rectF(rect.normalized());\par
15280     if (QCPAxisRect *affectedAxisRect = axisRectAt(rectF.topLeft()))\par
15281     \{\par
15282       // determine plottables that were hit by the rect and thus are candidates for selection:\par
15283       foreach (QCPAbstractPlottable *plottable, affectedAxisRect->plottables())\par
15284       \{\par
15285         if (QCPPlottableInterface1D *plottableInterface = plottable->interface1D())\par
15286         \{\par
15287           QCPDataSelection dataSel = plottableInterface->selectTestRect(rectF, true);\par
15288           if (!dataSel.isEmpty())\par
15289             potentialSelections.insertMulti(dataSel.dataPointCount(), QPair<QCPAbstractPlottable*, QCPDataSelection>(plottable, dataSel));\par
15290         \}\par
15291       \}\par
15292       \par
15293       if (!mInteractions.testFlag(QCP::iMultiSelect))\par
15294       \{\par
15295         // only leave plottable with most selected points in map, since we will only select a single plottable:\par
15296         if (!potentialSelections.isEmpty())\par
15297         \{\par
15298           QMap<int, QPair<QCPAbstractPlottable*, QCPDataSelection> >::iterator it = potentialSelections.begin();\par
15299           while (it != potentialSelections.end()-1) // erase all except last element\par
15300             it = potentialSelections.erase(it);\par
15301         \}\par
15302       \}\par
15303       \par
15304       bool additive = event->modifiers().testFlag(mMultiSelectModifier);\par
15305       // deselect all other layerables if not additive selection:\par
15306       if (!additive)\par
15307       \{\par
15308         // emit deselection except to those plottables who will be selected afterwards:\par
15309         foreach (QCPLayer *layer, mLayers)\par
15310         \{\par
15311           foreach (QCPLayerable *layerable, layer->children())\par
15312           \{\par
15313             if ((potentialSelections.isEmpty() || potentialSelections.constBegin()->first != layerable) && mInteractions.testFlag(layerable->selectionCategory()))\par
15314             \{\par
15315               bool selChanged = false;\par
15316               layerable->deselectEvent(&selChanged);\par
15317               selectionStateChanged |= selChanged;\par
15318             \}\par
15319           \}\par
15320         \}\par
15321       \}\par
15322       \par
15323       // go through selections in reverse (largest selection first) and emit select events:\par
15324       QMap<int, QPair<QCPAbstractPlottable*, QCPDataSelection> >::const_iterator it = potentialSelections.constEnd();\par
15325       while (it != potentialSelections.constBegin())\par
15326       \{\par
15327         --it;\par
15328         if (mInteractions.testFlag(it.value().first->selectionCategory()))\par
15329         \{\par
15330           bool selChanged = false;\par
15331           it.value().first->selectEvent(event, additive, QVariant::fromValue(it.value().second), &selChanged);\par
15332           selectionStateChanged |= selChanged;\par
15333         \}\par
15334       \}\par
15335     \}\par
15336   \}\par
15337   \par
15338   if (selectionStateChanged)\par
15339   \{\par
15340     emit selectionChangedByUser();\par
15341     replot(rpQueuedReplot);\par
15342   \} else if (mSelectionRect)\par
15343     mSelectionRect->layer()->replot();\par
15344 \}\par
}
}
{\xe \v processRectZoom\:QCustomPlot}
{\xe \v QCustomPlot\:processRectZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::processRectZoom (QRect  {\i rect}, QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADWB}
{\bkmkend AAAAAAADWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15358 \{\par
15359   Q_UNUSED(event)\par
15360   if (QCPAxisRect *axisRect = axisRectAt(rect.topLeft()))\par
15361   \{\par
15362     QList<QCPAxis*> affectedAxes = QList<QCPAxis*>() << axisRect->rangeZoomAxes(Qt::Horizontal) << axisRect->rangeZoomAxes(Qt::Vertical);\par
15363     affectedAxes.removeAll(static_cast<QCPAxis*>(0));\par
15364     axisRect->zoom(QRectF(rect), affectedAxes);\par
15365   \}\par
15366   replot(rpQueuedReplot); // always replot to make selection rect disappear\par
15367 \}\par
}
}
{\xe \v registerGraph\:QCustomPlot}
{\xe \v QCustomPlot\:registerGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::registerGraph ({\b QCPGraph} *  {\i graph}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWC}
{\bkmkend AAAAAAADWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15465 \{\par
15466   if (!graph)\par
15467   \{\par
15468     qDebug() << Q_FUNC_INFO << "passed graph is zero";\par
15469     return false;\par
15470   \}\par
15471   if (mGraphs.contains(graph))\par
15472   \{\par
15473     qDebug() << Q_FUNC_INFO << "graph already registered with this QCustomPlot";\par
15474     return false;\par
15475   \}\par
15476   \par
15477   mGraphs.append(graph);\par
15478   return true;\par
15479 \}\par
}
}
{\xe \v registerItem\:QCustomPlot}
{\xe \v QCustomPlot\:registerItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::registerItem ({\b QCPAbstractItem} *  {\i item}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWD}
{\bkmkend AAAAAAADWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15492 \{\par
15493   if (mItems.contains(item))\par
15494   \{\par
15495     qDebug() << Q_FUNC_INFO << "item already added to this QCustomPlot:" << reinterpret_cast<quintptr>(item);\par
15496     return false;\par
15497   \}\par
15498   if (item->parentPlot() != this)\par
15499   \{\par
15500     qDebug() << Q_FUNC_INFO << "item not created with this QCustomPlot as parent:" << reinterpret_cast<quintptr>(item);\par
15501     return false;\par
15502   \}\par
15503   \par
15504   mItems.append(item);\par
15505   if (!item->layer()) // usually the layer is already set in the constructor of the item (via QCPLayerable constructor)\par
15506     item->setLayer(currentLayer());\par
15507   return true;\par
15508 \}\par
}
}
{\xe \v registerPlottable\:QCustomPlot}
{\xe \v QCustomPlot\:registerPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::registerPlottable ({\b QCPAbstractPlottable} *  {\i plottable}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWE}
{\bkmkend AAAAAAADWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15434 \{\par
15435   if (mPlottables.contains(plottable))\par
15436   \{\par
15437     qDebug() << Q_FUNC_INFO << "plottable already added to this QCustomPlot:" << reinterpret_cast<quintptr>(plottable);\par
15438     return false;\par
15439   \}\par
15440   if (plottable->parentPlot() != this)\par
15441   \{\par
15442     qDebug() << Q_FUNC_INFO << "plottable not created with this QCustomPlot as parent:" << reinterpret_cast<quintptr>(plottable);\par
15443     return false;\par
15444   \}\par
15445   \par
15446   mPlottables.append(plottable);\par
15447   // possibly add plottable to legend:\par
15448   if (mAutoAddPlottableToLegend)\par
15449     plottable->addToLegend();\par
15450   if (!plottable->layer()) // usually the layer is already set in the constructor of the plottable (via QCPLayerable constructor)\par
15451     plottable->setLayer(currentLayer());\par
15452   return true;\par
15453 \}\par
}
}
{\xe \v removeGraph\:QCustomPlot}
{\xe \v QCustomPlot\:removeGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeGraph ({\b QCPGraph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAADWF}
{\bkmkend AAAAAAADWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i graph}  from the plot and deletes it. If necessary, the corresponding legend item is also removed from the default legend ({\b QCustomPlot::legend}). If any other graphs in the plot have a channel fill set towards the removed graph, the channel fill property of those graphs is reset to zero (no channel fill).\par
Returns true on success.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clearGraphs} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13729 \{\par
13730   return removePlottable(graph);\par
13731 \}\par
}
}
{\xe \v removeGraph\:QCustomPlot}
{\xe \v QCustomPlot\:removeGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeGraph (int  {\i index})}}
\par
{\bkmkstart AAAAAAADWG}
{\bkmkend AAAAAAADWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Removes and deletes the graph by its {\i index} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13738 \{\par
13739   if (index >= 0 && index < mGraphs.size())\par
13740     return removeGraph(mGraphs[index]);\par
13741   else\par
13742     return false;\par
13743 \}\par
}
}
{\xe \v removeItem\:QCustomPlot}
{\xe \v QCustomPlot\:removeItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeItem ({\b QCPAbstractItem} *  {\i item})}}
\par
{\bkmkstart AAAAAAADWH}
{\bkmkend AAAAAAADWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified item from the plot and deletes it.\par
Returns true on success.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clearItems} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13834 \{\par
13835   if (mItems.contains(item))\par
13836   \{\par
13837     delete item;\par
13838     mItems.removeOne(item);\par
13839     return true;\par
13840   \} else\par
13841   \{\par
13842     qDebug() << Q_FUNC_INFO << "item not in list:" << reinterpret_cast<quintptr>(item);\par
13843     return false;\par
13844   \}\par
13845 \}\par
}
}
{\xe \v removeItem\:QCustomPlot}
{\xe \v QCustomPlot\:removeItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeItem (int  {\i index})}}
\par
{\bkmkstart AAAAAAADWI}
{\bkmkend AAAAAAADWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Removes and deletes the item by its {\i index} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13852 \{\par
13853   if (index >= 0 && index < mItems.size())\par
13854     return removeItem(mItems[index]);\par
13855   else\par
13856   \{\par
13857     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13858     return false;\par
13859   \}\par
13860 \}\par
}
}
{\xe \v removeLayer\:QCustomPlot}
{\xe \v QCustomPlot\:removeLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeLayer ({\b QCPLayer} *  {\i layer})}}
\par
{\bkmkstart AAAAAAADWJ}
{\bkmkend AAAAAAADWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i layer}  and returns true on success.\par
All layerables (e.g. plottables and items) on the removed layer will be moved to the layer below {\i layer} . If {\i layer}  is the bottom layer, the layerables are moved to the layer above. In both cases, the total rendering order of all layerables in the {\b QCustomPlot} is preserved.\par
If {\i layer}  is the current layer ({\b setCurrentLayer}), the layer below (or above, if bottom layer) becomes the new current layer.\par
It is not possible to remove the last layer of the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layer}, {\b addLayer}, {\b moveLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14095 \{\par
14096   if (!mLayers.contains(layer))\par
14097   \{\par
14098     qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);\par
14099     return false;\par
14100   \}\par
14101   if (mLayers.size() < 2)\par
14102   \{\par
14103     qDebug() << Q_FUNC_INFO << "can't remove last layer";\par
14104     return false;\par
14105   \}\par
14106   \par
14107   // append all children of this layer to layer below (if this is lowest layer, prepend to layer above)\par
14108   int removedIndex = layer->index();\par
14109   bool isFirstLayer = removedIndex==0;\par
14110   QCPLayer *targetLayer = isFirstLayer ? mLayers.at(removedIndex+1) : mLayers.at(removedIndex-1);\par
14111   QList<QCPLayerable*> children = layer->children();\par
14112   if (isFirstLayer) // prepend in reverse order (so order relative to each other stays the same)\par
14113   \{\par
14114     for (int i=children.size()-1; i>=0; --i)\par
14115       children.at(i)->moveToLayer(targetLayer, true);\par
14116   \} else  // append normally\par
14117   \{\par
14118     for (int i=0; i<children.size(); ++i)\par
14119       children.at(i)->moveToLayer(targetLayer, false);\par
14120   \}\par
14121   // if removed layer is current layer, change current layer to layer below/above:\par
14122   if (layer == mCurrentLayer)\par
14123     setCurrentLayer(targetLayer);\par
14124   // invalidate the paint buffer that was responsible for this layer:\par
14125   if (!layer->mPaintBuffer.isNull())\par
14126     layer->mPaintBuffer.data()->setInvalidated();\par
14127   // remove layer:\par
14128   delete layer;\par
14129   mLayers.removeOne(layer);\par
14130   updateLayerIndices();\par
14131   return true;\par
14132 \}\par
}
}
{\xe \v removePlottable\:QCustomPlot}
{\xe \v QCustomPlot\:removePlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removePlottable ({\b QCPAbstractPlottable} *  {\i plottable})}}
\par
{\bkmkstart AAAAAAADWK}
{\bkmkend AAAAAAADWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified plottable from the plot and deletes it. If necessary, the corresponding legend item is also removed from the default legend ({\b QCustomPlot::legend}).\par
Returns true on success.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clearPlottables} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13530 \{\par
13531   if (!mPlottables.contains(plottable))\par
13532   \{\par
13533     qDebug() << Q_FUNC_INFO << "plottable not in list:" << reinterpret_cast<quintptr>(plottable);\par
13534     return false;\par
13535   \}\par
13536   \par
13537   // remove plottable from legend:\par
13538   plottable->removeFromLegend();\par
13539   // special handling for QCPGraphs to maintain the simple graph interface:\par
13540   if (QCPGraph *graph = qobject_cast<QCPGraph*>(plottable))\par
13541     mGraphs.removeOne(graph);\par
13542   // remove plottable:\par
13543   delete plottable;\par
13544   mPlottables.removeOne(plottable);\par
13545   return true;\par
13546 \}\par
}
}
{\xe \v removePlottable\:QCustomPlot}
{\xe \v QCustomPlot\:removePlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removePlottable (int  {\i index})}}
\par
{\bkmkstart AAAAAAADWL}
{\bkmkend AAAAAAADWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Removes and deletes the plottable by its {\i index} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13553 \{\par
13554   if (index >= 0 && index < mPlottables.size())\par
13555     return removePlottable(mPlottables[index]);\par
13556   else\par
13557   \{\par
13558     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13559     return false;\par
13560   \}\par
13561 \}\par
}
}
{\xe \v replot\:QCustomPlot}
{\xe \v QCustomPlot\:replot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::replot ({\b QCustomPlot::RefreshPriority}  {\i refreshPriority} = {\f2 {\b QCustomPlot::rpRefreshHint}})}}
\par
{\bkmkstart AAAAAAADWM}
{\bkmkend AAAAAAADWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Causes a complete replot into the internal paint buffer(s). Finally, the widget surface is refreshed with the new buffer contents. This is the method that must be called to make changes to the plot, e.g. on the axis ranges or data points of graphs, visible.\par
The parameter {\i refreshPriority}  can be used to fine-tune the timing of the replot. For example if your application calls {\b replot} very quickly in succession (e.g. multiple independent functions change some aspects of the plot and each wants to make sure the change gets replotted), it is advisable to set {\i refreshPriority}  to {\b QCustomPlot::rpQueuedReplot}. This way, the actual replotting is deferred to the next event loop iteration. Multiple successive calls of {\b replot} with this priority will only cause a single replot, avoiding redundant replots and improving performance.\par
Under a few circumstances, {\b QCustomPlot} causes a replot by itself. Those are resize events of the {\b QCustomPlot} widget and user interactions (object selection and range dragging/zooming).\par
Before the replot happens, the signal {\b beforeReplot} is emitted. After the replot, {\b afterReplot} is emitted. It is safe to mutually connect the replot slot with any of those two signals on two QCustomPlots to make them replot synchronously, it won't cause an infinite recursion.\par
If a layer is in mode {\b QCPLayer::lmBuffered} ({\b QCPLayer::setMode}), it is also possible to replot only that specific layer via {\b QCPLayer::replot}. See the documentation there for details. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14397 \{\par
14398   if (refreshPriority == QCustomPlot::rpQueuedReplot)\par
14399   \{\par
14400     if (!mReplotQueued)\par
14401     \{\par
14402       mReplotQueued = true;\par
14403       QTimer::singleShot(0, this, SLOT(replot()));\par
14404     \}\par
14405     return;\par
14406   \}\par
14407   \par
14408   if (mReplotting) // incase signals loop back to replot slot\par
14409     return;\par
14410   mReplotting = true;\par
14411   mReplotQueued = false;\par
14412   emit beforeReplot();\par
14413   \par
14414   updateLayout();\par
14415   // draw all layered objects (grid, axes, plottables, items, legend,...) into their buffers:\par
14416   setupPaintBuffers();\par
14417   foreach (QCPLayer *layer, mLayers)\par
14418     layer->drawToPaintBuffer();\par
14419   for (int i=0; i<mPaintBuffers.size(); ++i)\par
14420     mPaintBuffers.at(i)->setInvalidated(false);\par
14421   \par
14422   if ((refreshPriority == rpRefreshHint && mPlottingHints.testFlag(QCP::phImmediateRefresh)) || refreshPriority==rpImmediateRefresh)\par
14423     repaint();\par
14424   else\par
14425     update();\par
14426   \par
14427   emit afterReplot();\par
14428   mReplotting = false;\par
14429 \}\par
}
}
{\xe \v rescaleAxes\:QCustomPlot}
{\xe \v QCustomPlot\:rescaleAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::rescaleAxes (bool  {\i onlyVisiblePlottables} = {\f2 false})}}
\par
{\bkmkstart AAAAAAADWN}
{\bkmkend AAAAAAADWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the axes such that all plottables (like graphs) in the plot are fully visible.\par
if {\i onlyVisiblePlottables}  is set to true, only the plottables that have their visibility set to true ({\b QCPLayerable::setVisible}), will be used to rescale the axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractPlottable::rescaleAxes}, {\b QCPAxis::rescale} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14440 \{\par
14441   QList<QCPAxis*> allAxes;\par
14442   foreach (QCPAxisRect *rect, axisRects())\par
14443     allAxes << rect->axes();\par
14444   \par
14445   foreach (QCPAxis *axis, allAxes)\par
14446     axis->rescale(onlyVisiblePlottables);\par
14447 \}\par
}
}
{\xe \v resizeEvent\:QCustomPlot}
{\xe \v QCustomPlot\:resizeEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::resizeEvent (QResizeEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADWO}
{\bkmkend AAAAAAADWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14739 \{\par
14740   Q_UNUSED(event)\par
14741   // resize and repaint the buffer:\par
14742   setViewport(rect());\par
14743   replot(rpQueuedRefresh); // queued refresh is important here, to prevent painting issues in some contexts (e.g. MDI subwindow)\par
14744 \}\par
}
}
{\xe \v saveBmp\:QCustomPlot}
{\xe \v QCustomPlot\:saveBmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::saveBmp (const QString &  {\i fileName}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, double  {\i scale} = {\f2 1.0}, int  {\i resolution} = {\f2 96}, {\b QCP::ResolutionUnit}  {\i resolutionUnit} = {\f2 {\b QCP::ruDotsPerInch}})}}
\par
{\bkmkstart AAAAAAADWP}
{\bkmkend AAAAAAADWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves a BMP image file to {\i fileName}  on disc. The output plot will have the dimensions {\i width}  and {\i height}  in pixels, multiplied by {\i scale} . If either {\i width}  or {\i height}  is zero, the current width and height of the {\b QCustomPlot} widget is used instead. Line widths and texts etc. are not scaled up when larger widths/heights are used. If you want that effect, use the {\i scale}  parameter.\par
For example, if you set both {\i width}  and {\i height}  to 100 and {\i scale}  to 2, you will end up with an image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths, texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full 200*200 pixel resolution.\par
If you use a high scaling factor, it is recommended to enable antialiasing for all elements by temporarily setting {\b QCustomPlot::setAntialiasedElements} to {\b QCP::aeAll} as this allows {\b QCustomPlot} to place objects with sub-pixel accuracy.\par
The {\i resolution}  will be written to the image file header and has no direct consequence for the quality or the pixel size. However, if opening the image with a tool which respects the metadata, it will be able to scale the image to match either a given size in real units of length (inch, centimeters, etc.), or the target display DPI. You can specify in which units {\i resolution}  is given, by setting {\i resolutionUnit} . The {\i resolution}  is converted to the format's expected resolution unit internally.\par
Returns true on success. If this function fails, most likely the BMP format isn't supported by the system, see Qt docs about QImageWriter::supportedImageFormats().\par
The objects of the plot will appear in the current selection state. If you don't want any selected objects to be painted in their selected look, deselect everything with {\b deselectAll} before calling this function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Aviso:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If calling this function inside the constructor of the parent of the {\b QCustomPlot} widget (i.e. the {\b MainWindow} constructor, if {\b QCustomPlot} is inside the {\b MainWindow}), always provide explicit non-zero widths and heights. If you leave {\i width}  or {\i height}  as 0 (default), this function uses the current width and height of the {\b QCustomPlot} widget. However, in Qt, these aren't defined yet inside the constructor, so you would get an image that has strange widths/heights.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b savePdf}, {\b savePng}, {\b saveJpg}, {\b saveRastered} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14686 \{\par
14687   return saveRastered(fileName, width, height, scale, "BMP", -1, resolution, resolutionUnit);\par
14688 \}\par
}
}
{\xe \v saveJpg\:QCustomPlot}
{\xe \v QCustomPlot\:saveJpg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::saveJpg (const QString &  {\i fileName}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, double  {\i scale} = {\f2 1.0}, int  {\i quality} = {\f2 -1}, int  {\i resolution} = {\f2 96}, {\b QCP::ResolutionUnit}  {\i resolutionUnit} = {\f2 {\b QCP::ruDotsPerInch}})}}
\par
{\bkmkstart AAAAAAADWQ}
{\bkmkend AAAAAAADWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves a JPEG image file to {\i fileName}  on disc. The output plot will have the dimensions {\i width}  and {\i height}  in pixels, multiplied by {\i scale} . If either {\i width}  or {\i height}  is zero, the current width and height of the {\b QCustomPlot} widget is used instead. Line widths and texts etc. are not scaled up when larger widths/heights are used. If you want that effect, use the {\i scale}  parameter.\par
For example, if you set both {\i width}  and {\i height}  to 100 and {\i scale}  to 2, you will end up with an image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths, texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full 200*200 pixel resolution.\par
If you use a high scaling factor, it is recommended to enable antialiasing for all elements by temporarily setting {\b QCustomPlot::setAntialiasedElements} to {\b QCP::aeAll} as this allows {\b QCustomPlot} to place objects with sub-pixel accuracy.\par
image compression can be controlled with the {\i quality}  parameter which must be between 0 and 100 or -1 to use the default setting.\par
The {\i resolution}  will be written to the image file header and has no direct consequence for the quality or the pixel size. However, if opening the image with a tool which respects the metadata, it will be able to scale the image to match either a given size in real units of length (inch, centimeters, etc.), or the target display DPI. You can specify in which units {\i resolution}  is given, by setting {\i resolutionUnit} . The {\i resolution}  is converted to the format's expected resolution unit internally.\par
Returns true on success. If this function fails, most likely the JPEG format isn't supported by the system, see Qt docs about QImageWriter::supportedImageFormats().\par
The objects of the plot will appear in the current selection state. If you don't want any selected objects to be painted in their selected look, deselect everything with {\b deselectAll} before calling this function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Aviso:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If calling this function inside the constructor of the parent of the {\b QCustomPlot} widget (i.e. the {\b MainWindow} constructor, if {\b QCustomPlot} is inside the {\b MainWindow}), always provide explicit non-zero widths and heights. If you leave {\i width}  or {\i height}  as 0 (default), this function uses the current width and height of the {\b QCustomPlot} widget. However, in Qt, these aren't defined yet inside the constructor, so you would get an image that has strange widths/heights.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b savePdf}, {\b savePng}, {\b saveBmp}, {\b saveRastered} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14642 \{\par
14643   return saveRastered(fileName, width, height, scale, "JPG", quality, resolution, resolutionUnit);\par
14644 \}\par
}
}
{\xe \v savePdf\:QCustomPlot}
{\xe \v QCustomPlot\:savePdf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::savePdf (const QString &  {\i fileName}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, {\b QCP::ExportPen}  {\i exportPen} = {\f2 {\b QCP::epAllowCosmetic}}, const QString &  {\i pdfCreator} = {\f2 QString()}, const QString &  {\i pdfTitle} = {\f2 QString()})}}
\par
{\bkmkstart AAAAAAADWR}
{\bkmkend AAAAAAADWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves a PDF with the vectorized plot to the file {\i fileName} . The axis ratio as well as the scale of texts and lines will be derived from the specified {\i width}  and {\i height} . This means, the output will look like the normal on-screen output of a {\b QCustomPlot} widget with the corresponding pixel width and height. If either {\i width}  or {\i height}  is zero, the exported image will have the same dimensions as the {\b QCustomPlot} widget currently has.\par
Setting {\i exportPen}  to {\b QCP::epNoCosmetic} allows to disable the use of cosmetic pens when drawing to the PDF file. Cosmetic pens are pens with numerical width 0, which are always drawn as a one pixel wide line, no matter what zoom factor is set in the PDF-Viewer. For more information about cosmetic pens, see the QPainter and QPen documentation.\par
The objects of the plot will appear in the current selection state. If you don't want any selected objects to be painted in their selected look, deselect everything with {\b deselectAll} before calling this function.\par
Returns true on success.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Aviso:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
\par\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If you plan on editing the exported PDF file with a vector graphics editor like Inkscape, it is advised to set {\i exportPen}  to {\b QCP::epNoCosmetic} to avoid losing those cosmetic lines (which might be quite many, because cosmetic pens are the default for e.g. axes and tick marks). \par\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If calling this function inside the constructor of the parent of the {\b QCustomPlot} widget (i.e. the {\b MainWindow} constructor, if {\b QCustomPlot} is inside the {\b MainWindow}), always provide explicit non-zero widths and heights. If you leave {\i width}  or {\i height}  as 0 (default), this function uses the current width and height of the {\b QCustomPlot} widget. However, in Qt, these aren't defined yet inside the constructor, so you would get an image that has strange widths/heights.\par
}
{\i pdfCreator}  and {\i pdfTitle}  may be used to set the according metadata fields in the resulting PDF file.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Observação:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid On Android systems, this method does nothing and issues an according qDebug warning message. This is also the case if for other reasons the define flag {\f2 QT_NO_PRINTER}  is set.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b savePng}, {\b saveBmp}, {\b saveJpg}, {\b saveRastered} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14487 \{\par
14488   bool success = false;\par
14489 #ifdef QT_NO_PRINTER\par
14490   Q_UNUSED(fileName)\par
14491   Q_UNUSED(exportPen)\par
14492   Q_UNUSED(width)\par
14493   Q_UNUSED(height)\par
14494   Q_UNUSED(pdfCreator)\par
14495   Q_UNUSED(pdfTitle)\par
14496   qDebug() << Q_FUNC_INFO << "Qt was built without printer support (QT_NO_PRINTER). PDF not created.";\par
14497 #else\par
14498   int newWidth, newHeight;\par
14499   if (width == 0 || height == 0)\par
14500   \{\par
14501     newWidth = this->width();\par
14502     newHeight = this->height();\par
14503   \} else\par
14504   \{\par
14505     newWidth = width;\par
14506     newHeight = height;\par
14507   \}\par
14508   \par
14509   QPrinter printer(QPrinter::ScreenResolution);\par
14510   printer.setOutputFileName(fileName);\par
14511   printer.setOutputFormat(QPrinter::PdfFormat);\par
14512   printer.setColorMode(QPrinter::Color);\par
14513   printer.printEngine()->setProperty(QPrintEngine::PPK_Creator, pdfCreator);\par
14514   printer.printEngine()->setProperty(QPrintEngine::PPK_DocumentName, pdfTitle);\par
14515   QRect oldViewport = viewport();\par
14516   setViewport(QRect(0, 0, newWidth, newHeight));\par
14517 #if QT_VERSION < QT_VERSION_CHECK(5, 3, 0)\par
14518   printer.setFullPage(true);\par
14519   printer.setPaperSize(viewport().size(), QPrinter::DevicePixel);\par
14520 #else\par
14521   QPageLayout pageLayout;\par
14522   pageLayout.setMode(QPageLayout::FullPageMode);\par
14523   pageLayout.setOrientation(QPageLayout::Portrait);\par
14524   pageLayout.setMargins(QMarginsF(0, 0, 0, 0));\par
14525   pageLayout.setPageSize(QPageSize(viewport().size(), QPageSize::Point, QString(), QPageSize::ExactMatch));\par
14526   printer.setPageLayout(pageLayout);\par
14527 #endif\par
14528   QCPPainter printpainter;\par
14529   if (printpainter.begin(&printer))\par
14530   \{\par
14531     printpainter.setMode(QCPPainter::pmVectorized);\par
14532     printpainter.setMode(QCPPainter::pmNoCaching);\par
14533     printpainter.setMode(QCPPainter::pmNonCosmetic, exportPen==QCP::epNoCosmetic);\par
14534     printpainter.setWindow(mViewport);\par
14535     if (mBackgroundBrush.style() != Qt::NoBrush &&\par
14536         mBackgroundBrush.color() != Qt::white &&\par
14537         mBackgroundBrush.color() != Qt::transparent &&\par
14538         mBackgroundBrush.color().alpha() > 0) // draw pdf background color if not white/transparent\par
14539       printpainter.fillRect(viewport(), mBackgroundBrush);\par
14540     draw(&printpainter);\par
14541     printpainter.end();\par
14542     success = true;\par
14543   \}\par
14544   setViewport(oldViewport);\par
14545 #endif // QT_NO_PRINTER\par
14546   return success;\par
14547 \}\par
}
}
{\xe \v savePng\:QCustomPlot}
{\xe \v QCustomPlot\:savePng}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::savePng (const QString &  {\i fileName}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, double  {\i scale} = {\f2 1.0}, int  {\i quality} = {\f2 -1}, int  {\i resolution} = {\f2 96}, {\b QCP::ResolutionUnit}  {\i resolutionUnit} = {\f2 {\b QCP::ruDotsPerInch}})}}
\par
{\bkmkstart AAAAAAADWS}
{\bkmkend AAAAAAADWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves a PNG image file to {\i fileName}  on disc. The output plot will have the dimensions {\i width}  and {\i height}  in pixels, multiplied by {\i scale} . If either {\i width}  or {\i height}  is zero, the current width and height of the {\b QCustomPlot} widget is used instead. Line widths and texts etc. are not scaled up when larger widths/heights are used. If you want that effect, use the {\i scale}  parameter.\par
For example, if you set both {\i width}  and {\i height}  to 100 and {\i scale}  to 2, you will end up with an image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths, texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full 200*200 pixel resolution.\par
If you use a high scaling factor, it is recommended to enable antialiasing for all elements by temporarily setting {\b QCustomPlot::setAntialiasedElements} to {\b QCP::aeAll} as this allows {\b QCustomPlot} to place objects with sub-pixel accuracy.\par
image compression can be controlled with the {\i quality}  parameter which must be between 0 and 100 or -1 to use the default setting.\par
The {\i resolution}  will be written to the image file header and has no direct consequence for the quality or the pixel size. However, if opening the image with a tool which respects the metadata, it will be able to scale the image to match either a given size in real units of length (inch, centimeters, etc.), or the target display DPI. You can specify in which units {\i resolution}  is given, by setting {\i resolutionUnit} . The {\i resolution}  is converted to the format's expected resolution unit internally.\par
Returns true on success. If this function fails, most likely the PNG format isn't supported by the system, see Qt docs about QImageWriter::supportedImageFormats().\par
The objects of the plot will appear in the current selection state. If you don't want any selected objects to be painted in their selected look, deselect everything with {\b deselectAll} before calling this function.\par
If you want the PNG to have a transparent background, call {\b setBackground(const QBrush &brush)} with no brush (Qt::NoBrush) or a transparent color (Qt::transparent), before saving.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Aviso:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If calling this function inside the constructor of the parent of the {\b QCustomPlot} widget (i.e. the {\b MainWindow} constructor, if {\b QCustomPlot} is inside the {\b MainWindow}), always provide explicit non-zero widths and heights. If you leave {\i width}  or {\i height}  as 0 (default), this function uses the current width and height of the {\b QCustomPlot} widget. However, in Qt, these aren't defined yet inside the constructor, so you would get an image that has strange widths/heights.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b savePdf}, {\b saveBmp}, {\b saveJpg}, {\b saveRastered} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14595 \{\par
14596   return saveRastered(fileName, width, height, scale, "PNG", quality, resolution, resolutionUnit);\par
14597 \}\par
}
}
{\xe \v saveRastered\:QCustomPlot}
{\xe \v QCustomPlot\:saveRastered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::saveRastered (const QString &  {\i fileName}, int  {\i width}, int  {\i height}, double  {\i scale}, const char *  {\i format}, int  {\i quality} = {\f2 -1}, int  {\i resolution} = {\f2 96}, {\b QCP::ResolutionUnit}  {\i resolutionUnit} = {\f2 {\b QCP::ruDotsPerInch}})}}
\par
{\bkmkstart AAAAAAADWT}
{\bkmkend AAAAAAADWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves the plot to a rastered image file {\i fileName}  in the image format {\i format} . The plot is sized to {\i width}  and {\i height}  in pixels and scaled with {\i scale} . (width 100 and scale 2.0 lead to a full resolution file with width 200.) If the {\i format}  supports compression, {\i quality}  may be between 0 and 100 to control it.\par
Returns true on success. If this function fails, most likely the given {\i format}  isn't supported by the system, see Qt docs about QImageWriter::supportedImageFormats().\par
The {\i resolution}  will be written to the image file header (if the file format supports this) and has no direct consequence for the quality or the pixel size. However, if opening the image with a tool which respects the metadata, it will be able to scale the image to match either a given size in real units of length (inch, centimeters, etc.), or the target display DPI. You can specify in which units {\i resolution}  is given, by setting {\i resolutionUnit} . The {\i resolution}  is converted to the format's expected resolution unit internally.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b saveBmp}, {\b saveJpg}, {\b savePng}, {\b savePdf} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15609 \{\par
15610   QImage buffer = toPixmap(width, height, scale).toImage();\par
15611   \par
15612   int dotsPerMeter = 0;\par
15613   switch (resolutionUnit)\par
15614   \{\par
15615     case QCP::ruDotsPerMeter: dotsPerMeter = resolution; break;\par
15616     case QCP::ruDotsPerCentimeter: dotsPerMeter = resolution*100; break;\par
15617     case QCP::ruDotsPerInch: dotsPerMeter = resolution/0.0254; break;\par
15618   \}\par
15619   buffer.setDotsPerMeterX(dotsPerMeter); // this is saved together with some image formats, e.g. PNG, and is relevant when opening image in other tools\par
15620   buffer.setDotsPerMeterY(dotsPerMeter); // this is saved together with some image formats, e.g. PNG, and is relevant when opening image in other tools\par
15621   if (!buffer.isNull())\par
15622     return buffer.save(fileName, format, quality);\par
15623   else\par
15624     return false;\par
15625 \}\par
}
}
{\xe \v selectedAxes\:QCustomPlot}
{\xe \v QCustomPlot\:selectedAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCustomPlot::selectedAxes () const}}
\par
{\bkmkstart AAAAAAADWU}
{\bkmkend AAAAAAADWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the axes that currently have selected parts, i.e. whose selection state is not {\b QCPAxis::spNone}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectedPlottables}, {\b selectedLegends}, {\b setInteractions}, {\b QCPAxis::setSelectedParts}, {\b QCPAxis::setSelectableParts} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14305 \{\par
14306   QList<QCPAxis*> result, allAxes;\par
14307   foreach (QCPAxisRect *rect, axisRects())\par
14308     allAxes << rect->axes();\par
14309   \par
14310   foreach (QCPAxis *axis, allAxes)\par
14311   \{\par
14312     if (axis->selectedParts() != QCPAxis::spNone)\par
14313       result.append(axis);\par
14314   \}\par
14315   \par
14316   return result;\par
14317 \}\par
}
}
{\xe \v selectedGraphs\:QCustomPlot}
{\xe \v QCustomPlot\:selectedGraphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPGraph} * > QCustomPlot::selectedGraphs () const}}
\par
{\bkmkstart AAAAAAADWV}
{\bkmkend AAAAAAADWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of the selected graphs. If no graphs are currently selected, the list is empty.\par
If you are not only interested in selected graphs but other plottables like {\b QCPCurve}, {\b QCPBars}, etc., use {\b selectedPlottables}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b selectedPlottables}, {\b QCPAbstractPlottable::setSelectable}, {\b QCPAbstractPlottable::setSelection} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13780 \{\par
13781   QList<QCPGraph*> result;\par
13782   foreach (QCPGraph *graph, mGraphs)\par
13783   \{\par
13784     if (graph->selected())\par
13785       result.append(graph);\par
13786   \}\par
13787   return result;\par
13788 \}\par
}
}
{\xe \v selectedItems\:QCustomPlot}
{\xe \v QCustomPlot\:selectedItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractItem} * > QCustomPlot::selectedItems () const}}
\par
{\bkmkstart AAAAAAADWW}
{\bkmkend AAAAAAADWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of the selected items. If no items are currently selected, the list is empty.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b QCPAbstractItem::setSelectable}, {\b QCPAbstractItem::setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13893 \{\par
13894   QList<QCPAbstractItem*> result;\par
13895   foreach (QCPAbstractItem *item, mItems)\par
13896   \{\par
13897     if (item->selected())\par
13898       result.append(item);\par
13899   \}\par
13900   return result;\par
13901 \}\par
}
}
{\xe \v selectedLegends\:QCustomPlot}
{\xe \v QCustomPlot\:selectedLegends}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLegend} * > QCustomPlot::selectedLegends () const}}
\par
{\bkmkstart AAAAAAADWX}
{\bkmkend AAAAAAADWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the legends that currently have selected parts, i.e. whose selection state is not {\b QCPLegend::spNone}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectedPlottables}, {\b selectedAxes}, {\b setInteractions}, {\b QCPLegend::setSelectedParts}, {\b QCPLegend::setSelectableParts}, {\b QCPLegend::selectedItems} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14327 \{\par
14328   QList<QCPLegend*> result;\par
14329   \par
14330   QStack<QCPLayoutElement*> elementStack;\par
14331   if (mPlotLayout)\par
14332     elementStack.push(mPlotLayout);\par
14333   \par
14334   while (!elementStack.isEmpty())\par
14335   \{\par
14336     foreach (QCPLayoutElement *subElement, elementStack.pop()->elements(false))\par
14337     \{\par
14338       if (subElement)\par
14339       \{\par
14340         elementStack.push(subElement);\par
14341         if (QCPLegend *leg = qobject_cast<QCPLegend*>(subElement))\par
14342         \{\par
14343           if (leg->selectedParts() != QCPLegend::spNone)\par
14344             result.append(leg);\par
14345         \}\par
14346       \}\par
14347     \}\par
14348   \}\par
14349   \par
14350   return result;\par
14351 \}\par
}
}
{\xe \v selectedPlottables\:QCustomPlot}
{\xe \v QCustomPlot\:selectedPlottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractPlottable} * > QCustomPlot::selectedPlottables () const}}
\par
{\bkmkstart AAAAAAADWY}
{\bkmkend AAAAAAADWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of the selected plottables. If no plottables are currently selected, the list is empty.\par
There is a convenience function if you're only interested in selected graphs, see {\b selectedGraphs}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b QCPAbstractPlottable::setSelectable}, {\b QCPAbstractPlottable::setSelection} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13597 \{\par
13598   QList<QCPAbstractPlottable*> result;\par
13599   foreach (QCPAbstractPlottable *plottable, mPlottables)\par
13600   \{\par
13601     if (plottable->selected())\par
13602       result.append(plottable);\par
13603   \}\par
13604   return result;\par
13605 \}\par
}
}
{\xe \v selectionChangedByUser\:QCustomPlot}
{\xe \v QCustomPlot\:selectionChangedByUser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::selectionChangedByUser (){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADWZ}
{\bkmkend AAAAAAADWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted after the user has changed the selection in the {\b QCustomPlot}, e.g. by clicking. It is not emitted when the selection state of an object has changed programmatically by a direct call to {\f2 setSelected()} /{\f2 setSelection()}  on an object or by calling {\b deselectAll}.\par
In addition to this signal, selectable objects also provide individual signals, for example {\b QCPAxis::selectionChanged} or {\b QCPAbstractPlottable::selectionChanged}. Note that those signals are emitted even if the selection state is changed programmatically.\par
See the documentation of {\b setInteractions} for details about the selection mechanism.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectedPlottables}, {\b selectedGraphs}, {\b selectedItems}, {\b selectedAxes}, {\b selectedLegends} \par
}}}
{\xe \v selectionRect\:QCustomPlot}
{\xe \v QCustomPlot\:selectionRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionRect} * QCustomPlot::selectionRect () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADXA}
{\bkmkend AAAAAAADXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allows access to the currently used {\b QCPSelectionRect} instance (or subclass thereof), that is used to handle and draw selection rect interactions (see {\b setSelectionRectMode}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectionRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3639 \{ return mSelectionRect; \}\par
}
}
{\xe \v selectionRectMode\:QCustomPlot}
{\xe \v QCustomPlot\:selectionRectMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionRectMode} QCustomPlot::selectionRectMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADXB}
{\bkmkend AAAAAAADXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3638 \{ return mSelectionRectMode; \}\par
}
}
{\xe \v selectionTolerance\:QCustomPlot}
{\xe \v QCustomPlot\:selectionTolerance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::selectionTolerance () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADXC}
{\bkmkend AAAAAAADXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3634 \{ return mSelectionTolerance; \}\par
}
}
{\xe \v setAntialiasedElement\:QCustomPlot}
{\xe \v QCustomPlot\:setAntialiasedElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setAntialiasedElement ({\b QCP::AntialiasedElement}  {\i antialiasedElement}, bool  {\i enabled} = {\f2 true})}}
\par
{\bkmkstart AAAAAAADXD}
{\bkmkend AAAAAAADXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the specified {\i antialiasedElement}  is forcibly drawn antialiased.\par
See {\b setAntialiasedElements} for details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setNotAntialiasedElement} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12995 \{\par
12996   if (!enabled && mAntialiasedElements.testFlag(antialiasedElement))\par
12997     mAntialiasedElements &= ~antialiasedElement;\par
12998   else if (enabled && !mAntialiasedElements.testFlag(antialiasedElement))\par
12999     mAntialiasedElements |= antialiasedElement;\par
13000   \par
13001   // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:\par
13002   if ((mNotAntialiasedElements & mAntialiasedElements) != 0)\par
13003     mNotAntialiasedElements |= ~mAntialiasedElements;\par
13004 \}\par
}
}
{\xe \v setAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:setAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setAntialiasedElements (const QCP::AntialiasedElements &  {\i antialiasedElements})}}
\par
{\bkmkstart AAAAAAADXE}
{\bkmkend AAAAAAADXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which elements are forcibly drawn antialiased as an {\i or}  combination of {\b QCP::AntialiasedElement}.\par
This overrides the antialiasing settings for whole element groups, normally controlled with the {\i setAntialiasing}  function on the individual elements. If an element is neither specified in {\b setAntialiasedElements} nor in {\b setNotAntialiasedElements}, the antialiasing setting on each individual element instance is used.\par
For example, if {\i antialiasedElements}  contains {\b QCP::aePlottables}, all plottables will be drawn antialiased, no matter what the specific {\b QCPAbstractPlottable::setAntialiased} value was set to.\par
if an element in {\i antialiasedElements}  is already set in {\b setNotAntialiasedElements}, it is removed from there.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setNotAntialiasedElements} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12979 \{\par
12980   mAntialiasedElements = antialiasedElements;\par
12981   \par
12982   // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:\par
12983   if ((mNotAntialiasedElements & mAntialiasedElements) != 0)\par
12984     mNotAntialiasedElements |= ~mAntialiasedElements;\par
12985 \}\par
}
}
{\xe \v setAutoAddPlottableToLegend\:QCustomPlot}
{\xe \v QCustomPlot\:setAutoAddPlottableToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setAutoAddPlottableToLegend (bool  {\i on})}}
\par
{\bkmkstart AAAAAAADXF}
{\bkmkend AAAAAAADXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If set to true, adding a plottable (e.g. a graph) to the {\b QCustomPlot} automatically also adds the plottable to the legend ({\b QCustomPlot::legend}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addGraph}, {\b QCPLegend::addItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13059 \{\par
13060   mAutoAddPlottableToLegend = on;\par
13061 \}\par
}
}
{\xe \v setBackground\:QCustomPlot}
{\xe \v QCustomPlot\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackground (const QPixmap &  {\i pm})}}
\par
{\bkmkstart AAAAAAADXG}
{\bkmkend AAAAAAADXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets {\i pm}  as the viewport background pixmap (see {\b setViewport}). The pixmap is always drawn below all other objects in the plot.\par
For cases where the provided pixmap doesn't have the same size as the viewport, scaling can be enabled with {\b setBackgroundScaled} and the scaling mode (whether and how the aspect ratio is preserved) can be set with {\b setBackgroundScaledMode}. To set all these options in one call, consider using the overloaded version of this function.\par
If a background brush was set with {\b setBackground(const QBrush &brush)}, the viewport will first be filled with that brush, before drawing the background pixmap. This can be useful for background pixmaps with translucent areas.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackgroundScaled}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13421 \{\par
13422   mBackgroundPixmap = pm;\par
13423   mScaledBackgroundPixmap = QPixmap();\par
13424 \}\par
}
}
{\xe \v setBackground\:QCustomPlot}
{\xe \v QCustomPlot\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackground (const QPixmap &  {\i pm}, bool  {\i scaled}, Qt::AspectRatioMode  {\i mode} = {\f2 Qt::KeepAspectRatioByExpanding})}}
\par
{\bkmkstart AAAAAAADXH}
{\bkmkend AAAAAAADXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Allows setting the background pixmap of the viewport, whether it shall be scaled and how it shall be scaled in one call.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground(const QPixmap &pm)}, {\b setBackgroundScaled}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13452 \{\par
13453   mBackgroundPixmap = pm;\par
13454   mScaledBackgroundPixmap = QPixmap();\par
13455   mBackgroundScaled = scaled;\par
13456   mBackgroundScaledMode = mode;\par
13457 \}\par
}
}
{\xe \v setBackground\:QCustomPlot}
{\xe \v QCustomPlot\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackground (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAADXI}
{\bkmkend AAAAAAADXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the background brush of the viewport (see {\b setViewport}).\par
Before drawing everything else, the background is filled with {\i brush} . If a background pixmap was set with {\b setBackground(const QPixmap &pm)}, this brush will be used to fill the viewport before the background pixmap is drawn. This can be useful for background pixmaps with translucent areas.\par
Set {\i brush}  to Qt::NoBrush or Qt::Transparent to leave background transparent. This can be useful for exporting to image formats which support transparency, e.g. {\b savePng}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackgroundScaled}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13440 \{\par
13441   mBackgroundBrush = brush;\par
13442 \}\par
}
}
{\xe \v setBackgroundScaled\:QCustomPlot}
{\xe \v QCustomPlot\:setBackgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackgroundScaled (bool  {\i scaled})}}
\par
{\bkmkstart AAAAAAADXJ}
{\bkmkend AAAAAAADXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the viewport background pixmap shall be scaled to fit the viewport. If {\i scaled}  is set to true, control whether and how the aspect ratio of the original pixmap is preserved with {\b setBackgroundScaledMode}.\par
Note that the scaled version of the original pixmap is buffered, so there is no performance penalty on replots. (Except when the viewport dimensions are changed continuously.)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13470 \{\par
13471   mBackgroundScaled = scaled;\par
13472 \}\par
}
}
{\xe \v setBackgroundScaledMode\:QCustomPlot}
{\xe \v QCustomPlot\:setBackgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackgroundScaledMode (Qt::AspectRatioMode  {\i mode})}}
\par
{\bkmkstart AAAAAAADXK}
{\bkmkend AAAAAAADXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If scaling of the viewport background pixmap is enabled ({\b setBackgroundScaled}), use this function to define whether and how the aspect ratio of the original pixmap is preserved.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground}, {\b setBackgroundScaled} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13481 \{\par
13482   mBackgroundScaledMode = mode;\par
13483 \}\par
}
}
{\xe \v setBufferDevicePixelRatio\:QCustomPlot}
{\xe \v QCustomPlot\:setBufferDevicePixelRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBufferDevicePixelRatio (double  {\i ratio})}}
\par
{\bkmkstart AAAAAAADXL}
{\bkmkend AAAAAAADXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the device pixel ratio used by the paint buffers of this {\b QCustomPlot} instance.\par
Normally, this doesn't need to be set manually, because it is initialized with the regular {\i QWidget::devicePixelRatio}  which is configured by Qt to fit the display device (e.g. 1 for normal displays, 2 for High-DPI displays).\par
Device pixel ratios are supported by Qt only for Qt versions since 5.4. If this method is called when {\b QCustomPlot} is being used with older Qt versions, outputs an according qDebug message and leaves the internal buffer device pixel ratio at 1.0. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13390 \{\par
13391   if (!qFuzzyCompare(ratio, mBufferDevicePixelRatio))\par
13392   \{\par
13393 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
13394     mBufferDevicePixelRatio = ratio;\par
13395     for (int i=0; i<mPaintBuffers.size(); ++i)\par
13396       mPaintBuffers.at(i)->setDevicePixelRatio(mBufferDevicePixelRatio);\par
13397     // Note: axis label cache has devicePixelRatio as part of cache hash, so no need to manually clear cache here\par
13398 #else\par
13399     qDebug() << Q_FUNC_INFO << "Device pixel ratios not supported for Qt versions before 5.4";\par
13400     mBufferDevicePixelRatio = 1.0;\par
13401 #endif\par
13402   \}\par
13403 \}\par
}
}
{\xe \v setCurrentLayer\:QCustomPlot}
{\xe \v QCustomPlot\:setCurrentLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::setCurrentLayer (const QString &  {\i name})}}
\par
{\bkmkstart AAAAAAADXM}
{\bkmkend AAAAAAADXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the layer with the specified {\i name}  to be the current layer. All layerables ({\b QCPLayerable}), e.g. plottables and items, are created on the current layer.\par
Returns true on success, i.e. if there is a layer with the specified {\i name}  in the {\b QCustomPlot}.\par
Layer names are case-sensitive.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer}, {\b removeLayer}, {\b QCPLayerable::setLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14004 \{\par
14005   if (QCPLayer *newCurrentLayer = layer(name))\par
14006   \{\par
14007     return setCurrentLayer(newCurrentLayer);\par
14008   \} else\par
14009   \{\par
14010     qDebug() << Q_FUNC_INFO << "layer with name doesn't exist:" << name;\par
14011     return false;\par
14012   \}\par
14013 \}\par
}
}
{\xe \v setCurrentLayer\:QCustomPlot}
{\xe \v QCustomPlot\:setCurrentLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::setCurrentLayer ({\b QCPLayer} *  {\i layer})}}
\par
{\bkmkstart AAAAAAADXN}
{\bkmkend AAAAAAADXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Sets the provided {\i layer}  to be the current layer.\par
Returns true on success, i.e. when {\i layer}  is a valid layer in the {\b QCustomPlot}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer}, {\b removeLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14024 \{\par
14025   if (!mLayers.contains(layer))\par
14026   \{\par
14027     qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);\par
14028     return false;\par
14029   \}\par
14030   \par
14031   mCurrentLayer = layer;\par
14032   return true;\par
14033 \}\par
}
}
{\xe \v setInteraction\:QCustomPlot}
{\xe \v QCustomPlot\:setInteraction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setInteraction (const {\b QCP::Interaction} &  {\i interaction}, bool  {\i enabled} = {\f2 true})}}
\par
{\bkmkstart AAAAAAADXO}
{\bkmkend AAAAAAADXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the single {\i interaction}  of this {\b QCustomPlot} to {\i enabled} .\par
For details about the interaction system, see {\b setInteractions}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13130 \{\par
13131   if (!enabled && mInteractions.testFlag(interaction))\par
13132     mInteractions &= ~interaction;\par
13133   else if (enabled && !mInteractions.testFlag(interaction))\par
13134     mInteractions |= interaction;\par
13135 \}\par
}
}
{\xe \v setInteractions\:QCustomPlot}
{\xe \v QCustomPlot\:setInteractions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setInteractions (const QCP::Interactions &  {\i interactions})}}
\par
{\bkmkstart AAAAAAADXP}
{\bkmkend AAAAAAADXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the possible interactions of this {\b QCustomPlot} as an or-combination of {\b QCP::Interaction} enums. There are the following types of interactions:\par
{\b Axis range manipulation}  is controlled via {\b QCP::iRangeDrag} and {\b QCP::iRangeZoom}. When the respective interaction is enabled, the user may drag axes ranges and zoom with the mouse wheel. For details how to control which axes the user may drag/zoom and in what orientations, see {\b QCPAxisRect::setRangeDrag}, {\b QCPAxisRect::setRangeZoom}, {\b QCPAxisRect::setRangeDragAxes}, {\b QCPAxisRect::setRangeZoomAxes}.\par
{\b Plottable data selection}  is controlled by {\b QCP::iSelectPlottables}. If {\b QCP::iSelectPlottables} is set, the user may select plottables (graphs, curves, bars,...) and their data by clicking on them or in their vicinity ({\b setSelectionTolerance}). Whether the user can actually select a plottable and its data can further be restricted with the {\b QCPAbstractPlottable::setSelectable} method on the specific plottable. For details, see the special page about the data selection mechanism. To retrieve a list of all currently selected plottables, call {\b selectedPlottables}. If you're only interested in QCPGraphs, you may use the convenience function {\b selectedGraphs}.\par
{\b Item selection}  is controlled by {\b QCP::iSelectItems}. If {\b QCP::iSelectItems} is set, the user may select items ({\b QCPItemLine}, {\b QCPItemText},...) by clicking on them or in their vicinity. To find out whether a specific item is selected, call {\b QCPAbstractItem::selected()}. To retrieve a list of all currently selected items, call {\b selectedItems}.\par
{\b Axis selection}  is controlled with {\b QCP::iSelectAxes}. If {\b QCP::iSelectAxes} is set, the user may select parts of the axes by clicking on them. What parts exactly (e.g. Axis base line, tick labels, axis label) are selectable can be controlled via {\b QCPAxis::setSelectableParts} for each axis. To retrieve a list of all axes that currently contain selected parts, call {\b selectedAxes}. Which parts of an axis are selected, can be retrieved with {\b QCPAxis::selectedParts()}.\par
{\b Legend selection}  is controlled with {\b QCP::iSelectLegend}. If this is set, the user may select the legend itself or individual items by clicking on them. What parts exactly are selectable can be controlled via {\b QCPLegend::setSelectableParts}. To find out whether the legend or any of its child items are selected, check the value of {\b QCPLegend::selectedParts}. To find out which child items are selected, call {\b QCPLegend::selectedItems}.\par
{\b All other selectable elements}  The selection of all other selectable objects (e.g. {\b QCPTextElement}, or your own layerable subclasses) is controlled with {\b QCP::iSelectOther}. If set, the user may select those objects by clicking on them. To find out which are currently selected, you need to check their selected state explicitly.\par
If the selection state has changed by user interaction, the {\b selectionChangedByUser} signal is emitted. Each selectable object additionally emits an individual selectionChanged signal whenever their selection state has changed, i.e. not only by user interaction.\par
To allow multiple objects to be selected by holding the selection modifier ({\b setMultiSelectModifier}), set the flag {\b QCP::iMultiSelect}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Observação:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid In addition to the selection mechanism presented here, {\b QCustomPlot} always emits corresponding signals, when an object is clicked or double clicked. see {\b plottableClick} and {\b plottableDoubleClick} for example.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteraction}, {\b setSelectionTolerance} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13118 \{\par
13119   mInteractions = interactions;\par
13120 \}\par
}
}
{\xe \v setMultiSelectModifier\:QCustomPlot}
{\xe \v QCustomPlot\:setMultiSelectModifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setMultiSelectModifier (Qt::KeyboardModifier  {\i modifier})}}
\par
{\bkmkstart AAAAAAADXQ}
{\bkmkend AAAAAAADXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the keyboard modifier that will be recognized as multi-select-modifier.\par
If {\b QCP::iMultiSelect} is specified in {\b setInteractions}, the user may select multiple objects (or data points) by clicking on them one after the other while holding down {\i modifier} .\par
By default the multi-select-modifier is set to Qt::ControlModifier.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13207 \{\par
13208   mMultiSelectModifier = modifier;\par
13209 \}\par
}
}
{\xe \v setNoAntialiasingOnDrag\:QCustomPlot}
{\xe \v QCustomPlot\:setNoAntialiasingOnDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setNoAntialiasingOnDrag (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAADXR}
{\bkmkend AAAAAAADXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether antialiasing is disabled for this {\b QCustomPlot} while the user is dragging axes ranges. If many objects, especially plottables, are drawn antialiased, this greatly improves performance during dragging. Thus it creates a more responsive user experience. As soon as the user stops dragging, the last replot is done with normal antialiasing, to restore high image quality.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAntialiasedElements}, {\b setNotAntialiasedElements} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13165 \{\par
13166   mNoAntialiasingOnDrag = enabled;\par
13167 \}\par
}
}
{\xe \v setNotAntialiasedElement\:QCustomPlot}
{\xe \v QCustomPlot\:setNotAntialiasedElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setNotAntialiasedElement ({\b QCP::AntialiasedElement}  {\i notAntialiasedElement}, bool  {\i enabled} = {\f2 true})}}
\par
{\bkmkstart AAAAAAADXS}
{\bkmkend AAAAAAADXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the specified {\i notAntialiasedElement}  is forcibly drawn not antialiased.\par
See {\b setNotAntialiasedElements} for details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAntialiasedElement} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13041 \{\par
13042   if (!enabled && mNotAntialiasedElements.testFlag(notAntialiasedElement))\par
13043     mNotAntialiasedElements &= ~notAntialiasedElement;\par
13044   else if (enabled && !mNotAntialiasedElements.testFlag(notAntialiasedElement))\par
13045     mNotAntialiasedElements |= notAntialiasedElement;\par
13046   \par
13047   // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:\par
13048   if ((mNotAntialiasedElements & mAntialiasedElements) != 0)\par
13049     mAntialiasedElements |= ~mNotAntialiasedElements;\par
13050 \}\par
}
}
{\xe \v setNotAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:setNotAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setNotAntialiasedElements (const QCP::AntialiasedElements &  {\i notAntialiasedElements})}}
\par
{\bkmkstart AAAAAAADXT}
{\bkmkend AAAAAAADXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which elements are forcibly drawn not antialiased as an {\i or}  combination of {\b QCP::AntialiasedElement}.\par
This overrides the antialiasing settings for whole element groups, normally controlled with the {\i setAntialiasing}  function on the individual elements. If an element is neither specified in {\b setAntialiasedElements} nor in {\b setNotAntialiasedElements}, the antialiasing setting on each individual element instance is used.\par
For example, if {\i notAntialiasedElements}  contains {\b QCP::aePlottables}, no plottables will be drawn antialiased, no matter what the specific {\b QCPAbstractPlottable::setAntialiased} value was set to.\par
if an element in {\i notAntialiasedElements}  is already set in {\b setAntialiasedElements}, it is removed from there.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAntialiasedElements} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13025 \{\par
13026   mNotAntialiasedElements = notAntialiasedElements;\par
13027   \par
13028   // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:\par
13029   if ((mNotAntialiasedElements & mAntialiasedElements) != 0)\par
13030     mAntialiasedElements |= ~mNotAntialiasedElements;\par
13031 \}\par
}
}
{\xe \v setOpenGl\:QCustomPlot}
{\xe \v QCustomPlot\:setOpenGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setOpenGl (bool  {\i enabled}, int  {\i multisampling} = {\f2 16})}}
\par
{\bkmkstart AAAAAAADXU}
{\bkmkend AAAAAAADXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Aviso:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This is still an experimental feature and its performance depends on the system that it runs on. Having multiple {\b QCustomPlot} widgets in one application with enabled OpenGL rendering might cause context conflicts on some systems.\par
}This method allows to enable OpenGL plot rendering, for increased plotting performance of graphically demanding plots (thick lines, translucent fills, etc.).\par
If {\i enabled}  is set to true, {\b QCustomPlot} will try to initialize OpenGL and, if successful, continue plotting with hardware acceleration. The parameter {\i multisampling}  controls how many samples will be used per pixel, it essentially controls the antialiasing quality. If {\i multisampling}  is set too high for the current graphics hardware, the maximum allowed value will be used.\par
You can test whether switching to OpenGL rendering was successful by checking whether the according getter {\i {\b QCustomPlot::openGl()}}  returns true. If the OpenGL initialization fails, rendering continues with the regular software rasterizer, and an according qDebug output is generated.\par
If switching to OpenGL was successful, this method disables label caching ({\b setPlottingHint(QCP::phCacheLabels, false)}) and turns on {\b QCustomPlot}'s antialiasing override for all elements ({\b setAntialiasedElements(QCP::aeAll)}), leading to a higher quality output. The antialiasing override allows for pixel-grid aligned drawing in the OpenGL paint device. As stated before, in OpenGL rendering the actual antialiasing of the plot is controlled with {\i multisampling} . If {\i enabled}  is set to false, the antialiasing/label caching settings are restored to what they were before OpenGL was enabled, if they weren't altered in the meantime.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Observação:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid OpenGL support is only enabled if {\b QCustomPlot} is compiled with the macro {\f2 QCUSTOMPLOT_USE_OPENGL}  defined. This define must be set before including the {\b QCustomPlot} header both during compilation of the {\b QCustomPlot} library as well as when compiling your application. It is best to just include the line {\f2 DEFINES += QCUSTOMPLOT_USE_OPENGL}  in the respective qmake project files. \par
If you are using a Qt version before 5.0, you must also add the module "opengl" to your {\f2 QT}  variable in the qmake project files. For Qt versions 5.0 and higher, {\b QCustomPlot} switches to a newer OpenGL interface which is already in the "gui" module. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13318 \{\par
13319   mOpenGlMultisamples = qMax(0, multisampling);\par
13320 #ifdef QCUSTOMPLOT_USE_OPENGL\par
13321   mOpenGl = enabled;\par
13322   if (mOpenGl)\par
13323   \{\par
13324     if (setupOpenGl())\par
13325     \{\par
13326       // backup antialiasing override and labelcaching setting so we can restore upon disabling OpenGL\par
13327       mOpenGlAntialiasedElementsBackup = mAntialiasedElements;\par
13328       mOpenGlCacheLabelsBackup = mPlottingHints.testFlag(QCP::phCacheLabels);\par
13329       // set antialiasing override to antialias all (aligns gl pixel grid properly), and disable label caching (would use software rasterizer for pixmap caches):\par
13330       setAntialiasedElements(QCP::aeAll);\par
13331       setPlottingHint(QCP::phCacheLabels, false);\par
13332     \} else\par
13333     \{\par
13334       qDebug() << Q_FUNC_INFO << "Failed to enable OpenGL, continuing plotting without hardware acceleration.";\par
13335       mOpenGl = false;\par
13336     \}\par
13337   \} else\par
13338   \{\par
13339     // restore antialiasing override and labelcaching to what it was before enabling OpenGL, if nobody changed it in the meantime:\par
13340     if (mAntialiasedElements == QCP::aeAll)\par
13341       setAntialiasedElements(mOpenGlAntialiasedElementsBackup);\par
13342     if (!mPlottingHints.testFlag(QCP::phCacheLabels))\par
13343       setPlottingHint(QCP::phCacheLabels, mOpenGlCacheLabelsBackup);\par
13344     freeOpenGl();\par
13345   \}\par
13346   // recreate all paint buffers:\par
13347   mPaintBuffers.clear();\par
13348   setupPaintBuffers();\par
13349 #else\par
13350   Q_UNUSED(enabled)\par
13351   qDebug() << Q_FUNC_INFO << "QCustomPlot can't use OpenGL because QCUSTOMPLOT_USE_OPENGL was not defined during compilation (add 'DEFINES += QCUSTOMPLOT_USE_OPENGL' to your qmake .pro file)";\par
13352 #endif\par
13353 \}\par
}
}
{\xe \v setPlottingHint\:QCustomPlot}
{\xe \v QCustomPlot\:setPlottingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setPlottingHint ({\b QCP::PlottingHint}  {\i hint}, bool  {\i enabled} = {\f2 true})}}
\par
{\bkmkstart AAAAAAADXV}
{\bkmkend AAAAAAADXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the specified plotting {\i hint}  to {\i enabled} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPlottingHints} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13185 \{\par
13186   QCP::PlottingHints newHints = mPlottingHints;\par
13187   if (!enabled)\par
13188     newHints &= ~hint;\par
13189   else\par
13190     newHints |= hint;\par
13191   \par
13192   if (newHints != mPlottingHints)\par
13193     setPlottingHints(newHints);\par
13194 \}\par
}
}
{\xe \v setPlottingHints\:QCustomPlot}
{\xe \v QCustomPlot\:setPlottingHints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setPlottingHints (const QCP::PlottingHints &  {\i hints})}}
\par
{\bkmkstart AAAAAAADXW}
{\bkmkend AAAAAAADXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the plotting hints for this {\b QCustomPlot} instance as an {\i or}  combination of {\b QCP::PlottingHint}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPlottingHint} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13175 \{\par
13176   mPlottingHints = hints;\par
13177 \}\par
}
}
{\xe \v setSelectionRect\:QCustomPlot}
{\xe \v QCustomPlot\:setSelectionRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setSelectionRect ({\b QCPSelectionRect} *  {\i selectionRect})}}
\par
{\bkmkstart AAAAAAADXX}
{\bkmkend AAAAAAADXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\b QCPSelectionRect} instance that {\b QCustomPlot} will use if {\i mode}  is not {\b QCP::srmNone} and the user performs a click-and-drag interaction. {\b QCustomPlot} takes ownership of the passed {\i selectionRect} . It can be accessed later via {\b selectionRect}.\par
This method is useful if you wish to replace the default {\b QCPSelectionRect} instance with an instance of a {\b QCPSelectionRect} subclass, to introduce custom behaviour of the selection rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectionRectMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13265 \{\par
13266   if (mSelectionRect)\par
13267     delete mSelectionRect;\par
13268   \par
13269   mSelectionRect = selectionRect;\par
13270   \par
13271   if (mSelectionRect)\par
13272   \{\par
13273     // establish connections with new selection rect:\par
13274     if (mSelectionRectMode == QCP::srmSelect)\par
13275       connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectSelection(QRect,QMouseEvent*)));\par
13276     else if (mSelectionRectMode == QCP::srmZoom)\par
13277       connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectZoom(QRect,QMouseEvent*)));\par
13278   \}\par
13279 \}\par
}
}
{\xe \v setSelectionRectMode\:QCustomPlot}
{\xe \v QCustomPlot\:setSelectionRectMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setSelectionRectMode ({\b QCP::SelectionRectMode}  {\i mode})}}
\par
{\bkmkstart AAAAAAADXY}
{\bkmkend AAAAAAADXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how {\b QCustomPlot} processes mouse click-and-drag interactions by the user.\par
If {\i mode}  is {\b QCP::srmNone}, the mouse drag is forwarded to the underlying objects. For example, {\b QCPAxisRect} may process a mouse drag by dragging axis ranges, see {\b QCPAxisRect::setRangeDrag}. If {\i mode}  is not {\b QCP::srmNone}, the current selection rect ({\b selectionRect}) becomes activated and allows e.g. rect zooming and data point selection.\par
If you wish to provide your user both with axis range dragging and data selection/range zooming, use this method to switch between the modes just before the interaction is processed, e.g. in reaction to the {\b mousePress} or {\b mouseMove} signals. For example you could check whether the user is holding a certain keyboard modifier, and then decide which {\i mode}  shall be set.\par
If a selection rect interaction is currently active, and {\i mode}  is set to {\b QCP::srmNone}, the interaction is canceled ({\b QCPSelectionRect::cancel}). Switching between any of the other modes will keep the selection rect active. Upon completion of the interaction, the behaviour is as defined by the currently set {\i mode} , not the mode that was set when the interaction started.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b setSelectionRect}, {\b QCPSelectionRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13232 \{\par
13233   if (mSelectionRect)\par
13234   \{\par
13235     if (mode == QCP::srmNone)\par
13236       mSelectionRect->cancel(); // when switching to none, we immediately want to abort a potentially active selection rect\par
13237     \par
13238     // disconnect old connections:\par
13239     if (mSelectionRectMode == QCP::srmSelect)\par
13240       disconnect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectSelection(QRect,QMouseEvent*)));\par
13241     else if (mSelectionRectMode == QCP::srmZoom)\par
13242       disconnect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectZoom(QRect,QMouseEvent*)));\par
13243     \par
13244     // establish new ones:\par
13245     if (mode == QCP::srmSelect)\par
13246       connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectSelection(QRect,QMouseEvent*)));\par
13247     else if (mode == QCP::srmZoom)\par
13248       connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectZoom(QRect,QMouseEvent*)));\par
13249   \}\par
13250   \par
13251   mSelectionRectMode = mode;\par
13252 \}\par
}
}
{\xe \v setSelectionTolerance\:QCustomPlot}
{\xe \v QCustomPlot\:setSelectionTolerance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setSelectionTolerance (int  {\i pixels})}}
\par
{\bkmkstart AAAAAAADXZ}
{\bkmkend AAAAAAADXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the tolerance that is used to decide whether a click selects an object (e.g. a plottable) or not.\par
If the user clicks in the vicinity of the line of e.g. a {\b QCPGraph}, it's only regarded as a potential selection when the minimum distance between the click position and the graph line is smaller than {\i pixels} . Objects that are defined by an area (e.g. {\b QCPBars}) only react to clicks directly inside the area and ignore this selection tolerance. In other words, it only has meaning for parts of objects that are too thin to exactly hit with a click and thus need such a tolerance.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b QCPLayerable::selectTest} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13151 \{\par
13152   mSelectionTolerance = pixels;\par
13153 \}\par
}
}
{\xe \v setupOpenGl\:QCustomPlot}
{\xe \v QCustomPlot\:setupOpenGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::setupOpenGl (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYA}
{\bkmkend AAAAAAADYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15159 \{\par
15160 #ifdef QCP_OPENGL_FBO\par
15161   freeOpenGl();\par
15162   QSurfaceFormat proposedSurfaceFormat;\par
15163   proposedSurfaceFormat.setSamples(mOpenGlMultisamples);\par
15164 #ifdef QCP_OPENGL_OFFSCREENSURFACE\par
15165   QOffscreenSurface *surface = new QOffscreenSurface;\par
15166 #else\par
15167   QWindow *surface = new QWindow;\par
15168   surface->setSurfaceType(QSurface::OpenGLSurface);\par
15169 #endif\par
15170   surface->setFormat(proposedSurfaceFormat);\par
15171   surface->create();\par
15172   mGlSurface = QSharedPointer<QSurface>(surface);\par
15173   mGlContext = QSharedPointer<QOpenGLContext>(new QOpenGLContext);\par
15174   mGlContext->setFormat(mGlSurface->format());\par
15175   if (!mGlContext->create())\par
15176   \{\par
15177     qDebug() << Q_FUNC_INFO << "Failed to create OpenGL context";\par
15178     mGlContext.clear();\par
15179     mGlSurface.clear();\par
15180     return false;\par
15181   \}\par
15182   if (!mGlContext->makeCurrent(mGlSurface.data())) // context needs to be current to create paint device\par
15183   \{\par
15184     qDebug() << Q_FUNC_INFO << "Failed to make opengl context current";\par
15185     mGlContext.clear();\par
15186     mGlSurface.clear();\par
15187     return false;\par
15188   \}\par
15189   if (!QOpenGLFramebufferObject::hasOpenGLFramebufferObjects())\par
15190   \{\par
15191     qDebug() << Q_FUNC_INFO << "OpenGL of this system doesn't support frame buffer objects";\par
15192     mGlContext.clear();\par
15193     mGlSurface.clear();\par
15194     return false;\par
15195   \}\par
15196   mGlPaintDevice = QSharedPointer<QOpenGLPaintDevice>(new QOpenGLPaintDevice);\par
15197   return true;\par
15198 #elif defined(QCP_OPENGL_PBUFFER)\par
15199   return QGLFormat::hasOpenGL();\par
15200 #else\par
15201   return false;\par
15202 #endif\par
15203 \}\par
}
}
{\xe \v setupPaintBuffers\:QCustomPlot}
{\xe \v QCustomPlot\:setupPaintBuffers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setupPaintBuffers (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYB}
{\bkmkend AAAAAAADYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15063 \{\par
15064   int bufferIndex = 0;\par
15065   if (mPaintBuffers.isEmpty())\par
15066     mPaintBuffers.append(QSharedPointer<QCPAbstractPaintBuffer>(createPaintBuffer()));\par
15067   \par
15068   for (int layerIndex = 0; layerIndex < mLayers.size(); ++layerIndex)\par
15069   \{\par
15070     QCPLayer *layer = mLayers.at(layerIndex);\par
15071     if (layer->mode() == QCPLayer::lmLogical)\par
15072     \{\par
15073       layer->mPaintBuffer = mPaintBuffers.at(bufferIndex).toWeakRef();\par
15074     \} else if (layer->mode() == QCPLayer::lmBuffered)\par
15075     \{\par
15076       ++bufferIndex;\par
15077       if (bufferIndex >= mPaintBuffers.size())\par
15078         mPaintBuffers.append(QSharedPointer<QCPAbstractPaintBuffer>(createPaintBuffer()));\par
15079       layer->mPaintBuffer = mPaintBuffers.at(bufferIndex).toWeakRef();\par
15080       if (layerIndex < mLayers.size()-1 && mLayers.at(layerIndex+1)->mode() == QCPLayer::lmLogical) // not last layer, and next one is logical, so prepare another buffer for next layerables\par
15081       \{\par
15082         ++bufferIndex;\par
15083         if (bufferIndex >= mPaintBuffers.size())\par
15084           mPaintBuffers.append(QSharedPointer<QCPAbstractPaintBuffer>(createPaintBuffer()));\par
15085       \}\par
15086     \}\par
15087   \}\par
15088   // remove unneeded buffers:\par
15089   while (mPaintBuffers.size()-1 > bufferIndex)\par
15090     mPaintBuffers.removeLast();\par
15091   // resize buffers to viewport size and clear contents:\par
15092   for (int i=0; i<mPaintBuffers.size(); ++i)\par
15093   \{\par
15094     mPaintBuffers.at(i)->setSize(viewport().size()); // won't do anything if already correct size\par
15095     mPaintBuffers.at(i)->clear(Qt::transparent);\par
15096     mPaintBuffers.at(i)->setInvalidated();\par
15097   \}\par
15098 \}\par
}
}
{\xe \v setViewport\:QCustomPlot}
{\xe \v QCustomPlot\:setViewport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setViewport (const QRect &  {\i rect})}}
\par
{\bkmkstart AAAAAAADYC}
{\bkmkend AAAAAAADYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the viewport of this {\b QCustomPlot}. Usually users of {\b QCustomPlot} don't need to change the viewport manually.\par
The viewport is the area in which the plot is drawn. All mechanisms, e.g. margin caluclation take the viewport to be the outer border of the plot. The viewport normally is the rect() of the {\b QCustomPlot} widget, i.e. a rect with top left (0, 0) and size of the {\b QCustomPlot} widget.\par
Don't confuse the viewport with the axis rect ({\b QCustomPlot::axisRect}). An axis rect is typically an area enclosed by four axes, where the graphs/plottables are drawn in. The viewport is larger and contains also the axes themselves, their tick numbers, their labels, or even additional axis rects, color scales and other layout elements.\par
This function is used to allow arbitrary size exports with {\b toPixmap}, {\b savePng}, {\b savePdf}, etc. by temporarily changing the viewport size. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13372 \{\par
13373   mViewport = rect;\par
13374   if (mPlotLayout)\par
13375     mPlotLayout->setOuterRect(mViewport);\par
13376 \}\par
}
}
{\xe \v sizeHint\:QCustomPlot}
{\xe \v QCustomPlot\:sizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCustomPlot::sizeHint () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADYD}
{\bkmkend AAAAAAADYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14709 \{\par
14710   return mPlotLayout->minimumOuterSizeHint();\par
14711 \}\par
}
}
{\xe \v toPainter\:QCustomPlot}
{\xe \v QCustomPlot\:toPainter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::toPainter ({\b QCPPainter} *  {\i painter}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0})}}
\par
{\bkmkstart AAAAAAADYE}
{\bkmkend AAAAAAADYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renders the plot using the passed {\i painter} .\par
The plot is sized to {\i width}  and {\i height}  in pixels. If the {\i painter's}  scale is not 1.0, the resulting plot will appear scaled accordingly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Observação:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If you are restricted to using a QPainter (instead of {\b QCPPainter}), create a temporary QPicture and open a {\b QCPPainter} on it. Then call {\b toPainter} with this {\b QCPPainter}. After ending the paint operation on the picture, draw it with the QPainter. This will reproduce the painter actions the {\b QCPPainter} took, with a QPainter.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b toPixmap} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15692 \{\par
15693   // this method is somewhat similar to toPixmap. Change something here, and a change in toPixmap might be necessary, too.\par
15694   int newWidth, newHeight;\par
15695   if (width == 0 || height == 0)\par
15696   \{\par
15697     newWidth = this->width();\par
15698     newHeight = this->height();\par
15699   \} else\par
15700   \{\par
15701     newWidth = width;\par
15702     newHeight = height;\par
15703   \}\par
15704 \par
15705   if (painter->isActive())\par
15706   \{\par
15707     QRect oldViewport = viewport();\par
15708     setViewport(QRect(0, 0, newWidth, newHeight));\par
15709     painter->setMode(QCPPainter::pmNoCaching);\par
15710     if (mBackgroundBrush.style() != Qt::NoBrush) // unlike in toPixmap, we can't do QPixmap::fill for Qt::SolidPattern brush style, so we also draw solid fills with fillRect here\par
15711       painter->fillRect(mViewport, mBackgroundBrush);\par
15712     draw(painter);\par
15713     setViewport(oldViewport);\par
15714   \} else\par
15715     qDebug() << Q_FUNC_INFO << "Passed painter is not active";\par
15716 \}\par
}
}
{\xe \v toPixmap\:QCustomPlot}
{\xe \v QCustomPlot\:toPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCustomPlot::toPixmap (int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, double  {\i scale} = {\f2 1.0})}}
\par
{\bkmkstart AAAAAAADYF}
{\bkmkend AAAAAAADYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renders the plot to a pixmap and returns it.\par
The plot is sized to {\i width}  and {\i height}  in pixels and scaled with {\i scale} . (width 100 and scale 2.0 lead to a full resolution pixmap with width 200.)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b toPainter}, {\b saveRastered}, {\b saveBmp}, {\b savePng}, {\b saveJpg}, {\b savePdf} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15636 \{\par
15637   // this method is somewhat similar to toPainter. Change something here, and a change in toPainter might be necessary, too.\par
15638   int newWidth, newHeight;\par
15639   if (width == 0 || height == 0)\par
15640   \{\par
15641     newWidth = this->width();\par
15642     newHeight = this->height();\par
15643   \} else\par
15644   \{\par
15645     newWidth = width;\par
15646     newHeight = height;\par
15647   \}\par
15648   int scaledWidth = qRound(scale*newWidth);\par
15649   int scaledHeight = qRound(scale*newHeight);\par
15650 \par
15651   QPixmap result(scaledWidth, scaledHeight);\par
15652   result.fill(mBackgroundBrush.style() == Qt::SolidPattern ? mBackgroundBrush.color() : Qt::transparent); // if using non-solid pattern, make transparent now and draw brush pattern later\par
15653   QCPPainter painter;\par
15654   painter.begin(&result);\par
15655   if (painter.isActive())\par
15656   \{\par
15657     QRect oldViewport = viewport();\par
15658     setViewport(QRect(0, 0, newWidth, newHeight));\par
15659     painter.setMode(QCPPainter::pmNoCaching);\par
15660     if (!qFuzzyCompare(scale, 1.0))\par
15661     \{\par
15662       if (scale > 1.0) // for scale < 1 we always want cosmetic pens where possible, because else lines might disappear for very small scales\par
15663         painter.setMode(QCPPainter::pmNonCosmetic);\par
15664       painter.scale(scale, scale);\par
15665     \}\par
15666     if (mBackgroundBrush.style() != Qt::SolidPattern && mBackgroundBrush.style() != Qt::NoBrush) // solid fills were done a few lines above with QPixmap::fill\par
15667       painter.fillRect(mViewport, mBackgroundBrush);\par
15668     draw(&painter);\par
15669     setViewport(oldViewport);\par
15670     painter.end();\par
15671   \} else // might happen if pixmap has width or height zero\par
15672   \{\par
15673     qDebug() << Q_FUNC_INFO << "Couldn't activate painter on pixmap";\par
15674     return QPixmap();\par
15675   \}\par
15676   return result;\par
15677 \}\par
}
}
{\xe \v updateLayerIndices\:QCustomPlot}
{\xe \v QCustomPlot\:updateLayerIndices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::updateLayerIndices () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYG}
{\bkmkend AAAAAAADYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15517 \{\par
15518   for (int i=0; i<mLayers.size(); ++i)\par
15519     mLayers.at(i)->mIndex = i;\par
15520 \}\par
}
}
{\xe \v updateLayout\:QCustomPlot}
{\xe \v QCustomPlot\:updateLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::updateLayout (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADYH}
{\bkmkend AAAAAAADYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14997 \{\par
14998   // run through layout phases:\par
14999   mPlotLayout->update(QCPLayoutElement::upPreparation);\par
15000   mPlotLayout->update(QCPLayoutElement::upMargins);\par
15001   mPlotLayout->update(QCPLayoutElement::upLayout);\par
15002 \}\par
}
}
{\xe \v viewport\:QCustomPlot}
{\xe \v QCustomPlot\:viewport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCustomPlot::viewport () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADYI}
{\bkmkend AAAAAAADYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3624 \{ return mViewport; \}\par
}
}
{\xe \v wheelEvent\:QCustomPlot}
{\xe \v QCustomPlot\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADYJ}
{\bkmkend AAAAAAADYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14941 \{\par
14942   emit mouseWheel(event);\par
14943   // forward event to layerable under cursor:\par
14944   QList<QCPLayerable*> candidates = layerableListAt(event->pos(), false);\par
14945   for (int i=0; i<candidates.size(); ++i)\par
14946   \{\par
14947     event->accept(); // default impl of QCPLayerable's mouse events ignore the event, in that case propagate to next candidate in list\par
14948     candidates.at(i)->wheelEvent(event);\par
14949     if (event->isAccepted())\par
14950       break;\par
14951   \}\par
14952   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14953 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas e Funções Relacionadas\par
\pard\plain 
{\xe \v QCPAbstractItem\:QCustomPlot}
{\xe \v QCustomPlot\:QCPAbstractItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAbstractItem}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADYK}
{\bkmkend AAAAAAADYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPAbstractPlottable\:QCustomPlot}
{\xe \v QCustomPlot\:QCPAbstractPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAbstractPlottable}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADYL}
{\bkmkend AAAAAAADYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPAxis\:QCustomPlot}
{\xe \v QCustomPlot\:QCPAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAxis}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADYM}
{\bkmkend AAAAAAADYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPAxisRect\:QCustomPlot}
{\xe \v QCustomPlot\:QCPAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAxisRect}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADYN}
{\bkmkend AAAAAAADYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPGraph\:QCustomPlot}
{\xe \v QCustomPlot\:QCPGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPGraph}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADYO}
{\bkmkend AAAAAAADYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPLayer\:QCustomPlot}
{\xe \v QCustomPlot\:QCPLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLayer}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADYP}
{\bkmkend AAAAAAADYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPLegend\:QCustomPlot}
{\xe \v QCustomPlot\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADYQ}
{\bkmkend AAAAAAADYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v legend\:QCustomPlot}
{\xe \v QCustomPlot\:legend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLegend} * QCustomPlot::legend}}
\par
{\bkmkstart AAAAAAADYR}
{\bkmkend AAAAAAADYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the default legend of the main axis rect. The legend is invisible by default. Use {\b QCPLegend::setVisible} to change this.\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple legends to the plot, use the layout system interface to access the new legend. For example, legends can be placed inside an axis rect's {\b inset layout}, and must then also be accessed via the inset layout. If the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointer becomes 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\xe \v mAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:mAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::mAntialiasedElements{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYS}
{\bkmkend AAAAAAADYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAutoAddPlottableToLegend\:QCustomPlot}
{\xe \v QCustomPlot\:mAutoAddPlottableToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mAutoAddPlottableToLegend{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYT}
{\bkmkend AAAAAAADYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundBrush\:QCustomPlot}
{\xe \v QCustomPlot\:mBackgroundBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCustomPlot::mBackgroundBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYU}
{\bkmkend AAAAAAADYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundPixmap\:QCustomPlot}
{\xe \v QCustomPlot\:mBackgroundPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCustomPlot::mBackgroundPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYV}
{\bkmkend AAAAAAADYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundScaled\:QCustomPlot}
{\xe \v QCustomPlot\:mBackgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mBackgroundScaled{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYW}
{\bkmkend AAAAAAADYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundScaledMode\:QCustomPlot}
{\xe \v QCustomPlot\:mBackgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCustomPlot::mBackgroundScaledMode{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYX}
{\bkmkend AAAAAAADYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBufferDevicePixelRatio\:QCustomPlot}
{\xe \v QCustomPlot\:mBufferDevicePixelRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCustomPlot::mBufferDevicePixelRatio{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYY}
{\bkmkend AAAAAAADYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mCurrentLayer\:QCustomPlot}
{\xe \v QCustomPlot\:mCurrentLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCustomPlot::mCurrentLayer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADYZ}
{\bkmkend AAAAAAADYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mGraphs\:QCustomPlot}
{\xe \v QCustomPlot\:mGraphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPGraph}*> QCustomPlot::mGraphs{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZA}
{\bkmkend AAAAAAADZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInteractions\:QCustomPlot}
{\xe \v QCustomPlot\:mInteractions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::Interactions QCustomPlot::mInteractions{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZB}
{\bkmkend AAAAAAADZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mItems\:QCustomPlot}
{\xe \v QCustomPlot\:mItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPAbstractItem}*> QCustomPlot::mItems{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZC}
{\bkmkend AAAAAAADZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLayers\:QCustomPlot}
{\xe \v QCustomPlot\:mLayers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPLayer}*> QCustomPlot::mLayers{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZD}
{\bkmkend AAAAAAADZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseEventLayerable\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseEventLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPLayerable}> QCustomPlot::mMouseEventLayerable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZE}
{\bkmkend AAAAAAADZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseEventLayerableDetails\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseEventLayerableDetails}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant QCustomPlot::mMouseEventLayerableDetails{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZF}
{\bkmkend AAAAAAADZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseHasMoved\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseHasMoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mMouseHasMoved{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZG}
{\bkmkend AAAAAAADZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMousePressPos\:QCustomPlot}
{\xe \v QCustomPlot\:mMousePressPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCustomPlot::mMousePressPos{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZH}
{\bkmkend AAAAAAADZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseSignalLayerable\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseSignalLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPLayerable}> QCustomPlot::mMouseSignalLayerable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZI}
{\bkmkend AAAAAAADZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseSignalLayerableDetails\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseSignalLayerableDetails}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant QCustomPlot::mMouseSignalLayerableDetails{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZJ}
{\bkmkend AAAAAAADZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMultiSelectModifier\:QCustomPlot}
{\xe \v QCustomPlot\:mMultiSelectModifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::KeyboardModifier QCustomPlot::mMultiSelectModifier{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZK}
{\bkmkend AAAAAAADZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNoAntialiasingOnDrag\:QCustomPlot}
{\xe \v QCustomPlot\:mNoAntialiasingOnDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mNoAntialiasingOnDrag{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZL}
{\bkmkend AAAAAAADZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNotAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:mNotAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::mNotAntialiasedElements{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZM}
{\bkmkend AAAAAAADZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOpenGl\:QCustomPlot}
{\xe \v QCustomPlot\:mOpenGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mOpenGl{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZN}
{\bkmkend AAAAAAADZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOpenGlAntialiasedElementsBackup\:QCustomPlot}
{\xe \v QCustomPlot\:mOpenGlAntialiasedElementsBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::mOpenGlAntialiasedElementsBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZO}
{\bkmkend AAAAAAADZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOpenGlCacheLabelsBackup\:QCustomPlot}
{\xe \v QCustomPlot\:mOpenGlCacheLabelsBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mOpenGlCacheLabelsBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZP}
{\bkmkend AAAAAAADZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOpenGlMultisamples\:QCustomPlot}
{\xe \v QCustomPlot\:mOpenGlMultisamples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::mOpenGlMultisamples{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZQ}
{\bkmkend AAAAAAADZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPaintBuffers\:QCustomPlot}
{\xe \v QCustomPlot\:mPaintBuffers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QSharedPointer<{\b QCPAbstractPaintBuffer}> > QCustomPlot::mPaintBuffers{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZR}
{\bkmkend AAAAAAADZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPlotLayout\:QCustomPlot}
{\xe \v QCustomPlot\:mPlotLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutGrid}* QCustomPlot::mPlotLayout{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZS}
{\bkmkend AAAAAAADZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPlottables\:QCustomPlot}
{\xe \v QCustomPlot\:mPlottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPAbstractPlottable}*> QCustomPlot::mPlottables{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZT}
{\bkmkend AAAAAAADZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPlottingHints\:QCustomPlot}
{\xe \v QCustomPlot\:mPlottingHints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::PlottingHints QCustomPlot::mPlottingHints{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZU}
{\bkmkend AAAAAAADZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mReplotQueued\:QCustomPlot}
{\xe \v QCustomPlot\:mReplotQueued}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mReplotQueued{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZV}
{\bkmkend AAAAAAADZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mReplotting\:QCustomPlot}
{\xe \v QCustomPlot\:mReplotting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mReplotting{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZW}
{\bkmkend AAAAAAADZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScaledBackgroundPixmap\:QCustomPlot}
{\xe \v QCustomPlot\:mScaledBackgroundPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCustomPlot::mScaledBackgroundPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZX}
{\bkmkend AAAAAAADZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectionRect\:QCustomPlot}
{\xe \v QCustomPlot\:mSelectionRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionRect}* QCustomPlot::mSelectionRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZY}
{\bkmkend AAAAAAADZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectionRectMode\:QCustomPlot}
{\xe \v QCustomPlot\:mSelectionRectMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionRectMode} QCustomPlot::mSelectionRectMode{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADZZ}
{\bkmkend AAAAAAADZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectionTolerance\:QCustomPlot}
{\xe \v QCustomPlot\:mSelectionTolerance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::mSelectionTolerance{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEAA}
{\bkmkend AAAAAAAEAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mViewport\:QCustomPlot}
{\xe \v QCustomPlot\:mViewport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCustomPlot::mViewport{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEAB}
{\bkmkend AAAAAAAEAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xAxis\:QCustomPlot}
{\xe \v QCustomPlot\:xAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCustomPlot::xAxis}}
\par
{\bkmkstart AAAAAAAEAC}
{\bkmkend AAAAAAAEAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the primary x Axis (bottom) of the main axis rect of the plot.\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple axis rects or multiple axes to one side, use the {\b QCPAxisRect::axis} interface to access the new axes. If one of the four default axes or the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointers become 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\xe \v xAxis2\:QCustomPlot}
{\xe \v QCustomPlot\:xAxis2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCustomPlot::xAxis2}}
\par
{\bkmkstart AAAAAAAEAD}
{\bkmkend AAAAAAAEAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the secondary x Axis (top) of the main axis rect of the plot. Secondary axes are invisible by default. Use {\b QCPAxis::setVisible} to change this (or use {\b QCPAxisRect::setupFullAxesBox}).\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple axis rects or multiple axes to one side, use the {\b QCPAxisRect::axis} interface to access the new axes. If one of the four default axes or the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointers become 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\xe \v yAxis\:QCustomPlot}
{\xe \v QCustomPlot\:yAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCustomPlot::yAxis}}
\par
{\bkmkstart AAAAAAAEAE}
{\bkmkend AAAAAAAEAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the primary y Axis (left) of the main axis rect of the plot.\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple axis rects or multiple axes to one side, use the {\b QCPAxisRect::axis} interface to access the new axes. If one of the four default axes or the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointers become 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\xe \v yAxis2\:QCustomPlot}
{\xe \v QCustomPlot\:yAxis2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCustomPlot::yAxis2}}
\par
{\bkmkstart AAAAAAAEAF}
{\bkmkend AAAAAAAEAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the secondary y Axis (right) of the main axis rect of the plot. Secondary axes are invisible by default. Use {\b QCPAxis::setVisible} to change this (or use {\b QCPAxisRect::setupFullAxesBox}).\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple axis rects or multiple axes to one side, use the {\b QCPAxisRect::axis} interface to access the new axes. If one of the four default axes or the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointers become 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documentação para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}}