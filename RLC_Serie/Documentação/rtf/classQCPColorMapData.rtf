{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência da Classe QCPColorMapData\par \pard\plain 
{\tc\tcl2 \v QCPColorMapData}
{\xe \v QCPColorMapData}
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the two-dimensional data of a {\b QCPColorMap} plottable. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorMapData} (int {\b keySize}, int {\b valueSize}, const {\b QCPRange} &{\b keyRange}, const {\b QCPRange} &{\b valueRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~QCPColorMapData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorMapData} (const {\b QCPColorMapData} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorMapData} & {\b operator=} (const {\b QCPColorMapData} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b keySize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b valueSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b keyRange} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b valueRange} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b dataBounds} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b data} (double key, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b cell} (int keyIndex, int valueIndex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b alpha} (int keyIndex, int valueIndex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSize} (int {\b keySize}, int {\b valueSize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setKeySize} (int {\b keySize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValueSize} (int {\b valueSize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRange} (const {\b QCPRange} &{\b keyRange}, const {\b QCPRange} &{\b valueRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setKeyRange} (const {\b QCPRange} &{\b keyRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValueRange} (const {\b QCPRange} &{\b valueRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (double key, double value, double z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCell} (int keyIndex, int valueIndex, double z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlpha} (int keyIndex, int valueIndex, unsigned char {\b alpha})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b recalculateDataBounds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearAlpha} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fill} (double z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fillAlpha} (unsigned char {\b alpha})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b coordToCell} (double key, double value, int *keyIndex, int *valueIndex) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cellToCoord} (int keyIndex, int valueIndex, double *key, double *value) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b createAlpha} (bool initializeOpaque=true)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mKeySize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mValueSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mKeyRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mValueRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mIsEmpty}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double * {\b mData}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char * {\b mAlpha}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mDataBounds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mDataModified}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPColorMap}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the two-dimensional data of a {\b QCPColorMap} plottable. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a data storage for {\b QCPColorMap}. It holds a two-dimensional array, which {\b QCPColorMap} then displays as a 2D image in the plot, where the array values are represented by a color, depending on the value.\par
The size of the array can be controlled via {\b setSize} (or {\b setKeySize}, {\b setValueSize}). Which plot coordinates these cells correspond to can be configured with {\b setRange} (or {\b setKeyRange}, {\b setValueRange}).\par
The data cells can be accessed in two ways: They can be directly addressed by an integer index with {\b setCell}. This is the fastest method. Alternatively, they can be addressed by their plot coordinate with {\b setData}. plot coordinate to cell index transformations and vice versa are provided by the functions {\b coordToCell} and {\b cellToCoord}.\par
A {\b QCPColorMapData} also holds an on-demand two-dimensional array of alpha values which (if allocated) has the same size as the data map. It can be accessed via {\b setAlpha}, {\b fillAlpha} and {\b clearAlpha}. The memory for the alpha map is only allocated if needed, i.e. on the first call of {\b setAlpha}. {\b clearAlpha} restores full opacity and frees the alpha map.\par
This class also buffers the minimum and maximum values that are in the data set, to provide {\b QCPColorMap::rescaleDataRange} with the necessary information quickly. Setting a cell to a value that is greater than the current maximum increases this maximum to the new value. However, setting the cell that currently holds the maximum value to a smaller value doesn't decrease the maximum again, because finding the true new maximum would require going through the entire data array, which might be time consuming. The same holds for the data minimum. This functionality is given by {\b recalculateDataBounds}, such that you can decide when it is sensible to find the true current minimum and maximum. The method {\b QCPColorMap::rescaleDataRange} offers a convenience parameter {\i recalculateDataBounds}  which may be set to true to automatically call {\b recalculateDataBounds} internally. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v QCPColorMapData\:QCPColorMapData}
{\xe \v QCPColorMapData\:QCPColorMapData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorMapData::QCPColorMapData (int  {\i keySize}, int  {\i valueSize}, const {\b QCPRange} &  {\i keyRange}, const {\b QCPRange} &  {\i valueRange})}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b QCPColorMapData} instance. The instance has {\i keySize}  cells in the key direction and {\i valueSize}  cells in the value direction. These cells will be displayed by the {\b QCPColorMap} at the coordinates {\i keyRange}  and {\i valueRange} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSize}, {\b setKeySize}, {\b setValueSize}, {\b setRange}, {\b setKeyRange}, {\b setValueRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24978                                                                                                                  :\par
24979   mKeySize(0),\par
24980   mValueSize(0),\par
24981   mKeyRange(keyRange),\par
24982   mValueRange(valueRange),\par
24983   mIsEmpty(true),\par
24984   mData(0),\par
24985   mAlpha(0),\par
24986   mDataModified(true)\par
24987 \{\par
24988   setSize(keySize, valueSize);\par
24989   fill(0);\par
24990 \}\par
}
}
{\xe \v ~QCPColorMapData\:QCPColorMapData}
{\xe \v QCPColorMapData\:~QCPColorMapData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorMapData::~QCPColorMapData ()}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24993 \{\par
24994   if (mData)\par
24995     delete[] mData;\par
24996   if (mAlpha)\par
24997     delete[] mAlpha;\par
24998 \}\par
}
}
{\xe \v QCPColorMapData\:QCPColorMapData}
{\xe \v QCPColorMapData\:QCPColorMapData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorMapData::QCPColorMapData (const {\b QCPColorMapData} &  {\i other})}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b QCPColorMapData} instance copying the data and range of {\i other} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25003                                                              :\par
25004   mKeySize(0),\par
25005   mValueSize(0),\par
25006   mIsEmpty(true),\par
25007   mData(0),\par
25008   mAlpha(0),\par
25009   mDataModified(true)\par
25010 \{\par
25011   *this = other;\par
25012 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções membros\par
\pard\plain 
{\xe \v alpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:alpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char QCPColorMapData::alpha (int  {\i keyIndex}, int  {\i valueIndex})}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the alpha map value of the cell with the indices {\i keyIndex}  and {\i valueIndex} .\par
If this color map data doesn't have an alpha map (because {\b setAlpha} was never called after creation or after a call to {\b clearAlpha}), returns 255, which corresponds to full opacity.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAlpha} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25071 \{\par
25072   if (mAlpha && keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)\par
25073     return mAlpha[valueIndex*mKeySize + keyIndex];\par
25074   else\par
25075     return 255;\par
25076 \}\par
}
}
{\xe \v cell\:QCPColorMapData}
{\xe \v QCPColorMapData\:cell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPColorMapData::cell (int  {\i keyIndex}, int  {\i valueIndex})}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25055 \{\par
25056   if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)\par
25057     return mData[valueIndex*mKeySize + keyIndex];\par
25058   else\par
25059     return 0;\par
25060 \}\par
}
}
{\xe \v cellToCoord\:QCPColorMapData}
{\xe \v QCPColorMapData\:cellToCoord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::cellToCoord (int  {\i keyIndex}, int  {\i valueIndex}, double *  {\i key}, double *  {\i value}) const}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms cell indices given by {\i keyIndex}  and {\i valueIndex}  to cell indices of this {\b QCPColorMapData} instance. The resulting coordinates are returned via the output parameters {\i key}  and {\i value} .\par
If you are only interested in a key or value coordinate, you may pass 0 as {\i key}  or {\i value} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Observação:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\b QCPColorMap} always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use {\b QCPColorMap} with logarithmic axes, you shouldn't use the {\b QCPColorMapData::cellToCoord} method as it uses a linear transformation to determine the cell index.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b coordToCell}, {\b QCPAxis::pixelToCoord} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25406 \{\par
25407   if (key)\par
25408     *key = keyIndex/(double)(mKeySize-1)*(mKeyRange.upper-mKeyRange.lower)+mKeyRange.lower;\par
25409   if (value)\par
25410     *value = valueIndex/(double)(mValueSize-1)*(mValueRange.upper-mValueRange.lower)+mValueRange.lower;\par
25411 \}\par
}
}
{\xe \v clear\:QCPColorMapData}
{\xe \v QCPColorMapData\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::clear ()}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees the internal data memory.\par
This is equivalent to calling {\b setSize(0, 0)}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25316 \{\par
25317   setSize(0, 0);\par
25318 \}\par
}
}
{\xe \v clearAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:clearAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::clearAlpha ()}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees the internal alpha map. The color map will have full opacity again. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25324 \{\par
25325   if (mAlpha)\par
25326   \{\par
25327     delete[] mAlpha;\par
25328     mAlpha = 0;\par
25329     mDataModified = true;\par
25330   \}\par
25331 \}\par
}
}
{\xe \v coordToCell\:QCPColorMapData}
{\xe \v QCPColorMapData\:coordToCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::coordToCell (double  {\i key}, double  {\i value}, int *  {\i keyIndex}, int *  {\i valueIndex}) const}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms plot coordinates given by {\i key}  and {\i value}  to cell indices of this {\b QCPColorMapData} instance. The resulting cell indices are returned via the output parameters {\i keyIndex}  and {\i valueIndex} .\par
The retrieved key/value cell indices can then be used for example with {\b setCell}.\par
If you are only interested in a key or value index, you may pass 0 as {\i valueIndex}  or {\i keyIndex} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Observação:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\b QCPColorMap} always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use {\b QCPColorMap} with logarithmic axes, you shouldn't use the {\b QCPColorMapData::coordToCell} method as it uses a linear transformation to determine the cell index.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b cellToCoord}, {\b QCPAxis::coordToPixel} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25383 \{\par
25384   if (keyIndex)\par
25385     *keyIndex = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;\par
25386   if (valueIndex)\par
25387     *valueIndex = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;\par
25388 \}\par
}
}
{\xe \v createAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:createAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMapData::createAlpha (bool  {\i initializeOpaque} = {\f2 true}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25427 \{\par
25428   clearAlpha();\par
25429   if (isEmpty())\par
25430     return false;\par
25431   \par
25432 #ifdef __EXCEPTIONS\par
25433   try \{ // 2D arrays get memory intensive fast. So if the allocation fails, at least output debug message\par
25434 #endif\par
25435     mAlpha = new unsigned char[mKeySize*mValueSize];\par
25436 #ifdef __EXCEPTIONS\par
25437   \} catch (...) \{ mAlpha = 0; \}\par
25438 #endif\par
25439   if (mAlpha)\par
25440   \{\par
25441     if (initializeOpaque)\par
25442       fillAlpha(255);\par
25443     return true;\par
25444   \} else\par
25445   \{\par
25446     qDebug() << Q_FUNC_INFO << "out of memory for data dimensions "<< mKeySize << "*" << mValueSize;\par
25447     return false;\par
25448   \}\par
25449 \}\par
}
}
{\xe \v data\:QCPColorMapData}
{\xe \v QCPColorMapData\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPColorMapData::data (double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25044 \{\par
25045   int keyCell = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;\par
25046   int valueCell = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;\par
25047   if (keyCell >= 0 && keyCell < mKeySize && valueCell >= 0 && valueCell < mValueSize)\par
25048     return mData[valueCell*mKeySize + keyCell];\par
25049   else\par
25050     return 0;\par
25051 \}\par
}
}
{\xe \v dataBounds\:QCPColorMapData}
{\xe \v QCPColorMapData\:dataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::dataBounds () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5693 \{ return mDataBounds; \}\par
}
}
{\xe \v fill\:QCPColorMapData}
{\xe \v QCPColorMapData\:fill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::fill (double  {\i z})}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets all cells to the value {\i z} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25337 \{\par
25338   const int dataCount = mValueSize*mKeySize;\par
25339   for (int i=0; i<dataCount; ++i)\par
25340     mData[i] = z;\par
25341   mDataBounds = QCPRange(z, z);\par
25342   mDataModified = true;\par
25343 \}\par
}
}
{\xe \v fillAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:fillAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::fillAlpha (unsigned char  {\i alpha})}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the opacity of all color map cells to {\i alpha} . A value of 0 for {\i alpha}  results in a fully transparent color map, and a value of 255 results in a fully opaque color map.\par
If you wish to restore opacity to 100% and free any used memory for the alpha map, rather use {\b clearAlpha}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAlpha} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25355 \{\par
25356   if (mAlpha || createAlpha(false))\par
25357   \{\par
25358     const int dataCount = mValueSize*mKeySize;\par
25359     for (int i=0; i<dataCount; ++i)\par
25360       mAlpha[i] = alpha;\par
25361     mDataModified = true;\par
25362   \}\par
25363 \}\par
}
}
{\xe \v isEmpty\:QCPColorMapData}
{\xe \v QCPColorMapData\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMapData::isEmpty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this instance carries no data. This is equivalent to having a size where at least one of the dimensions is 0 (see {\b setSize}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5715 \{ return mIsEmpty; \}\par
}
}
{\xe \v keyRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:keyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::keyRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5691 \{ return mKeyRange; \}\par
}
}
{\xe \v keySize\:QCPColorMapData}
{\xe \v QCPColorMapData\:keySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorMapData::keySize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5689 \{ return mKeySize; \}\par
}
}
{\xe \v operator=\:QCPColorMapData}
{\xe \v QCPColorMapData\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorMapData} & QCPColorMapData::operator= (const {\b QCPColorMapData} &  {\i other})}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overwrites this color map data instance with the data stored in {\i other} . The alpha map state is transferred, too. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25019 \{\par
25020   if (&other != this)\par
25021   \{\par
25022     const int keySize = other.keySize();\par
25023     const int valueSize = other.valueSize();\par
25024     if (!other.mAlpha && mAlpha)\par
25025       clearAlpha();\par
25026     setSize(keySize, valueSize);\par
25027     if (other.mAlpha && !mAlpha)\par
25028       createAlpha(false);\par
25029     setRange(other.keyRange(), other.valueRange());\par
25030     if (!isEmpty())\par
25031     \{\par
25032       memcpy(mData, other.mData, sizeof(mData[0])*keySize*valueSize);\par
25033       if (mAlpha)\par
25034         memcpy(mAlpha, other.mAlpha, sizeof(mAlpha[0])*keySize*valueSize);\par
25035     \}\par
25036     mDataBounds = other.mDataBounds;\par
25037     mDataModified = true;\par
25038   \}\par
25039   return *this;\par
25040 \}\par
}
}
{\xe \v recalculateDataBounds\:QCPColorMapData}
{\xe \v QCPColorMapData\:recalculateDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::recalculateDataBounds ()}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Goes through the data and updates the buffered minimum and maximum data values.\par
Calling this method is only advised if you are about to call {\b QCPColorMap::rescaleDataRange} and can not guarantee that the cells holding the maximum or minimum data haven't been overwritten with a smaller or larger value respectively, since the buffered maximum/minimum values have been updated the last time. Why this is the case is explained in the class description ({\b QCPColorMapData}).\par
Note that the method {\b QCPColorMap::rescaleDataRange} provides a parameter {\i recalculateDataBounds}  for convenience. Setting this to true will call this method for you, before doing the rescale. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25292 \{\par
25293   if (mKeySize > 0 && mValueSize > 0)\par
25294   \{\par
25295     double minHeight = mData[0];\par
25296     double maxHeight = mData[0];\par
25297     const int dataCount = mValueSize*mKeySize;\par
25298     for (int i=0; i<dataCount; ++i)\par
25299     \{\par
25300       if (mData[i] > maxHeight)\par
25301         maxHeight = mData[i];\par
25302       if (mData[i] < minHeight)\par
25303         minHeight = mData[i];\par
25304     \}\par
25305     mDataBounds.lower = minHeight;\par
25306     mDataBounds.upper = maxHeight;\par
25307   \}\par
25308 \}\par
}
}
{\xe \v setAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:setAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setAlpha (int  {\i keyIndex}, int  {\i valueIndex}, unsigned char  {\i alpha})}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the alpha of the color map cell given by {\i keyIndex}  and {\i valueIndex}  to {\i alpha} . A value of 0 for {\i alpha}  results in a fully transparent cell, and a value of 255 results in a fully opaque cell.\par
If an alpha map doesn't exist yet for this color map data, it will be created here. If you wish to restore full opacity and free any allocated memory of the alpha map, call {\b clearAlpha}.\par
Note that the cell-wise alpha which can be configured here is independent of any alpha configured in the color map's gradient ({\b QCPColorGradient}). If a cell is affected both by the cell-wise and gradient alpha, the alpha values will be blended accordingly during rendering of the color map.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b fillAlpha}, {\b clearAlpha} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25266 \{\par
25267   if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)\par
25268   \{\par
25269     if (mAlpha || createAlpha())\par
25270     \{\par
25271       mAlpha[valueIndex*mKeySize + keyIndex] = alpha;\par
25272       mDataModified = true;\par
25273     \}\par
25274   \} else\par
25275     qDebug() << Q_FUNC_INFO << "index out of bounds:" << keyIndex << valueIndex;\par
25276 \}\par
}
}
{\xe \v setCell\:QCPColorMapData}
{\xe \v QCPColorMapData\:setCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setCell (int  {\i keyIndex}, int  {\i valueIndex}, double  {\i z})}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the data of the cell with indices {\i keyIndex}  and {\i valueIndex}  to {\i z} . The indices enumerate the cells starting from zero, up to the map's size-1 in the respective dimension (see {\b setSize}).\par
In the standard plot configuration (horizontal key axis and vertical value axis, both not range-reversed), the cell with indices (0, 0) is in the bottom left corner and the cell with indices (keySize-1, valueSize-1) is in the top right corner of the color map.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setData}, {\b setSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25237 \{\par
25238   if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)\par
25239   \{\par
25240     mData[valueIndex*mKeySize + keyIndex] = z;\par
25241     if (z < mDataBounds.lower)\par
25242       mDataBounds.lower = z;\par
25243     if (z > mDataBounds.upper)\par
25244       mDataBounds.upper = z;\par
25245      mDataModified = true;\par
25246   \} else\par
25247     qDebug() << Q_FUNC_INFO << "index out of bounds:" << keyIndex << valueIndex;\par
25248 \}\par
}
}
{\xe \v setData\:QCPColorMapData}
{\xe \v QCPColorMapData\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setData (double  {\i key}, double  {\i value}, double  {\i z})}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the data of the cell, which lies at the plot coordinates given by {\i key}  and {\i value} , to {\i z} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Observação:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\b QCPColorMap} always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use {\b QCPColorMap} with logarithmic axes, you shouldn't use the {\b QCPColorMapData::setData} method as it uses a linear transformation to determine the cell index. Rather directly access the cell index with {\b QCPColorMapData::setCell}.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setCell}, {\b setRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25211 \{\par
25212   int keyCell = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;\par
25213   int valueCell = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;\par
25214   if (keyCell >= 0 && keyCell < mKeySize && valueCell >= 0 && valueCell < mValueSize)\par
25215   \{\par
25216     mData[valueCell*mKeySize + keyCell] = z;\par
25217     if (z < mDataBounds.lower)\par
25218       mDataBounds.lower = z;\par
25219     if (z > mDataBounds.upper)\par
25220       mDataBounds.upper = z;\par
25221      mDataModified = true;\par
25222   \}\par
25223 \}\par
}
}
{\xe \v setKeyRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:setKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setKeyRange (const {\b QCPRange} &  {\i keyRange})}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the coordinate range the data shall be distributed over in the key dimension. Together with the value range, This defines the rectangular area covered by the color map in plot coordinates.\par
The outer cells will be centered on the range boundaries given to this function. For example, if the key size ({\b setKeySize}) is 3 and {\i keyRange}  is set to {\f2 {\b QCPRange(2, 3)}}  there will be cells centered on the key coordinates 2, 2.5 and 3.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange}, {\b setValueRange}, {\b setSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25179 \{\par
25180   mKeyRange = keyRange;\par
25181 \}\par
}
}
{\xe \v setKeySize\:QCPColorMapData}
{\xe \v QCPColorMapData\:setKeySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setKeySize (int  {\i keySize})}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the data array to have {\i keySize}  cells in the key dimension.\par
The current data is discarded and the map cells are set to 0, unless the map had already the requested size.\par
Setting {\i keySize}  to zero frees the internal data array and {\b isEmpty} returns true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setKeyRange}, {\b setSize}, {\b setValueSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25133 \{\par
25134   setSize(keySize, mValueSize);\par
25135 \}\par
}
}
{\xe \v setRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:setRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setRange (const {\b QCPRange} &  {\i keyRange}, const {\b QCPRange} &  {\i valueRange})}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the coordinate ranges the data shall be distributed over. This defines the rectangular area covered by the color map in plot coordinates.\par
The outer cells will be centered on the range boundaries given to this function. For example, if the key size ({\b setKeySize}) is 3 and {\i keyRange}  is set to {\f2 {\b QCPRange(2, 3)}}  there will be cells centered on the key coordinates 2, 2.5 and 3.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25163 \{\par
25164   setKeyRange(keyRange);\par
25165   setValueRange(valueRange);\par
25166 \}\par
}
}
{\xe \v setSize\:QCPColorMapData}
{\xe \v QCPColorMapData\:setSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setSize (int  {\i keySize}, int  {\i valueSize})}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the data array to have {\i keySize}  cells in the key dimension and {\i valueSize}  cells in the value dimension.\par
The current data is discarded and the map cells are set to 0, unless the map had already the requested size.\par
Setting at least one of {\i keySize}  or {\i valueSize}  to zero frees the internal data array and {\b isEmpty} returns true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange}, {\b setKeySize}, {\b setValueSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25091 \{\par
25092   if (keySize != mKeySize || valueSize != mValueSize)\par
25093   \{\par
25094     mKeySize = keySize;\par
25095     mValueSize = valueSize;\par
25096     if (mData)\par
25097       delete[] mData;\par
25098     mIsEmpty = mKeySize == 0 || mValueSize == 0;\par
25099     if (!mIsEmpty)\par
25100     \{\par
25101 #ifdef __EXCEPTIONS\par
25102       try \{ // 2D arrays get memory intensive fast. So if the allocation fails, at least output debug message\par
25103 #endif\par
25104       mData = new double[mKeySize*mValueSize];\par
25105 #ifdef __EXCEPTIONS\par
25106       \} catch (...) \{ mData = 0; \}\par
25107 #endif\par
25108       if (mData)\par
25109         fill(0);\par
25110       else\par
25111         qDebug() << Q_FUNC_INFO << "out of memory for data dimensions "<< mKeySize << "*" << mValueSize;\par
25112     \} else\par
25113       mData = 0;\par
25114     \par
25115     if (mAlpha) // if we had an alpha map, recreate it with new size\par
25116       createAlpha();\par
25117     \par
25118     mDataModified = true;\par
25119   \}\par
25120 \}\par
}
}
{\xe \v setValueRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:setValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setValueRange (const {\b QCPRange} &  {\i valueRange})}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the coordinate range the data shall be distributed over in the value dimension. Together with the key range, This defines the rectangular area covered by the color map in plot coordinates.\par
The outer cells will be centered on the range boundaries given to this function. For example, if the value size ({\b setValueSize}) is 3 and {\i valueRange}  is set to {\f2 {\b QCPRange(2, 3)}}  there will be cells centered on the value coordinates 2, 2.5 and 3.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange}, {\b setKeyRange}, {\b setSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25194 \{\par
25195   mValueRange = valueRange;\par
25196 \}\par
}
}
{\xe \v setValueSize\:QCPColorMapData}
{\xe \v QCPColorMapData\:setValueSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setValueSize (int  {\i valueSize})}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the data array to have {\i valueSize}  cells in the value dimension.\par
The current data is discarded and the map cells are set to 0, unless the map had already the requested size.\par
Setting {\i valueSize}  to zero frees the internal data array and {\b isEmpty} returns true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setValueRange}, {\b setSize}, {\b setKeySize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25148 \{\par
25149   setSize(mKeySize, valueSize);\par
25150 \}\par
}
}
{\xe \v valueRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:valueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::valueRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5692 \{ return mValueRange; \}\par
}
}
{\xe \v valueSize\:QCPColorMapData}
{\xe \v QCPColorMapData\:valueSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorMapData::valueSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5690 \{ return mValueSize; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas e Funções Relacionadas\par
\pard\plain 
{\xe \v QCPColorMap\:QCPColorMapData}
{\xe \v QCPColorMapData\:QCPColorMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPColorMap}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:mAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char* QCPColorMapData::mAlpha{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mData\:QCPColorMapData}
{\xe \v QCPColorMapData\:mData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double* QCPColorMapData::mData{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataBounds\:QCPColorMapData}
{\xe \v QCPColorMapData\:mDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::mDataBounds{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataModified\:QCPColorMapData}
{\xe \v QCPColorMapData\:mDataModified}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMapData::mDataModified{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mIsEmpty\:QCPColorMapData}
{\xe \v QCPColorMapData\:mIsEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMapData::mIsEmpty{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mKeyRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:mKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::mKeyRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mKeySize\:QCPColorMapData}
{\xe \v QCPColorMapData\:mKeySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorMapData::mKeySize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mValueRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:mValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::mValueRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mValueSize\:QCPColorMapData}
{\xe \v QCPColorMapData\:mValueSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorMapData::mValueSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documentação para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}}