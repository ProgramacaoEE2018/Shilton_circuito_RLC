{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment RLC_Serie  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
v1.1 \par
}}RLC_Serie}
{\comment Generated byDoxgyen. }
{\creatim \yr2018\mo5\dy23\hr21\min24\sec22}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt RLC_Serie}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version v1.1\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Wed May 23 2018 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Shilton_circuito_RLC{\tc \v Shilton_circuito_RLC}\par \pard\plain 
{\bkmkstart AAAAAAAEAR}
{\bkmkend AAAAAAAEAR}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Objetivo: plotar a resposta de um circuito RLC s\'E9rie\par
Objetivo secund\'E1rio: analisar sua estabilidade do circuito,bem como subamortecimento e superamortecimento do sinal\par
Entrada: os componentes com seus valores e a e o tipo de fonte com seus parametros\par
Sa\'EDda: grafico com sinal de tens\'F5es do circuito \par
}}

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b QCP} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADYF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Ui} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPAxisPainterPrivate::CachedLabel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Capacitor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Indutor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAbstractPaintBuffer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPPaintBufferPixmap\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPAxisPainterPrivate\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAxisTicker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPAxisTickerDateTime\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAxisTickerFixed\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAxisTickerLog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAxisTickerPi\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAxisTickerText\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAxisTickerTime\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPBarsData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPColorGradient\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPColorMapData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPCurveData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPDataContainer< DataType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPDataRange\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPDataSelection\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPErrorBarsData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPFinancialData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPGraphData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPItemAnchor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDG \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPItemPosition\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPLineEnding\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPPlottableInterface1D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPAbstractPlottable1D< DataType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAbstractPlottable1D< QCPBarsData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPBars\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPAbstractPlottable1D< QCPCurveData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPCurve\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPAbstractPlottable1D< QCPFinancialData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPFinancial\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPAbstractPlottable1D< QCPGraphData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPGraph\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPAbstractPlottable1D< QCPStatisticalBoxData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPStatisticalBox\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPErrorBars\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPRange\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPScatterStyle\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPSelectionDecorator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADIO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPSelectionDecoratorBracket\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADJM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPStatisticalBoxData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPVector2D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QMainWindow
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MainWindow\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QObject
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPBarsGroup\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPLayer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPLayerable\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACRY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPAbstractItem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPItemBracket\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPItemCurve\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPItemEllipse\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPItemLine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPItemPixmap\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPItemRect\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPItemStraightLine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPItemText\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPItemTracer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPAbstractPlottable\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPAbstractPlottable1D< DataType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAbstractPlottable1D< QCPBarsData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAbstractPlottable1D< QCPCurveData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAbstractPlottable1D< QCPFinancialData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAbstractPlottable1D< QCPGraphData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAbstractPlottable1D< QCPStatisticalBoxData >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPColorMap\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPErrorBars\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPAxis\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPGrid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPLayoutElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPAbstractLegendItem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPPlottableLegendItem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPAxisRect\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPColorScaleAxisRectPrivate\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPColorScale\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPLayout\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPLayoutGrid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPLegend\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPLayoutInset\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPTextElement\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPSelectionRect\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QCPMarginGroup\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QPainter
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCPPainter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QWidget
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
QCustomPlot\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Resistor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADXX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Tensao\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADYC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QCPAxisPainterPrivate::TickLabelData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b QCPAxisPainterPrivate::CachedLabel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Capacitor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Indutor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MainWindow} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAbstractItem} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all items in a plot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAbstractLegendItem} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all entries in a {\b QCPLegend} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAbstractPaintBuffer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for paint buffers, which define the rendering backend })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAbstractPlottable} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all data representing objects in a plot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAbstractPlottable1D< DataType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A template base class for plottables with one-dimensional data })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxis} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a single axis inside a {\b QCustomPlot} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisPainterPrivate} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisRect} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds multiple axes and arranges them in a rectangular shape })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisTicker} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The base class tick generator used by {\b QCPAxis} to create tick positions and tick labels })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisTickerDateTime} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker for calendar dates and times as axis ticks })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisTickerFixed} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker with a fixed tick step })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisTickerLog} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker suited for logarithmic axes })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisTickerPi} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker to display ticks in units of an arbitrary constant, for example pi })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisTickerText} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker which allows arbitrary labels at specified coordinates })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisTickerTime} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker for time spans in units of milliseconds to days })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPBars} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a bar chart in a plot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPBarsData} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point (one bar) for {\b QCPBars} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPBarsGroup} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Groups multiple {\b QCPBars} together so they appear side by side })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPColorGradient} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines a color gradient for use with e.g. {\b QCPColorMap} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPColorMap} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a two-dimensional color map in a plot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPColorMapData} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the two-dimensional data of a {\b QCPColorMap} plottable })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPColorScale} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A color scale for use with color coding data such as {\b QCPColorMap} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPColorScaleAxisRectPrivate} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPCurve} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a parametric curve in a plot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPCurveData} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPCurve} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPDataContainer< DataType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The generic data container for one-dimensional plottables })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPDataRange} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data range given by begin and end index })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPDataSelection} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data set by holding multiple {\b QCPDataRange} instances })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPErrorBars} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable that adds a set of error bars to other plottables })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPErrorBarsData} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single error bar for {\b QCPErrorBars} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPFinancial} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a financial stock chart })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPFinancialData} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPFinancial} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPGraph} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a graph in a plot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPGraphData} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPGraph} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPGrid} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Responsible for drawing the grid of a {\b QCPAxis} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemAnchor} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An anchor of an item to which positions can be attached to })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemBracket} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bracket for referencing/highlighting certain parts in the plot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemCurve} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A curved line from one point to another })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemEllipse} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An ellipse })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemLine} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A line from one point to another })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemPixmap} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An arbitrary pixmap })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemPosition} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages the position of an item })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemRect} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A rectangle })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemStraightLine} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A straight line that spans infinitely in both directions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemText} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A text label })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPItemTracer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Item that sticks to {\b QCPGraph} data points })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPLayer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layer that may contain objects, to control the rendering order })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPLayerable} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all drawable objects })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACRY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPLayout} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for layouts })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPLayoutElement} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all objects that form the layout system })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPLayoutGrid} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout that arranges child elements in a grid })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPLayoutInset} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout that places child elements aligned to the border or arbitrarily positioned })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPLegend} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a legend inside a {\b QCustomPlot} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPLineEnding} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handles the different ending decorations for line-like items })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPMarginGroup} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A margin group allows synchronization of margin sides if working with multiple layout elements })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPPaintBufferPixmap} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A paint buffer based on QPixmap, using software raster rendering })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPPainter} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QPainter subclass used internally })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPPlottableInterface1D} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines an abstract interface for one-dimensional plottables })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPPlottableLegendItem} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A legend item representing a plottable with an icon and the plottable name })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPRange} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the range an axis is encompassing })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPScatterStyle} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the visual appearance of scatter points })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPSelectionDecorator} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls how a plottable's data selection is drawn })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADIO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPSelectionDecoratorBracket} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A selection decorator which draws brackets around each selected data segment })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADJM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPSelectionRect} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides rect/rubber-band data selection and range zoom interaction })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPStatisticalBox} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a single statistical box in a plot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPStatisticalBoxData} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPStatisticalBox} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPTextElement} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout element displaying a text })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPVector2D} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents two doubles as a mathematical 2D vector })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCustomPlot} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The central class of the library. This is the QWidget which displays the plot and interacts with the user })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Resistor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADXX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Tensao} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADYC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QCPAxisPainterPrivate::TickLabelData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Classes_cirkt.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b mainwindow.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b mainwindow.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b qcustomplot.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b qcustomplot.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCP Namespace Reference\par \pard\plain 
{\tc\tcl2 \v QCP}
{\xe \v QCP}
{\bkmkstart AAAAAAADYF}
{\bkmkend AAAAAAADYF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ResolutionUnit} \{ {\b ruDotsPerMeter}, 
{\b ruDotsPerCentimeter}, 
{\b ruDotsPerInch}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ExportPen} \{ {\b epNoCosmetic}, 
{\b epAllowCosmetic}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SignDomain} \{ {\b sdNegative}, 
{\b sdBoth}, 
{\b sdPositive}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b MarginSide} \{ {\b msLeft} = 0x01, 
{\b msRight} = 0x02, 
{\b msTop} = 0x04, 
{\b msBottom} = 0x08, 
{\b msAll} = 0xFF, 
{\b msNone} = 0x00
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AntialiasedElement} \{ {\b aeAxes} = 0x0001, 
{\b aeGrid} = 0x0002, 
{\b aeSubGrid} = 0x0004, 
{\b aeLegend} = 0x0008, 
{\b aeLegendItems} = 0x0010, 
{\b aePlottables} = 0x0020, 
{\b aeItems} = 0x0040, 
{\b aeScatters} = 0x0080, 
{\b aeFills} = 0x0100, 
{\b aeZeroLine} = 0x0200, 
{\b aeOther} = 0x8000, 
{\b aeAll} = 0xFFFF, 
{\b aeNone} = 0x0000
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PlottingHint} \{ {\b phNone} = 0x000, 
{\b phFastPolylines} = 0x001, 
{\b phImmediateRefresh} = 0x002, 
{\b phCacheLabels} = 0x004
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Interaction} \{ {\b iRangeDrag} = 0x001, 
{\b iRangeZoom} = 0x002, 
{\b iMultiSelect} = 0x004, 
{\b iSelectPlottables} = 0x008, 
{\b iSelectAxes} = 0x010, 
{\b iSelectLegend} = 0x020, 
{\b iSelectItems} = 0x040, 
{\b iSelectOther} = 0x080
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SelectionRectMode} \{ {\b srmNone}, 
{\b srmZoom}, 
{\b srmSelect}, 
{\b srmCustom}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SelectionType} \{ {\b stNone}, 
{\b stWhole}, 
{\b stSingleData}, 
{\b stDataRange}, 
{\b stMultipleDataRanges}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInvalidData} (double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInvalidData} (double value1, double value2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMarginValue} (QMargins &margins, {\b QCP::MarginSide} side, int value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getMarginValue} (const QMargins &margins, {\b QCP::MarginSide} side)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QMetaObject {\b staticMetaObject}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b QCP} Namespace contains general enums, QFlags and functions used throughout the {\b QCustomPlot} library.\par
It provides QMetaObject-based reflection of its enums and flags via {\i {\b QCP::staticMetaObject}} . \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v AntialiasedElement\:QCP}
{\xe \v QCP\:AntialiasedElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCP::AntialiasedElement}}}
\par
{\bkmkstart AAAAAAADYG}
{\bkmkend AAAAAAADYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines what objects of a plot can be forcibly drawn antialiased/not antialiased. If an object is neither forcibly drawn antialiased nor forcibly drawn not antialiased, it is up to the respective element how it is drawn. Typically it provides a {\i setAntialiased}  function for this.\par
{\f2 AntialiasedElements}  is a flag of or-combined elements of this enum type.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::setAntialiasedElements}, {\b QCustomPlot::setNotAntialiasedElements} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v aeAxes\:QCP}
{\xe \v QCP\:aeAxes}
{\qr aeAxes{\bkmkstart AAAAAAADYH}
{\bkmkend AAAAAAADYH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0001}  Axis base line and tick marks \par
}\cell }{\row }
{\xe \v aeGrid\:QCP}
{\xe \v QCP\:aeGrid}
{\qr aeGrid{\bkmkstart AAAAAAADYI}
{\bkmkend AAAAAAADYI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0002}  Grid lines \par
}\cell }{\row }
{\xe \v aeSubGrid\:QCP}
{\xe \v QCP\:aeSubGrid}
{\qr aeSubGrid{\bkmkstart AAAAAAADYJ}
{\bkmkend AAAAAAADYJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0004}  Sub grid lines \par
}\cell }{\row }
{\xe \v aeLegend\:QCP}
{\xe \v QCP\:aeLegend}
{\qr aeLegend{\bkmkstart AAAAAAADYK}
{\bkmkend AAAAAAADYK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0008}  Legend box \par
}\cell }{\row }
{\xe \v aeLegendItems\:QCP}
{\xe \v QCP\:aeLegendItems}
{\qr aeLegendItems{\bkmkstart AAAAAAADYL}
{\bkmkend AAAAAAADYL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0010}  Legend items \par
}\cell }{\row }
{\xe \v aePlottables\:QCP}
{\xe \v QCP\:aePlottables}
{\qr aePlottables{\bkmkstart AAAAAAADYM}
{\bkmkend AAAAAAADYM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0020}  Main lines of plottables \par
}\cell }{\row }
{\xe \v aeItems\:QCP}
{\xe \v QCP\:aeItems}
{\qr aeItems{\bkmkstart AAAAAAADYN}
{\bkmkend AAAAAAADYN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0040}  Main lines of items \par
}\cell }{\row }
{\xe \v aeScatters\:QCP}
{\xe \v QCP\:aeScatters}
{\qr aeScatters{\bkmkstart AAAAAAADYO}
{\bkmkend AAAAAAADYO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0080}  Scatter symbols of plottables (excluding scatter symbols of type ssPixmap) \par
}\cell }{\row }
{\xe \v aeFills\:QCP}
{\xe \v QCP\:aeFills}
{\qr aeFills{\bkmkstart AAAAAAADYP}
{\bkmkend AAAAAAADYP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0100}  Borders of fills (e.g. under or between graphs) \par
}\cell }{\row }
{\xe \v aeZeroLine\:QCP}
{\xe \v QCP\:aeZeroLine}
{\qr aeZeroLine{\bkmkstart AAAAAAADYQ}
{\bkmkend AAAAAAADYQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0200}  Zero-lines, see {\b QCPGrid::setZeroLinePen} \par
}\cell }{\row }
{\xe \v aeOther\:QCP}
{\xe \v QCP\:aeOther}
{\qr aeOther{\bkmkstart AAAAAAADYR}
{\bkmkend AAAAAAADYR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x8000}  Other elements that don't fit into any of the existing categories \par
}\cell }{\row }
{\xe \v aeAll\:QCP}
{\xe \v QCP\:aeAll}
{\qr aeAll{\bkmkstart AAAAAAADYS}
{\bkmkend AAAAAAADYS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0xFFFF}  All elements \par
}\cell }{\row }
{\xe \v aeNone\:QCP}
{\xe \v QCP\:aeNone}
{\qr aeNone{\bkmkstart AAAAAAADYT}
{\bkmkend AAAAAAADYT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x0000}  No elements \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   214                         \{ aeAxes           = 0x0001 \par
  215                           ,aeGrid          = 0x0002 \par
  216                           ,aeSubGrid       = 0x0004 \par
  217                           ,aeLegend        = 0x0008 \par
  218                           ,aeLegendItems   = 0x0010 \par
  219                           ,aePlottables    = 0x0020 \par
  220                           ,aeItems         = 0x0040 \par
  221                           ,aeScatters      = 0x0080 \par
  222                           ,aeFills         = 0x0100 \par
  223                           ,aeZeroLine      = 0x0200 \par
  224                           ,aeOther         = 0x8000 \par
  225                           ,aeAll           = 0xFFFF \par
  226                           ,aeNone          = 0x0000 \par
  227                         \};\par
}
}
{\xe \v ExportPen\:QCP}
{\xe \v QCP\:ExportPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCP::ExportPen}}}
\par
{\bkmkstart AAAAAAADYU}
{\bkmkend AAAAAAADYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines how cosmetic pens (pens with numerical width 0) are handled during export.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::savePdf} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v epNoCosmetic\:QCP}
{\xe \v QCP\:epNoCosmetic}
{\qr epNoCosmetic{\bkmkstart AAAAAAADYV}
{\bkmkend AAAAAAADYV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cosmetic pens are converted to pens with pixel width 1 when exporting. \par
}\cell }{\row }
{\xe \v epAllowCosmetic\:QCP}
{\xe \v QCP\:epAllowCosmetic}
{\qr epAllowCosmetic{\bkmkstart AAAAAAADYW}
{\bkmkend AAAAAAADYW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cosmetic pens are exported normally (e.g. in PDF exports, cosmetic pens always appear as 1 pixel on screen, independent of viewer zoom level) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   175                \{ epNoCosmetic     \par
  176                  ,epAllowCosmetic \par
  177                \};\par
}
}
{\xe \v Interaction\:QCP}
{\xe \v QCP\:Interaction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCP::Interaction}}}
\par
{\bkmkstart AAAAAAADYX}
{\bkmkend AAAAAAADYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the mouse interactions possible with {\b QCustomPlot}.\par
{\f2 Interactions}  is a flag of or-combined elements of this enum type.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::setInteractions} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v iRangeDrag\:QCP}
{\xe \v QCP\:iRangeDrag}
{\qr iRangeDrag{\bkmkstart AAAAAAADYY}
{\bkmkend AAAAAAADYY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x001}  Axis ranges are draggable (see {\b QCPAxisRect::setRangeDrag}, {\b QCPAxisRect::setRangeDragAxes}) \par
}\cell }{\row }
{\xe \v iRangeZoom\:QCP}
{\xe \v QCP\:iRangeZoom}
{\qr iRangeZoom{\bkmkstart AAAAAAADYZ}
{\bkmkend AAAAAAADYZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x002}  Axis ranges are zoomable with the mouse wheel (see {\b QCPAxisRect::setRangeZoom}, {\b QCPAxisRect::setRangeZoomAxes}) \par
}\cell }{\row }
{\xe \v iMultiSelect\:QCP}
{\xe \v QCP\:iMultiSelect}
{\qr iMultiSelect{\bkmkstart AAAAAAADZA}
{\bkmkend AAAAAAADZA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x004}  The user can select multiple objects by holding the modifier set by {\b QCustomPlot::setMultiSelectModifier} while clicking \par
}\cell }{\row }
{\xe \v iSelectPlottables\:QCP}
{\xe \v QCP\:iSelectPlottables}
{\qr iSelectPlottables{\bkmkstart AAAAAAADZB}
{\bkmkend AAAAAAADZB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x008}  Plottables are selectable (e.g. graphs, curves, bars,... see {\b QCPAbstractPlottable}) \par
}\cell }{\row }
{\xe \v iSelectAxes\:QCP}
{\xe \v QCP\:iSelectAxes}
{\qr iSelectAxes{\bkmkstart AAAAAAADZC}
{\bkmkend AAAAAAADZC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x010}  Axes are selectable (or parts of them, see {\b QCPAxis::setSelectableParts}) \par
}\cell }{\row }
{\xe \v iSelectLegend\:QCP}
{\xe \v QCP\:iSelectLegend}
{\qr iSelectLegend{\bkmkstart AAAAAAADZD}
{\bkmkend AAAAAAADZD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x020}  Legends are selectable (or their child items, see {\b QCPLegend::setSelectableParts}) \par
}\cell }{\row }
{\xe \v iSelectItems\:QCP}
{\xe \v QCP\:iSelectItems}
{\qr iSelectItems{\bkmkstart AAAAAAADZE}
{\bkmkend AAAAAAADZE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x040}  Items are selectable (Rectangles, Arrows, Textitems, etc. see {\b QCPAbstractItem}) \par
}\cell }{\row }
{\xe \v iSelectOther\:QCP}
{\xe \v QCP\:iSelectOther}
{\qr iSelectOther{\bkmkstart AAAAAAADZF}
{\bkmkend AAAAAAADZF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x080}  All other objects are selectable (e.g. your own derived layerables, other layout elements,...) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   251                  \{ iRangeDrag         = 0x001 \par
  252                    ,iRangeZoom        = 0x002 \par
  253                    ,iMultiSelect      = 0x004 \par
  254                    ,iSelectPlottables = 0x008 \par
  255                    ,iSelectAxes       = 0x010 \par
  256                    ,iSelectLegend     = 0x020 \par
  257                    ,iSelectItems      = 0x040 \par
  258                    ,iSelectOther      = 0x080 \par
  259                  \};\par
}
}
{\xe \v MarginSide\:QCP}
{\xe \v QCP\:MarginSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCP::MarginSide}}}
\par
{\bkmkstart AAAAAAADZG}
{\bkmkend AAAAAAADZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the sides of a rectangular entity to which margins can be applied.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPLayoutElement::setAutoMargins}, {\b QCPAxisRect::setAutoMargins} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v msLeft\:QCP}
{\xe \v QCP\:msLeft}
{\qr msLeft{\bkmkstart AAAAAAADZH}
{\bkmkend AAAAAAADZH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x01}  left margin \par
}\cell }{\row }
{\xe \v msRight\:QCP}
{\xe \v QCP\:msRight}
{\qr msRight{\bkmkstart AAAAAAADZI}
{\bkmkend AAAAAAADZI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x02}  right margin \par
}\cell }{\row }
{\xe \v msTop\:QCP}
{\xe \v QCP\:msTop}
{\qr msTop{\bkmkstart AAAAAAADZJ}
{\bkmkend AAAAAAADZJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x04}  top margin \par
}\cell }{\row }
{\xe \v msBottom\:QCP}
{\xe \v QCP\:msBottom}
{\qr msBottom{\bkmkstart AAAAAAADZK}
{\bkmkend AAAAAAADZK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x08}  bottom margin \par
}\cell }{\row }
{\xe \v msAll\:QCP}
{\xe \v QCP\:msAll}
{\qr msAll{\bkmkstart AAAAAAADZL}
{\bkmkend AAAAAAADZL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0xFF}  all margins \par
}\cell }{\row }
{\xe \v msNone\:QCP}
{\xe \v QCP\:msNone}
{\qr msNone{\bkmkstart AAAAAAADZM}
{\bkmkend AAAAAAADZM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x00}  no margin \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   196                 \{ msLeft     = 0x01 \par
  197                   ,msRight   = 0x02 \par
  198                   ,msTop     = 0x04 \par
  199                   ,msBottom  = 0x08 \par
  200                   ,msAll     = 0xFF \par
  201                   ,msNone    = 0x00 \par
  202                 \};\par
}
}
{\xe \v PlottingHint\:QCP}
{\xe \v QCP\:PlottingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCP::PlottingHint}}}
\par
{\bkmkstart AAAAAAADZN}
{\bkmkend AAAAAAADZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines plotting hints that control various aspects of the quality and speed of plotting.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::setPlottingHints} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v phNone\:QCP}
{\xe \v QCP\:phNone}
{\qr phNone{\bkmkstart AAAAAAADZO}
{\bkmkend AAAAAAADZO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x000}  No hints are set \par
}\cell }{\row }
{\xe \v phFastPolylines\:QCP}
{\xe \v QCP\:phFastPolylines}
{\qr phFastPolylines{\bkmkstart AAAAAAADZP}
{\bkmkend AAAAAAADZP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x001}  Graph/Curve lines are drawn with a faster method. This reduces the quality especially of the line segment joins, thus is most effective for pen sizes larger than 1. It is only used for solid line pens. \par
}\cell }{\row }
{\xe \v phImmediateRefresh\:QCP}
{\xe \v QCP\:phImmediateRefresh}
{\qr phImmediateRefresh{\bkmkstart AAAAAAADZQ}
{\bkmkend AAAAAAADZQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x002}  causes an immediate repaint() instead of a soft update() when {\b QCustomPlot::replot()} is called with parameter {\b QCustomPlot::rpRefreshHint}. This is set by default to prevent the plot from freezing on fast consecutive replots (e.g. user drags ranges with mouse). \par
}\cell }{\row }
{\xe \v phCacheLabels\:QCP}
{\xe \v QCP\:phCacheLabels}
{\qr phCacheLabels{\bkmkstart AAAAAAADZR}
{\bkmkend AAAAAAADZR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x004}  axis (tick) labels will be cached as pixmaps, increasing replot performance. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   235                   \{ phNone              = 0x000 \par
  236                     ,phFastPolylines    = 0x001 \par
  237                     ,phImmediateRefresh = 0x002 \par
  239                     ,phCacheLabels      = 0x004 \par
  241                   \};\par
}
}
{\xe \v ResolutionUnit\:QCP}
{\xe \v QCP\:ResolutionUnit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCP::ResolutionUnit}}}
\par
{\bkmkstart AAAAAAADZS}
{\bkmkend AAAAAAADZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the different units in which the image resolution can be specified in the export functions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::savePng}, {\b QCustomPlot::saveJpg}, {\b QCustomPlot::saveBmp}, {\b QCustomPlot::saveRastered} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ruDotsPerMeter\:QCP}
{\xe \v QCP\:ruDotsPerMeter}
{\qr ruDotsPerMeter{\bkmkstart AAAAAAADZT}
{\bkmkend AAAAAAADZT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resolution is given in dots per meter (dpm) \par
}\cell }{\row }
{\xe \v ruDotsPerCentimeter\:QCP}
{\xe \v QCP\:ruDotsPerCentimeter}
{\qr ruDotsPerCentimeter{\bkmkstart AAAAAAADZU}
{\bkmkend AAAAAAADZU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resolution is given in dots per centimeter (dpcm) \par
}\cell }{\row }
{\xe \v ruDotsPerInch\:QCP}
{\xe \v QCP\:ruDotsPerInch}
{\qr ruDotsPerInch{\bkmkstart AAAAAAADZV}
{\bkmkend AAAAAAADZV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resolution is given in dots per inch (DPI/PPI) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165                     \{ ruDotsPerMeter       \par
  166                       ,ruDotsPerCentimeter \par
  167                       ,ruDotsPerInch       \par
  168                     \};\par
}
}
{\xe \v SelectionRectMode\:QCP}
{\xe \v QCP\:SelectionRectMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCP::SelectionRectMode}}}
\par
{\bkmkstart AAAAAAADZW}
{\bkmkend AAAAAAADZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the behaviour of the selection rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::setSelectionRectMode}, {\b QCustomPlot::selectionRect}, {\b QCPSelectionRect} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v srmNone\:QCP}
{\xe \v QCP\:srmNone}
{\qr srmNone{\bkmkstart AAAAAAADZX}
{\bkmkend AAAAAAADZX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The selection rect is disabled, and all mouse events are forwarded to the underlying objects, e.g. for axis range dragging. \par
}\cell }{\row }
{\xe \v srmZoom\:QCP}
{\xe \v QCP\:srmZoom}
{\qr srmZoom{\bkmkstart AAAAAAADZY}
{\bkmkend AAAAAAADZY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When dragging the mouse, a selection rect becomes active. Upon releasing, the axes that are currently set as range zoom axes ({\b QCPAxisRect::setRangeZoomAxes}) will have their ranges zoomed accordingly. \par
}\cell }{\row }
{\xe \v srmSelect\:QCP}
{\xe \v QCP\:srmSelect}
{\qr srmSelect{\bkmkstart AAAAAAADZZ}
{\bkmkend AAAAAAADZZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When dragging the mouse, a selection rect becomes active. Upon releasing, plottable data points that were within the selection rect are selected, if the plottable's selectability setting permits. (See data selection mechanism for details.) \par
}\cell }{\row }
{\xe \v srmCustom\:QCP}
{\xe \v QCP\:srmCustom}
{\qr srmCustom{\bkmkstart AAAAAAAEAA}
{\bkmkend AAAAAAAEAA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When dragging the mouse, a selection rect becomes active. It is the programmer's responsibility to connect according slots to the selection rect's signals (e.g. {\b QCPSelectionRect::accepted}) in order to process the user interaction. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   267                        \{ srmNone    \par
  268                          ,srmZoom   \par
  269                          ,srmSelect \par
  270                          ,srmCustom \par
  271                        \};\par
}
}
{\xe \v SelectionType\:QCP}
{\xe \v QCP\:SelectionType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCP::SelectionType}}}
\par
{\bkmkstart AAAAAAAEAB}
{\bkmkend AAAAAAAEAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the different ways a plottable can be selected. These images show the effect of the different selection types, when the indicated selection rect was dragged:\par
{\qc  \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx1749
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx3498
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5247
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6996
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8745
\pard \widctlpar\intbl\adjustright
{ \cell }{ \cell }{ \cell }{ \cell }{  \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
} \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractPlottable::setSelectable}, {\b QCPDataSelection::enforceType} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v stNone\:QCP}
{\xe \v QCP\:stNone}
{\qr stNone{\bkmkstart AAAAAAAEAC}
{\bkmkend AAAAAAAEAC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The plottable is not selectable. \par
}\cell }{\row }
{\xe \v stWhole\:QCP}
{\xe \v QCP\:stWhole}
{\qr stWhole{\bkmkstart AAAAAAAEAD}
{\bkmkend AAAAAAAEAD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Selection behaves like {\b stMultipleDataRanges}, but if there are any data points selected, the entire plottable is drawn as selected. \par
}\cell }{\row }
{\xe \v stSingleData\:QCP}
{\xe \v QCP\:stSingleData}
{\qr stSingleData{\bkmkstart AAAAAAAEAE}
{\bkmkend AAAAAAAEAE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
One individual data point can be selected at a time. \par
}\cell }{\row }
{\xe \v stDataRange\:QCP}
{\xe \v QCP\:stDataRange}
{\qr stDataRange{\bkmkstart AAAAAAAEAF}
{\bkmkend AAAAAAAEAF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiple contiguous data points (a data range) can be selected. \par
}\cell }{\row }
{\xe \v stMultipleDataRanges\:QCP}
{\xe \v QCP\:stMultipleDataRanges}
{\qr stMultipleDataRanges{\bkmkstart AAAAAAAEAG}
{\bkmkend AAAAAAAEAG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Any combination of data points/ranges can be selected. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   291                    \{ stNone                \par
  292                      ,stWhole              \par
  293                      ,stSingleData         \par
  294                      ,stDataRange          \par
  295                      ,stMultipleDataRanges \par
  296                     \};\par
}
}
{\xe \v SignDomain\:QCP}
{\xe \v QCP\:SignDomain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCP::SignDomain}}}
\par
{\bkmkstart AAAAAAAEAH}
{\bkmkend AAAAAAAEAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents negative and positive sign domain, e.g. for passing to {\b QCPAbstractPlottable::getKeyRange} and {\b QCPAbstractPlottable::getValueRange}.\par
This is primarily needed when working with logarithmic axis scales, since only one of the sign domains can be visible at a time. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v sdNegative\:QCP}
{\xe \v QCP\:sdNegative}
{\qr sdNegative{\bkmkstart AAAAAAAEAI}
{\bkmkend AAAAAAAEAI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The negative sign domain, i.e. numbers smaller than zero. \par
}\cell }{\row }
{\xe \v sdBoth\:QCP}
{\xe \v QCP\:sdBoth}
{\qr sdBoth{\bkmkstart AAAAAAAEAJ}
{\bkmkend AAAAAAAEAJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Both sign domains, including zero, i.e. all numbers. \par
}\cell }{\row }
{\xe \v sdPositive\:QCP}
{\xe \v QCP\:sdPositive}
{\qr sdPositive{\bkmkstart AAAAAAAEAK}
{\bkmkend AAAAAAAEAK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The positive sign domain, i.e. numbers greater than zero. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   186                 \{ sdNegative  \par
  187                   ,sdBoth     \par
  188                   ,sdPositive \par
  189                 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getMarginValue\:QCP}
{\xe \v QCP\:getMarginValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCP::getMarginValue (const QMargins &  {\i margins}, {\b QCP::MarginSide}  {\i side}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEAL}
{\bkmkend AAAAAAAEAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   346 \{\par
  347   switch (side)\par
  348   \{\par
  349     case QCP::msLeft: return margins.left();\par
  350     case QCP::msRight: return margins.right();\par
  351     case QCP::msTop: return margins.top();\par
  352     case QCP::msBottom: return margins.bottom();\par
  353     default: break;\par
  354   \}\par
  355   return 0;\par
  356 \}\par
}
}
{\xe \v isInvalidData\:QCP}
{\xe \v QCP\:isInvalidData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCP::isInvalidData (double  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEAM}
{\bkmkend AAAAAAAEAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   305 \{\par
  306   return qIsNaN(value) || qIsInf(value);\par
  307 \}\par
}
}
{\xe \v isInvalidData\:QCP}
{\xe \v QCP\:isInvalidData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCP::isInvalidData (double  {\i value1}, double  {\i value2}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEAN}
{\bkmkend AAAAAAAEAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   315 \{\par
  316   return isInvalidData(value1) || isInvalidData(value2);\par
  317 \}\par
}
}
{\xe \v setMarginValue\:QCP}
{\xe \v QCP\:setMarginValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCP::setMarginValue (QMargins &  {\i margins}, {\b QCP::MarginSide}  {\i side}, int  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEAO}
{\bkmkend AAAAAAAEAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   326 \{\par
  327   switch (side)\par
  328   \{\par
  329     case QCP::msLeft: margins.setLeft(value); break;\par
  330     case QCP::msRight: margins.setRight(value); break;\par
  331     case QCP::msTop: margins.setTop(value); break;\par
  332     case QCP::msBottom: margins.setBottom(value); break;\par
  333     case QCP::msAll: margins = QMargins(value, value, value, value); break;\par
  334     default: break;\par
  335   \}\par
  336 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v staticMetaObject\:QCP}
{\xe \v QCP\:staticMetaObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QMetaObject QCP::staticMetaObject}}
\par
{\bkmkstart AAAAAAAEAP}
{\bkmkend AAAAAAAEAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ui Namespace Reference\par \pard\plain 
{\tc\tcl2 \v Ui}
{\xe \v Ui}
{\bkmkstart AAAAAAAEAQ}
{\bkmkend AAAAAAAEAQ}

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisPainterPrivate::CachedLabel Struct Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisPainterPrivate::CachedLabel}
{\xe \v QCPAxisPainterPrivate::CachedLabel}
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPAxisPainterPrivate::CachedLabel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_q_c_p_axis_painter_private_1_1_cached_label__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointF {\b offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b pixmap}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v offset\:QCPAxisPainterPrivate::CachedLabel}
{\xe \v QCPAxisPainterPrivate::CachedLabel\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPAxisPainterPrivate::CachedLabel::offset}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pixmap\:QCPAxisPainterPrivate::CachedLabel}
{\xe \v QCPAxisPainterPrivate::CachedLabel\:pixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPAxisPainterPrivate::CachedLabel::pixmap}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Capacitor Class Reference\par \pard\plain 
{\tc\tcl2 \v Capacitor}
{\xe \v Capacitor}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\par
{
{\f2 #include <Classes_cirkt.h>}}\par
Collaboration diagram for Capacitor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_capacitor__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Capacitor} (float valor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_imp} (complex< double > s)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b get_capacit} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
complex< double > {\b get_imp} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Capacitor\:Capacitor}
{\xe \v Capacitor\:Capacitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Capacitor::Capacitor (float  {\i valor})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    35 \{capacit = valor;\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_capacit\:Capacitor}
{\xe \v Capacitor\:get_capacit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Capacitor::get_capacit ()}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    37 \{return capacit;\}\par
}
}
{\xe \v get_imp\:Capacitor}
{\xe \v Capacitor\:get_imp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
complex< double > Capacitor::get_imp ()}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    38 \{ return imp; \}\par
}
}
{\xe \v set_imp\:Capacitor}
{\xe \v Capacitor\:set_imp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Capacitor::set_imp (complex< double >  {\i s})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    36 \{imp = complex<double>(1,0)/(s * complex<double>(capacit,0));\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Classes_cirkt.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Indutor Class Reference\par \pard\plain 
{\tc\tcl2 \v Indutor}
{\xe \v Indutor}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\par
{
{\f2 #include <Classes_cirkt.h>}}\par
Collaboration diagram for Indutor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_indutor__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Indutor} (float valor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_imp} (complex< double > s)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b get_indutor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
complex< double > {\b get_imp} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Indutor\:Indutor}
{\xe \v Indutor\:Indutor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Indutor::Indutor (float  {\i valor})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{indutancia = valor;\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_imp\:Indutor}
{\xe \v Indutor\:get_imp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
complex< double > Indutor::get_imp ()}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    54 \{ return imp;\}\par
}
}
{\xe \v get_indutor\:Indutor}
{\xe \v Indutor\:get_indutor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Indutor::get_indutor ()}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    53 \{return indutancia;\}\par
}
}
{\xe \v set_imp\:Indutor}
{\xe \v Indutor\:set_imp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Indutor::set_imp (complex< double >  {\i s})}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    52 \{imp = s*complex<double>(indutancia,0);\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Classes_cirkt.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MainWindow Class Reference\par \pard\plain 
{\tc\tcl2 \v MainWindow}
{\xe \v MainWindow}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
\par
{
{\f2 #include <mainwindow.h>}}\par
Inheritance diagram for MainWindow:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_main_window__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for MainWindow:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_main_window__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MainWindow} (QWidget *parent=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~MainWindow} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MainWindow\:MainWindow}
{\xe \v MainWindow\:MainWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MainWindow::MainWindow (QWidget *  {\i parent} = {\f2 0}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     4                                       :\par
    5     QMainWindow(parent),\par
    6     ui(new Ui::MainWindow)\par
    7 \{\par
    8     ui->setupUi(this);\par
    9 \}\par
}
}
{\xe \v ~MainWindow\:MainWindow}
{\xe \v MainWindow\:~MainWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MainWindow::~MainWindow ()}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     delete ui;\par
   14 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b mainwindow.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b mainwindow.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAbstractItem Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAbstractItem}
{\xe \v QCPAbstractItem}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all items in a plot. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAbstractItem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_item__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAbstractItem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_item__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (bool {\b selected})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectableChanged} (bool {\b selectable})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractItem} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAbstractItem} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b clipToAxisRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b clipAxisRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b selectable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b selected} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setClipToAxisRect} (bool clip)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setClipAxisRect} ({\b QCPAxisRect} *rect)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectable} (bool {\b selectable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelected} (bool {\b selected})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPItemPosition} * > {\b positions} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPItemAnchor} * > {\b anchors} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} * {\b position} (const QString &name) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} * {\b anchor} (const QString &name) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasAnchor} (const QString &name) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QRect {\b clipRect} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b anchorPixelPosition} (int anchorId) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b rectDistance} (const QRectF &rect, const QPointF &pos, bool filledRect) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} * {\b createPosition} (const QString &name)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} * {\b createAnchor} (const QString &name, int anchorId)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mClipToAxisRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxisRect} > {\b mClipAxisRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPItemPosition} * > {\b mPositions}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPItemAnchor} * > {\b mAnchors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mSelectable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mSelected}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemAnchor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all items in a plot. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In {\b QCustomPlot}, items are supplemental graphical elements that are neither plottables ({\b QCPAbstractPlottable}) nor axes ({\b QCPAxis}). While plottables are always tied to two axes and thus plot coordinates, items can also be placed in absolute coordinates independent of any axes. Each specific item has at least one {\b QCPItemPosition} member which controls the positioning. Some items are defined by more than one coordinate and thus have two or more {\b QCPItemPosition} members (For example, {\b QCPItemRect} has {\i topLeft}  and {\i bottomRight} ).\par
This abstract base class defines a very basic interface like visibility and clipping. Since this class is abstract, it can't be instantiated. Use one of the subclasses or create a subclass yourself to create new items.\par
The built-in items are: \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPItemLine}\cell }{A line defined by a start and an end point. May have different ending styles on each side (e.g. arrows). \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPItemStraightLine}\cell }{A straight line defined by a start and a direction point. Unlike {\b QCPItemLine}, the straight line is infinitely long and has no endings. \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPItemCurve}\cell }{A curve defined by start, end and two intermediate control points. May have different ending styles on each side (e.g. arrows). \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPItemRect}\cell }{A rectangle \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPItemEllipse}\cell }{An ellipse \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPItemPixmap}\cell }{An arbitrary pixmap \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPItemText}\cell }{A text label \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPItemBracket}\cell }{A bracket which may be used to reference/highlight certain parts in the plot. \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPItemTracer}\cell }{An item that can be attached to a {\b QCPGraph} and sticks to its data points, given a key coordinate. \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Clipping
\par}
{\tc\tcl2 \v Clipping}
Items are by default clipped to the main axis rect (they are only visible inside the axis rect). To make an item visible outside that axis rect, disable clipping via {\b setClipToAxisRect(false)}.\par
On the other hand if you want the item to be clipped to a different axis rect, specify it via {\b setClipAxisRect}. This clipAxisRect property of an item is only used for clipping behaviour, and in principle is independent of the coordinate axes the item might be tied to via its position members ({\b QCPItemPosition::setAxes}). However, it is common that the axis rect for clipping also contains the axes used for the item positions.\par}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Using items
\par}
{\tc\tcl2 \v Using items}
First you instantiate the item you want to use and add it to the plot: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }by default, the positions of the item are bound to the x- and y-Axis of the plot. So we can just set the plot coordinates where the line should start/end: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }If we don't want the line to be positioned in plot coordinates but a different coordinate system, e.g. absolute pixel positions on the {\b QCustomPlot} surface, we need to change the position type like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }Then we can set the coordinates, this time in pixels: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }and make the line visible on the entire {\b QCustomPlot}, by disabling clipping to the axis rect: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } For more advanced plots, it is even possible to set different types and parent anchors per X/Y coordinate of an item position, using for example {\b QCPItemPosition::setTypeX} or {\b QCPItemPosition::setParentAnchorX}. For details, see the documentation of {\b QCPItemPosition}.\par}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Creating own items
\par}
{\tc\tcl2 \v Creating own items}
To create an own item, you implement a subclass of {\b QCPAbstractItem}. These are the pure virtual functions, you must implement: {
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b selectTest} \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b draw}\par
}
See the documentation of those functions for what they need to do.\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Allowing the item to be positioned
\par}
{\tc\tcl3 \v Allowing the item to be positioned}
As mentioned, item positions are represented by {\b QCPItemPosition} members. Let's assume the new item shall have only one point as its position (as opposed to two like a rect or multiple like a polygon). You then add a public member of type {\b QCPItemPosition} like so:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid QCPItemPosition * const myPosition;\par
}
\par
the const makes sure the pointer itself can't be modified from the user of your new item (the {\b QCPItemPosition} instance it points to, can be modified, of course). The initialization of this pointer is made easy with the {\b createPosition} function. Just assign the return value of this function to each {\b QCPItemPosition} in the constructor of your item. {\b createPosition} takes a string which is the name of the position, typically this is identical to the variable name. For example, the constructor of QCPItemExample could look like this:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid QCPItemExample::QCPItemExample(QCustomPlot *parentPlot) :\par
  QCPAbstractItem(parentPlot),\par
  myPosition(createPosition("myPosition"))\par
\{\par
  // other constructor code\par
\}\par
}
\par}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
The draw function
\par}
{\tc\tcl3 \v The draw function}
To give your item a visual representation, reimplement the {\b draw} function and use the passed {\b QCPPainter} to draw the item. You can retrieve the item position in pixel coordinates from the position member(s) via {\b QCPItemPosition::pixelPosition}.\par
To optimize performance you should calculate a bounding rect first (don't forget to take the pen width into account), check whether it intersects the {\b clipRect}, and only draw the item at all if this is the case.\par}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
The selectTest function
\par}
{\tc\tcl3 \v The selectTest function}
Your implementation of the {\b selectTest} function may use the helpers {\b QCPVector2D::distanceSquaredToLine} and {\b rectDistance}. With these, the implementation of the selection test becomes significantly simpler for most items. See the documentation of {\b selectTest} for what the function parameters mean and what the function should return.\par}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Providing anchors
\par}
{\tc\tcl3 \v Providing anchors}
Providing anchors ({\b QCPItemAnchor}) starts off like adding a position. First you create a public member, e.g.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid QCPItemAnchor * const bottom;\par
}
\par
and create it in the constructor with the {\b createAnchor} function, assigning it a name and an anchor id (an integer enumerating all anchors on the item, you may create an own enum for this). Since anchors can be placed anywhere, relative to the item's position(s), your item needs to provide the position of every anchor with the reimplementation of the {\b anchorPixelPosition}(int anchorId) function.\par
In essence the {\b QCPItemAnchor} is merely an intermediary that itself asks your item for the pixel position when anything attached to the anchor needs to know the coordinates. \par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAbstractItem\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:QCPAbstractItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAbstractItem::QCPAbstractItem ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class constructor which initializes base class members. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12203                                                         :\par
12204   QCPLayerable(parentPlot),\par
12205   mClipToAxisRect(false),\par
12206   mSelectable(true),\par
12207   mSelected(false)\par
12208 \{\par
12209   parentPlot->registerItem(this);\par
12210   \par
12211   QList<QCPAxisRect*> rects = parentPlot->axisRects();\par
12212   if (rects.size() > 0)\par
12213   \{\par
12214     setClipToAxisRect(true);\par
12215     setClipAxisRect(rects.first());\par
12216   \}\par
12217 \}\par
}
}
{\xe \v ~QCPAbstractItem\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:~QCPAbstractItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAbstractItem::~QCPAbstractItem (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12220 \{\par
12221   // don't delete mPositions because every position is also an anchor and thus in mAnchors\par
12222   qDeleteAll(mAnchors);\par
12223 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v anchor\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:anchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor} * QCPAbstractItem::anchor (const QString &  {\i name}) const}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b QCPItemAnchor} with the specified {\i name} . If this item doesn't have an anchor by that name, returns 0.\par
This function provides an alternative way to access item anchors. Normally, you access anchors direcly by their member pointers (which typically have the same variable name as {\i name} ).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b anchors}, {\b position} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12330 \{\par
12331   for (int i=0; i<mAnchors.size(); ++i)\par
12332   \{\par
12333     if (mAnchors.at(i)->name() == name)\par
12334       return mAnchors.at(i);\par
12335   \}\par
12336   qDebug() << Q_FUNC_INFO << "anchor with name not found:" << name;\par
12337   return 0;\par
12338 \}\par
}
}
{\xe \v anchorPixelPosition\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:anchorPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPAbstractItem::anchorPixelPosition (int  {\i anchorId}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPItemBracket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemPixmap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemEllipse} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPItemRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12443 \{\par
12444   qDebug() << Q_FUNC_INFO << "called on item which shouldn't have any anchors (this method not reimplemented). anchorId" << anchorId;\par
12445   return QPointF();\par
12446 \}\par
}
}
{\xe \v anchors\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:anchors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPItemAnchor} * > QCPAbstractItem::anchors () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all anchors of the item in a list. Note that since a position ({\b QCPItemPosition}) is always also an anchor, the list will also contain the positions of this item.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b positions}, {\b anchor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3535 \{ return mAnchors; \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12389 \{\par
12390   applyAntialiasingHint(painter, mAntialiased, QCP::aeItems);\par
12391 \}\par
}
}
{\xe \v clipAxisRect\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:clipAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect} * QCPAbstractItem::clipAxisRect () const}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12227 \{\par
12228   return mClipAxisRect.data();\par
12229 \}\par
}
}
{\xe \v clipRect\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:clipRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAbstractItem::clipRect () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12368 \{\par
12369   if (mClipToAxisRect && mClipAxisRect)\par
12370     return mClipAxisRect.data()->rect();\par
12371   else\par
12372     return mParentPlot->viewport();\par
12373 \}\par
}
}
{\xe \v clipToAxisRect\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:clipToAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractItem::clipToAxisRect () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3519 \{ return mClipToAxisRect; \}\par
}
}
{\xe \v createAnchor\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:createAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor} * QCPAbstractItem::createAnchor (const QString &  {\i name}, int  {\i anchorId}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12497 \{\par
12498   if (hasAnchor(name))\par
12499     qDebug() << Q_FUNC_INFO << "anchor/position with name exists already:" << name;\par
12500   QCPItemAnchor *newAnchor = new QCPItemAnchor(mParentPlot, this, name, anchorId);\par
12501   mAnchors.append(newAnchor);\par
12502   return newAnchor;\par
12503 \}\par
}
}
{\xe \v createPosition\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:createPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition} * QCPAbstractItem::createPosition (const QString &  {\i name}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12463 \{\par
12464   if (hasAnchor(name))\par
12465     qDebug() << Q_FUNC_INFO << "anchor/position with name exists already:" << name;\par
12466   QCPItemPosition *newPosition = new QCPItemPosition(mParentPlot, this, name);\par
12467   mPositions.append(newPosition);\par
12468   mAnchors.append(newPosition); // every position is also an anchor\par
12469   newPosition->setAxes(mParentPlot->xAxis, mParentPlot->yAxis);\par
12470   newPosition->setType(QCPItemPosition::ptPlotCoords);\par
12471   if (mParentPlot->axisRect())\par
12472     newPosition->setAxisRect(mParentPlot->axisRect());\par
12473   newPosition->setCoords(0, 0);\par
12474   return newPosition;\par
12475 \}\par
}
}
{\xe \v deselectEvent\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12521 \{\par
12522   if (mSelectable)\par
12523   \{\par
12524     bool selBefore = mSelected;\par
12525     setSelected(false);\par
12526     if (selectionStateChanged)\par
12527       *selectionStateChanged = mSelected != selBefore;\par
12528   \}\par
12529 \}\par
}
}
{\xe \v draw\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Implemented in {\b QCPItemBracket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemTracer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemPixmap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemEllipse} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemLine} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPItemStraightLine} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v hasAnchor\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:hasAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractItem::hasAnchor (const QString &  {\i name}) const}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this item has an anchor with the specified {\i name} .\par
Note that you can check for positions with this function, too. This is because every position is also an anchor ({\b QCPItemPosition} inherits from {\b QCPItemAnchor}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b anchor}, {\b position} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12349 \{\par
12350   for (int i=0; i<mAnchors.size(); ++i)\par
12351   \{\par
12352     if (mAnchors.at(i)->name() == name)\par
12353       return true;\par
12354   \}\par
12355   return false;\par
12356 \}\par
}
}
{\xe \v position\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition} * QCPAbstractItem::position (const QString &  {\i name}) const}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b QCPItemPosition} with the specified {\i name} . If this item doesn't have a position by that name, returns 0.\par
This function provides an alternative way to access item positions. Normally, you access positions direcly by their member pointers (which typically have the same variable name as {\i name} ).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b positions}, {\b anchor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12309 \{\par
12310   for (int i=0; i<mPositions.size(); ++i)\par
12311   \{\par
12312     if (mPositions.at(i)->name() == name)\par
12313       return mPositions.at(i);\par
12314   \}\par
12315   qDebug() << Q_FUNC_INFO << "position with name not found:" << name;\par
12316   return 0;\par
12317 \}\par
}
}
{\xe \v positions\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:positions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPItemPosition} * > QCPAbstractItem::positions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all positions of the item in a list.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b anchors}, {\b position} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3534 \{ return mPositions; \}\par
}
}
{\xe \v rectDistance\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:rectDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAbstractItem::rectDistance (const QRectF &  {\i rect}, const QPointF &  {\i pos}, bool  {\i filledRect}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12407 \{\par
12408   double result = -1;\par
12409 \par
12410   // distance to border:\par
12411   QList<QLineF> lines;\par
12412   lines << QLineF(rect.topLeft(), rect.topRight()) << QLineF(rect.bottomLeft(), rect.bottomRight())\par
12413         << QLineF(rect.topLeft(), rect.bottomLeft()) << QLineF(rect.topRight(), rect.bottomRight());\par
12414   double minDistSqr = std::numeric_limits<double>::max();\par
12415   for (int i=0; i<lines.size(); ++i)\par
12416   \{\par
12417     double distSqr = QCPVector2D(pos).distanceSquaredToLine(lines.at(i).p1(), lines.at(i).p2());\par
12418     if (distSqr < minDistSqr)\par
12419       minDistSqr = distSqr;\par
12420   \}\par
12421   result = qSqrt(minDistSqr);\par
12422   \par
12423   // filled rect, allow click inside to count as hit:\par
12424   if (filledRect && result > mParentPlot->selectionTolerance()*0.99)\par
12425   \{\par
12426     if (rect.contains(pos))\par
12427       result = mParentPlot->selectionTolerance()*0.99;\par
12428   \}\par
12429   return result;\par
12430 \}\par
}
}
{\xe \v selectable\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:selectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractItem::selectable () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3521 \{ return mSelectable; \}\par
}
}
{\xe \v selectableChanged\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:selectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::selectableChanged (bool  {\i selectable}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v selected\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:selected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractItem::selected () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3522 \{ return mSelected; \}\par
}
}
{\xe \v selectEvent\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12507 \{\par
12508   Q_UNUSED(event)\par
12509   Q_UNUSED(details)\par
12510   if (mSelectable)\par
12511   \{\par
12512     bool selBefore = mSelected;\par
12513     setSelected(additive ? !mSelected : true);\par
12514     if (selectionStateChanged)\par
12515       *selectionStateChanged = mSelected != selBefore;\par
12516   \}\par
12517 \}\par
}
}
{\xe \v selectionCategory\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPAbstractItem::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12533 \{\par
12534   return QCP::iSelectItems;\par
12535 \}\par
}
}
{\xe \v selectionChanged\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::selectionChanged (bool  {\i selected}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this item has changed, either by user interaction or by a direct call to {\b setSelected}. \par
}}
{\xe \v selectTest\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual double QCPAbstractItem::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Implemented in {\b QCPItemBracket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemTracer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemPixmap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemEllipse} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAES \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemLine} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAET \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPItemStraightLine} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setClipAxisRect\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:setClipAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::setClipAxisRect ({\b QCPAxisRect} *  {\i rect})}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the clip axis rect. It defines the rect that will be used to clip the item when {\b setClipToAxisRect} is set to true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setClipToAxisRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12251 \{\par
12252   mClipAxisRect = rect;\par
12253   if (mClipToAxisRect)\par
12254     setParentLayerable(mClipAxisRect.data());\par
12255 \}\par
}
}
{\xe \v setClipToAxisRect\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:setClipToAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::setClipToAxisRect (bool  {\i clip})}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the item shall be clipped to an axis rect or whether it shall be visible on the entire {\b QCustomPlot}. The axis rect can be set with {\b setClipAxisRect}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setClipAxisRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12238 \{\par
12239   mClipToAxisRect = clip;\par
12240   if (mClipToAxisRect)\par
12241     setParentLayerable(mClipAxisRect.data());\par
12242 \}\par
}
}
{\xe \v setSelectable\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:setSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::setSelectable (bool  {\i selectable})}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the user can (de-)select this item by clicking on the {\b QCustomPlot} surface. (When {\b QCustomPlot::setInteractions} contains QCustomPlot::iSelectItems.)\par
However, even when {\i selectable}  was set to false, it is possible to set the selection manually, by calling {\b setSelected}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::setInteractions}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12267 \{\par
12268   if (mSelectable != selectable)\par
12269   \{\par
12270     mSelectable = selectable;\par
12271     emit selectableChanged(mSelectable);\par
12272   \}\par
12273 \}\par
}
}
{\xe \v setSelected\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:setSelected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractItem::setSelected (bool  {\i selected})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this item is selected or not. When selected, it might use a different visual appearance (e.g. pen and brush), this depends on the specific item though.\par
The entire selection mechanism for items is handled automatically when {\b QCustomPlot::setInteractions} contains QCustomPlot::iSelectItems. You only need to call this function when you wish to change the selection state manually.\par
This function can change the selection state even when {\b setSelectable} was set to false.\par
emits the {\b selectionChanged} signal when {\i selected}  is different from the previous selection state.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectable}, {\b selectTest} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12290 \{\par
12291   if (mSelected != selected)\par
12292   \{\par
12293     mSelected = selected;\par
12294     emit selectionChanged(mSelected);\par
12295   \}\par
12296 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPItemAnchor\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:QCPItemAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPItemAnchor}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAnchors\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:mAnchors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPItemAnchor}*> QCPAbstractItem::mAnchors{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mClipAxisRect\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:mClipAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxisRect}> QCPAbstractItem::mClipAxisRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mClipToAxisRect\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:mClipToAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractItem::mClipToAxisRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPositions\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:mPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPItemPosition}*> QCPAbstractItem::mPositions{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectable\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:mSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractItem::mSelectable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelected\:QCPAbstractItem}
{\xe \v QCPAbstractItem\:mSelected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractItem::mSelected{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAbstractLegendItem Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem}
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all entries in a {\b QCPLegend}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAbstractLegendItem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_legend_item__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAbstractLegendItem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_legend_item__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (bool {\b selected})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectableChanged} (bool {\b selectable})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractLegendItem} ({\b QCPLegend} *parent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLegend} * {\b parentLegend} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b font} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b textColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b selectedFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b selectedTextColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b selectable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b selected} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFont} (const QFont &{\b font})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTextColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedFont} (const QFont &{\b font})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedTextColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectable} (bool {\b selectable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelected} (bool {\b selected})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QRect {\b clipRect} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLegend} * {\b mParentLegend}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mTextColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mSelectedFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mSelectedTextColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mSelectable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mSelected}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all entries in a {\b QCPLegend}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It defines a very basic interface for entries in a {\b QCPLegend}. For representing plottables in the legend, the subclass {\b QCPPlottableLegendItem} is more suitable.\par
Only derive directly from this class when you need absolute freedom (e.g. a custom legend entry that's not even associated with a plottable).\par
You must implement the following pure virtual functions: {
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b draw} (from {\b QCPLayerable})\par
}
You inherit the following members you may use: \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPLegend} *{\b mParentLegend}   \cell }{A pointer to the parent {\b QCPLegend}. \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{QFont {\b mFont}   \cell }{The generic font of the item. You should use this font for all or at least the most prominent text of the item.  \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAbstractLegendItem\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:QCPAbstractLegendItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAbstractLegendItem::QCPAbstractLegendItem ({\b QCPLegend} *  {\i parent}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b QCPAbstractLegendItem} and associates it with the {\b QCPLegend} {\i parent} . This does not cause the item to be added to {\i parent} , so {\b QCPLegend::addItem} must be called separately. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17967                                                               :\par
17968   QCPLayoutElement(parent->parentPlot()),\par
17969   mParentLegend(parent),\par
17970   mFont(parent->font()),\par
17971   mTextColor(parent->textColor()),\par
17972   mSelectedFont(parent->selectedFont()),\par
17973   mSelectedTextColor(parent->selectedTextColor()),\par
17974   mSelectable(true),\par
17975   mSelected(false)\par
17976 \{\par
17977   setLayer(QLatin1String("legend"));\par
17978   setMargins(QMargins(0, 0, 0, 0));\par
17979 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v applyDefaultAntialiasingHint\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18070 \{\par
18071   applyAntialiasingHint(painter, mAntialiased, QCP::aeLegendItems);\par
18072 \}\par
}
}
{\xe \v clipRect\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:clipRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAbstractLegendItem::clipRect () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18076 \{\par
18077   return mOuterRect;\par
18078 \}\par
}
}
{\xe \v deselectEvent\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18096 \{\par
18097   if (mSelectable && mParentLegend->selectableParts().testFlag(QCPLegend::spItems))\par
18098   \{\par
18099     bool selBefore = mSelected;\par
18100     setSelected(false);\par
18101     if (selectionStateChanged)\par
18102       *selectionStateChanged = mSelected != selBefore;\par
18103   \}\par
18104 \}\par
}
}
{\xe \v draw\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void QCPAbstractLegendItem::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Implemented in {\b QCPPlottableLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v font\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:font}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAbstractLegendItem::font () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4725 \{ return mFont; \}\par
}
}
{\xe \v parentLegend\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:parentLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLegend}* QCPAbstractLegendItem::parentLegend () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4724 \{ return mParentLegend; \}\par
}
}
{\xe \v selectable\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:selectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractLegendItem::selectable () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4729 \{ return mSelectable; \}\par
}
}
{\xe \v selectableChanged\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:selectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::selectableChanged (bool  {\i selectable}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v selected\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:selected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractLegendItem::selected () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4730 \{ return mSelected; \}\par
}
}
{\xe \v selectedFont\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:selectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAbstractLegendItem::selectedFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4727 \{ return mSelectedFont; \}\par
}
}
{\xe \v selectedTextColor\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:selectedTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAbstractLegendItem::selectedTextColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4728 \{ return mSelectedTextColor; \}\par
}
}
{\xe \v selectEvent\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18082 \{\par
18083   Q_UNUSED(event)\par
18084   Q_UNUSED(details)\par
18085   if (mSelectable && mParentLegend->selectableParts().testFlag(QCPLegend::spItems))\par
18086   \{\par
18087     bool selBefore = mSelected;\par
18088     setSelected(additive ? !mSelected : true);\par
18089     if (selectionStateChanged)\par
18090       *selectionStateChanged = mSelected != selBefore;\par
18091   \}\par
18092 \}\par
}
}
{\xe \v selectionCategory\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPAbstractLegendItem::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18825 \{\par
18826   return QCP::iSelectLegend;\par
18827 \}\par
}
}
{\xe \v selectionChanged\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::selectionChanged (bool  {\i selected}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this legend item has changed, either by user interaction or by a direct call to {\b setSelected}. \par
}}
{\xe \v selectTest\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAbstractLegendItem::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layout elements are sensitive to events inside their outer rect. If {\i pos}  is within the outer rect, this method returns a value corresponding to 0.99 times the parent plot's selection tolerance. However, layout elements are not selectable by default. So if {\i onlySelectable}  is true, -1.0 is returned.\par
See {\b QCPLayerable::selectTest} for a general explanation of this virtual method.\par
{\b QCPLayoutElement} subclasses may reimplement this method to provide more specific selection test behaviour. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18056 \{\par
18057   Q_UNUSED(details)\par
18058   if (!mParentPlot) return -1;\par
18059   if (onlySelectable && (!mSelectable || !mParentLegend->selectableParts().testFlag(QCPLegend::spItems)))\par
18060     return -1;\par
18061   \par
18062   if (mRect.contains(pos.toPoint()))\par
18063     return mParentPlot->selectionTolerance()*0.99;\par
18064   else\par
18065     return -1;\par
18066 \}\par
}
}
{\xe \v setFont\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:setFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::setFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the default font of this specific legend item to {\i font} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTextColor}, {\b QCPLegend::setFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17987 \{\par
17988   mFont = font;\par
17989 \}\par
}
}
{\xe \v setSelectable\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:setSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::setSelectable (bool  {\i selectable})}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this specific legend item is selectable.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid setSelectedParts, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18029 \{\par
18030   if (mSelectable != selectable)\par
18031   \{\par
18032     mSelectable = selectable;\par
18033     emit selectableChanged(mSelectable);\par
18034   \}\par
18035 \}\par
}
}
{\xe \v setSelected\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:setSelected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::setSelected (bool  {\i selected})}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this specific legend item is selected.\par
It is possible to set the selection state of this item by calling this function directly, even if setSelectable is set to false.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid setSelectableParts, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18046 \{\par
18047   if (mSelected != selected)\par
18048   \{\par
18049     mSelected = selected;\par
18050     emit selectionChanged(mSelected);\par
18051   \}\par
18052 \}\par
}
}
{\xe \v setSelectedFont\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:setSelectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::setSelectedFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When this legend item is selected, {\i font}  is used to draw generic text, instead of the normal font set with {\b setFont}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFont}, {\b QCPLegend::setSelectedFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18008 \{\par
18009   mSelectedFont = font;\par
18010 \}\par
}
}
{\xe \v setSelectedTextColor\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:setSelectedTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::setSelectedTextColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When this legend item is selected, {\i color}  is used to draw generic text, instead of the normal color set with {\b setTextColor}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTextColor}, {\b QCPLegend::setSelectedTextColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18019 \{\par
18020   mSelectedTextColor = color;\par
18021 \}\par
}
}
{\xe \v setTextColor\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:setTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractLegendItem::setTextColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the default text color of this specific legend item to {\i color} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFont}, {\b QCPLegend::setTextColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17997 \{\par
17998   mTextColor = color;\par
17999 \}\par
}
}
{\xe \v textColor\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:textColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAbstractLegendItem::textColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4726 \{ return mTextColor; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLegend\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mFont\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:mFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAbstractLegendItem::mFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentLegend\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:mParentLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLegend}* QCPAbstractLegendItem::mParentLegend{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectable\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:mSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractLegendItem::mSelectable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelected\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:mSelected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractLegendItem::mSelected{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedFont\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:mSelectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAbstractLegendItem::mSelectedFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedTextColor\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:mSelectedTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAbstractLegendItem::mSelectedTextColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTextColor\:QCPAbstractLegendItem}
{\xe \v QCPAbstractLegendItem\:mTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAbstractLegendItem::mTextColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAbstractPaintBuffer Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer}
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for paint buffers, which define the rendering backend. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAbstractPaintBuffer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_paint_buffer__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAbstractPaintBuffer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_paint_buffer__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPaintBuffer} (const QSize &{\b size}, double {\b devicePixelRatio})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAbstractPaintBuffer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b invalidated} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b devicePixelRatio} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSize} (const QSize &{\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInvalidated} (bool {\b invalidated}=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDevicePixelRatio} (double ratio)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPPainter} * {\b startPainting} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b donePainting} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b clear} (const QColor &color)=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b reallocateBuffer} ()=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b mSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mDevicePixelRatio}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mInvalidated}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for paint buffers, which define the rendering backend. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This abstract base class defines the basic interface that a paint buffer needs to provide in order to be usable by {\b QCustomPlot}.\par
A paint buffer manages both a surface to draw onto, and the matching paint device. The size of the surface can be changed via {\b setSize}. External classes ({\b QCustomPlot} and {\b QCPLayer}) request a painter via {\b startPainting} and then perform the draw calls. Once the painting is complete, {\b donePainting} is called, so the paint buffer implementation can do clean up if necessary. Before rendering a frame, each paint buffer is usually filled with a color using {\b clear} (usually the color is {\f2 Qt::transparent} ), to remove the contents of the previous frame.\par
The simplest paint buffer implementation is {\b QCPPaintBufferPixmap} which allows regular software rendering via the raster engine. Hardware accelerated rendering via pixel buffers and frame buffer objects is provided by QCPPaintBufferGlPbuffer and QCPPaintBufferGlFbo. They are used automatically if {\b QCustomPlot::setOpenGl} is enabled. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAbstractPaintBuffer\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:QCPAbstractPaintBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAbstractPaintBuffer::QCPAbstractPaintBuffer (const QSize &  {\i size}, double  {\i devicePixelRatio}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a paint buffer and initializes it with the provided {\i size}  and {\i devicePixelRatio} .\par
Subclasses must call their {\b reallocateBuffer} implementation in their respective constructors. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   570                                                                                          :\par
  571   mSize(size),\par
  572   mDevicePixelRatio(devicePixelRatio),\par
  573   mInvalidated(true)\par
  574 \{\par
  575 \}\par
}
}
{\xe \v ~QCPAbstractPaintBuffer\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:~QCPAbstractPaintBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAbstractPaintBuffer::~QCPAbstractPaintBuffer (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   578 \{\par
  579 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v clear\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPaintBuffer::clear (const QColor &  {\i color}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the entire buffer with the provided {\i color} . To have an empty transparent buffer, use the named color {\f2 Qt::transparent} .\par
This method must not be called if there is currently a painter (acquired with {\b startPainting}) active. \par
}{
Implemented in {\b QCPPaintBufferPixmap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v devicePixelRatio\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:devicePixelRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAbstractPaintBuffer::devicePixelRatio () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   524 \{ return mDevicePixelRatio; \}\par
}
}
{\xe \v donePainting\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:donePainting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPaintBuffer::donePainting (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you have acquired a {\b QCPPainter} to paint onto this paint buffer via {\b startPainting}, call this method as soon as you are done with the painting operations and have deleted the painter.\par
paint buffer subclasses may use this method to perform any type of cleanup that is necessary. The default implementation does nothing. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   533 \{\}\par
}
}
{\xe \v draw\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPaintBuffer::draw ({\b QCPPainter} *  {\i painter}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the contents of this buffer with the provided {\i painter} . This is the method that is used to finally join all paint buffers and draw them onto the screen. \par
}{
Implemented in {\b QCPPaintBufferPixmap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v invalidated\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:invalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPaintBuffer::invalidated () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   523 \{ return mInvalidated; \}\par
}
}
{\xe \v reallocateBuffer\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:reallocateBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPaintBuffer::reallocateBuffer (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reallocates the internal buffer with the currently configured size ({\b setSize}) and device pixel ratio, if applicable ({\b setDevicePixelRatio}). It is called as soon as any of those properties are changed on this paint buffer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Subclasses of {\b QCPAbstractPaintBuffer} must call their reimplementation of this method in their constructor, to perform the first allocation (this can not be done by the base class because calling pure virtual methods in base class constructors is not possible). \par
}}{
Implemented in {\b QCPPaintBufferPixmap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setDevicePixelRatio\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:setDevicePixelRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPaintBuffer::setDevicePixelRatio (double  {\i ratio})}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the the device pixel ratio to {\i ratio} . This is useful to render on high-DPI output devices. The ratio is automatically set to the device pixel ratio used by the parent {\b QCustomPlot} instance.\par
The buffer is reallocated (by calling {\b reallocateBuffer}), so any painters that were obtained by {\b startPainting} are invalidated and must not be used after calling this method.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This method is only available for Qt versions 5.4 and higher. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   628 \{\par
  629   if (!qFuzzyCompare(ratio, mDevicePixelRatio))\par
  630   \{\par
  631 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
  632     mDevicePixelRatio = ratio;\par
  633     reallocateBuffer();\par
  634 #else\par
  635     qDebug() << Q_FUNC_INFO << "Device pixel ratios not supported for Qt versions before 5.4";\par
  636     mDevicePixelRatio = 1.0;\par
  637 #endif\par
  638   \}\par
  639 \}\par
}
}
{\xe \v setInvalidated\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:setInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPaintBuffer::setInvalidated (bool  {\i invalidated} = {\f2 true})}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the invalidated flag to {\i invalidated} .\par
This mechanism is used internally in conjunction with isolated replotting of {\b QCPLayer} instances (in {\b QCPLayer::lmBuffered} mode). If {\b QCPLayer::replot} is called on a buffered layer, i.e. an isolated repaint of only that layer (and its dedicated paint buffer) is requested, {\b QCustomPlot} will decide depending on the invalidated flags of other paint buffers whether it also replots them, instead of only the layer on which the replot was called.\par
The invalidated flag is set to true when {\b QCPLayer} association has changed, i.e. if layers were added or removed from this buffer, or if they were reordered. It is set to false as soon as all associated {\b QCPLayer} instances are drawn onto the buffer.\par
Under normal circumstances, it is not necessary to manually call this method. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   614 \{\par
  615   mInvalidated = invalidated;\par
  616 \}\par
}
}
{\xe \v setSize\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:setSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPaintBuffer::setSize (const QSize &  {\i size})}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the paint buffer size.\par
The buffer is reallocated (by calling {\b reallocateBuffer}), so any painters that were obtained by {\b startPainting} are invalidated and must not be used after calling this method.\par
If {\i size}  is already the current buffer size, this method does nothing. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   590 \{\par
  591   if (mSize != size)\par
  592   \{\par
  593     mSize = size;\par
  594     reallocateBuffer();\par
  595   \}\par
  596 \}\par
}
}
{\xe \v size\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPAbstractPaintBuffer::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   522 \{ return mSize; \}\par
}
}
{\xe \v startPainting\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:startPainting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPPainter} * QCPAbstractPaintBuffer::startPainting (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPPainter} which is ready to draw to this buffer. The ownership and thus the responsibility to delete the painter after the painting operations are complete is given to the caller of this method.\par
Once you are done using the painter, delete the painter and call {\b donePainting}.\par
While a painter generated with this method is active, you must not call {\b setSize}, {\b setDevicePixelRatio} or {\b clear}.\par
This method may return 0, if a painter couldn't be activated on the buffer. This usually indicates a problem with the respective painting backend. \par
}{
Implemented in {\b QCPPaintBufferPixmap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mDevicePixelRatio\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:mDevicePixelRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAbstractPaintBuffer::mDevicePixelRatio{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInvalidated\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:mInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPaintBuffer::mInvalidated{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSize\:QCPAbstractPaintBuffer}
{\xe \v QCPAbstractPaintBuffer\:mSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPAbstractPaintBuffer::mSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAbstractPlottable Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable}
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all data representing objects in a plot. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAbstractPlottable:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_plottable__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAbstractPlottable:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_plottable__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (bool {\b selected})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (const {\b QCPDataSelection} &{\b selection})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectableChanged} ({\b QCP::SelectionType} {\b selectable})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAbstractPlottable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b name} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiasedFill} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiasedScatters} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b keyAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b valueAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionType} {\b selectable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b selected} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b selection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionDecorator} * {\b selectionDecorator} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (const QString &{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedFill} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedScatters} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setKeyAxis} ({\b QCPAxis} *axis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValueAxis} ({\b QCPAxis} *axis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectable} ({\b QCP::SelectionType} {\b selectable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelection} ({\b QCPDataSelection} {\b selection})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectionDecorator} ({\b QCPSelectionDecorator} *decorator)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPPlottableInterface1D} * {\b interface1D} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b coordsToPixels} (double key, double value, double &x, double &y) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QPointF {\b coordsToPixels} (double key, double value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsToCoords} (double x, double y, double &key, double &value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsToCoords} (const QPointF &pixelPos, double &key, double &value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleAxes} (bool onlyEnlarge=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleKeyAxis} (bool onlyEnlarge=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleValueAxis} (bool onlyEnlarge=false, bool inKeyRange=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addToLegend} ({\b QCPLegend} *legend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addToLegend} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeFromLegend} ({\b QCPLegend} *legend) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeFromLegend} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QRect {\b clipRect} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyFillAntialiasingHint} ({\b QCPPainter} *painter) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyScattersAntialiasingHint} ({\b QCPPainter} *painter) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiasedFill}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiasedScatters}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxis} > {\b mKeyAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxis} > {\b mValueAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionType} {\b mSelectable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b mSelection}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionDecorator} * {\b mSelectionDecorator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPPlottableLegendItem}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all data representing objects in a plot. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It defines a very basic interface like name, pen, brush, visibility etc. Since this class is abstract, it can't be instantiated. Use one of the subclasses or create a subclass yourself to create new ways of displaying data (see "Creating own plottables" below). Plottables that display one-dimensional data (i.e. data points have a single key dimension and one or multiple values at each key) are based off of the template subclass {\b QCPAbstractPlottable1D}, see details there.\par
All further specifics are in the subclasses, for example: {
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A normal graph with possibly a line and/or scatter points {\b QCPGraph} (typically created with {\b QCustomPlot::addGraph}) \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A parametric curve: {\b QCPCurve} \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A bar chart: {\b QCPBars} \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A statistical box plot: {\b QCPStatisticalBox} \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A color encoded two-dimensional map: {\b QCPColorMap} \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
An OHLC/Candlestick chart: {\b QCPFinancial}\par
}
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Creating own plottables
\par}
{\tc\tcl2 \v Creating own plottables}
Subclassing directly from {\b QCPAbstractPlottable} is only recommended if you wish to display two-dimensional data like {\b QCPColorMap}, i.e. two logical key dimensions and one (or more) data dimensions. If you want to display data with only one logical key dimension, you should rather derive from {\b QCPAbstractPlottable1D}.\par
If subclassing {\b QCPAbstractPlottable} directly, these are the pure virtual functions you must implement: {
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b selectTest} \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b draw} \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b drawLegendIcon} \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b getKeyRange} \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b getValueRange}\par
}
See the documentation of those functions for what they need to do.\par
For drawing your plot, you can use the {\b coordsToPixels} functions to translate a point in plot coordinates to pixel coordinates. This function is quite convenient, because it takes the orientation of the key and value axes into account for you (x and y are swapped when the key axis is vertical and the value axis horizontal). If you are worried about performance (i.e. you need to translate many points in a loop like {\b QCPGraph}), you can directly use {\b QCPAxis::coordToPixel}. However, you must then take care about the orientation of the axis yourself.\par
Here are some important members you inherit from {\b QCPAbstractPlottable}: \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCustomPlot} *{\b mParentPlot}   \cell }{A pointer to the parent {\b QCustomPlot} instance. The parent plot is inferred from the axes that are passed in the constructor. \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{QString {\b mName}   \cell }{The name of the plottable. \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{QPen {\b mPen}   \cell }{The generic pen of the plottable. You should use this pen for the most prominent data representing lines in the plottable (e.g {\b QCPGraph} uses this pen for its graph lines and scatters) \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{QBrush {\b mBrush}   \cell }{The generic brush of the plottable. You should use this brush for the most prominent fillable structures in the plottable (e.g. {\b QCPGraph} uses this brush to control filling under the graph) \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{QPointer<{\b QCPAxis}> {\b mKeyAxis} , {\b mValueAxis}   \cell }{The key and value axes this plottable is attached to. Call their {\b QCPAxis::coordToPixel} functions to translate coordinates to pixels in either the key or value dimension. Make sure to check whether the pointer is null before using it. If one of the axes is null, don't draw the plottable. \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPSelectionDecorator} {\b mSelectionDecorator}   \cell }{The currently set selection decorator which specifies how selected data of the plottable shall be drawn and decorated. When drawing your data, you must consult this decorator for the appropriate pen/brush before drawing unselected/selected data segments. Finally, you should call its {\b QCPSelectionDecorator::drawDecoration} method at the end of your {\b draw} implementation. \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCP::SelectionType} {\b mSelectable}   \cell }{In which composition, if at all, this plottable's data may be selected. Enforcing this setting on the data selection is done by {\b QCPAbstractPlottable} automatically. \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPDataSelection} {\b mSelection}   \cell }{Holds the current selection state of the plottable's data, i.e. the selected data ranges ({\b QCPDataRange}).  \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAbstractPlottable\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:QCPAbstractPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAbstractPlottable::QCPAbstractPlottable ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis})}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an abstract plottable which uses {\i keyAxis}  as its key axis ("x") and {\i valueAxis}  as its value axis ("y"). {\i keyAxis}  and {\i valueAxis}  must reside in the same {\b QCustomPlot} instance and have perpendicular orientations. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.\par
Since {\b QCPAbstractPlottable} is an abstract class that defines the basic interface to plottables, it can't be directly instantiated.\par
You probably want one of the subclasses like {\b QCPGraph} or {\b QCPCurve} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10690                                                                                :\par
10691   QCPLayerable(keyAxis->parentPlot(), QString(), keyAxis->axisRect()),\par
10692   mName(),\par
10693   mAntialiasedFill(true),\par
10694   mAntialiasedScatters(true),\par
10695   mPen(Qt::black),\par
10696   mBrush(Qt::NoBrush),\par
10697   mKeyAxis(keyAxis),\par
10698   mValueAxis(valueAxis),\par
10699   mSelectable(QCP::stWhole),\par
10700   mSelectionDecorator(0)\par
10701 \{\par
10702   if (keyAxis->parentPlot() != valueAxis->parentPlot())\par
10703     qDebug() << Q_FUNC_INFO << "Parent plot of keyAxis is not the same as that of valueAxis.";\par
10704   if (keyAxis->orientation() == valueAxis->orientation())\par
10705     qDebug() << Q_FUNC_INFO << "keyAxis and valueAxis must be orthogonal to each other.";\par
10706   \par
10707   mParentPlot->registerPlottable(this);\par
10708   setSelectionDecorator(new QCPSelectionDecorator);\par
10709 \}\par
}
}
{\xe \v ~QCPAbstractPlottable\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:~QCPAbstractPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAbstractPlottable::~QCPAbstractPlottable (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10712 \{\par
10713   if (mSelectionDecorator)\par
10714   \{\par
10715     delete mSelectionDecorator;\par
10716     mSelectionDecorator = 0;\par
10717   \}\par
10718 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addToLegend\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:addToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::addToLegend ({\b QCPLegend} *  {\i legend})}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds this plottable to the specified {\i legend} .\par
Creates a {\b QCPPlottableLegendItem} which is inserted into the legend. Returns true on success, i.e. when the legend exists and a legend item associated with this plottable isn't already in the legend.\par
If the plottable needs a more specialized representation in the legend, you can create a corresponding subclass of {\b QCPPlottableLegendItem} and add it to the legend manually instead of calling this method.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeFromLegend}, {\b QCPLegend::addItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11084 \{\par
11085   if (!legend)\par
11086   \{\par
11087     qDebug() << Q_FUNC_INFO << "passed legend is null";\par
11088     return false;\par
11089   \}\par
11090   if (legend->parentPlot() != mParentPlot)\par
11091   \{\par
11092     qDebug() << Q_FUNC_INFO << "passed legend isn't in the same QCustomPlot as this plottable";\par
11093     return false;\par
11094   \}\par
11095   \par
11096   if (!legend->hasItemWithPlottable(this))\par
11097   \{\par
11098     legend->addItem(new QCPPlottableLegendItem(legend, this));\par
11099     return true;\par
11100   \} else\par
11101     return false;\par
11102 \}\par
}
}
{\xe \v addToLegend\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:addToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::addToLegend ()}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds this plottable to the legend of the parent {\b QCustomPlot} ({\b QCustomPlot::legend}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeFromLegend} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11111 \{\par
11112   if (!mParentPlot || !mParentPlot->legend)\par
11113     return false;\par
11114   else\par
11115     return addToLegend(mParentPlot->legend);\par
11116 \}\par
}
}
{\xe \v antialiasedFill\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:antialiasedFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::antialiasedFill () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3308 \{ return mAntialiasedFill; \}\par
}
}
{\xe \v antialiasedScatters\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:antialiasedScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::antialiasedScatters () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3309 \{ return mAntialiasedScatters; \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11187 \{\par
11188   applyAntialiasingHint(painter, mAntialiased, QCP::aePlottables);\par
11189 \}\par
}
}
{\xe \v applyFillAntialiasingHint\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:applyFillAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::applyFillAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11203 \{\par
11204   applyAntialiasingHint(painter, mAntialiasedFill, QCP::aeFills);\par
11205 \}\par
}
}
{\xe \v applyScattersAntialiasingHint\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:applyScattersAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::applyScattersAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11219 \{\par
11220   applyAntialiasingHint(painter, mAntialiasedScatters, QCP::aeScatters);\par
11221 \}\par
}
}
{\xe \v brush\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAbstractPlottable::brush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3311 \{ return mBrush; \}\par
}
}
{\xe \v clipRect\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:clipRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAbstractPlottable::clipRect () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11158 \{\par
11159   if (mKeyAxis && mValueAxis)\par
11160     return mKeyAxis.data()->axisRect()->rect() & mValueAxis.data()->axisRect()->rect();\par
11161   else\par
11162     return QRect();\par
11163 \}\par
}
}
{\xe \v coordsToPixels\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:coordsToPixels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::coordsToPixels (double  {\i key}, double  {\i value}, double &  {\i x}, double &  {\i y}) const}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function for transforming a key/value pair to pixels on the {\b QCustomPlot} surface, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).\par
{\i key}  and {\i value}  are transformed to the coodinates in pixels and are written to {\i x}  and {\i y} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b pixelsToCoords}, {\b QCPAxis::coordToPixel} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10903 \{\par
10904   QCPAxis *keyAxis = mKeyAxis.data();\par
10905   QCPAxis *valueAxis = mValueAxis.data();\par
10906   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
10907   \par
10908   if (keyAxis->orientation() == Qt::Horizontal)\par
10909   \{\par
10910     x = keyAxis->coordToPixel(key);\par
10911     y = valueAxis->coordToPixel(value);\par
10912   \} else\par
10913   \{\par
10914     y = keyAxis->coordToPixel(key);\par
10915     x = valueAxis->coordToPixel(value);\par
10916   \}\par
10917 \}\par
}
}
{\xe \v coordsToPixels\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:coordsToPixels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QPointF QCPAbstractPlottable::coordsToPixels (double  {\i key}, double  {\i value}) const}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Transforms the given {\i key}  and {\i value}  to pixel coordinates and returns them in a QPointF. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10924 \{\par
10925   QCPAxis *keyAxis = mKeyAxis.data();\par
10926   QCPAxis *valueAxis = mValueAxis.data();\par
10927   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); \}\par
10928   \par
10929   if (keyAxis->orientation() == Qt::Horizontal)\par
10930     return QPointF(keyAxis->coordToPixel(key), valueAxis->coordToPixel(value));\par
10931   else\par
10932     return QPointF(valueAxis->coordToPixel(value), keyAxis->coordToPixel(key));\par
10933 \}\par
}
}
{\xe \v deselectEvent\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11256 \{\par
11257   if (mSelectable != QCP::stNone)\par
11258   \{\par
11259     QCPDataSelection selectionBefore = mSelection;\par
11260     setSelection(QCPDataSelection());\par
11261     if (selectionStateChanged)\par
11262       *selectionStateChanged = mSelection != selectionBefore;\par
11263   \}\par
11264 \}\par
}
}
{\xe \v draw\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void QCPAbstractPlottable::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v drawLegendIcon\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getKeyRange\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPAbstractPlottable::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIY \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getValueRange\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPAbstractPlottable::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v interface1D\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:interface1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPPlottableInterface1D} * QCPAbstractPlottable::interface1D (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this plottable is a one-dimensional plottable, i.e. it implements the {\b QCPPlottableInterface1D}, returns the {\i this}  pointer with that type. Otherwise (e.g. in the case of a {\b QCPColorMap}) returns zero.\par
You can use this method to gain read access to data coordinates while holding a pointer to the abstract base class only. \par
}{
Reimplemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3333 \{ return 0; \}\par
}
}
{\xe \v keyAxis\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:keyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis}* QCPAbstractPlottable::keyAxis () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3312 \{ return mKeyAxis.data(); \}\par
}
}
{\xe \v name\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAbstractPlottable::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3307 \{ return mName; \}\par
}
}
{\xe \v pen\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAbstractPlottable::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3310 \{ return mPen; \}\par
}
}
{\xe \v pixelsToCoords\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:pixelsToCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::pixelsToCoords (double  {\i x}, double  {\i y}, double &  {\i key}, double &  {\i value}) const}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function for transforming a x/y pixel pair on the {\b QCustomPlot} surface to plot coordinates, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).\par
{\i x}  and {\i y}  are transformed to the plot coodinates and are written to {\i key}  and {\i value} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b coordsToPixels}, {\b QCPAxis::coordToPixel} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10945 \{\par
10946   QCPAxis *keyAxis = mKeyAxis.data();\par
10947   QCPAxis *valueAxis = mValueAxis.data();\par
10948   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
10949   \par
10950   if (keyAxis->orientation() == Qt::Horizontal)\par
10951   \{\par
10952     key = keyAxis->pixelToCoord(x);\par
10953     value = valueAxis->pixelToCoord(y);\par
10954   \} else\par
10955   \{\par
10956     key = keyAxis->pixelToCoord(y);\par
10957     value = valueAxis->pixelToCoord(x);\par
10958   \}\par
10959 \}\par
}
}
{\xe \v pixelsToCoords\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:pixelsToCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::pixelsToCoords (const QPointF &  {\i pixelPos}, double &  {\i key}, double &  {\i value}) const}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns the pixel input {\i pixelPos}  as plot coordinates {\i key}  and {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10966 \{\par
10967   pixelsToCoords(pixelPos.x(), pixelPos.y(), key, value);\par
10968 \}\par
}
}
{\xe \v removeFromLegend\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:removeFromLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::removeFromLegend ({\b QCPLegend} *  {\i legend}) const}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Removes the plottable from the specifed {\i legend} . This means the {\b QCPPlottableLegendItem} that is associated with this plottable is removed.\par
Returns true on success, i.e. if the legend exists and a legend item associated with this plottable was found and removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addToLegend}, {\b QCPLegend::removeItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11129 \{\par
11130   if (!legend)\par
11131   \{\par
11132     qDebug() << Q_FUNC_INFO << "passed legend is null";\par
11133     return false;\par
11134   \}\par
11135   \par
11136   if (QCPPlottableLegendItem *lip = legend->itemWithPlottable(this))\par
11137     return legend->removeItem(lip);\par
11138   else\par
11139     return false;\par
11140 \}\par
}
}
{\xe \v removeFromLegend\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:removeFromLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::removeFromLegend () const}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Removes the plottable from the legend of the parent {\b QCustomPlot}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addToLegend} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11149 \{\par
11150   if (!mParentPlot || !mParentPlot->legend)\par
11151     return false;\par
11152   else\par
11153     return removeFromLegend(mParentPlot->legend);\par
11154 \}\par
}
}
{\xe \v rescaleAxes\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:rescaleAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::rescaleAxes (bool  {\i onlyEnlarge} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i.e. a range containing different signs and/or zero. Instead it will stay in the current sign domain and ignore all parts of the plottable that lie outside of that domain.\par
{\i onlyEnlarge}  makes sure the ranges are only expanded, never reduced. So it's possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has {\i onlyEnlarge}  set to false (the default), and all subsequent set to true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleKeyAxis}, {\b rescaleValueAxis}, {\b QCustomPlot::rescaleAxes}, {\b QCPAxis::rescale} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10984 \{\par
10985   rescaleKeyAxis(onlyEnlarge);\par
10986   rescaleValueAxis(onlyEnlarge);\par
10987 \}\par
}
}
{\xe \v rescaleKeyAxis\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:rescaleKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::rescaleKeyAxis (bool  {\i onlyEnlarge} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the key axis of the plottable so the whole plottable is visible.\par
See {\b rescaleAxes} for detailed behaviour. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10995 \{\par
10996   QCPAxis *keyAxis = mKeyAxis.data();\par
10997   if (!keyAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key axis"; return; \}\par
10998   \par
10999   QCP::SignDomain signDomain = QCP::sdBoth;\par
11000   if (keyAxis->scaleType() == QCPAxis::stLogarithmic)\par
11001     signDomain = (keyAxis->range().upper < 0 ? QCP::sdNegative : QCP::sdPositive);\par
11002   \par
11003   bool foundRange;\par
11004   QCPRange newRange = getKeyRange(foundRange, signDomain);\par
11005   if (foundRange)\par
11006   \{\par
11007     if (onlyEnlarge)\par
11008       newRange.expand(keyAxis->range());\par
11009     if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable\par
11010     \{\par
11011       double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason\par
11012       if (keyAxis->scaleType() == QCPAxis::stLinear)\par
11013       \{\par
11014         newRange.lower = center-keyAxis->range().size()/2.0;\par
11015         newRange.upper = center+keyAxis->range().size()/2.0;\par
11016       \} else // scaleType() == stLogarithmic\par
11017       \{\par
11018         newRange.lower = center/qSqrt(keyAxis->range().upper/keyAxis->range().lower);\par
11019         newRange.upper = center*qSqrt(keyAxis->range().upper/keyAxis->range().lower);\par
11020       \}\par
11021     \}\par
11022     keyAxis->setRange(newRange);\par
11023   \}\par
11024 \}\par
}
}
{\xe \v rescaleValueAxis\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:rescaleValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::rescaleValueAxis (bool  {\i onlyEnlarge} = {\f2 false}, bool  {\i inKeyRange} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the value axis of the plottable so the whole plottable is visible. If {\i inKeyRange}  is set to true, only the data points which are in the currently visible key axis range are considered.\par
Returns true if the axis was actually scaled. This might not be the case if this plottable has an invalid range, e.g. because it has no data points.\par
See {\b rescaleAxes} for detailed behaviour. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11037 \{\par
11038   QCPAxis *keyAxis = mKeyAxis.data();\par
11039   QCPAxis *valueAxis = mValueAxis.data();\par
11040   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
11041   \par
11042   QCP::SignDomain signDomain = QCP::sdBoth;\par
11043   if (valueAxis->scaleType() == QCPAxis::stLogarithmic)\par
11044     signDomain = (valueAxis->range().upper < 0 ? QCP::sdNegative : QCP::sdPositive);\par
11045   \par
11046   bool foundRange;\par
11047   QCPRange newRange = getValueRange(foundRange, signDomain, inKeyRange ? keyAxis->range() : QCPRange());\par
11048   if (foundRange)\par
11049   \{\par
11050     if (onlyEnlarge)\par
11051       newRange.expand(valueAxis->range());\par
11052     if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable\par
11053     \{\par
11054       double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason\par
11055       if (valueAxis->scaleType() == QCPAxis::stLinear)\par
11056       \{\par
11057         newRange.lower = center-valueAxis->range().size()/2.0;\par
11058         newRange.upper = center+valueAxis->range().size()/2.0;\par
11059       \} else // scaleType() == stLogarithmic\par
11060       \{\par
11061         newRange.lower = center/qSqrt(valueAxis->range().upper/valueAxis->range().lower);\par
11062         newRange.upper = center*qSqrt(valueAxis->range().upper/valueAxis->range().lower);\par
11063       \}\par
11064     \}\par
11065     valueAxis->setRange(newRange);\par
11066   \}\par
11067 \}\par
}
}
{\xe \v selectable\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionType} QCPAbstractPlottable::selectable () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3314 \{ return mSelectable; \}\par
}
}
{\xe \v selectableChanged\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectableChanged ({\b QCP::SelectionType}  {\i selectable}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selectability of this plottable has changed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectable} \par
}}}
{\xe \v selected\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::selected () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if there are any data points of the plottable currently selected. Use {\b selection} to retrieve the current {\b QCPDataSelection}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3315 \{ return !mSelection.isEmpty(); \}\par
}
}
{\xe \v selectEvent\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11225 \{\par
11226   Q_UNUSED(event)\par
11227   \par
11228   if (mSelectable != QCP::stNone)\par
11229   \{\par
11230     QCPDataSelection newSelection = details.value<QCPDataSelection>();\par
11231     QCPDataSelection selectionBefore = mSelection;\par
11232     if (additive)\par
11233     \{\par
11234       if (mSelectable == QCP::stWhole) // in whole selection mode, we toggle to no selection even if currently unselected point was hit\par
11235       \{\par
11236         if (selected())\par
11237           setSelection(QCPDataSelection());\par
11238         else\par
11239           setSelection(newSelection);\par
11240       \} else // in all other selection modes we toggle selections of homogeneously selected/unselected segments\par
11241       \{\par
11242         if (mSelection.contains(newSelection)) // if entire newSelection is already selected, toggle selection\par
11243           setSelection(mSelection-newSelection);\par
11244         else\par
11245           setSelection(mSelection+newSelection);\par
11246       \}\par
11247     \} else\par
11248       setSelection(newSelection);\par
11249     if (selectionStateChanged)\par
11250       *selectionStateChanged = mSelection != selectionBefore;\par
11251   \}\par
11252 \}\par
}
}
{\xe \v selection\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPAbstractPlottable::selection () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPDataSelection} encompassing all the data points that are currently selected on this plottable.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selected}, {\b setSelection}, {\b setSelectable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3316 \{ return mSelection; \}\par
}
}
{\xe \v selectionCategory\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPAbstractPlottable::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11167 \{\par
11168   return QCP::iSelectPlottables;\par
11169 \}\par
}
}
{\xe \v selectionChanged\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectionChanged (bool  {\i selected}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to {\b setSelection}. The parameter {\i selected}  indicates whether there are any points selected or not.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectionChanged(const QCPDataSelection &selection)} \par
}}}
{\xe \v selectionChanged\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectionChanged (const {\b QCPDataSelection} &  {\i selection}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to {\b setSelection}. The parameter {\i selection}  holds the currently selected data ranges.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectionChanged(bool selected)} \par
}}}
{\xe \v selectionDecorator\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionDecorator} * QCPAbstractPlottable::selectionDecorator () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides access to the selection decorator of this plottable. The selection decorator controls how selected data ranges are drawn (e.g. their pen color and fill), see {\b QCPSelectionDecorator} for details.\par
If you wish to use an own {\b QCPSelectionDecorator} subclass, pass an instance of it to {\b setSelectionDecorator}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3317 \{ return mSelectionDecorator; \}\par
}
}
{\xe \v selectTest\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual double QCPAbstractPlottable::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v setAntialiasedFill\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setAntialiasedFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setAntialiasedFill (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether fills of this plottable are drawn antialiased or not.\par
Note that this setting may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10736 \{\par
10737   mAntialiasedFill = enabled;\par
10738 \}\par
}
}
{\xe \v setAntialiasedScatters\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setAntialiasedScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setAntialiasedScatters (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the scatter symbols of this plottable are drawn antialiased or not.\par
Note that this setting may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10747 \{\par
10748   mAntialiasedScatters = enabled;\par
10749 \}\par
}
}
{\xe \v setBrush\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.\par
For example, the {\b QCPGraph} subclass draws the fill under the graph with this brush, when it's not set to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10774 \{\par
10775   mBrush = brush;\par
10776 \}\par
}
}
{\xe \v setKeyAxis\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setKeyAxis ({\b QCPAxis} *  {\i axis})}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The key axis of a plottable can be set to any axis of a {\b QCustomPlot}, as long as it is orthogonal to the plottable's value axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ({\b QCustomPlot::xAxis}) as key axis and the y-axis ({\b QCustomPlot::yAxis}) as value axis.\par
Normally, the key and value axes are set in the constructor of the plottable (or {\b QCustomPlot::addGraph} when working with QCPGraphs through the dedicated graph interface).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setValueAxis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10790 \{\par
10791   mKeyAxis = axis;\par
10792 \}\par
}
}
{\xe \v setName\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setName (const QString &  {\i name})}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The name is the textual representation of this plottable as it is displayed in the legend ({\b QCPLegend}). It may contain any UTF-8 characters, including newlines. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10725 \{\par
10726   mName = name;\par
10727 \}\par
}
}
{\xe \v setPen\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The pen is used to draw basic lines that make up the plottable representation in the plot.\par
For example, the {\b QCPGraph} subclass draws its graph lines with this pen.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10760 \{\par
10761   mPen = pen;\par
10762 \}\par
}
}
{\xe \v setSelectable\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setSelectable ({\b QCP::SelectionType}  {\i selectable})}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether and to which granularity this plottable can be selected.\par
A selection can happen by clicking on the {\b QCustomPlot} surface (When {\b QCustomPlot::setInteractions} contains {\b QCP::iSelectPlottables}), by dragging a selection rect (When {\b QCustomPlot::setSelectionRectMode} is {\b QCP::srmSelect}), or programmatically by calling {\b setSelection}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelection}, {\b QCP::SelectionType} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10877 \{\par
10878   if (mSelectable != selectable)\par
10879   \{\par
10880     mSelectable = selectable;\par
10881     QCPDataSelection oldSelection = mSelection;\par
10882     mSelection.enforceType(mSelectable);\par
10883     emit selectableChanged(mSelectable);\par
10884     if (mSelection != oldSelection)\par
10885     \{\par
10886       emit selectionChanged(selected());\par
10887       emit selectionChanged(mSelection);\par
10888     \}\par
10889   \}\par
10890 \}\par
}
}
{\xe \v setSelection\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setSelection ({\b QCPDataSelection}  {\i selection})}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which data ranges of this plottable are selected. Selected data ranges are drawn differently (e.g. color) in the plot. This can be controlled via the selection decorator (see {\b selectionDecorator}).\par
The entire selection mechanism for plottables is handled automatically when {\b QCustomPlot::setInteractions} contains iSelectPlottables. You only need to call this function when you wish to change the selection state programmatically.\par
Using {\b setSelectable} you can further specify for each plottable whether and to which granularity it is selectable. If {\i selection}  is not compatible with the current {\b QCP::SelectionType} set via {\b setSelectable}, the resulting selection will be adjusted accordingly (see {\b QCPDataSelection::enforceType}).\par
emits the {\b selectionChanged} signal when {\i selected}  is different from the previous selection state.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectable}, {\b selectTest} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10830 \{\par
10831   selection.enforceType(mSelectable);\par
10832   if (mSelection != selection)\par
10833   \{\par
10834     mSelection = selection;\par
10835     emit selectionChanged(selected());\par
10836     emit selectionChanged(mSelection);\par
10837   \}\par
10838 \}\par
}
}
{\xe \v setSelectionDecorator\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setSelectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setSelectionDecorator ({\b QCPSelectionDecorator} *  {\i decorator})}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use this method to set an own {\b QCPSelectionDecorator} (subclass) instance. This allows you to customize the visual representation of selected data ranges further than by using the default {\b QCPSelectionDecorator}.\par
The plottable takes ownership of the {\i decorator} .\par
The currently set decorator can be accessed via {\b selectionDecorator}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10850 \{\par
10851   if (decorator)\par
10852   \{\par
10853     if (decorator->registerWithPlottable(this))\par
10854     \{\par
10855       if (mSelectionDecorator) // delete old decorator if necessary\par
10856         delete mSelectionDecorator;\par
10857       mSelectionDecorator = decorator;\par
10858     \}\par
10859   \} else if (mSelectionDecorator) // just clear decorator\par
10860   \{\par
10861     delete mSelectionDecorator;\par
10862     mSelectionDecorator = 0;\par
10863   \}\par
10864 \}\par
}
}
{\xe \v setValueAxis\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:setValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setValueAxis ({\b QCPAxis} *  {\i axis})}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The value axis of a plottable can be set to any axis of a {\b QCustomPlot}, as long as it is orthogonal to the plottable's key axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ({\b QCustomPlot::xAxis}) as key axis and the y-axis ({\b QCustomPlot::yAxis}) as value axis.\par
Normally, the key and value axes are set in the constructor of the plottable (or {\b QCustomPlot::addGraph} when working with QCPGraphs through the dedicated graph interface).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setKeyAxis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10806 \{\par
10807   mValueAxis = axis;\par
10808 \}\par
}
}
{\xe \v valueAxis\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:valueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis}* QCPAbstractPlottable::valueAxis () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3313 \{ return mValueAxis.data(); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPAxis\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:QCPAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAxis}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPPlottableLegendItem\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:QCPPlottableLegendItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPPlottableLegendItem}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAntialiasedFill\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mAntialiasedFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::mAntialiasedFill{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAntialiasedScatters\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mAntialiasedScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::mAntialiasedScatters{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBrush\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAbstractPlottable::mBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mKeyAxis\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxis}> QCPAbstractPlottable::mKeyAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mName\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAbstractPlottable::mName{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAbstractPlottable::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectable\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionType} QCPAbstractPlottable::mSelectable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelection\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPAbstractPlottable::mSelection{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectionDecorator\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mSelectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionDecorator}* QCPAbstractPlottable::mSelectionDecorator{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mValueAxis\:QCPAbstractPlottable}
{\xe \v QCPAbstractPlottable\:mValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxis}> QCPAbstractPlottable::mValueAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAbstractPlottable1D< DataType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v QCPAbstractPlottable1D< DataType >}
{\xe \v QCPAbstractPlottable1D< DataType >}
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A template base class for plottables with one-dimensional data. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAbstractPlottable1D< DataType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_plottable1_d__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAbstractPlottable1D< DataType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_abstract_plottable1_d__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable1D} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAbstractPlottable1D} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b dataCount} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainKey} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataSortKey} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainValue} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b dataValueRange} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b dataPixelPosition} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b sortKeyIsMainKey} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPDataSelection} {\b selectTestRect} (const QRectF &rect, bool onlySelectable) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findBegin} (double sortKey, bool expandedRange=true) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findEnd} (double sortKey, bool expandedRange=true) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPPlottableInterface1D} * {\b interface1D} () {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getDataSegments} (QList< {\b QCPDataRange} > &selectedSegments, QList< {\b QCPDataRange} > &unselectedSegments) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawPolyline} ({\b QCPPainter} *painter, const QVector< QPointF > &lineData) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPDataContainer}< DataType > > {\b mDataContainer}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class DataType>\par
class QCPAbstractPlottable1D< DataType >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A template base class for plottables with one-dimensional data. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This template class derives from {\b QCPAbstractPlottable} and from the abstract interface {\b QCPPlottableInterface1D}. It serves as a base class for all one-dimensional data (i.e. data with one key dimension), such as {\b QCPGraph} and {\b QCPCurve}.\par
The template parameter {\i DataType}  is the type of the data points of this plottable (e.g. {\b QCPGraphData} or {\b QCPCurveData}). The main purpose of this base class is to provide the member {\i mDataContainer}  (a shared pointer to a {\b QCPDataContainer<DataType>}) and implement the according virtual methods of the {\b QCPPlottableInterface1D}, such that most subclassed plottables don't need to worry about this anymore.\par
Further, it provides a convenience method for retrieving selected/unselected data segments via {\b getDataSegments}. This is useful when subclasses implement their {\b draw} method and need to draw selected segments with a different pen/brush than unselected segments (also see {\b QCPSelectionDecorator}).\par
This class implements basic functionality of {\b QCPAbstractPlottable::selectTest} and {\b QCPPlottableInterface1D::selectTestRect}, assuming point-like data points, based on the 1D data interface. In spite of that, most plottable subclasses will want to reimplement those methods again, to provide a more accurate hit test based on their specific data visualization geometry. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAbstractPlottable1D\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:QCPAbstractPlottable1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPAbstractPlottable1D}< DataType >::{\b QCPAbstractPlottable1D} ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis})}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Forwards {\i keyAxis}  and {\i valueAxis}  to the {\b QCPAbstractPlottable} constructor and allocates the {\i mDataContainer} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4096                                                                                              :\par
 4097   QCPAbstractPlottable(keyAxis, valueAxis),\par
 4098   mDataContainer(new QCPDataContainer<DataType>)\par
 4099 \{\par
 4100 \}\par
}
}
{\xe \v ~QCPAbstractPlottable1D\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:~QCPAbstractPlottable1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPAbstractPlottable1D}< DataType >::~{\b QCPAbstractPlottable1D} (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4104 \{\par
 4105 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dataCount\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > int {\b QCPAbstractPlottable1D}< DataType >::dataCount () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data points of the plottable. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4112 \{\par
 4113   return mDataContainer->size();\par
 4114 \}\par
}
}
{\xe \v dataMainKey\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > double {\b QCPAbstractPlottable1D}< DataType >::dataMainKey (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main key of the data point at the given {\i index} .\par
What the main key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4121 \{\par
 4122   if (index >= 0 && index < mDataContainer->size())\par
 4123   \{\par
 4124     return (mDataContainer->constBegin()+index)->mainKey();\par
 4125   \} else\par
 4126   \{\par
 4127     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4128     return 0;\par
 4129   \}\par
 4130 \}\par
}
}
{\xe \v dataMainValue\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataMainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > double {\b QCPAbstractPlottable1D}< DataType >::dataMainValue (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main value of the data point at the given {\i index} .\par
What the main value is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4153 \{\par
 4154   if (index >= 0 && index < mDataContainer->size())\par
 4155   \{\par
 4156     return (mDataContainer->constBegin()+index)->mainValue();\par
 4157   \} else\par
 4158   \{\par
 4159     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4160     return 0;\par
 4161   \}\par
 4162 \}\par
}
}
{\xe \v dataPixelPosition\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > QPointF {\b QCPAbstractPlottable1D}< DataType >::dataPixelPosition (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position on the widget surface at which the data point at the given {\i index}  appears.\par
Usually this corresponds to the point of {\b dataMainKey}/{\b dataMainValue}, in pixel coordinates. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values. For example, {\b QCPBars} apparent data values can be shifted depending on their stacking, bar grouping or configured base value. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4185 \{\par
 4186   if (index >= 0 && index < mDataContainer->size())\par
 4187   \{\par
 4188     const typename QCPDataContainer<DataType>::const_iterator it = mDataContainer->constBegin()+index;\par
 4189     return coordsToPixels(it->mainKey(), it->mainValue());\par
 4190   \} else\par
 4191   \{\par
 4192     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4193     return QPointF();\par
 4194   \}\par
 4195 \}\par
}
}
{\xe \v dataSortKey\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > double {\b QCPAbstractPlottable1D}< DataType >::dataSortKey (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the sort key of the data point at the given {\i index} .\par
What the sort key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4137 \{\par
 4138   if (index >= 0 && index < mDataContainer->size())\par
 4139   \{\par
 4140     return (mDataContainer->constBegin()+index)->sortKey();\par
 4141   \} else\par
 4142   \{\par
 4143     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4144     return 0;\par
 4145   \}\par
 4146 \}\par
}
}
{\xe \v dataValueRange\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPRange} {\b QCPAbstractPlottable1D}< DataType >::dataValueRange (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the value range of the data point at the given {\i index} .\par
What the value range is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4169 \{\par
 4170   if (index >= 0 && index < mDataContainer->size())\par
 4171   \{\par
 4172     return (mDataContainer->constBegin()+index)->valueRange();\par
 4173   \} else\par
 4174   \{\par
 4175     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4176     return QCPRange(0, 0);\par
 4177   \}\par
 4178 \}\par
}
}
{\xe \v drawPolyline\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:drawPolyline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPAbstractPlottable1D}< DataType >::drawPolyline ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i lineData}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A helper method which draws a line with the passed {\i painter} , according to the pixel data in {\i lineData} . NaN points create gaps in the line, as expected from {\b QCustomPlot}'s plottables (this is the main difference to QPainter's regular drawPolyline, which handles NaNs by lagging or crashing).\par
Further it uses a faster line drawing technique based on {\b QCPPainter::drawLine} rather than {\f2 QPainter::drawPolyline}  if the configured {\b QCustomPlot::setPlottingHints()} and {\i painter}  style allows. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4378 \{\par
 4379   // if drawing solid line and not in PDF, use much faster line drawing instead of polyline:\par
 4380   if (mParentPlot->plottingHints().testFlag(QCP::phFastPolylines) &&\par
 4381       painter->pen().style() == Qt::SolidLine &&\par
 4382       !painter->modes().testFlag(QCPPainter::pmVectorized) &&\par
 4383       !painter->modes().testFlag(QCPPainter::pmNoCaching))\par
 4384   \{\par
 4385     int i = 0;\par
 4386     bool lastIsNan = false;\par
 4387     const int lineDataSize = lineData.size();\par
 4388     while (i < lineDataSize && (qIsNaN(lineData.at(i).y()) || qIsNaN(lineData.at(i).x()))) // make sure first point is not NaN\par
 4389       ++i;\par
 4390     ++i; // because drawing works in 1 point retrospect\par
 4391     while (i < lineDataSize)\par
 4392     \{\par
 4393       if (!qIsNaN(lineData.at(i).y()) && !qIsNaN(lineData.at(i).x())) // NaNs create a gap in the line\par
 4394       \{\par
 4395         if (!lastIsNan)\par
 4396           painter->drawLine(lineData.at(i-1), lineData.at(i));\par
 4397         else\par
 4398           lastIsNan = false;\par
 4399       \} else\par
 4400         lastIsNan = true;\par
 4401       ++i;\par
 4402     \}\par
 4403   \} else\par
 4404   \{\par
 4405     int segmentStart = 0;\par
 4406     int i = 0;\par
 4407     const int lineDataSize = lineData.size();\par
 4408     while (i < lineDataSize)\par
 4409     \{\par
 4410       if (qIsNaN(lineData.at(i).y()) || qIsNaN(lineData.at(i).x()) || qIsInf(lineData.at(i).y())) // NaNs create a gap in the line. Also filter Infs which make drawPolyline block\par
 4411       \{\par
 4412         painter->drawPolyline(lineData.constData()+segmentStart, i-segmentStart); // i, because we don't want to include the current NaN point\par
 4413         segmentStart = i+1;\par
 4414       \}\par
 4415       ++i;\par
 4416     \}\par
 4417     // draw last segment:\par
 4418     painter->drawPolyline(lineData.constData()+segmentStart, lineDataSize-segmentStart);\par
 4419   \}\par
 4420 \}\par
}
}
{\xe \v findBegin\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:findBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > int {\b QCPAbstractPlottable1D}< DataType >::findBegin (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index of the data point with a (sort-)key that is equal to, just below, or just above {\i sortKey} . If {\i expandedRange}  is true, the data point just below {\i sortKey}  will be considered, otherwise the one just above.\par
This can be used in conjunction with {\b findEnd} to iterate over data points within a given key range, including or excluding the bounding data points that are just beyond the specified range.\par
If {\i expandedRange}  is true but there are no data points below {\i sortKey} , 0 is returned.\par
If the container is empty, returns 0 (in that case, {\b findEnd} will also return 0, so a loop using these methods will not iterate over the index 0).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findEnd}, {\b QCPDataContainer::findBegin} \par
}}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4264 \{\par
 4265   return mDataContainer->findBegin(sortKey, expandedRange)-mDataContainer->constBegin();\par
 4266 \}\par
}
}
{\xe \v findEnd\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:findEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > int {\b QCPAbstractPlottable1D}< DataType >::findEnd (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index one after the data point with a (sort-)key that is equal to, just above, or just below {\i sortKey} . If {\i expandedRange}  is true, the data point just above {\i sortKey}  will be considered, otherwise the one just below.\par
This can be used in conjunction with {\b findBegin} to iterate over data points within a given key range, including the bounding data points that are just below and above the specified range.\par
If {\i expandedRange}  is true but there are no data points above {\i sortKey} , the index just above the highest data point is returned.\par
If the container is empty, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findBegin}, {\b QCPDataContainer::findEnd} \par
}}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4273 \{\par
 4274   return mDataContainer->findEnd(sortKey, expandedRange)-mDataContainer->constBegin();\par
 4275 \}\par
}
}
{\xe \v getDataSegments\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:getDataSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPAbstractPlottable1D}< DataType >::getDataSegments (QList< {\b QCPDataRange} > &  {\i selectedSegments}, QList< {\b QCPDataRange} > &  {\i unselectedSegments}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits all data into selected and unselected segments and outputs them via {\i selectedSegments}  and {\i unselectedSegments} , respectively.\par
This is useful when subclasses implement their {\b draw} method and need to draw selected segments with a different pen/brush than unselected segments (also see {\b QCPSelectionDecorator}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelection} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4348 \{\par
 4349   selectedSegments.clear();\par
 4350   unselectedSegments.clear();\par
 4351   if (mSelectable == QCP::stWhole) // stWhole selection type draws the entire plottable with selected style if mSelection isn't empty\par
 4352   \{\par
 4353     if (selected())\par
 4354       selectedSegments << QCPDataRange(0, dataCount());\par
 4355     else\par
 4356       unselectedSegments << QCPDataRange(0, dataCount());\par
 4357   \} else\par
 4358   \{\par
 4359     QCPDataSelection sel(selection());\par
 4360     sel.simplify();\par
 4361     selectedSegments = sel.dataRanges();\par
 4362     unselectedSegments = sel.inverse(QCPDataRange(0, dataCount())).dataRanges();\par
 4363   \}\par
 4364 \}\par
}
}
{\xe \v interface1D\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:interface1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPPlottableInterface1D} * {\b QCPAbstractPlottable1D}< DataType >::interface1D (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPPlottableInterface1D} pointer to this plottable, providing access to its 1D interface.\par
}{
Reimplemented from {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3890 \{ return this; \}\par
}
}
{\xe \v selectTest\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > double {\b QCPAbstractPlottable1D}< DataType >::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4286 \{\par
 4287   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
 4288     return -1;\par
 4289   if (!mKeyAxis || !mValueAxis)\par
 4290     return -1;\par
 4291   \par
 4292   QCPDataSelection selectionResult;\par
 4293   double minDistSqr = std::numeric_limits<double>::max();\par
 4294   int minDistIndex = mDataContainer->size();\par
 4295   \par
 4296   typename QCPDataContainer<DataType>::const_iterator begin = mDataContainer->constBegin();\par
 4297   typename QCPDataContainer<DataType>::const_iterator end = mDataContainer->constEnd();\par
 4298   if (DataType::sortKeyIsMainKey()) // we can assume that data is sorted by main key, so can reduce the searched key interval:\par
 4299   \{\par
 4300     // determine which key range comes into question, taking selection tolerance around pos into account:\par
 4301     double posKeyMin, posKeyMax, dummy;\par
 4302     pixelsToCoords(pos-QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMin, dummy);\par
 4303     pixelsToCoords(pos+QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMax, dummy);\par
 4304     if (posKeyMin > posKeyMax)\par
 4305       qSwap(posKeyMin, posKeyMax);\par
 4306     begin = mDataContainer->findBegin(posKeyMin, true);\par
 4307     end = mDataContainer->findEnd(posKeyMax, true);\par
 4308   \}\par
 4309   if (begin == end)\par
 4310     return -1;\par
 4311   QCPRange keyRange(mKeyAxis->range());\par
 4312   QCPRange valueRange(mValueAxis->range());\par
 4313   for (typename QCPDataContainer<DataType>::const_iterator it=begin; it!=end; ++it)\par
 4314   \{\par
 4315     const double mainKey = it->mainKey();\par
 4316     const double mainValue = it->mainValue();\par
 4317     if (keyRange.contains(mainKey) && valueRange.contains(mainValue)) // make sure data point is inside visible range, for speedup in cases where sort key isn't main key and we iterate over all points\par
 4318     \{\par
 4319       const double currentDistSqr = QCPVector2D(coordsToPixels(mainKey, mainValue)-pos).lengthSquared();\par
 4320       if (currentDistSqr < minDistSqr)\par
 4321       \{\par
 4322         minDistSqr = currentDistSqr;\par
 4323         minDistIndex = it-mDataContainer->constBegin();\par
 4324       \}\par
 4325     \}\par
 4326   \}\par
 4327   if (minDistIndex != mDataContainer->size())\par
 4328     selectionResult.addDataRange(QCPDataRange(minDistIndex, minDistIndex+1), false);\par
 4329   \par
 4330   selectionResult.simplify();\par
 4331   if (details)\par
 4332     details->setValue(selectionResult);\par
 4333   return qSqrt(minDistSqr);\par
 4334 \}\par
}
}
{\xe \v selectTestRect\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectTestRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPDataSelection} {\b QCPAbstractPlottable1D}< DataType >::selectTestRect (const QRectF &  {\i rect}, bool  {\i onlySelectable}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a rect-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAML \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4215 \{\par
 4216   QCPDataSelection result;\par
 4217   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
 4218     return result;\par
 4219   if (!mKeyAxis || !mValueAxis)\par
 4220     return result;\par
 4221   \par
 4222   // convert rect given in pixels to ranges given in plot coordinates:\par
 4223   double key1, value1, key2, value2;\par
 4224   pixelsToCoords(rect.topLeft(), key1, value1);\par
 4225   pixelsToCoords(rect.bottomRight(), key2, value2);\par
 4226   QCPRange keyRange(key1, key2); // QCPRange normalizes internally so we don't have to care about whether key1 < key2\par
 4227   QCPRange valueRange(value1, value2);\par
 4228   typename QCPDataContainer<DataType>::const_iterator begin = mDataContainer->constBegin();\par
 4229   typename QCPDataContainer<DataType>::const_iterator end = mDataContainer->constEnd();\par
 4230   if (DataType::sortKeyIsMainKey()) // we can assume that data is sorted by main key, so can reduce the searched key interval:\par
 4231   \{\par
 4232     begin = mDataContainer->findBegin(keyRange.lower, false);\par
 4233     end = mDataContainer->findEnd(keyRange.upper, false);\par
 4234   \}\par
 4235   if (begin == end)\par
 4236     return result;\par
 4237   \par
 4238   int currentSegmentBegin = -1; // -1 means we're currently not in a segment that's contained in rect\par
 4239   for (typename QCPDataContainer<DataType>::const_iterator it=begin; it!=end; ++it)\par
 4240   \{\par
 4241     if (currentSegmentBegin == -1)\par
 4242     \{\par
 4243       if (valueRange.contains(it->mainValue()) && keyRange.contains(it->mainKey())) // start segment\par
 4244         currentSegmentBegin = it-mDataContainer->constBegin();\par
 4245     \} else if (!valueRange.contains(it->mainValue()) || !keyRange.contains(it->mainKey())) // segment just ended\par
 4246     \{\par
 4247       result.addDataRange(QCPDataRange(currentSegmentBegin, it-mDataContainer->constBegin()), false);\par
 4248       currentSegmentBegin = -1;\par
 4249     \}\par
 4250   \}\par
 4251   // process potential last segment:\par
 4252   if (currentSegmentBegin != -1)\par
 4253     result.addDataRange(QCPDataRange(currentSegmentBegin, end-mDataContainer->constBegin()), false);\par
 4254   \par
 4255   result.simplify();\par
 4256   return result;\par
 4257 \}\par
}
}
{\xe \v sortKeyIsMainKey\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > bool {\b QCPAbstractPlottable1D}< DataType >::sortKeyIsMainKey () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the sort key ({\b dataSortKey}) is identical to the main key ({\b dataMainKey}).\par
What the sort and main keys are, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4202 \{\par
 4203   return DataType::sortKeyIsMainKey();\par
 4204 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mDataContainer\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> QSharedPointer<{\b QCPDataContainer}<DataType> > {\b QCPAbstractPlottable1D}< DataType >::mDataContainer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxis Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxis}
{\xe \v QCPAxis}
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a single axis inside a {\b QCustomPlot}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAxis:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAxis:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AxisType} \{ {\b atLeft} = 0x01, 
{\b atRight} = 0x02, 
{\b atTop} = 0x04, 
{\b atBottom} = 0x08
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LabelSide} \{ {\b lsInside}, 
{\b lsOutside}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ScaleType} \{ {\b stLinear}, 
{\b stLogarithmic}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SelectablePart} \{ {\b spNone} = 0, 
{\b spAxis} = 0x001, 
{\b spTickLabels} = 0x002, 
{\b spAxisLabel} = 0x004
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rangeChanged} (const {\b QCPRange} &newRange)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rangeChanged} (const {\b QCPRange} &newRange, const {\b QCPRange} &oldRange)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scaleTypeChanged} ({\b QCPAxis::ScaleType} {\b scaleType})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (const QCPAxis::SelectableParts &parts)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectableChanged} (const QCPAxis::SelectableParts &parts)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} ({\b QCPAxisRect} *parent, {\b AxisType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAxis} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AxisType} {\b axisType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b axisRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScaleType} {\b scaleType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b range} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rangeReversed} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPAxisTicker} > {\b ticker} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ticks} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b tickLabels} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickLabelPadding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b tickLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b tickLabelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b tickLabelRotation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelSide} {\b tickLabelSide} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b numberFormat} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numberPrecision} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< double > {\b tickVector} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QString > {\b tickVectorLabels} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickLengthIn} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickLengthOut} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b subTicks} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b subTickLengthIn} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b subTickLengthOut} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b basePen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b tickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b subTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b labelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b labelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b label} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b labelPadding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b padding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b offset} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b selectedParts} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b selectableParts} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b selectedTickLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b selectedLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b selectedTickLabelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b selectedLabelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedBasePen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedSubTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b lowerEnding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b upperEnding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGrid} * {\b grid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setScaleType} ({\b QCPAxis::ScaleType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setRange} (const {\b QCPRange} &{\b range})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRange} (double lower, double upper)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRange} (double position, double size, Qt::AlignmentFlag alignment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeLower} (double lower)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeUpper} (double upper)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeReversed} (bool reversed)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTicker} (QSharedPointer< {\b QCPAxisTicker} > {\b ticker})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTicks} (bool show)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabels} (bool show)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelPadding} (int {\b padding})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelFont} (const QFont &font)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelRotation} (double degrees)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelSide} ({\b LabelSide} side)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNumberFormat} (const QString &formatCode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNumberPrecision} (int precision)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLength} (int inside, int outside=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLengthIn} (int inside)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLengthOut} (int outside)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTicks} (bool show)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickLength} (int inside, int outside=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickLengthIn} (int inside)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickLengthOut} (int outside)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBasePen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLabelFont} (const QFont &font)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLabelColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLabel} (const QString &str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLabelPadding} (int {\b padding})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPadding} (int {\b padding})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOffset} (int {\b offset})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedTickLabelFont} (const QFont &font)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedLabelFont} (const QFont &font)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedTickLabelColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedLabelColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedBasePen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedTickPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedSubTickPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectableParts} (const QCPAxis::SelectableParts &{\b selectableParts})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectedParts} (const QCPAxis::SelectableParts &{\b selectedParts})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLowerEnding} (const {\b QCPLineEnding} &ending)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setUpperEnding} (const {\b QCPLineEnding} &ending)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientation {\b orientation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pixelOrientation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveRange} (double diff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scaleRange} (double factor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scaleRange} (double factor, double center)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScaleRatio} (const {\b QCPAxis} *otherAxis, double ratio=1.0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescale} (bool onlyVisiblePlottables=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b pixelToCoord} (double value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b coordToPixel} (double value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SelectablePart} {\b getPartAt} (const QPointF &pos) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractPlottable} * > {\b plottables} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPGraph} * > {\b graphs} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractItem} * > {\b items} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AxisType} {\b marginSideToAxisType} ({\b QCP::MarginSide} side)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static Qt::Orientation {\b orientation} ({\b AxisType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AxisType} {\b opposite} ({\b AxisType} type)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b calculateMargin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupTickVectors} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b getBasePen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b getTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b getSubTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b getTickLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b getLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b getTickLabelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b getLabelColor} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AxisType} {\b mAxisType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b mAxisRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mPadding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientation {\b mOrientation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b mSelectableParts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b mSelectedParts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mBasePen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedBasePen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mLabel}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mLabelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mSelectedLabelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mLabelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mSelectedLabelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mTickLabels}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mTickLabelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mSelectedTickLabelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mTickLabelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mSelectedTickLabelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mNumberPrecision}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLatin1Char {\b mNumberFormatChar}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mNumberBeautifulPowers}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mTicks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mSubTicks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mTickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedTickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSubTickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedSubTickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mRangeReversed}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScaleType} {\b mScaleType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGrid} * {\b mGrid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisPainterPrivate} * {\b mAxisPainter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPAxisTicker} > {\b mTicker}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< double > {\b mTickVector}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QString > {\b mTickVectorLabels}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< double > {\b mSubTickVector}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mCachedMarginValid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mCachedMargin}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mDragging}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mDragStartRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mAADragBackup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mNotAADragBackup}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPGrid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisRect}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a single axis inside a {\b QCustomPlot}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Usually doesn't need to be instantiated externally. Access QCustomPlot's default four axes via {\b QCustomPlot::xAxis} (bottom), {\b QCustomPlot::yAxis} (left), {\b QCustomPlot::xAxis2} (top) and {\b QCustomPlot::yAxis2} (right).\par
Axes are always part of an axis rect, see {\b QCPAxisRect}.  {\qc Naming convention of axis parts}  \par
  {\qc Overview of the spacings and paddings that define the geometry of an axis. The dashed gray line on the left represents the {\b QCustomPlot} widget border.} \par
Each axis holds an instance of {\b QCPAxisTicker} which is used to generate the tick coordinates and tick labels. You can access the currently installed {\b ticker} or set a new one (possibly one of the specialized subclasses, or your own subclass) via {\b setTicker}. For details, see the documentation of {\b QCPAxisTicker}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v AxisType\:QCPAxis}
{\xe \v QCPAxis\:AxisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxis::AxisType}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines at which side of the axis rect the axis will appear. This also affects how the tick marks are drawn, on which side the labels are placed etc. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v atLeft\:QCPAxis}
{\xe \v QCPAxis\:atLeft}
{\qr atLeft{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x01}  Axis is vertical and on the left side of the axis rect \par
}\cell }{\row }
{\xe \v atRight\:QCPAxis}
{\xe \v QCPAxis\:atRight}
{\qr atRight{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x02}  Axis is vertical and on the right side of the axis rect \par
}\cell }{\row }
{\xe \v atTop\:QCPAxis}
{\xe \v QCPAxis\:atTop}
{\qr atTop{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x04}  Axis is horizontal and on the top side of the axis rect \par
}\cell }{\row }
{\xe \v atBottom\:QCPAxis}
{\xe \v QCPAxis\:atBottom}
{\qr atBottom{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x08}  Axis is horizontal and on the bottom side of the axis rect \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1964                 \{ atLeft    = 0x01  \par
 1965                   ,atRight  = 0x02  \par
 1966                   ,atTop    = 0x04  \par
 1967                   ,atBottom = 0x08  \par
 1968                 \};\par
}
}
{\xe \v LabelSide\:QCPAxis}
{\xe \v QCPAxis\:LabelSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxis::LabelSide}}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines on which side of the axis the tick labels (numbers) shall appear.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabelSide} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v lsInside\:QCPAxis}
{\xe \v QCPAxis\:lsInside}
{\qr lsInside{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tick labels will be displayed inside the axis rect and clipped to the inner axis rect. \par
}\cell }{\row }
{\xe \v lsOutside\:QCPAxis}
{\xe \v QCPAxis\:lsOutside}
{\qr lsOutside{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tick labels will be displayed outside the axis rect. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1977                  \{ lsInside    \par
 1978                    ,lsOutside  \par
 1979                  \};\par
}
}
{\xe \v ScaleType\:QCPAxis}
{\xe \v QCPAxis\:ScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxis::ScaleType}}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the scale of an axis. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setScaleType} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v stLinear\:QCPAxis}
{\xe \v QCPAxis\:stLinear}
{\qr stLinear{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Linear scaling. \par
}\cell }{\row }
{\xe \v stLogarithmic\:QCPAxis}
{\xe \v QCPAxis\:stLogarithmic}
{\qr stLogarithmic{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logarithmic scaling with correspondingly transformed axis coordinates (possibly also {\b setTicker} to a {\b QCPAxisTickerLog} instance). \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1985                  \{ stLinear       \par
 1986                    ,stLogarithmic \par
 1987                  \};\par
}
}
{\xe \v SelectablePart\:QCPAxis}
{\xe \v QCPAxis\:SelectablePart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxis::SelectablePart}}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the selectable parts of an axis. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectableParts}, {\b setSelectedParts} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v spNone\:QCPAxis}
{\xe \v QCPAxis\:spNone}
{\qr spNone{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
None of the selectable parts. \par
}\cell }{\row }
{\xe \v spAxis\:QCPAxis}
{\xe \v QCPAxis\:spAxis}
{\qr spAxis{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The axis backbone and tick marks. \par
}\cell }{\row }
{\xe \v spTickLabels\:QCPAxis}
{\xe \v QCPAxis\:spTickLabels}
{\qr spTickLabels{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tick labels (numbers) of this axis (as a whole, not individually) \par
}\cell }{\row }
{\xe \v spAxisLabel\:QCPAxis}
{\xe \v QCPAxis\:spAxisLabel}
{\qr spAxisLabel{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The axis label. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1993                       \{ spNone        = 0      \par
 1994                         ,spAxis       = 0x001  \par
 1995                         ,spTickLabels = 0x002  \par
 1996                         ,spAxisLabel  = 0x004  \par
 1997                       \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxis\:QCPAxis}
{\xe \v QCPAxis\:QCPAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxis::QCPAxis ({\b QCPAxisRect} *  {\i parent}, {\b AxisType}  {\i type}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an Axis instance of Type {\i type}  for the axis rect {\i parent} .\par
Usually it isn't necessary to instantiate axes directly, because you can let {\b QCustomPlot} create them for you with {\b QCPAxisRect::addAxis}. If you want to use own QCPAxis-subclasses however, create them manually and then inject them also via {\b QCPAxisRect::addAxis}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7499                                                    :\par
 7500   QCPLayerable(parent->parentPlot(), QString(), parent),\par
 7501   // axis base:\par
 7502   mAxisType(type),\par
 7503   mAxisRect(parent),\par
 7504   mPadding(5),\par
 7505   mOrientation(orientation(type)),\par
 7506   mSelectableParts(spAxis | spTickLabels | spAxisLabel),\par
 7507   mSelectedParts(spNone),\par
 7508   mBasePen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),\par
 7509   mSelectedBasePen(QPen(Qt::blue, 2)),\par
 7510   // axis label:\par
 7511   mLabel(),\par
 7512   mLabelFont(mParentPlot->font()),\par
 7513   mSelectedLabelFont(QFont(mLabelFont.family(), mLabelFont.pointSize(), QFont::Bold)),\par
 7514   mLabelColor(Qt::black),\par
 7515   mSelectedLabelColor(Qt::blue),\par
 7516   // tick labels:\par
 7517   mTickLabels(true),\par
 7518   mTickLabelFont(mParentPlot->font()),\par
 7519   mSelectedTickLabelFont(QFont(mTickLabelFont.family(), mTickLabelFont.pointSize(), QFont::Bold)),\par
 7520   mTickLabelColor(Qt::black),\par
 7521   mSelectedTickLabelColor(Qt::blue),\par
 7522   mNumberPrecision(6),\par
 7523   mNumberFormatChar('g'),\par
 7524   mNumberBeautifulPowers(true),\par
 7525   // ticks and subticks:\par
 7526   mTicks(true),\par
 7527   mSubTicks(true),\par
 7528   mTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),\par
 7529   mSelectedTickPen(QPen(Qt::blue, 2)),\par
 7530   mSubTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),\par
 7531   mSelectedSubTickPen(QPen(Qt::blue, 2)),\par
 7532   // scale and range:\par
 7533   mRange(0, 5),\par
 7534   mRangeReversed(false),\par
 7535   mScaleType(stLinear),\par
 7536   // internal members:\par
 7537   mGrid(new QCPGrid(this)),\par
 7538   mAxisPainter(new QCPAxisPainterPrivate(parent->parentPlot())),\par
 7539   mTicker(new QCPAxisTicker),\par
 7540   mCachedMarginValid(false),\par
 7541   mCachedMargin(0)\par
 7542 \{\par
 7543   setParent(parent);\par
 7544   mGrid->setVisible(false);\par
 7545   setAntialiased(false);\par
 7546   setLayer(mParentPlot->currentLayer()); // it's actually on that layer already, but we want it in front of the grid, so we place it on there again\par
 7547   \par
 7548   if (type == atTop)\par
 7549   \{\par
 7550     setTickLabelPadding(3);\par
 7551     setLabelPadding(6);\par
 7552   \} else if (type == atRight)\par
 7553   \{\par
 7554     setTickLabelPadding(7);\par
 7555     setLabelPadding(12);\par
 7556   \} else if (type == atBottom)\par
 7557   \{\par
 7558     setTickLabelPadding(3);\par
 7559     setLabelPadding(3);\par
 7560   \} else if (type == atLeft)\par
 7561   \{\par
 7562     setTickLabelPadding(5);\par
 7563     setLabelPadding(10);\par
 7564   \}\par
 7565 \}\par
}
}
{\xe \v ~QCPAxis\:QCPAxis}
{\xe \v QCPAxis\:~QCPAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxis::~QCPAxis (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7568 \{\par
 7569   delete mAxisPainter;\par
 7570   delete mGrid; // delete grid here instead of via parent ~QObject for better defined deletion order\par
 7571 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v applyDefaultAntialiasingHint\:QCPAxis}
{\xe \v QCPAxis\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8946 \{\par
 8947   applyAntialiasingHint(painter, mAntialiased, QCP::aeAxes);\par
 8948 \}\par
}
}
{\xe \v axisRect\:QCPAxis}
{\xe \v QCPAxis\:axisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect}* QCPAxis::axisRect () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2007 \{ return mAxisRect; \}\par
}
}
{\xe \v axisType\:QCPAxis}
{\xe \v QCPAxis\:axisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AxisType} QCPAxis::axisType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2006 \{ return mAxisType; \}\par
}
}
{\xe \v basePen\:QCPAxis}
{\xe \v QCPAxis\:basePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::basePen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2028 \{ return mBasePen; \}\par
}
}
{\xe \v calculateMargin\:QCPAxis}
{\xe \v QCPAxis\:calculateMargin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::calculateMargin (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9107 \{\par
 9108   if (!mVisible) // if not visible, directly return 0, don't cache 0 because we can't react to setVisible in QCPAxis\par
 9109     return 0;\par
 9110   \par
 9111   if (mCachedMarginValid)\par
 9112     return mCachedMargin;\par
 9113   \par
 9114   // run through similar steps as QCPAxis::draw, and calculate margin needed to fit axis and its labels\par
 9115   int margin = 0;\par
 9116   \par
 9117   QVector<double> tickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter\par
 9118   QVector<QString> tickLabels; // the final vector passed to QCPAxisPainter\par
 9119   tickPositions.reserve(mTickVector.size());\par
 9120   tickLabels.reserve(mTickVector.size());\par
 9121   \par
 9122   if (mTicks)\par
 9123   \{\par
 9124     for (int i=0; i<mTickVector.size(); ++i)\par
 9125     \{\par
 9126       tickPositions.append(coordToPixel(mTickVector.at(i)));\par
 9127       if (mTickLabels)\par
 9128         tickLabels.append(mTickVectorLabels.at(i));\par
 9129     \}\par
 9130   \}\par
 9131   // transfer all properties of this axis to QCPAxisPainterPrivate which it needs to calculate the size.\par
 9132   // Note that some axis painter properties are already set by direct feed-through with QCPAxis setters\par
 9133   mAxisPainter->type = mAxisType;\par
 9134   mAxisPainter->labelFont = getLabelFont();\par
 9135   mAxisPainter->label = mLabel;\par
 9136   mAxisPainter->tickLabelFont = mTickLabelFont;\par
 9137   mAxisPainter->axisRect = mAxisRect->rect();\par
 9138   mAxisPainter->viewportRect = mParentPlot->viewport();\par
 9139   mAxisPainter->tickPositions = tickPositions;\par
 9140   mAxisPainter->tickLabels = tickLabels;\par
 9141   margin += mAxisPainter->size();\par
 9142   margin += mPadding;\par
 9143 \par
 9144   mCachedMargin = margin;\par
 9145   mCachedMarginValid = true;\par
 9146   return margin;\par
 9147 \}\par
}
}
{\xe \v coordToPixel\:QCPAxis}
{\xe \v QCPAxis\:coordToPixel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxis::coordToPixel (double  {\i value}) const}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms {\i value} , in coordinates of the axis, to pixel coordinates of the {\b QCustomPlot} widget. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8594 \{\par
 8595   if (orientation() == Qt::Horizontal)\par
 8596   \{\par
 8597     if (mScaleType == stLinear)\par
 8598     \{\par
 8599       if (!mRangeReversed)\par
 8600         return (value-mRange.lower)/mRange.size()*mAxisRect->width()+mAxisRect->left();\par
 8601       else\par
 8602         return (mRange.upper-value)/mRange.size()*mAxisRect->width()+mAxisRect->left();\par
 8603     \} else // mScaleType == stLogarithmic\par
 8604     \{\par
 8605       if (value >= 0.0 && mRange.upper < 0.0) // invalid value for logarithmic scale, just draw it outside visible range\par
 8606         return !mRangeReversed ? mAxisRect->right()+200 : mAxisRect->left()-200;\par
 8607       else if (value <= 0.0 && mRange.upper >= 0.0) // invalid value for logarithmic scale, just draw it outside visible range\par
 8608         return !mRangeReversed ? mAxisRect->left()-200 : mAxisRect->right()+200;\par
 8609       else\par
 8610       \{\par
 8611         if (!mRangeReversed)\par
 8612           return qLn(value/mRange.lower)/qLn(mRange.upper/mRange.lower)*mAxisRect->width()+mAxisRect->left();\par
 8613         else\par
 8614           return qLn(mRange.upper/value)/qLn(mRange.upper/mRange.lower)*mAxisRect->width()+mAxisRect->left();\par
 8615       \}\par
 8616     \}\par
 8617   \} else // orientation() == Qt::Vertical\par
 8618   \{\par
 8619     if (mScaleType == stLinear)\par
 8620     \{\par
 8621       if (!mRangeReversed)\par
 8622         return mAxisRect->bottom()-(value-mRange.lower)/mRange.size()*mAxisRect->height();\par
 8623       else\par
 8624         return mAxisRect->bottom()-(mRange.upper-value)/mRange.size()*mAxisRect->height();\par
 8625     \} else // mScaleType == stLogarithmic\par
 8626     \{\par
 8627       if (value >= 0.0 && mRange.upper < 0.0) // invalid value for logarithmic scale, just draw it outside visible range\par
 8628         return !mRangeReversed ? mAxisRect->top()-200 : mAxisRect->bottom()+200;\par
 8629       else if (value <= 0.0 && mRange.upper >= 0.0) // invalid value for logarithmic scale, just draw it outside visible range\par
 8630         return !mRangeReversed ? mAxisRect->bottom()+200 : mAxisRect->top()-200;\par
 8631       else\par
 8632       \{\par
 8633         if (!mRangeReversed)\par
 8634           return mAxisRect->bottom()-qLn(value/mRange.lower)/qLn(mRange.upper/mRange.lower)*mAxisRect->height();\par
 8635         else\par
 8636           return mAxisRect->bottom()-qLn(mRange.upper/value)/qLn(mRange.upper/mRange.lower)*mAxisRect->height();\par
 8637       \}\par
 8638     \}\par
 8639   \}\par
 8640 \}\par
}
}
{\xe \v deselectEvent\:QCPAxis}
{\xe \v QCPAxis\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8792 \{\par
 8793   SelectableParts selBefore = mSelectedParts;\par
 8794   setSelectedParts(mSelectedParts & ~mSelectableParts);\par
 8795   if (selectionStateChanged)\par
 8796     *selectionStateChanged = mSelectedParts != selBefore;\par
 8797 \}\par
}
}
{\xe \v draw\:QCPAxis}
{\xe \v QCPAxis\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8957 \{\par
 8958   QVector<double> subTickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter\par
 8959   QVector<double> tickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter\par
 8960   QVector<QString> tickLabels; // the final vector passed to QCPAxisPainter\par
 8961   tickPositions.reserve(mTickVector.size());\par
 8962   tickLabels.reserve(mTickVector.size());\par
 8963   subTickPositions.reserve(mSubTickVector.size());\par
 8964   \par
 8965   if (mTicks)\par
 8966   \{\par
 8967     for (int i=0; i<mTickVector.size(); ++i)\par
 8968     \{\par
 8969       tickPositions.append(coordToPixel(mTickVector.at(i)));\par
 8970       if (mTickLabels)\par
 8971         tickLabels.append(mTickVectorLabels.at(i));\par
 8972     \}\par
 8973 \par
 8974     if (mSubTicks)\par
 8975     \{\par
 8976       const int subTickCount = mSubTickVector.size();\par
 8977       for (int i=0; i<subTickCount; ++i)\par
 8978         subTickPositions.append(coordToPixel(mSubTickVector.at(i)));\par
 8979     \}\par
 8980   \}\par
 8981   \par
 8982   // transfer all properties of this axis to QCPAxisPainterPrivate which it needs to draw the axis.\par
 8983   // Note that some axis painter properties are already set by direct feed-through with QCPAxis setters\par
 8984   mAxisPainter->type = mAxisType;\par
 8985   mAxisPainter->basePen = getBasePen();\par
 8986   mAxisPainter->labelFont = getLabelFont();\par
 8987   mAxisPainter->labelColor = getLabelColor();\par
 8988   mAxisPainter->label = mLabel;\par
 8989   mAxisPainter->substituteExponent = mNumberBeautifulPowers;\par
 8990   mAxisPainter->tickPen = getTickPen();\par
 8991   mAxisPainter->subTickPen = getSubTickPen();\par
 8992   mAxisPainter->tickLabelFont = getTickLabelFont();\par
 8993   mAxisPainter->tickLabelColor = getTickLabelColor();\par
 8994   mAxisPainter->axisRect = mAxisRect->rect();\par
 8995   mAxisPainter->viewportRect = mParentPlot->viewport();\par
 8996   mAxisPainter->abbreviateDecimalPowers = mScaleType == stLogarithmic;\par
 8997   mAxisPainter->reversedEndings = mRangeReversed;\par
 8998   mAxisPainter->tickPositions = tickPositions;\par
 8999   mAxisPainter->tickLabels = tickLabels;\par
 9000   mAxisPainter->subTickPositions = subTickPositions;\par
 9001   mAxisPainter->draw(painter);\par
 9002 \}\par
}
}
{\xe \v getBasePen\:QCPAxis}
{\xe \v QCPAxis\:getBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::getBasePen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9028 \{\par
 9029   return mSelectedParts.testFlag(spAxis) ? mSelectedBasePen : mBasePen;\par
 9030 \}\par
}
}
{\xe \v getLabelColor\:QCPAxis}
{\xe \v QCPAxis\:getLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::getLabelColor () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9088 \{\par
 9089   return mSelectedParts.testFlag(spAxisLabel) ? mSelectedLabelColor : mLabelColor;\par
 9090 \}\par
}
}
{\xe \v getLabelFont\:QCPAxis}
{\xe \v QCPAxis\:getLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::getLabelFont () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9068 \{\par
 9069   return mSelectedParts.testFlag(spAxisLabel) ? mSelectedLabelFont : mLabelFont;\par
 9070 \}\par
}
}
{\xe \v getPartAt\:QCPAxis}
{\xe \v QCPAxis\:getPartAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::SelectablePart} QCPAxis::getPartAt (const QPointF &  {\i pos}) const}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the part of the axis that is hit by {\i pos}  (in pixels). The return value of this function is independent of the user-selectable parts defined with {\b setSelectableParts}. Further, this function does not change the current selection state of the axis.\par
If the axis is not visible ({\b setVisible}), this function always returns {\b spNone}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedParts}, {\b setSelectableParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8652 \{\par
 8653   if (!mVisible)\par
 8654     return spNone;\par
 8655   \par
 8656   if (mAxisPainter->axisSelectionBox().contains(pos.toPoint()))\par
 8657     return spAxis;\par
 8658   else if (mAxisPainter->tickLabelsSelectionBox().contains(pos.toPoint()))\par
 8659     return spTickLabels;\par
 8660   else if (mAxisPainter->labelSelectionBox().contains(pos.toPoint()))\par
 8661     return spAxisLabel;\par
 8662   else\par
 8663     return spNone;\par
 8664 \}\par
}
}
{\xe \v getSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:getSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::getSubTickPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9048 \{\par
 9049   return mSelectedParts.testFlag(spAxis) ? mSelectedSubTickPen : mSubTickPen;\par
 9050 \}\par
}
}
{\xe \v getTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:getTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::getTickLabelColor () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9078 \{\par
 9079   return mSelectedParts.testFlag(spTickLabels) ? mSelectedTickLabelColor : mTickLabelColor;\par
 9080 \}\par
}
}
{\xe \v getTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:getTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::getTickLabelFont () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9058 \{\par
 9059   return mSelectedParts.testFlag(spTickLabels) ? mSelectedTickLabelFont : mTickLabelFont;\par
 9060 \}\par
}
}
{\xe \v getTickPen\:QCPAxis}
{\xe \v QCPAxis\:getTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::getTickPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9038 \{\par
 9039   return mSelectedParts.testFlag(spAxis) ? mSelectedTickPen : mTickPen;\par
 9040 \}\par
}
}
{\xe \v graphs\:QCPAxis}
{\xe \v QCPAxis\:graphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPGraph} * > QCPAxis::graphs () const}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the graphs that have this axis as key or value axis.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottables}, {\b items} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8705 \{\par
 8706   QList<QCPGraph*> result;\par
 8707   if (!mParentPlot) return result;\par
 8708   \par
 8709   for (int i=0; i<mParentPlot->mGraphs.size(); ++i)\par
 8710   \{\par
 8711     if (mParentPlot->mGraphs.at(i)->keyAxis() == this || mParentPlot->mGraphs.at(i)->valueAxis() == this)\par
 8712       result.append(mParentPlot->mGraphs.at(i));\par
 8713   \}\par
 8714   return result;\par
 8715 \}\par
}
}
{\xe \v grid\:QCPAxis}
{\xe \v QCPAxis\:grid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGrid} * QCPAxis::grid () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b QCPGrid} instance belonging to this axis. Access it to set details about the way the grid is displayed. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2048 \{ return mGrid; \}\par
}
}
{\xe \v items\:QCPAxis}
{\xe \v QCPAxis\:items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractItem} * > QCPAxis::items () const}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the items that are associated with this axis. An item is considered associated with an axis if at least one of its positions uses the axis as key or value axis.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottables}, {\b graphs} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8724 \{\par
 8725   QList<QCPAbstractItem*> result;\par
 8726   if (!mParentPlot) return result;\par
 8727   \par
 8728   for (int itemId=0; itemId<mParentPlot->mItems.size(); ++itemId)\par
 8729   \{\par
 8730     QList<QCPItemPosition*> positions = mParentPlot->mItems.at(itemId)->positions();\par
 8731     for (int posId=0; posId<positions.size(); ++posId)\par
 8732     \{\par
 8733       if (positions.at(posId)->keyAxis() == this || positions.at(posId)->valueAxis() == this)\par
 8734       \{\par
 8735         result.append(mParentPlot->mItems.at(itemId));\par
 8736         break;\par
 8737       \}\par
 8738     \}\par
 8739   \}\par
 8740   return result;\par
 8741 \}\par
}
}
{\xe \v label\:QCPAxis}
{\xe \v QCPAxis\:label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxis::label () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2033 \{ return mLabel; \}\par
}
}
{\xe \v labelColor\:QCPAxis}
{\xe \v QCPAxis\:labelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::labelColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2032 \{ return mLabelColor; \}\par
}
}
{\xe \v labelFont\:QCPAxis}
{\xe \v QCPAxis\:labelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::labelFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2031 \{ return mLabelFont; \}\par
}
}
{\xe \v labelPadding\:QCPAxis}
{\xe \v QCPAxis\:labelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::labelPadding () const}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7631 \{\par
 7632   return mAxisPainter->labelPadding;\par
 7633 \}\par
}
}
{\xe \v lowerEnding\:QCPAxis}
{\xe \v QCPAxis\:lowerEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPAxis::lowerEnding () const}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7643 \{\par
 7644   return mAxisPainter->lowerEnding;\par
 7645 \}\par
}
}
{\xe \v marginSideToAxisType\:QCPAxis}
{\xe \v QCPAxis\:marginSideToAxisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::AxisType} QCPAxis::marginSideToAxisType ({\b QCP::MarginSide}  {\i side}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms a margin side to the logically corresponding axis type. ({\b QCP::msLeft} to {\b QCPAxis::atLeft}, {\b QCP::msRight} to {\b QCPAxis::atRight}, etc.) \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8748 \{\par
 8749   switch (side)\par
 8750   \{\par
 8751     case QCP::msLeft: return atLeft;\par
 8752     case QCP::msRight: return atRight;\par
 8753     case QCP::msTop: return atTop;\par
 8754     case QCP::msBottom: return atBottom;\par
 8755     default: break;\par
 8756   \}\par
 8757   qDebug() << Q_FUNC_INFO << "Invalid margin side passed:" << (int)side;\par
 8758   return atLeft;\par
 8759 \}\par
}
}
{\xe \v mouseMoveEvent\:QCPAxis}
{\xe \v QCPAxis\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::mouseMoveEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8853 \{\par
 8854   if (mDragging)\par
 8855   \{\par
 8856     const double startPixel = orientation() == Qt::Horizontal ? startPos.x() : startPos.y();\par
 8857     const double currentPixel = orientation() == Qt::Horizontal ? event->pos().x() : event->pos().y();\par
 8858     if (mScaleType == QCPAxis::stLinear)\par
 8859     \{\par
 8860       const double diff = pixelToCoord(startPixel) - pixelToCoord(currentPixel);\par
 8861       setRange(mDragStartRange.lower+diff, mDragStartRange.upper+diff);\par
 8862     \} else if (mScaleType == QCPAxis::stLogarithmic)\par
 8863     \{\par
 8864       const double diff = pixelToCoord(startPixel) / pixelToCoord(currentPixel);\par
 8865       setRange(mDragStartRange.lower*diff, mDragStartRange.upper*diff);\par
 8866     \}\par
 8867     \par
 8868     if (mParentPlot->noAntialiasingOnDrag())\par
 8869       mParentPlot->setNotAntialiasedElements(QCP::aeAll);\par
 8870     mParentPlot->replot(QCustomPlot::rpQueuedReplot);\par
 8871   \}\par
 8872 \}\par
}
}
{\xe \v mousePressEvent\:QCPAxis}
{\xe \v QCPAxis\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::mousePressEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
{\b QCustomPlot} uses an event propagation system that works the same as Qt's system. If your layerable doesn't reimplement the {\b mousePressEvent} or explicitly calls {\f2 event->ignore()}  in its reimplementation, the event will be propagated to the next layerable in the stacking order.\par
Once a layerable has accepted the {\b mousePressEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} or {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8815 \{\par
 8816   Q_UNUSED(details)\par
 8817   if (!mParentPlot->interactions().testFlag(QCP::iRangeDrag) ||\par
 8818       !mAxisRect->rangeDrag().testFlag(orientation()) ||\par
 8819       !mAxisRect->rangeDragAxes(orientation()).contains(this))\par
 8820   \{\par
 8821     event->ignore();\par
 8822     return;\par
 8823   \}\par
 8824   \par
 8825   if (event->buttons() & Qt::LeftButton)\par
 8826   \{\par
 8827     mDragging = true;\par
 8828     // initialize antialiasing backup in case we start dragging:\par
 8829     if (mParentPlot->noAntialiasingOnDrag())\par
 8830     \{\par
 8831       mAADragBackup = mParentPlot->antialiasedElements();\par
 8832       mNotAADragBackup = mParentPlot->notAntialiasedElements();\par
 8833     \}\par
 8834     // Mouse range dragging interaction:\par
 8835     if (mParentPlot->interactions().testFlag(QCP::iRangeDrag))\par
 8836       mDragStartRange = mRange;\par
 8837   \}\par
 8838 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPAxis}
{\xe \v QCPAxis\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::mouseReleaseEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8887 \{\par
 8888   Q_UNUSED(event)\par
 8889   Q_UNUSED(startPos)\par
 8890   mDragging = false;\par
 8891   if (mParentPlot->noAntialiasingOnDrag())\par
 8892   \{\par
 8893     mParentPlot->setAntialiasedElements(mAADragBackup);\par
 8894     mParentPlot->setNotAntialiasedElements(mNotAADragBackup);\par
 8895   \}\par
 8896 \}\par
}
}
{\xe \v moveRange\:QCPAxis}
{\xe \v QCPAxis\:moveRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::moveRange (double  {\i diff})}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the scale type ({\b setScaleType}) is {\b stLinear}, {\i diff}  is added to the lower and upper bounds of the range. The range is simply moved by {\i diff} .\par
If the scale type is {\b stLogarithmic}, the range bounds are multiplied by {\i diff} . This corresponds to an apparent "linear" move in logarithmic scaling by a distance of log(diff). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8405 \{\par
 8406   QCPRange oldRange = mRange;\par
 8407   if (mScaleType == stLinear)\par
 8408   \{\par
 8409     mRange.lower += diff;\par
 8410     mRange.upper += diff;\par
 8411   \} else // mScaleType == stLogarithmic\par
 8412   \{\par
 8413     mRange.lower *= diff;\par
 8414     mRange.upper *= diff;\par
 8415   \}\par
 8416   emit rangeChanged(mRange);\par
 8417   emit rangeChanged(mRange, oldRange);\par
 8418 \}\par
}
}
{\xe \v numberFormat\:QCPAxis}
{\xe \v QCPAxis\:numberFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxis::numberFormat () const}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7593 \{\par
 7594   QString result;\par
 7595   result.append(mNumberFormatChar);\par
 7596   if (mNumberBeautifulPowers)\par
 7597   \{\par
 7598     result.append(QLatin1Char('b'));\par
 7599     if (mAxisPainter->numberMultiplyCross)\par
 7600       result.append(QLatin1Char('c'));\par
 7601   \}\par
 7602   return result;\par
 7603 \}\par
}
}
{\xe \v numberPrecision\:QCPAxis}
{\xe \v QCPAxis\:numberPrecision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::numberPrecision () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2020 \{ return mNumberPrecision; \}\par
}
}
{\xe \v offset\:QCPAxis}
{\xe \v QCPAxis\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::offset () const}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7637 \{\par
 7638   return mAxisPainter->offset;\par
 7639 \}\par
}
}
{\xe \v opposite\:QCPAxis}
{\xe \v QCPAxis\:opposite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::AxisType} QCPAxis::opposite ({\b QCPAxis::AxisType}  {\i type}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the axis type that describes the opposite axis of an axis with the specified {\i type} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8765 \{\par
 8766   switch (type)\par
 8767   \{\par
 8768     case atLeft: return atRight; break;\par
 8769     case atRight: return atLeft; break;\par
 8770     case atBottom: return atTop; break;\par
 8771     case atTop: return atBottom; break;\par
 8772     default: qDebug() << Q_FUNC_INFO << "invalid axis type"; return atLeft; break;\par
 8773   \}\par
 8774 \}\par
}
}
{\xe \v orientation\:QCPAxis}
{\xe \v QCPAxis\:orientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientation QCPAxis::orientation () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orientation of this axis. The axis orientation (horizontal or vertical) is deduced from the axis type (left, top, right or bottom).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b orientation(AxisType type)}, {\b pixelOrientation} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2100 \{ return mOrientation; \}\par
}
}
{\xe \v orientation\:QCPAxis}
{\xe \v QCPAxis\:orientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static Qt::Orientation QCPAxis::orientation ({\b AxisType}  {\i type}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orientation of the specified axis type\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b orientation()}, {\b pixelOrientation} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2115 \{ return type==atBottom||type==atTop ? Qt::Horizontal : Qt::Vertical; \}\par
}
}
{\xe \v padding\:QCPAxis}
{\xe \v QCPAxis\:padding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::padding () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2035 \{ return mPadding; \}\par
}
}
{\xe \v pixelOrientation\:QCPAxis}
{\xe \v QCPAxis\:pixelOrientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::pixelOrientation () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns which direction points towards higher coordinate values/keys, in pixel space.\par
This method returns either 1 or -1. If it returns 1, then going in the positive direction along the orientation of the axis in pixels corresponds to going from lower to higher axis coordinates. On the other hand, if this method returns -1, going to smaller pixel values corresponds to going from lower to higher axis coordinates.\par
For example, this is useful to easily shift axis coordinates by a certain amount given in pixels, without having to care about reversed or vertically aligned axes:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid double newKey = keyAxis->pixelToCoord(keyAxis->coordToPixel(oldKey)+10*keyAxis->pixelOrientation());\par
}
\par
{\i newKey}  will then contain a key that is ten pixels towards higher keys, starting from {\i oldKey} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2101 \{ return rangeReversed() != (orientation()==Qt::Vertical) ? -1 : 1; \}\par
}
}
{\xe \v pixelToCoord\:QCPAxis}
{\xe \v QCPAxis\:pixelToCoord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxis::pixelToCoord (double  {\i value}) const}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms {\i value} , in pixel coordinates of the {\b QCustomPlot} widget, to axis coordinates. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8556 \{\par
 8557   if (orientation() == Qt::Horizontal)\par
 8558   \{\par
 8559     if (mScaleType == stLinear)\par
 8560     \{\par
 8561       if (!mRangeReversed)\par
 8562         return (value-mAxisRect->left())/(double)mAxisRect->width()*mRange.size()+mRange.lower;\par
 8563       else\par
 8564         return -(value-mAxisRect->left())/(double)mAxisRect->width()*mRange.size()+mRange.upper;\par
 8565     \} else // mScaleType == stLogarithmic\par
 8566     \{\par
 8567       if (!mRangeReversed)\par
 8568         return qPow(mRange.upper/mRange.lower, (value-mAxisRect->left())/(double)mAxisRect->width())*mRange.lower;\par
 8569       else\par
 8570         return qPow(mRange.upper/mRange.lower, (mAxisRect->left()-value)/(double)mAxisRect->width())*mRange.upper;\par
 8571     \}\par
 8572   \} else // orientation() == Qt::Vertical\par
 8573   \{\par
 8574     if (mScaleType == stLinear)\par
 8575     \{\par
 8576       if (!mRangeReversed)\par
 8577         return (mAxisRect->bottom()-value)/(double)mAxisRect->height()*mRange.size()+mRange.lower;\par
 8578       else\par
 8579         return -(mAxisRect->bottom()-value)/(double)mAxisRect->height()*mRange.size()+mRange.upper;\par
 8580     \} else // mScaleType == stLogarithmic\par
 8581     \{\par
 8582       if (!mRangeReversed)\par
 8583         return qPow(mRange.upper/mRange.lower, (mAxisRect->bottom()-value)/(double)mAxisRect->height())*mRange.lower;\par
 8584       else\par
 8585         return qPow(mRange.upper/mRange.lower, (value-mAxisRect->bottom())/(double)mAxisRect->height())*mRange.upper;\par
 8586     \}\par
 8587   \}\par
 8588 \}\par
}
}
{\xe \v plottables\:QCPAxis}
{\xe \v QCPAxis\:plottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractPlottable} * > QCPAxis::plottables () const}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the plottables that have this axis as key or value axis.\par
If you are only interested in plottables of type {\b QCPGraph}, see {\b graphs}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graphs}, {\b items} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8687 \{\par
 8688   QList<QCPAbstractPlottable*> result;\par
 8689   if (!mParentPlot) return result;\par
 8690   \par
 8691   for (int i=0; i<mParentPlot->mPlottables.size(); ++i)\par
 8692   \{\par
 8693     if (mParentPlot->mPlottables.at(i)->keyAxis() == this ||mParentPlot->mPlottables.at(i)->valueAxis() == this)\par
 8694       result.append(mParentPlot->mPlottables.at(i));\par
 8695   \}\par
 8696   return result;\par
 8697 \}\par
}
}
{\xe \v range\:QCPAxis}
{\xe \v QCPAxis\:range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} QCPAxis::range () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2009 \{ return mRange; \}\par
}
}
{\xe \v rangeChanged\:QCPAxis}
{\xe \v QCPAxis\:rangeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::rangeChanged (const {\b QCPRange} &  {\i newRange}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the range of this axis has changed. You can connect it to the {\b setRange} slot of another axis to communicate the new range to the other axis, in order for it to be synchronized.\par
You may also manipulate/correct the range with {\b setRange} in a slot connected to this signal. This is useful if for example a maximum range span shall not be exceeded, or if the lower/upper range shouldn't go beyond certain values (see {\b QCPRange::bounded}). For example, the following slot would limit the x axis to ranges between 0 and 10: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid customPlot->xAxis->setRange(newRange.bounded(0, 10))\par
}
 \par
}}
{\xe \v rangeChanged\:QCPAxis}
{\xe \v QCPAxis\:rangeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::rangeChanged (const {\b QCPRange} &  {\i newRange}, const {\b QCPRange} &  {\i oldRange}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Additionally to the new range, this signal also provides the previous range held by the axis as {\i oldRange} . \par
}}
{\xe \v rangeReversed\:QCPAxis}
{\xe \v QCPAxis\:rangeReversed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::rangeReversed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2010 \{ return mRangeReversed; \}\par
}
}
{\xe \v rescale\:QCPAxis}
{\xe \v QCPAxis\:rescale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::rescale (bool  {\i onlyVisiblePlottables} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Changes the axis range such that all plottables associated with this axis are fully visible in that dimension.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractPlottable::rescaleAxes}, {\b QCustomPlot::rescaleAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8507 \{\par
 8508   QList<QCPAbstractPlottable*> p = plottables();\par
 8509   QCPRange newRange;\par
 8510   bool haveRange = false;\par
 8511   for (int i=0; i<p.size(); ++i)\par
 8512   \{\par
 8513     if (!p.at(i)->realVisibility() && onlyVisiblePlottables)\par
 8514       continue;\par
 8515     QCPRange plottableRange;\par
 8516     bool currentFoundRange;\par
 8517     QCP::SignDomain signDomain = QCP::sdBoth;\par
 8518     if (mScaleType == stLogarithmic)\par
 8519       signDomain = (mRange.upper < 0 ? QCP::sdNegative : QCP::sdPositive);\par
 8520     if (p.at(i)->keyAxis() == this)\par
 8521       plottableRange = p.at(i)->getKeyRange(currentFoundRange, signDomain);\par
 8522     else\par
 8523       plottableRange = p.at(i)->getValueRange(currentFoundRange, signDomain);\par
 8524     if (currentFoundRange)\par
 8525     \{\par
 8526       if (!haveRange)\par
 8527         newRange = plottableRange;\par
 8528       else\par
 8529         newRange.expand(plottableRange);\par
 8530       haveRange = true;\par
 8531     \}\par
 8532   \}\par
 8533   if (haveRange)\par
 8534   \{\par
 8535     if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable\par
 8536     \{\par
 8537       double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason\par
 8538       if (mScaleType == stLinear)\par
 8539       \{\par
 8540         newRange.lower = center-mRange.size()/2.0;\par
 8541         newRange.upper = center+mRange.size()/2.0;\par
 8542       \} else // mScaleType == stLogarithmic\par
 8543       \{\par
 8544         newRange.lower = center/qSqrt(mRange.upper/mRange.lower);\par
 8545         newRange.upper = center*qSqrt(mRange.upper/mRange.lower);\par
 8546       \}\par
 8547     \}\par
 8548     setRange(newRange);\par
 8549   \}\par
 8550 \}\par
}
}
{\xe \v scaleRange\:QCPAxis}
{\xe \v QCPAxis\:scaleRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::scaleRange (double  {\i factor})}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scales the range of this axis by {\i factor}  around the center of the current axis range. For example, if {\i factor}  is 2.0, then the axis range will double its size, and the point at the axis range center won't have changed its position in the {\b QCustomPlot} widget (i.e. coordinates around the center will have moved symmetrically closer).\par
If you wish to scale around a different coordinate than the current axis range center, use the overload {\b scaleRange(double factor, double center)}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8430 \{\par
 8431   scaleRange(factor, range().center());\par
 8432 \}\par
}
}
{\xe \v scaleRange\:QCPAxis}
{\xe \v QCPAxis\:scaleRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::scaleRange (double  {\i factor}, double  {\i center})}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Scales the range of this axis by {\i factor}  around the coordinate {\i center} . For example, if {\i factor}  is 2.0, {\i center}  is 1.0, then the axis range will double its size, and the point at coordinate 1.0 won't have changed its position in the {\b QCustomPlot} widget (i.e. coordinates around 1.0 will have moved symmetrically closer to 1.0).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b scaleRange(double factor)} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8444 \{\par
 8445   QCPRange oldRange = mRange;\par
 8446   if (mScaleType == stLinear)\par
 8447   \{\par
 8448     QCPRange newRange;\par
 8449     newRange.lower = (mRange.lower-center)*factor + center;\par
 8450     newRange.upper = (mRange.upper-center)*factor + center;\par
 8451     if (QCPRange::validRange(newRange))\par
 8452       mRange = newRange.sanitizedForLinScale();\par
 8453   \} else // mScaleType == stLogarithmic\par
 8454   \{\par
 8455     if ((mRange.upper < 0 && center < 0) || (mRange.upper > 0 && center > 0)) // make sure center has same sign as range\par
 8456     \{\par
 8457       QCPRange newRange;\par
 8458       newRange.lower = qPow(mRange.lower/center, factor)*center;\par
 8459       newRange.upper = qPow(mRange.upper/center, factor)*center;\par
 8460       if (QCPRange::validRange(newRange))\par
 8461         mRange = newRange.sanitizedForLogScale();\par
 8462     \} else\par
 8463       qDebug() << Q_FUNC_INFO << "Center of scaling operation doesn't lie in same logarithmic sign domain as range:" << center;\par
 8464   \}\par
 8465   emit rangeChanged(mRange);\par
 8466   emit rangeChanged(mRange, oldRange);\par
 8467 \}\par
}
}
{\xe \v scaleType\:QCPAxis}
{\xe \v QCPAxis\:scaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScaleType} QCPAxis::scaleType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2008 \{ return mScaleType; \}\par
}
}
{\xe \v scaleTypeChanged\:QCPAxis}
{\xe \v QCPAxis\:scaleTypeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::scaleTypeChanged ({\b QCPAxis::ScaleType}  {\i scaleType}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the scale type changes, by calls to {\b setScaleType} \par
}}
{\xe \v selectableChanged\:QCPAxis}
{\xe \v QCPAxis\:selectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::selectableChanged (const QCPAxis::SelectableParts &  {\i parts}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selectability changes, by calls to {\b setSelectableParts} \par
}}
{\xe \v selectableParts\:QCPAxis}
{\xe \v QCPAxis\:selectableParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPAxis::selectableParts () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2038 \{ return mSelectableParts; \}\par
}
}
{\xe \v selectedBasePen\:QCPAxis}
{\xe \v QCPAxis\:selectedBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::selectedBasePen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2043 \{ return mSelectedBasePen; \}\par
}
}
{\xe \v selectedLabelColor\:QCPAxis}
{\xe \v QCPAxis\:selectedLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::selectedLabelColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2042 \{ return mSelectedLabelColor; \}\par
}
}
{\xe \v selectedLabelFont\:QCPAxis}
{\xe \v QCPAxis\:selectedLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::selectedLabelFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2040 \{ return mSelectedLabelFont; \}\par
}
}
{\xe \v selectedParts\:QCPAxis}
{\xe \v QCPAxis\:selectedParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPAxis::selectedParts () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2037 \{ return mSelectedParts; \}\par
}
}
{\xe \v selectedSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:selectedSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::selectedSubTickPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2045 \{ return mSelectedSubTickPen; \}\par
}
}
{\xe \v selectedTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:selectedTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::selectedTickLabelColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2041 \{ return mSelectedTickLabelColor; \}\par
}
}
{\xe \v selectedTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:selectedTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::selectedTickLabelFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2039 \{ return mSelectedTickLabelFont; \}\par
}
}
{\xe \v selectedTickPen\:QCPAxis}
{\xe \v QCPAxis\:selectedTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::selectedTickPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2044 \{ return mSelectedTickPen; \}\par
}
}
{\xe \v selectEvent\:QCPAxis}
{\xe \v QCPAxis\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8778 \{\par
 8779   Q_UNUSED(event)\par
 8780   SelectablePart part = details.value<SelectablePart>();\par
 8781   if (mSelectableParts.testFlag(part))\par
 8782   \{\par
 8783     SelectableParts selBefore = mSelectedParts;\par
 8784     setSelectedParts(additive ? mSelectedParts^part : part);\par
 8785     if (selectionStateChanged)\par
 8786       *selectionStateChanged = mSelectedParts != selBefore;\par
 8787   \}\par
 8788 \}\par
}
}
{\xe \v selectionCategory\:QCPAxis}
{\xe \v QCPAxis\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPAxis::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9151 \{\par
 9152   return QCP::iSelectAxes;\par
 9153 \}\par
}
}
{\xe \v selectionChanged\:QCPAxis}
{\xe \v QCPAxis\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::selectionChanged (const QCPAxis::SelectableParts &  {\i parts}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this axis has changed, either by user interaction or by a direct call to {\b setSelectedParts}. \par
}}
{\xe \v selectTest\:QCPAxis}
{\xe \v QCPAxis\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxis::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8668 \{\par
 8669   if (!mParentPlot) return -1;\par
 8670   SelectablePart part = getPartAt(pos);\par
 8671   if ((onlySelectable && !mSelectableParts.testFlag(part)) || part == spNone)\par
 8672     return -1;\par
 8673   \par
 8674   if (details)\par
 8675     details->setValue(part);\par
 8676   return mParentPlot->selectionTolerance()*0.99;\par
 8677 \}\par
}
}
{\xe \v setBasePen\:QCPAxis}
{\xe \v QCPAxis\:setBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setBasePen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen, the axis base line is drawn with.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickPen}, {\b setSubTickPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8182 \{\par
 8183   mBasePen = pen;\par
 8184 \}\par
}
}
{\xe \v setLabel\:QCPAxis}
{\xe \v QCPAxis\:setLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLabel (const QString &  {\i str})}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the text of the axis label that will be shown below/above or next to the axis, depending on its orientation. To disable axis labels, pass an empty string as {\i str} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8235 \{\par
 8236   if (mLabel != str)\par
 8237   \{\par
 8238     mLabel = str;\par
 8239     mCachedMarginValid = false;\par
 8240   \}\par
 8241 \}\par
}
}
{\xe \v setLabelColor\:QCPAxis}
{\xe \v QCPAxis\:setLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLabelColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color of the axis label.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8226 \{\par
 8227   mLabelColor = color;\par
 8228 \}\par
}
}
{\xe \v setLabelFont\:QCPAxis}
{\xe \v QCPAxis\:setLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLabelFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font of the axis label.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8212 \{\par
 8213   if (mLabelFont != font)\par
 8214   \{\par
 8215     mLabelFont = font;\par
 8216     mCachedMarginValid = false;\par
 8217   \}\par
 8218 \}\par
}
}
{\xe \v setLabelPadding\:QCPAxis}
{\xe \v QCPAxis\:setLabelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLabelPadding (int  {\i padding})}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the distance between the tick labels and the axis label.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabelPadding}, {\b setPadding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8249 \{\par
 8250   if (mAxisPainter->labelPadding != padding)\par
 8251   \{\par
 8252     mAxisPainter->labelPadding = padding;\par
 8253     mCachedMarginValid = false;\par
 8254   \}\par
 8255 \}\par
}
}
{\xe \v setLowerEnding\:QCPAxis}
{\xe \v QCPAxis\:setLowerEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLowerEnding (const {\b QCPLineEnding} &  {\i ending})}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the style for the lower axis ending. See the documentation of {\b QCPLineEnding} for available styles.\par
For horizontal axes, this method refers to the left ending, for vertical axes the bottom ending. Note that this meaning does not change when the axis range is reversed with {\b setRangeReversed}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setUpperEnding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8378 \{\par
 8379   mAxisPainter->lowerEnding = ending;\par
 8380 \}\par
}
}
{\xe \v setNumberFormat\:QCPAxis}
{\xe \v QCPAxis\:setNumberFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setNumberFormat (const QString &  {\i formatCode})}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number format for the numbers in tick labels. This {\i formatCode}  is an extended version of the format code used e.g. by QString::number() and QLocale::toString(). For reference about that, see the "Argument Formats" section in the detailed description of the QString class.\par
{\i formatCode}  is a string of one, two or three characters. The first character is identical to the normal format code used by Qt. In short, this means: 'e'/'E' scientific format, 'f' fixed format, 'g'/'G' scientific or fixed, whichever is shorter.\par
The second and third characters are optional and specific to {\b QCustomPlot}:\par
If the first char was 'e' or 'g', numbers are/might be displayed in the scientific format, e.g. "5.5e9", which is ugly in a plot. So when the second char of {\i formatCode}  is set to 'b' (for "beautiful"), those exponential numbers are formatted in a more natural way, i.e. "5.5
[multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot. If instead a cross should be shown (as is usual in the USA), the third char of {\i formatCode}  can be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the cross and 183 (0xB7) for the dot.\par
Examples for {\i formatCode:}  {
\par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 g}  normal format code behaviour. If number is small, fixed format is used, if number is large, normal scientific format is used \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 gb}  If number is small, fixed format is used, if number is large, scientific format is used with beautifully typeset decimal powers and a dot as multiplication sign \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 ebc}  All numbers are in scientific format with beautifully typeset decimal power and a cross as multiplication sign \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 fb}  illegal format code, since fixed format doesn't support (or need) beautifully typeset decimal powers. Format code will be reduced to 'f'. \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 hello}  illegal format code, since first char is not 'e', 'E', 'f', 'g' or 'G'. Current format code will not be changed. \par
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8004 \{\par
 8005   if (formatCode.isEmpty())\par
 8006   \{\par
 8007     qDebug() << Q_FUNC_INFO << "Passed formatCode is empty";\par
 8008     return;\par
 8009   \}\par
 8010   mCachedMarginValid = false;\par
 8011   \par
 8012   // interpret first char as number format char:\par
 8013   QString allowedFormatChars(QLatin1String("eEfgG"));\par
 8014   if (allowedFormatChars.contains(formatCode.at(0)))\par
 8015   \{\par
 8016     mNumberFormatChar = QLatin1Char(formatCode.at(0).toLatin1());\par
 8017   \} else\par
 8018   \{\par
 8019     qDebug() << Q_FUNC_INFO << "Invalid number format code (first char not in 'eEfgG'):" << formatCode;\par
 8020     return;\par
 8021   \}\par
 8022   if (formatCode.length() < 2)\par
 8023   \{\par
 8024     mNumberBeautifulPowers = false;\par
 8025     mAxisPainter->numberMultiplyCross = false;\par
 8026     return;\par
 8027   \}\par
 8028   \par
 8029   // interpret second char as indicator for beautiful decimal powers:\par
 8030   if (formatCode.at(1) == QLatin1Char('b') && (mNumberFormatChar == QLatin1Char('e') || mNumberFormatChar == QLatin1Char('g')))\par
 8031   \{\par
 8032     mNumberBeautifulPowers = true;\par
 8033   \} else\par
 8034   \{\par
 8035     qDebug() << Q_FUNC_INFO << "Invalid number format code (second char not 'b' or first char neither 'e' nor 'g'):" << formatCode;\par
 8036     return;\par
 8037   \}\par
 8038   if (formatCode.length() < 3)\par
 8039   \{\par
 8040     mAxisPainter->numberMultiplyCross = false;\par
 8041     return;\par
 8042   \}\par
 8043   \par
 8044   // interpret third char as indicator for dot or cross multiplication symbol:\par
 8045   if (formatCode.at(2) == QLatin1Char('c'))\par
 8046   \{\par
 8047     mAxisPainter->numberMultiplyCross = true;\par
 8048   \} else if (formatCode.at(2) == QLatin1Char('d'))\par
 8049   \{\par
 8050     mAxisPainter->numberMultiplyCross = false;\par
 8051   \} else\par
 8052   \{\par
 8053     qDebug() << Q_FUNC_INFO << "Invalid number format code (third char neither 'c' nor 'd'):" << formatCode;\par
 8054     return;\par
 8055   \}\par
 8056 \}\par
}
}
{\xe \v setNumberPrecision\:QCPAxis}
{\xe \v QCPAxis\:setNumberPrecision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setNumberPrecision (int  {\i precision})}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the precision of the tick label numbers. See QLocale::toString(double i, char f, int prec) for details. The effect of precisions are most notably for number Formats starting with 'e', see {\b setNumberFormat} \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8064 \{\par
 8065   if (mNumberPrecision != precision)\par
 8066   \{\par
 8067     mNumberPrecision = precision;\par
 8068     mCachedMarginValid = false;\par
 8069   \}\par
 8070 \}\par
}
}
{\xe \v setOffset\:QCPAxis}
{\xe \v QCPAxis\:setOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setOffset (int  {\i offset})}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the offset the axis has to its axis rect side.\par
If an axis rect side has multiple axes and automatic margin calculation is enabled for that side, only the offset of the inner most axis has meaning (even if it is set to be invisible). The offset of the other, outer axes is controlled automatically, to place them at appropriate positions. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8285 \{\par
 8286   mAxisPainter->offset = offset;\par
 8287 \}\par
}
}
{\xe \v setPadding\:QCPAxis}
{\xe \v QCPAxis\:setPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setPadding (int  {\i padding})}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the padding of the axis.\par
When {\b QCPAxisRect::setAutoMargins} is enabled, the padding is the additional outer most space, that is left blank.\par
The axis padding has no meaning if {\b QCPAxisRect::setAutoMargins} is disabled.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelPadding}, {\b setTickLabelPadding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8268 \{\par
 8269   if (mPadding != padding)\par
 8270   \{\par
 8271     mPadding = padding;\par
 8272     mCachedMarginValid = false;\par
 8273   \}\par
 8274 \}\par
}
}
{\xe \v setRange\:QCPAxis}
{\xe \v QCPAxis\:setRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRange (const {\b QCPRange} &  {\i range})}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the range of the axis.\par
This slot may be connected with the {\b rangeChanged} signal of another axis so this axis is always synchronized with the other axis range, when it changes.\par
To invert the direction of an axis, use {\b setRangeReversed}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7684 \{\par
 7685   if (range.lower == mRange.lower && range.upper == mRange.upper)\par
 7686     return;\par
 7687   \par
 7688   if (!QCPRange::validRange(range)) return;\par
 7689   QCPRange oldRange = mRange;\par
 7690   if (mScaleType == stLogarithmic)\par
 7691   \{\par
 7692     mRange = range.sanitizedForLogScale();\par
 7693   \} else\par
 7694   \{\par
 7695     mRange = range.sanitizedForLinScale();\par
 7696   \}\par
 7697   emit rangeChanged(mRange);\par
 7698   emit rangeChanged(mRange, oldRange);\par
 7699 \}\par
}
}
{\xe \v setRange\:QCPAxis}
{\xe \v QCPAxis\:setRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRange (double  {\i lower}, double  {\i upper})}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the lower and upper bound of the axis range.\par
To invert the direction of an axis, use {\b setRangeReversed}.\par
There is also a slot to set a range, see {\b setRange(const QCPRange &range)}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7754 \{\par
 7755   if (lower == mRange.lower && upper == mRange.upper)\par
 7756     return;\par
 7757   \par
 7758   if (!QCPRange::validRange(lower, upper)) return;\par
 7759   QCPRange oldRange = mRange;\par
 7760   mRange.lower = lower;\par
 7761   mRange.upper = upper;\par
 7762   if (mScaleType == stLogarithmic)\par
 7763   \{\par
 7764     mRange = mRange.sanitizedForLogScale();\par
 7765   \} else\par
 7766   \{\par
 7767     mRange = mRange.sanitizedForLinScale();\par
 7768   \}\par
 7769   emit rangeChanged(mRange);\par
 7770   emit rangeChanged(mRange, oldRange);\par
 7771 \}\par
}
}
{\xe \v setRange\:QCPAxis}
{\xe \v QCPAxis\:setRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRange (double  {\i position}, double  {\i size}, Qt::AlignmentFlag  {\i alignment})}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the range of the axis.\par
The {\i position}  coordinate indicates together with the {\i alignment}  parameter, where the new range will be positioned. {\i size}  defines the size of the new axis range. {\i alignment}  may be Qt::AlignLeft, Qt::AlignRight or Qt::AlignCenter. This will cause the left border, right border, or center of the range to be aligned with {\i position} . Any other values of {\i alignment}  will default to Qt::AlignCenter. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7785 \{\par
 7786   if (alignment == Qt::AlignLeft)\par
 7787     setRange(position, position+size);\par
 7788   else if (alignment == Qt::AlignRight)\par
 7789     setRange(position-size, position);\par
 7790   else // alignment == Qt::AlignCenter\par
 7791     setRange(position-size/2.0, position+size/2.0);\par
 7792 \}\par
}
}
{\xe \v setRangeLower\:QCPAxis}
{\xe \v QCPAxis\:setRangeLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRangeLower (double  {\i lower})}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the lower bound of the axis range. The upper bound is not changed. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7799 \{\par
 7800   if (mRange.lower == lower)\par
 7801     return;\par
 7802   \par
 7803   QCPRange oldRange = mRange;\par
 7804   mRange.lower = lower;\par
 7805   if (mScaleType == stLogarithmic)\par
 7806   \{\par
 7807     mRange = mRange.sanitizedForLogScale();\par
 7808   \} else\par
 7809   \{\par
 7810     mRange = mRange.sanitizedForLinScale();\par
 7811   \}\par
 7812   emit rangeChanged(mRange);\par
 7813   emit rangeChanged(mRange, oldRange);\par
 7814 \}\par
}
}
{\xe \v setRangeReversed\:QCPAxis}
{\xe \v QCPAxis\:setRangeReversed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRangeReversed (bool  {\i reversed})}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the axis range (direction) is displayed reversed. Normally, the values on horizontal axes increase left to right, on vertical axes bottom to top. When {\i reversed}  is set to true, the direction of increasing values is inverted.\par
Note that the range and data interface stays the same for reversed axes, e.g. the {\i lower}  part of the {\b setRange} interface will still reference the mathematically smaller number than the {\i upper}  part. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7848 \{\par
 7849   mRangeReversed = reversed;\par
 7850 \}\par
}
}
{\xe \v setRangeUpper\:QCPAxis}
{\xe \v QCPAxis\:setRangeUpper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRangeUpper (double  {\i upper})}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the upper bound of the axis range. The lower bound is not changed. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7821 \{\par
 7822   if (mRange.upper == upper)\par
 7823     return;\par
 7824   \par
 7825   QCPRange oldRange = mRange;\par
 7826   mRange.upper = upper;\par
 7827   if (mScaleType == stLogarithmic)\par
 7828   \{\par
 7829     mRange = mRange.sanitizedForLogScale();\par
 7830   \} else\par
 7831   \{\par
 7832     mRange = mRange.sanitizedForLinScale();\par
 7833   \}\par
 7834   emit rangeChanged(mRange);\par
 7835   emit rangeChanged(mRange, oldRange);\par
 7836 \}\par
}
}
{\xe \v setScaleRatio\:QCPAxis}
{\xe \v QCPAxis\:setScaleRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setScaleRatio (const {\b QCPAxis} *  {\i otherAxis}, double  {\i ratio} = {\f2 1.0})}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scales the range of this axis to have a certain scale {\i ratio}  to {\i otherAxis} . The scaling will be done around the center of the current axis range.\par
For example, if {\i ratio}  is 1, this axis is the {\i yAxis}  and {\i otherAxis}  is {\i xAxis} , graphs plotted with those axes will appear in a 1:1 aspect ratio, independent of the aspect ratio the axis rect has.\par
This is an operation that changes the range of this axis once, it doesn't fix the scale ratio indefinitely. Note that calling this function in the constructor of the {\b QCustomPlot}'s parent won't have the desired effect, since the widget dimensions aren't defined yet, and a resizeEvent will follow. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8483 \{\par
 8484   int otherPixelSize, ownPixelSize;\par
 8485   \par
 8486   if (otherAxis->orientation() == Qt::Horizontal)\par
 8487     otherPixelSize = otherAxis->axisRect()->width();\par
 8488   else\par
 8489     otherPixelSize = otherAxis->axisRect()->height();\par
 8490   \par
 8491   if (orientation() == Qt::Horizontal)\par
 8492     ownPixelSize = axisRect()->width();\par
 8493   else\par
 8494     ownPixelSize = axisRect()->height();\par
 8495   \par
 8496   double newRangeSize = ratio*otherAxis->range().size()*ownPixelSize/(double)otherPixelSize;\par
 8497   setRange(range().center(), newRangeSize, Qt::AlignCenter);\par
 8498 \}\par
}
}
{\xe \v setScaleType\:QCPAxis}
{\xe \v QCPAxis\:setScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setScaleType ({\b QCPAxis::ScaleType}  {\i type})}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the axis uses a linear scale or a logarithmic scale.\par
Note that this method controls the coordinate transformation. You will likely also want to use a logarithmic tick spacing and labeling, which can be achieved by setting an instance of {\b QCPAxisTickerLog} via {\b setTicker}. See the documentation of {\b QCPAxisTickerLog} about the details of logarithmic axis tick creation.\par
{\b setNumberPrecision} \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7664 \{\par
 7665   if (mScaleType != type)\par
 7666   \{\par
 7667     mScaleType = type;\par
 7668     if (mScaleType == stLogarithmic)\par
 7669       setRange(mRange.sanitizedForLogScale());\par
 7670     mCachedMarginValid = false;\par
 7671     emit scaleTypeChanged(mScaleType);\par
 7672   \}\par
 7673 \}\par
}
}
{\xe \v setSelectableParts\:QCPAxis}
{\xe \v QCPAxis\:setSelectableParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectableParts (const QCPAxis::SelectableParts &  {\i selectableParts})}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the user can (de-)select the parts in {\i selectable}  by clicking on the {\b QCustomPlot} surface. (When {\b QCustomPlot::setInteractions} contains iSelectAxes.)\par
However, even when {\i selectable}  is set to a value not allowing the selection of a specific part, it is still possible to set the selection of this part manually, by calling {\b setSelectedParts} directly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SelectablePart}, {\b setSelectedParts} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7712 \{\par
 7713   if (mSelectableParts != selectable)\par
 7714   \{\par
 7715     mSelectableParts = selectable;\par
 7716     emit selectableChanged(mSelectableParts);\par
 7717   \}\par
 7718 \}\par
}
}
{\xe \v setSelectedBasePen\:QCPAxis}
{\xe \v QCPAxis\:setSelectedBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedBasePen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that is used to draw the axis base line when selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBasePen}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8343 \{\par
 8344   mSelectedBasePen = pen;\par
 8345 \}\par
}
}
{\xe \v setSelectedLabelColor\:QCPAxis}
{\xe \v QCPAxis\:setSelectedLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedLabelColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color that is used for the axis label when it is selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelColor}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8333 \{\par
 8334   mSelectedLabelColor = color;\par
 8335 \}\par
}
}
{\xe \v setSelectedLabelFont\:QCPAxis}
{\xe \v QCPAxis\:setSelectedLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedLabelFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font that is used for the axis label when it is selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelFont}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8309 \{\par
 8310   mSelectedLabelFont = font;\par
 8311   // don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts\par
 8312 \}\par
}
}
{\xe \v setSelectedParts\:QCPAxis}
{\xe \v QCPAxis\:setSelectedParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedParts (const QCPAxis::SelectableParts &  {\i selectedParts})}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the selected state of the respective axis parts described by {\b SelectablePart}. When a part is selected, it uses a different pen/font.\par
The entire selection mechanism for axes is handled automatically when {\b QCustomPlot::setInteractions} contains iSelectAxes. You only need to call this function when you wish to change the selection state manually.\par
This function can change the selection state of a part, independent of the {\b setSelectableParts} setting.\par
emits the {\b selectionChanged} signal when {\i selected}  is different from the previous selection state.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SelectablePart}, {\b setSelectableParts}, {\b selectTest}, {\b setSelectedBasePen}, {\b setSelectedTickPen}, {\b setSelectedSubTickPen}, {\b setSelectedTickLabelFont}, {\b setSelectedLabelFont}, {\b setSelectedTickLabelColor}, {\b setSelectedLabelColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7736 \{\par
 7737   if (mSelectedParts != selected)\par
 7738   \{\par
 7739     mSelectedParts = selected;\par
 7740     emit selectionChanged(mSelectedParts);\par
 7741   \}\par
 7742 \}\par
}
}
{\xe \v setSelectedSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:setSelectedSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedSubTickPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that is used to draw the subticks when selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTickPen}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8363 \{\par
 8364   mSelectedSubTickPen = pen;\par
 8365 \}\par
}
}
{\xe \v setSelectedTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:setSelectedTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedTickLabelColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color that is used for tick labels when they are selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabelColor}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8320 \{\par
 8321   if (color != mSelectedTickLabelColor)\par
 8322   \{\par
 8323     mSelectedTickLabelColor = color;\par
 8324   \}\par
 8325 \}\par
}
}
{\xe \v setSelectedTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:setSelectedTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedTickLabelFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font that is used for tick labels when they are selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabelFont}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8295 \{\par
 8296   if (font != mSelectedTickLabelFont)\par
 8297   \{\par
 8298     mSelectedTickLabelFont = font;\par
 8299     // don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts\par
 8300   \}\par
 8301 \}\par
}
}
{\xe \v setSelectedTickPen\:QCPAxis}
{\xe \v QCPAxis\:setSelectedTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedTickPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that is used to draw the (major) ticks when selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickPen}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8353 \{\par
 8354   mSelectedTickPen = pen;\par
 8355 \}\par
}
}
{\xe \v setSubTickLength\:QCPAxis}
{\xe \v QCPAxis\:setSubTickLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTickLength (int  {\i inside}, int  {\i outside} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the subticks in pixels. {\i inside}  is the length the subticks will reach inside the plot and {\i outside}  is the length they will reach outside the plot. If {\i outside}  is greater than zero, the tick labels and axis label will increase their distance to the axis accordingly, so they won't collide with the ticks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLength}, {\b setSubTickLengthIn}, {\b setSubTickLengthOut} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8141 \{\par
 8142   setSubTickLengthIn(inside);\par
 8143   setSubTickLengthOut(outside);\par
 8144 \}\par
}
}
{\xe \v setSubTickLengthIn\:QCPAxis}
{\xe \v QCPAxis\:setSubTickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTickLengthIn (int  {\i inside})}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the inward subticks in pixels. {\i inside}  is the length the subticks will reach inside the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTickLengthOut}, {\b setSubTickLength}, {\b setTickLength} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8153 \{\par
 8154   if (mAxisPainter->subTickLengthIn != inside)\par
 8155   \{\par
 8156     mAxisPainter->subTickLengthIn = inside;\par
 8157   \}\par
 8158 \}\par
}
}
{\xe \v setSubTickLengthOut\:QCPAxis}
{\xe \v QCPAxis\:setSubTickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTickLengthOut (int  {\i outside})}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the outward subticks in pixels. {\i outside}  is the length the subticks will reach outside the plot. If {\i outside}  is greater than zero, the tick labels will increase their distance to the axis accordingly, so they won't collide with the ticks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTickLengthIn}, {\b setSubTickLength}, {\b setTickLength} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8168 \{\par
 8169   if (mAxisPainter->subTickLengthOut != outside)\par
 8170   \{\par
 8171     mAxisPainter->subTickLengthOut = outside;\par
 8172     mCachedMarginValid = false; // only outside tick length can change margin\par
 8173   \}\par
 8174 \}\par
}
}
{\xe \v setSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:setSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTickPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen, subtick marks will be drawn with.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid setSubTickCount, {\b setSubTickLength}, {\b setBasePen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8202 \{\par
 8203   mSubTickPen = pen;\par
 8204 \}\par
}
}
{\xe \v setSubTicks\:QCPAxis}
{\xe \v QCPAxis\:setSubTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTicks (bool  {\i show})}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether sub tick marks are displayed.\par
Sub ticks are only potentially visible if (major) ticks are also visible (see {\b setTicks})\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTicks} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8124 \{\par
 8125   if (mSubTicks != show)\par
 8126   \{\par
 8127     mSubTicks = show;\par
 8128     mCachedMarginValid = false;\par
 8129   \}\par
 8130 \}\par
}
}
{\xe \v setTicker\:QCPAxis}
{\xe \v QCPAxis\:setTicker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTicker (QSharedPointer< {\b QCPAxisTicker} >  {\i ticker})}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The axis ticker is responsible for generating the tick positions and tick labels. See the documentation of {\b QCPAxisTicker} for details on how to work with axis tickers.\par
You can change the tick positioning/labeling behaviour of this axis by setting a different {\b QCPAxisTicker} subclass using this method. If you only wish to modify the currently installed axis ticker, access it via {\b ticker}.\par
Since the ticker is stored in the axis as a shared pointer, multiple axes may share the same axis ticker simply by passing the same shared pointer to multiple axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b ticker} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7866 \{\par
 7867   if (ticker)\par
 7868     mTicker = ticker;\par
 7869   else\par
 7870     qDebug() << Q_FUNC_INFO << "can not set 0 as axis ticker";\par
 7871   // no need to invalidate margin cache here because produced tick labels are checked for changes in setupTickVector\par
 7872 \}\par
}
}
{\xe \v setTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color of the tick labels.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabels}, {\b setTickLabelFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7938 \{\par
 7939   mTickLabelColor = color;\par
 7940 \}\par
}
}
{\xe \v setTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font of the tick labels.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabels}, {\b setTickLabelColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7924 \{\par
 7925   if (font != mTickLabelFont)\par
 7926   \{\par
 7927     mTickLabelFont = font;\par
 7928     mCachedMarginValid = false;\par
 7929   \}\par
 7930 \}\par
}
}
{\xe \v setTickLabelPadding\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelPadding (int  {\i padding})}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the distance between the axis base line (including any outward ticks) and the tick labels. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelPadding}, {\b setPadding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7910 \{\par
 7911   if (mAxisPainter->tickLabelPadding != padding)\par
 7912   \{\par
 7913     mAxisPainter->tickLabelPadding = padding;\par
 7914     mCachedMarginValid = false;\par
 7915   \}\par
 7916 \}\par
}
}
{\xe \v setTickLabelRotation\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelRotation (double  {\i degrees})}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the rotation of the tick labels. If {\i degrees}  is zero, the labels are drawn normally. Else, the tick labels are drawn rotated by {\i degrees}  clockwise. The specified angle is bound to values from -90 to 90 degrees.\par
If {\i degrees}  is exactly -90, 0 or 90, the tick labels are centered on the tick coordinate. For other angles, the label is drawn with an offset such that it seems to point toward or away from the tick mark. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7952 \{\par
 7953   if (!qFuzzyIsNull(degrees-mAxisPainter->tickLabelRotation))\par
 7954   \{\par
 7955     mAxisPainter->tickLabelRotation = qBound(-90.0, degrees, 90.0);\par
 7956     mCachedMarginValid = false;\par
 7957   \}\par
 7958 \}\par
}
}
{\xe \v setTickLabels\:QCPAxis}
{\xe \v QCPAxis\:setTickLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabels (bool  {\i show})}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether tick labels are displayed. Tick labels are the numbers drawn next to tick marks. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7895 \{\par
 7896   if (mTickLabels != show)\par
 7897   \{\par
 7898     mTickLabels = show;\par
 7899     mCachedMarginValid = false;\par
 7900     if (!mTickLabels)\par
 7901       mTickVectorLabels.clear();\par
 7902   \}\par
 7903 \}\par
}
}
{\xe \v setTickLabelSide\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelSide ({\b LabelSide}  {\i side})}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the tick labels (numbers) shall appear inside or outside the axis rect.\par
The usual and default setting is {\b lsOutside}. Very compact plots sometimes require tick labels to be inside the axis rect, to save space. If {\i side}  is set to {\b lsInside}, the tick labels appear on the inside are additionally clipped to the axis rect. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7968 \{\par
 7969   mAxisPainter->tickLabelSide = side;\par
 7970   mCachedMarginValid = false;\par
 7971 \}\par
}
}
{\xe \v setTickLength\:QCPAxis}
{\xe \v QCPAxis\:setTickLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLength (int  {\i inside}, int  {\i outside} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the ticks in pixels. {\i inside}  is the length the ticks will reach inside the plot and {\i outside}  is the length they will reach outside the plot. If {\i outside}  is greater than zero, the tick labels and axis label will increase their distance to the axis accordingly, so they won't collide with the ticks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTickLength}, {\b setTickLengthIn}, {\b setTickLengthOut} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8081 \{\par
 8082   setTickLengthIn(inside);\par
 8083   setTickLengthOut(outside);\par
 8084 \}\par
}
}
{\xe \v setTickLengthIn\:QCPAxis}
{\xe \v QCPAxis\:setTickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLengthIn (int  {\i inside})}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the inward ticks in pixels. {\i inside}  is the length the ticks will reach inside the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLengthOut}, {\b setTickLength}, {\b setSubTickLength} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8093 \{\par
 8094   if (mAxisPainter->tickLengthIn != inside)\par
 8095   \{\par
 8096     mAxisPainter->tickLengthIn = inside;\par
 8097   \}\par
 8098 \}\par
}
}
{\xe \v setTickLengthOut\:QCPAxis}
{\xe \v QCPAxis\:setTickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLengthOut (int  {\i outside})}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the outward ticks in pixels. {\i outside}  is the length the ticks will reach outside the plot. If {\i outside}  is greater than zero, the tick labels and axis label will increase their distance to the axis accordingly, so they won't collide with the ticks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLengthIn}, {\b setTickLength}, {\b setSubTickLength} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8108 \{\par
 8109   if (mAxisPainter->tickLengthOut != outside)\par
 8110   \{\par
 8111     mAxisPainter->tickLengthOut = outside;\par
 8112     mCachedMarginValid = false; // only outside tick length can change margin\par
 8113   \}\par
 8114 \}\par
}
}
{\xe \v setTickPen\:QCPAxis}
{\xe \v QCPAxis\:setTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen, tick marks will be drawn with.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLength}, {\b setBasePen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8192 \{\par
 8193   mTickPen = pen;\par
 8194 \}\par
}
}
{\xe \v setTicks\:QCPAxis}
{\xe \v QCPAxis\:setTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTicks (bool  {\i show})}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether tick marks are displayed.\par
Note that setting {\i show}  to false does not imply that tick labels are invisible, too. To achieve that, see {\b setTickLabels}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTicks} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7883 \{\par
 7884   if (mTicks != show)\par
 7885   \{\par
 7886     mTicks = show;\par
 7887     mCachedMarginValid = false;\par
 7888   \}\par
 7889 \}\par
}
}
{\xe \v setUpperEnding\:QCPAxis}
{\xe \v QCPAxis\:setUpperEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setUpperEnding (const {\b QCPLineEnding} &  {\i ending})}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the style for the upper axis ending. See the documentation of {\b QCPLineEnding} for available styles.\par
For horizontal axes, this method refers to the right ending, for vertical axes the top ending. Note that this meaning does not change when the axis range is reversed with {\b setRangeReversed}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLowerEnding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8393 \{\par
 8394   mAxisPainter->upperEnding = ending;\par
 8395 \}\par
}
}
{\xe \v setupTickVectors\:QCPAxis}
{\xe \v QCPAxis\:setupTickVectors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setupTickVectors (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9013 \{\par
 9014   if (!mParentPlot) return;\par
 9015   if ((!mTicks && !mTickLabels && !mGrid->visible()) || mRange.size() <= 0) return;\par
 9016   \par
 9017   QVector<QString> oldLabels = mTickVectorLabels;\par
 9018   mTicker->generate(mRange, mParentPlot->locale(), mNumberFormatChar, mNumberPrecision, mTickVector, mSubTicks ? &mSubTickVector : 0, mTickLabels ? &mTickVectorLabels : 0);\par
 9019   mCachedMarginValid &= mTickVectorLabels == oldLabels; // if labels have changed, margin might have changed, too\par
 9020 \}\par
}
}
{\xe \v subTickLengthIn\:QCPAxis}
{\xe \v QCPAxis\:subTickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::subTickLengthIn () const}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7619 \{\par
 7620   return mAxisPainter->subTickLengthIn;\par
 7621 \}\par
}
}
{\xe \v subTickLengthOut\:QCPAxis}
{\xe \v QCPAxis\:subTickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::subTickLengthOut () const}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7625 \{\par
 7626   return mAxisPainter->subTickLengthOut;\par
 7627 \}\par
}
}
{\xe \v subTickPen\:QCPAxis}
{\xe \v QCPAxis\:subTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::subTickPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2030 \{ return mSubTickPen; \}\par
}
}
{\xe \v subTicks\:QCPAxis}
{\xe \v QCPAxis\:subTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::subTicks () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2025 \{ return mSubTicks; \}\par
}
}
{\xe \v ticker\:QCPAxis}
{\xe \v QCPAxis\:ticker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer< {\b QCPAxisTicker} > QCPAxis::ticker () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a modifiable shared pointer to the currently installed axis ticker. The axis ticker is responsible for generating the tick positions and tick labels of this axis. You can access the {\b QCPAxisTicker} with this method and modify basic properties such as the approximate tick count ({\b QCPAxisTicker::setTickCount}).\par
You can gain more control over the axis ticks by setting a different {\b QCPAxisTicker} subclass, see the documentation there. A new axis ticker can be set with {\b setTicker}.\par
Since the ticker is stored in the axis as a shared pointer, multiple axes may share the same axis ticker simply by passing the same shared pointer to multiple axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTicker} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2011 \{ return mTicker; \}\par
}
}
{\xe \v tickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:tickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::tickLabelColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2016 \{ return mTickLabelColor; \}\par
}
}
{\xe \v tickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:tickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::tickLabelFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2015 \{ return mTickLabelFont; \}\par
}
}
{\xe \v tickLabelPadding\:QCPAxis}
{\xe \v QCPAxis\:tickLabelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::tickLabelPadding () const}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7575 \{\par
 7576   return mAxisPainter->tickLabelPadding;\par
 7577 \}\par
}
}
{\xe \v tickLabelRotation\:QCPAxis}
{\xe \v QCPAxis\:tickLabelRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxis::tickLabelRotation () const}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7581 \{\par
 7582   return mAxisPainter->tickLabelRotation;\par
 7583 \}\par
}
}
{\xe \v tickLabels\:QCPAxis}
{\xe \v QCPAxis\:tickLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::tickLabels () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2013 \{ return mTickLabels; \}\par
}
}
{\xe \v tickLabelSide\:QCPAxis}
{\xe \v QCPAxis\:tickLabelSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::LabelSide} QCPAxis::tickLabelSide () const}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7587 \{\par
 7588   return mAxisPainter->tickLabelSide;\par
 7589 \}\par
}
}
{\xe \v tickLengthIn\:QCPAxis}
{\xe \v QCPAxis\:tickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::tickLengthIn () const}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7607 \{\par
 7608   return mAxisPainter->tickLengthIn;\par
 7609 \}\par
}
}
{\xe \v tickLengthOut\:QCPAxis}
{\xe \v QCPAxis\:tickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::tickLengthOut () const}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7613 \{\par
 7614   return mAxisPainter->tickLengthOut;\par
 7615 \}\par
}
}
{\xe \v tickPen\:QCPAxis}
{\xe \v QCPAxis\:tickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::tickPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2029 \{ return mTickPen; \}\par
}
}
{\xe \v ticks\:QCPAxis}
{\xe \v QCPAxis\:ticks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::ticks () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2012 \{ return mTicks; \}\par
}
}
{\xe \v tickVector\:QCPAxis}
{\xe \v QCPAxis\:tickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<double> QCPAxis::tickVector () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2021 \{ return mTickVector; \}\par
}
}
{\xe \v tickVectorLabels\:QCPAxis}
{\xe \v QCPAxis\:tickVectorLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<QString> QCPAxis::tickVectorLabels () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2022 \{ return mTickVectorLabels; \}\par
}
}
{\xe \v upperEnding\:QCPAxis}
{\xe \v QCPAxis\:upperEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPAxis::upperEnding () const}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7649 \{\par
 7650   return mAxisPainter->upperEnding;\par
 7651 \}\par
}
}
{\xe \v wheelEvent\:QCPAxis}
{\xe \v QCPAxis\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} .\par
The {\f2 event->delta()}  indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making {\f2 event->delta()}  larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8914 \{\par
 8915   // Mouse range zooming interaction:\par
 8916   if (!mParentPlot->interactions().testFlag(QCP::iRangeZoom) ||\par
 8917       !mAxisRect->rangeZoom().testFlag(orientation()) ||\par
 8918       !mAxisRect->rangeZoomAxes(orientation()).contains(this))\par
 8919   \{\par
 8920     event->ignore();\par
 8921     return;\par
 8922   \}\par
 8923   \par
 8924   const double wheelSteps = event->delta()/120.0; // a single step delta is +/-120 usually\par
 8925   const double factor = qPow(mAxisRect->rangeZoomFactor(orientation()), wheelSteps);\par
 8926   scaleRange(factor, pixelToCoord(orientation() == Qt::Horizontal ? event->pos().x() : event->pos().y()));\par
 8927   mParentPlot->replot();\par
 8928 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPAxisRect\:QCPAxis}
{\xe \v QCPAxis\:QCPAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAxisRect}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPGrid\:QCPAxis}
{\xe \v QCPAxis\:QCPGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPGrid}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPAxis}
{\xe \v QCPAxis\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAADragBackup\:QCPAxis}
{\xe \v QCPAxis\:mAADragBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCPAxis::mAADragBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAxisPainter\:QCPAxis}
{\xe \v QCPAxis\:mAxisPainter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisPainterPrivate}* QCPAxis::mAxisPainter{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAxisRect\:QCPAxis}
{\xe \v QCPAxis\:mAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect}* QCPAxis::mAxisRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAxisType\:QCPAxis}
{\xe \v QCPAxis\:mAxisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AxisType} QCPAxis::mAxisType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBasePen\:QCPAxis}
{\xe \v QCPAxis\:mBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mBasePen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mCachedMargin\:QCPAxis}
{\xe \v QCPAxis\:mCachedMargin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::mCachedMargin{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mCachedMarginValid\:QCPAxis}
{\xe \v QCPAxis\:mCachedMarginValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mCachedMarginValid{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragging\:QCPAxis}
{\xe \v QCPAxis\:mDragging}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mDragging{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragStartRange\:QCPAxis}
{\xe \v QCPAxis\:mDragStartRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPAxis::mDragStartRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mGrid\:QCPAxis}
{\xe \v QCPAxis\:mGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGrid}* QCPAxis::mGrid{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLabel\:QCPAxis}
{\xe \v QCPAxis\:mLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxis::mLabel{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLabelColor\:QCPAxis}
{\xe \v QCPAxis\:mLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::mLabelColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLabelFont\:QCPAxis}
{\xe \v QCPAxis\:mLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::mLabelFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNotAADragBackup\:QCPAxis}
{\xe \v QCPAxis\:mNotAADragBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCPAxis::mNotAADragBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNumberBeautifulPowers\:QCPAxis}
{\xe \v QCPAxis\:mNumberBeautifulPowers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mNumberBeautifulPowers{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNumberFormatChar\:QCPAxis}
{\xe \v QCPAxis\:mNumberFormatChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLatin1Char QCPAxis::mNumberFormatChar{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNumberPrecision\:QCPAxis}
{\xe \v QCPAxis\:mNumberPrecision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::mNumberPrecision{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOrientation\:QCPAxis}
{\xe \v QCPAxis\:mOrientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientation QCPAxis::mOrientation{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPadding\:QCPAxis}
{\xe \v QCPAxis\:mPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::mPadding{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRange\:QCPAxis}
{\xe \v QCPAxis\:mRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPAxis::mRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeReversed\:QCPAxis}
{\xe \v QCPAxis\:mRangeReversed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mRangeReversed{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScaleType\:QCPAxis}
{\xe \v QCPAxis\:mScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScaleType} QCPAxis::mScaleType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectableParts\:QCPAxis}
{\xe \v QCPAxis\:mSelectableParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPAxis::mSelectableParts{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedBasePen\:QCPAxis}
{\xe \v QCPAxis\:mSelectedBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mSelectedBasePen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedLabelColor\:QCPAxis}
{\xe \v QCPAxis\:mSelectedLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::mSelectedLabelColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedLabelFont\:QCPAxis}
{\xe \v QCPAxis\:mSelectedLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::mSelectedLabelFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedParts\:QCPAxis}
{\xe \v QCPAxis\:mSelectedParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPAxis::mSelectedParts{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:mSelectedSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mSelectedSubTickPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:mSelectedTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::mSelectedTickLabelColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:mSelectedTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::mSelectedTickLabelFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedTickPen\:QCPAxis}
{\xe \v QCPAxis\:mSelectedTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mSelectedTickPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:mSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mSubTickPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSubTicks\:QCPAxis}
{\xe \v QCPAxis\:mSubTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mSubTicks{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSubTickVector\:QCPAxis}
{\xe \v QCPAxis\:mSubTickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<double> QCPAxis::mSubTickVector{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTicker\:QCPAxis}
{\xe \v QCPAxis\:mTicker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer<{\b QCPAxisTicker}> QCPAxis::mTicker{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:mTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::mTickLabelColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:mTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::mTickLabelFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickLabels\:QCPAxis}
{\xe \v QCPAxis\:mTickLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mTickLabels{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickPen\:QCPAxis}
{\xe \v QCPAxis\:mTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mTickPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTicks\:QCPAxis}
{\xe \v QCPAxis\:mTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mTicks{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickVector\:QCPAxis}
{\xe \v QCPAxis\:mTickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<double> QCPAxis::mTickVector{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickVectorLabels\:QCPAxis}
{\xe \v QCPAxis\:mTickVectorLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<QString> QCPAxis::mTickVectorLabels{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisPainterPrivate Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate}
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPAxisPainterPrivate:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_painter_private__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CachedLabel}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TickLabelData}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisPainterPrivate} ({\b QCustomPlot} *parentPlot)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAxisPainterPrivate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearCache} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b axisSelectionBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b tickLabelsSelectionBox} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b labelSelectionBox} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis::AxisType} {\b type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b basePen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b lowerEnding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b upperEnding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b labelPadding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b labelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b labelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b label}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickLabelPadding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b tickLabelRotation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis::LabelSide} {\b tickLabelSide}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b substituteExponent}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b numberMultiplyCross}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickLengthIn}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickLengthOut}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b subTickLengthIn}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b subTickLengthOut}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b tickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b subTickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b tickLabelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b tickLabelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b axisRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b viewportRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b abbreviateDecimalPowers}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b reversedEndings}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< double > {\b subTickPositions}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< double > {\b tickPositions}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QString > {\b tickLabels}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QByteArray {\b generateLabelParameterHash} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b placeTickLabel} ({\b QCPPainter} *painter, double position, int distanceToAxis, const QString &text, QSize *tickLabelsSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawTickLabel} ({\b QCPPainter} *painter, double x, double y, const {\b TickLabelData} &labelData) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TickLabelData} {\b getTickLabelData} (const QFont &font, const QString &text) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b getTickLabelDrawOffset} (const {\b TickLabelData} &labelData) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getMaxTickLabelSize} (const QFont &font, const QString &text, QSize *tickLabelsSize) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QByteArray {\b mLabelParameterHash}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCache< QString, {\b CachedLabel} > {\b mLabelCache}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mAxisSelectionBox}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mTickLabelsSelectionBox}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mLabelSelectionBox}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxisPainterPrivate\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:QCPAxisPainterPrivate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisPainterPrivate::QCPAxisPainterPrivate ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b QCPAxisPainterPrivate} instance. Make sure to not create a new instance on every redraw, to utilize the caching mechanisms. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9176                                                                     :\par
 9177   type(QCPAxis::atLeft),\par
 9178   basePen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),\par
 9179   lowerEnding(QCPLineEnding::esNone),\par
 9180   upperEnding(QCPLineEnding::esNone),\par
 9181   labelPadding(0),\par
 9182   tickLabelPadding(0),\par
 9183   tickLabelRotation(0),\par
 9184   tickLabelSide(QCPAxis::lsOutside),\par
 9185   substituteExponent(true),\par
 9186   numberMultiplyCross(false),\par
 9187   tickLengthIn(5),\par
 9188   tickLengthOut(0),\par
 9189   subTickLengthIn(2),\par
 9190   subTickLengthOut(0),\par
 9191   tickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),\par
 9192   subTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),\par
 9193   offset(0),\par
 9194   abbreviateDecimalPowers(false),\par
 9195   reversedEndings(false),\par
 9196   mParentPlot(parentPlot),\par
 9197   mLabelCache(16) // cache at most 16 (tick) labels\par
 9198 \{\par
 9199 \}\par
}
}
{\xe \v ~QCPAxisPainterPrivate\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:~QCPAxisPainterPrivate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisPainterPrivate::~QCPAxisPainterPrivate (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9202 \{\par
 9203 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v axisSelectionBox\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:axisSelectionBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::axisSelectionBox () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2226 \{ return mAxisSelectionBox; \}\par
}
}
{\xe \v clearCache\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:clearCache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisPainterPrivate::clearCache ()}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9445 \{\par
 9446   mLabelCache.clear();\par
 9447 \}\par
}
}
{\xe \v draw\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisPainterPrivate::draw ({\b QCPPainter} *  {\i painter}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9213 \{\par
 9214   QByteArray newHash = generateLabelParameterHash();\par
 9215   if (newHash != mLabelParameterHash)\par
 9216   \{\par
 9217     mLabelCache.clear();\par
 9218     mLabelParameterHash = newHash;\par
 9219   \}\par
 9220   \par
 9221   QPoint origin;\par
 9222   switch (type)\par
 9223   \{\par
 9224     case QCPAxis::atLeft:   origin = axisRect.bottomLeft() +QPoint(-offset, 0); break;\par
 9225     case QCPAxis::atRight:  origin = axisRect.bottomRight()+QPoint(+offset, 0); break;\par
 9226     case QCPAxis::atTop:    origin = axisRect.topLeft()    +QPoint(0, -offset); break;\par
 9227     case QCPAxis::atBottom: origin = axisRect.bottomLeft() +QPoint(0, +offset); break;\par
 9228   \}\par
 9229 \par
 9230   double xCor = 0, yCor = 0; // paint system correction, for pixel exact matches (affects baselines and ticks of top/right axes)\par
 9231   switch (type)\par
 9232   \{\par
 9233     case QCPAxis::atTop: yCor = -1; break;\par
 9234     case QCPAxis::atRight: xCor = 1; break;\par
 9235     default: break;\par
 9236   \}\par
 9237   int margin = 0;\par
 9238   // draw baseline:\par
 9239   QLineF baseLine;\par
 9240   painter->setPen(basePen);\par
 9241   if (QCPAxis::orientation(type) == Qt::Horizontal)\par
 9242     baseLine.setPoints(origin+QPointF(xCor, yCor), origin+QPointF(axisRect.width()+xCor, yCor));\par
 9243   else\par
 9244     baseLine.setPoints(origin+QPointF(xCor, yCor), origin+QPointF(xCor, -axisRect.height()+yCor));\par
 9245   if (reversedEndings)\par
 9246     baseLine = QLineF(baseLine.p2(), baseLine.p1()); // won't make a difference for line itself, but for line endings later\par
 9247   painter->drawLine(baseLine);\par
 9248   \par
 9249   // draw ticks:\par
 9250   if (!tickPositions.isEmpty())\par
 9251   \{\par
 9252     painter->setPen(tickPen);\par
 9253     int tickDir = (type == QCPAxis::atBottom || type == QCPAxis::atRight) ? -1 : 1; // direction of ticks ("inward" is right for left axis and left for right axis)\par
 9254     if (QCPAxis::orientation(type) == Qt::Horizontal)\par
 9255     \{\par
 9256       for (int i=0; i<tickPositions.size(); ++i)\par
 9257         painter->drawLine(QLineF(tickPositions.at(i)+xCor, origin.y()-tickLengthOut*tickDir+yCor, tickPositions.at(i)+xCor, origin.y()+tickLengthIn*tickDir+yCor));\par
 9258     \} else\par
 9259     \{\par
 9260       for (int i=0; i<tickPositions.size(); ++i)\par
 9261         painter->drawLine(QLineF(origin.x()-tickLengthOut*tickDir+xCor, tickPositions.at(i)+yCor, origin.x()+tickLengthIn*tickDir+xCor, tickPositions.at(i)+yCor));\par
 9262     \}\par
 9263   \}\par
 9264   \par
 9265   // draw subticks:\par
 9266   if (!subTickPositions.isEmpty())\par
 9267   \{\par
 9268     painter->setPen(subTickPen);\par
 9269     // direction of ticks ("inward" is right for left axis and left for right axis)\par
 9270     int tickDir = (type == QCPAxis::atBottom || type == QCPAxis::atRight) ? -1 : 1;\par
 9271     if (QCPAxis::orientation(type) == Qt::Horizontal)\par
 9272     \{\par
 9273       for (int i=0; i<subTickPositions.size(); ++i)\par
 9274         painter->drawLine(QLineF(subTickPositions.at(i)+xCor, origin.y()-subTickLengthOut*tickDir+yCor, subTickPositions.at(i)+xCor, origin.y()+subTickLengthIn*tickDir+yCor));\par
 9275     \} else\par
 9276     \{\par
 9277       for (int i=0; i<subTickPositions.size(); ++i)\par
 9278         painter->drawLine(QLineF(origin.x()-subTickLengthOut*tickDir+xCor, subTickPositions.at(i)+yCor, origin.x()+subTickLengthIn*tickDir+xCor, subTickPositions.at(i)+yCor));\par
 9279     \}\par
 9280   \}\par
 9281   margin += qMax(0, qMax(tickLengthOut, subTickLengthOut));\par
 9282   \par
 9283   // draw axis base endings:\par
 9284   bool antialiasingBackup = painter->antialiasing();\par
 9285   painter->setAntialiasing(true); // always want endings to be antialiased, even if base and ticks themselves aren't\par
 9286   painter->setBrush(QBrush(basePen.color()));\par
 9287   QCPVector2D baseLineVector(baseLine.dx(), baseLine.dy());\par
 9288   if (lowerEnding.style() != QCPLineEnding::esNone)\par
 9289     lowerEnding.draw(painter, QCPVector2D(baseLine.p1())-baseLineVector.normalized()*lowerEnding.realLength()*(lowerEnding.inverted()?-1:1), -baseLineVector);\par
 9290   if (upperEnding.style() != QCPLineEnding::esNone)\par
 9291     upperEnding.draw(painter, QCPVector2D(baseLine.p2())+baseLineVector.normalized()*upperEnding.realLength()*(upperEnding.inverted()?-1:1), baseLineVector);\par
 9292   painter->setAntialiasing(antialiasingBackup);\par
 9293   \par
 9294   // tick labels:\par
 9295   QRect oldClipRect;\par
 9296   if (tickLabelSide == QCPAxis::lsInside) // if using inside labels, clip them to the axis rect\par
 9297   \{\par
 9298     oldClipRect = painter->clipRegion().boundingRect();\par
 9299     painter->setClipRect(axisRect);\par
 9300   \}\par
 9301   QSize tickLabelsSize(0, 0); // size of largest tick label, for offset calculation of axis label\par
 9302   if (!tickLabels.isEmpty())\par
 9303   \{\par
 9304     if (tickLabelSide == QCPAxis::lsOutside)\par
 9305       margin += tickLabelPadding;\par
 9306     painter->setFont(tickLabelFont);\par
 9307     painter->setPen(QPen(tickLabelColor));\par
 9308     const int maxLabelIndex = qMin(tickPositions.size(), tickLabels.size());\par
 9309     int distanceToAxis = margin;\par
 9310     if (tickLabelSide == QCPAxis::lsInside)\par
 9311       distanceToAxis = -(qMax(tickLengthIn, subTickLengthIn)+tickLabelPadding);\par
 9312     for (int i=0; i<maxLabelIndex; ++i)\par
 9313       placeTickLabel(painter, tickPositions.at(i), distanceToAxis, tickLabels.at(i), &tickLabelsSize);\par
 9314     if (tickLabelSide == QCPAxis::lsOutside)\par
 9315       margin += (QCPAxis::orientation(type) == Qt::Horizontal) ? tickLabelsSize.height() : tickLabelsSize.width();\par
 9316   \}\par
 9317   if (tickLabelSide == QCPAxis::lsInside)\par
 9318     painter->setClipRect(oldClipRect);\par
 9319   \par
 9320   // axis label:\par
 9321   QRect labelBounds;\par
 9322   if (!label.isEmpty())\par
 9323   \{\par
 9324     margin += labelPadding;\par
 9325     painter->setFont(labelFont);\par
 9326     painter->setPen(QPen(labelColor));\par
 9327     labelBounds = painter->fontMetrics().boundingRect(0, 0, 0, 0, Qt::TextDontClip, label);\par
 9328     if (type == QCPAxis::atLeft)\par
 9329     \{\par
 9330       QTransform oldTransform = painter->transform();\par
 9331       painter->translate((origin.x()-margin-labelBounds.height()), origin.y());\par
 9332       painter->rotate(-90);\par
 9333       painter->drawText(0, 0, axisRect.height(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);\par
 9334       painter->setTransform(oldTransform);\par
 9335     \}\par
 9336     else if (type == QCPAxis::atRight)\par
 9337     \{\par
 9338       QTransform oldTransform = painter->transform();\par
 9339       painter->translate((origin.x()+margin+labelBounds.height()), origin.y()-axisRect.height());\par
 9340       painter->rotate(90);\par
 9341       painter->drawText(0, 0, axisRect.height(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);\par
 9342       painter->setTransform(oldTransform);\par
 9343     \}\par
 9344     else if (type == QCPAxis::atTop)\par
 9345       painter->drawText(origin.x(), origin.y()-margin-labelBounds.height(), axisRect.width(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);\par
 9346     else if (type == QCPAxis::atBottom)\par
 9347       painter->drawText(origin.x(), origin.y()+margin, axisRect.width(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, label);\par
 9348   \}\par
 9349   \par
 9350   // set selection boxes:\par
 9351   int selectionTolerance = 0;\par
 9352   if (mParentPlot)\par
 9353     selectionTolerance = mParentPlot->selectionTolerance();\par
 9354   else\par
 9355     qDebug() << Q_FUNC_INFO << "mParentPlot is null";\par
 9356   int selAxisOutSize = qMax(qMax(tickLengthOut, subTickLengthOut), selectionTolerance);\par
 9357   int selAxisInSize = selectionTolerance;\par
 9358   int selTickLabelSize;\par
 9359   int selTickLabelOffset;\par
 9360   if (tickLabelSide == QCPAxis::lsOutside)\par
 9361   \{\par
 9362     selTickLabelSize = (QCPAxis::orientation(type) == Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width());\par
 9363     selTickLabelOffset = qMax(tickLengthOut, subTickLengthOut)+tickLabelPadding;\par
 9364   \} else\par
 9365   \{\par
 9366     selTickLabelSize = -(QCPAxis::orientation(type) == Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width());\par
 9367     selTickLabelOffset = -(qMax(tickLengthIn, subTickLengthIn)+tickLabelPadding);\par
 9368   \}\par
 9369   int selLabelSize = labelBounds.height();\par
 9370   int selLabelOffset = qMax(tickLengthOut, subTickLengthOut)+(!tickLabels.isEmpty() && tickLabelSide == QCPAxis::lsOutside ? tickLabelPadding+selTickLabelSize : 0)+labelPadding;\par
 9371   if (type == QCPAxis::atLeft)\par
 9372   \{\par
 9373     mAxisSelectionBox.setCoords(origin.x()-selAxisOutSize, axisRect.top(), origin.x()+selAxisInSize, axisRect.bottom());\par
 9374     mTickLabelsSelectionBox.setCoords(origin.x()-selTickLabelOffset-selTickLabelSize, axisRect.top(), origin.x()-selTickLabelOffset, axisRect.bottom());\par
 9375     mLabelSelectionBox.setCoords(origin.x()-selLabelOffset-selLabelSize, axisRect.top(), origin.x()-selLabelOffset, axisRect.bottom());\par
 9376   \} else if (type == QCPAxis::atRight)\par
 9377   \{\par
 9378     mAxisSelectionBox.setCoords(origin.x()-selAxisInSize, axisRect.top(), origin.x()+selAxisOutSize, axisRect.bottom());\par
 9379     mTickLabelsSelectionBox.setCoords(origin.x()+selTickLabelOffset+selTickLabelSize, axisRect.top(), origin.x()+selTickLabelOffset, axisRect.bottom());\par
 9380     mLabelSelectionBox.setCoords(origin.x()+selLabelOffset+selLabelSize, axisRect.top(), origin.x()+selLabelOffset, axisRect.bottom());\par
 9381   \} else if (type == QCPAxis::atTop)\par
 9382   \{\par
 9383     mAxisSelectionBox.setCoords(axisRect.left(), origin.y()-selAxisOutSize, axisRect.right(), origin.y()+selAxisInSize);\par
 9384     mTickLabelsSelectionBox.setCoords(axisRect.left(), origin.y()-selTickLabelOffset-selTickLabelSize, axisRect.right(), origin.y()-selTickLabelOffset);\par
 9385     mLabelSelectionBox.setCoords(axisRect.left(), origin.y()-selLabelOffset-selLabelSize, axisRect.right(), origin.y()-selLabelOffset);\par
 9386   \} else if (type == QCPAxis::atBottom)\par
 9387   \{\par
 9388     mAxisSelectionBox.setCoords(axisRect.left(), origin.y()-selAxisInSize, axisRect.right(), origin.y()+selAxisOutSize);\par
 9389     mTickLabelsSelectionBox.setCoords(axisRect.left(), origin.y()+selTickLabelOffset+selTickLabelSize, axisRect.right(), origin.y()+selTickLabelOffset);\par
 9390     mLabelSelectionBox.setCoords(axisRect.left(), origin.y()+selLabelOffset+selLabelSize, axisRect.right(), origin.y()+selLabelOffset);\par
 9391   \}\par
 9392   mAxisSelectionBox = mAxisSelectionBox.normalized();\par
 9393   mTickLabelsSelectionBox = mTickLabelsSelectionBox.normalized();\par
 9394   mLabelSelectionBox = mLabelSelectionBox.normalized();\par
 9395   // draw hitboxes for debug purposes:\par
 9396   //painter->setBrush(Qt::NoBrush);\par
 9397   //painter->drawRects(QVector<QRect>() << mAxisSelectionBox << mTickLabelsSelectionBox << mLabelSelectionBox);\par
 9398 \}\par
}
}
{\xe \v drawTickLabel\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:drawTickLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisPainterPrivate::drawTickLabel ({\b QCPPainter} *  {\i painter}, double  {\i x}, double  {\i y}, const {\b TickLabelData} &  {\i labelData}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9578 \{\par
 9579   // backup painter settings that we're about to change:\par
 9580   QTransform oldTransform = painter->transform();\par
 9581   QFont oldFont = painter->font();\par
 9582   \par
 9583   // transform painter to position/rotation:\par
 9584   painter->translate(x, y);\par
 9585   if (!qFuzzyIsNull(tickLabelRotation))\par
 9586     painter->rotate(tickLabelRotation);\par
 9587   \par
 9588   // draw text:\par
 9589   if (!labelData.expPart.isEmpty()) // indicator that beautiful powers must be used\par
 9590   \{\par
 9591     painter->setFont(labelData.baseFont);\par
 9592     painter->drawText(0, 0, 0, 0, Qt::TextDontClip, labelData.basePart);\par
 9593     if (!labelData.suffixPart.isEmpty())\par
 9594       painter->drawText(labelData.baseBounds.width()+1+labelData.expBounds.width(), 0, 0, 0, Qt::TextDontClip, labelData.suffixPart);\par
 9595     painter->setFont(labelData.expFont);\par
 9596     painter->drawText(labelData.baseBounds.width()+1, 0, labelData.expBounds.width(), labelData.expBounds.height(), Qt::TextDontClip,  labelData.expPart);\par
 9597   \} else\par
 9598   \{\par
 9599     painter->setFont(labelData.baseFont);\par
 9600     painter->drawText(0, 0, labelData.totalBounds.width(), labelData.totalBounds.height(), Qt::TextDontClip | Qt::AlignHCenter, labelData.basePart);\par
 9601   \}\par
 9602   \par
 9603   // reset painter settings to what it was before:\par
 9604   painter->setTransform(oldTransform);\par
 9605   painter->setFont(oldFont);\par
 9606 \}\par
}
}
{\xe \v generateLabelParameterHash\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:generateLabelParameterHash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QByteArray QCPAxisPainterPrivate::generateLabelParameterHash () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9457 \{\par
 9458   QByteArray result;\par
 9459   result.append(QByteArray::number(mParentPlot->bufferDevicePixelRatio()));\par
 9460   result.append(QByteArray::number(tickLabelRotation));\par
 9461   result.append(QByteArray::number((int)tickLabelSide));\par
 9462   result.append(QByteArray::number((int)substituteExponent));\par
 9463   result.append(QByteArray::number((int)numberMultiplyCross));\par
 9464   result.append(tickLabelColor.name().toLatin1()+QByteArray::number(tickLabelColor.alpha(), 16));\par
 9465   result.append(tickLabelFont.toString().toLatin1());\par
 9466   return result;\par
 9467 \}\par
}
}
{\xe \v getMaxTickLabelSize\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:getMaxTickLabelSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisPainterPrivate::getMaxTickLabelSize (const QFont &  {\i font}, const QString &  {\i text}, QSize *  {\i tickLabelsSize}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9799 \{\par
 9800   // note: this function must return the same tick label sizes as the placeTickLabel function.\par
 9801   QSize finalSize;\par
 9802   if (mParentPlot->plottingHints().testFlag(QCP::phCacheLabels) && mLabelCache.contains(text)) // label caching enabled and have cached label\par
 9803   \{\par
 9804     const CachedLabel *cachedLabel = mLabelCache.object(text);\par
 9805     finalSize = cachedLabel->pixmap.size()/mParentPlot->bufferDevicePixelRatio();\par
 9806   \} else // label caching disabled or no label with this text cached:\par
 9807   \{\par
 9808     TickLabelData labelData = getTickLabelData(font, text);\par
 9809     finalSize = labelData.rotatedTotalBounds.size();\par
 9810   \}\par
 9811   \par
 9812   // expand passed tickLabelsSize if current tick label is larger:\par
 9813   if (finalSize.width() > tickLabelsSize->width())\par
 9814     tickLabelsSize->setWidth(finalSize.width());\par
 9815   if (finalSize.height() > tickLabelsSize->height())\par
 9816     tickLabelsSize->setHeight(finalSize.height());\par
 9817 \}\par
}
}
{\xe \v getTickLabelData\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:getTickLabelData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisPainterPrivate::TickLabelData} QCPAxisPainterPrivate::getTickLabelData (const QFont &  {\i font}, const QString &  {\i text}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9617 \{\par
 9618   TickLabelData result;\par
 9619   \par
 9620   // determine whether beautiful decimal powers should be used\par
 9621   bool useBeautifulPowers = false;\par
 9622   int ePos = -1; // first index of exponent part, text before that will be basePart, text until eLast will be expPart\par
 9623   int eLast = -1; // last index of exponent part, rest of text after this will be suffixPart\par
 9624   if (substituteExponent)\par
 9625   \{\par
 9626     ePos = text.indexOf(QLatin1Char('e'));\par
 9627     if (ePos > 0 && text.at(ePos-1).isDigit())\par
 9628     \{\par
 9629       eLast = ePos;\par
 9630       while (eLast+1 < text.size() && (text.at(eLast+1) == QLatin1Char('+') || text.at(eLast+1) == QLatin1Char('-') || text.at(eLast+1).isDigit()))\par
 9631         ++eLast;\par
 9632       if (eLast > ePos) // only if also to right of 'e' is a digit/+/- interpret it as beautifiable power\par
 9633         useBeautifulPowers = true;\par
 9634     \}\par
 9635   \}\par
 9636   \par
 9637   // calculate text bounding rects and do string preparation for beautiful decimal powers:\par
 9638   result.baseFont = font;\par
 9639   if (result.baseFont.pointSizeF() > 0) // might return -1 if specified with setPixelSize, in that case we can't do correction in next line\par
 9640     result.baseFont.setPointSizeF(result.baseFont.pointSizeF()+0.05); // QFontMetrics.boundingRect has a bug for exact point sizes that make the results oscillate due to internal rounding\par
 9641   if (useBeautifulPowers)\par
 9642   \{\par
 9643     // split text into parts of number/symbol that will be drawn normally and part that will be drawn as exponent:\par
 9644     result.basePart = text.left(ePos);\par
 9645     result.suffixPart = text.mid(eLast+1); // also drawn normally but after exponent\par
 9646     // in log scaling, we want to turn "1*10^n" into "10^n", else add multiplication sign and decimal base:\par
 9647     if (abbreviateDecimalPowers && result.basePart == QLatin1String("1"))\par
 9648       result.basePart = QLatin1String("10");\par
 9649     else\par
 9650       result.basePart += (numberMultiplyCross ? QString(QChar(215)) : QString(QChar(183))) + QLatin1String("10");\par
 9651     result.expPart = text.mid(ePos+1, eLast-ePos);\par
 9652     // clip "+" and leading zeros off expPart:\par
 9653     while (result.expPart.length() > 2 && result.expPart.at(1) == QLatin1Char('0')) // length > 2 so we leave one zero when numberFormatChar is 'e'\par
 9654       result.expPart.remove(1, 1);\par
 9655     if (!result.expPart.isEmpty() && result.expPart.at(0) == QLatin1Char('+'))\par
 9656       result.expPart.remove(0, 1);\par
 9657     // prepare smaller font for exponent:\par
 9658     result.expFont = font;\par
 9659     if (result.expFont.pointSize() > 0)\par
 9660       result.expFont.setPointSize(result.expFont.pointSize()*0.75);\par
 9661     else\par
 9662       result.expFont.setPixelSize(result.expFont.pixelSize()*0.75);\par
 9663     // calculate bounding rects of base part(s), exponent part and total one:\par
 9664     result.baseBounds = QFontMetrics(result.baseFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip, result.basePart);\par
 9665     result.expBounds = QFontMetrics(result.expFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip, result.expPart);\par
 9666     if (!result.suffixPart.isEmpty())\par
 9667       result.suffixBounds = QFontMetrics(result.baseFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip, result.suffixPart);\par
 9668     result.totalBounds = result.baseBounds.adjusted(0, 0, result.expBounds.width()+result.suffixBounds.width()+2, 0); // +2 consists of the 1 pixel spacing between base and exponent (see drawTickLabel) and an extra pixel to include AA\par
 9669   \} else // useBeautifulPowers == false\par
 9670   \{\par
 9671     result.basePart = text;\par
 9672     result.totalBounds = QFontMetrics(result.baseFont).boundingRect(0, 0, 0, 0, Qt::TextDontClip | Qt::AlignHCenter, result.basePart);\par
 9673   \}\par
 9674   result.totalBounds.moveTopLeft(QPoint(0, 0)); // want bounding box aligned top left at origin, independent of how it was created, to make further processing simpler\par
 9675   \par
 9676   // calculate possibly different bounding rect after rotation:\par
 9677   result.rotatedTotalBounds = result.totalBounds;\par
 9678   if (!qFuzzyIsNull(tickLabelRotation))\par
 9679   \{\par
 9680     QTransform transform;\par
 9681     transform.rotate(tickLabelRotation);\par
 9682     result.rotatedTotalBounds = transform.mapRect(result.rotatedTotalBounds);\par
 9683   \}\par
 9684   \par
 9685   return result;\par
 9686 \}\par
}
}
{\xe \v getTickLabelDrawOffset\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:getTickLabelDrawOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPAxisPainterPrivate::getTickLabelDrawOffset (const {\b TickLabelData} &  {\i labelData}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9699 \{\par
 9700   /*\par
 9701     calculate label offset from base point at tick (non-trivial, for best visual appearance): short\par
 9702     explanation for bottom axis: The anchor, i.e. the point in the label that is placed\par
 9703     horizontally under the corresponding tick is always on the label side that is closer to the\par
 9704     axis (e.g. the left side of the text when we're rotating clockwise). On that side, the height\par
 9705     is halved and the resulting point is defined the anchor. This way, a 90 degree rotated text\par
 9706     will be centered under the tick (i.e. displaced horizontally by half its height). At the same\par
 9707     time, a 45 degree rotated text will "point toward" its tick, as is typical for rotated tick\par
 9708     labels.\par
 9709   */\par
 9710   bool doRotation = !qFuzzyIsNull(tickLabelRotation);\par
 9711   bool flip = qFuzzyCompare(qAbs(tickLabelRotation), 90.0); // perfect +/-90 degree flip. Indicates vertical label centering on vertical axes.\par
 9712   double radians = tickLabelRotation/180.0*M_PI;\par
 9713   int x=0, y=0;\par
 9714   if ((type == QCPAxis::atLeft && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atRight && tickLabelSide == QCPAxis::lsInside)) // Anchor at right side of tick label\par
 9715   \{\par
 9716     if (doRotation)\par
 9717     \{\par
 9718       if (tickLabelRotation > 0)\par
 9719       \{\par
 9720         x = -qCos(radians)*labelData.totalBounds.width();\par
 9721         y = flip ? -labelData.totalBounds.width()/2.0 : -qSin(radians)*labelData.totalBounds.width()-qCos(radians)*labelData.totalBounds.height()/2.0;\par
 9722       \} else\par
 9723       \{\par
 9724         x = -qCos(-radians)*labelData.totalBounds.width()-qSin(-radians)*labelData.totalBounds.height();\par
 9725         y = flip ? +labelData.totalBounds.width()/2.0 : +qSin(-radians)*labelData.totalBounds.width()-qCos(-radians)*labelData.totalBounds.height()/2.0;\par
 9726       \}\par
 9727     \} else\par
 9728     \{\par
 9729       x = -labelData.totalBounds.width();\par
 9730       y = -labelData.totalBounds.height()/2.0;\par
 9731     \}\par
 9732   \} else if ((type == QCPAxis::atRight && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atLeft && tickLabelSide == QCPAxis::lsInside)) // Anchor at left side of tick label\par
 9733   \{\par
 9734     if (doRotation)\par
 9735     \{\par
 9736       if (tickLabelRotation > 0)\par
 9737       \{\par
 9738         x = +qSin(radians)*labelData.totalBounds.height();\par
 9739         y = flip ? -labelData.totalBounds.width()/2.0 : -qCos(radians)*labelData.totalBounds.height()/2.0;\par
 9740       \} else\par
 9741       \{\par
 9742         x = 0;\par
 9743         y = flip ? +labelData.totalBounds.width()/2.0 : -qCos(-radians)*labelData.totalBounds.height()/2.0;\par
 9744       \}\par
 9745     \} else\par
 9746     \{\par
 9747       x = 0;\par
 9748       y = -labelData.totalBounds.height()/2.0;\par
 9749     \}\par
 9750   \} else if ((type == QCPAxis::atTop && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atBottom && tickLabelSide == QCPAxis::lsInside)) // Anchor at bottom side of tick label\par
 9751   \{\par
 9752     if (doRotation)\par
 9753     \{\par
 9754       if (tickLabelRotation > 0)\par
 9755       \{\par
 9756         x = -qCos(radians)*labelData.totalBounds.width()+qSin(radians)*labelData.totalBounds.height()/2.0;\par
 9757         y = -qSin(radians)*labelData.totalBounds.width()-qCos(radians)*labelData.totalBounds.height();\par
 9758       \} else\par
 9759       \{\par
 9760         x = -qSin(-radians)*labelData.totalBounds.height()/2.0;\par
 9761         y = -qCos(-radians)*labelData.totalBounds.height();\par
 9762       \}\par
 9763     \} else\par
 9764     \{\par
 9765       x = -labelData.totalBounds.width()/2.0;\par
 9766       y = -labelData.totalBounds.height();\par
 9767     \}\par
 9768   \} else if ((type == QCPAxis::atBottom && tickLabelSide == QCPAxis::lsOutside) || (type == QCPAxis::atTop && tickLabelSide == QCPAxis::lsInside)) // Anchor at top side of tick label\par
 9769   \{\par
 9770     if (doRotation)\par
 9771     \{\par
 9772       if (tickLabelRotation > 0)\par
 9773       \{\par
 9774         x = +qSin(radians)*labelData.totalBounds.height()/2.0;\par
 9775         y = 0;\par
 9776       \} else\par
 9777       \{\par
 9778         x = -qCos(-radians)*labelData.totalBounds.width()-qSin(-radians)*labelData.totalBounds.height()/2.0;\par
 9779         y = +qSin(-radians)*labelData.totalBounds.width();\par
 9780       \}\par
 9781     \} else\par
 9782     \{\par
 9783       x = -labelData.totalBounds.width()/2.0;\par
 9784       y = 0;\par
 9785     \}\par
 9786   \}\par
 9787   \par
 9788   return QPointF(x, y);\par
 9789 \}\par
}
}
{\xe \v labelSelectionBox\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:labelSelectionBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::labelSelectionBox () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2228 \{ return mLabelSelectionBox; \}\par
}
}
{\xe \v placeTickLabel\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:placeTickLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisPainterPrivate::placeTickLabel ({\b QCPPainter} *  {\i painter}, double  {\i position}, int  {\i distanceToAxis}, const QString &  {\i text}, QSize *  {\i tickLabelsSize}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9489 \{\par
 9490   // warning: if you change anything here, also adapt getMaxTickLabelSize() accordingly!\par
 9491   if (text.isEmpty()) return;\par
 9492   QSize finalSize;\par
 9493   QPointF labelAnchor;\par
 9494   switch (type)\par
 9495   \{\par
 9496     case QCPAxis::atLeft:   labelAnchor = QPointF(axisRect.left()-distanceToAxis-offset, position); break;\par
 9497     case QCPAxis::atRight:  labelAnchor = QPointF(axisRect.right()+distanceToAxis+offset, position); break;\par
 9498     case QCPAxis::atTop:    labelAnchor = QPointF(position, axisRect.top()-distanceToAxis-offset); break;\par
 9499     case QCPAxis::atBottom: labelAnchor = QPointF(position, axisRect.bottom()+distanceToAxis+offset); break;\par
 9500   \}\par
 9501   if (mParentPlot->plottingHints().testFlag(QCP::phCacheLabels) && !painter->modes().testFlag(QCPPainter::pmNoCaching)) // label caching enabled\par
 9502   \{\par
 9503     CachedLabel *cachedLabel = mLabelCache.take(text); // attempt to get label from cache\par
 9504     if (!cachedLabel)  // no cached label existed, create it\par
 9505     \{\par
 9506       cachedLabel = new CachedLabel;\par
 9507       TickLabelData labelData = getTickLabelData(painter->font(), text);\par
 9508       cachedLabel->offset = getTickLabelDrawOffset(labelData)+labelData.rotatedTotalBounds.topLeft();\par
 9509       if (!qFuzzyCompare(1.0, mParentPlot->bufferDevicePixelRatio()))\par
 9510       \{\par
 9511         cachedLabel->pixmap = QPixmap(labelData.rotatedTotalBounds.size()*mParentPlot->bufferDevicePixelRatio());\par
 9512 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
 9513 #  ifdef QCP_DEVICEPIXELRATIO_FLOAT\par
 9514         cachedLabel->pixmap.setDevicePixelRatio(mParentPlot->devicePixelRatioF());\par
 9515 #  else\par
 9516         cachedLabel->pixmap.setDevicePixelRatio(mParentPlot->devicePixelRatio());\par
 9517 #  endif\par
 9518 #endif\par
 9519       \} else\par
 9520         cachedLabel->pixmap = QPixmap(labelData.rotatedTotalBounds.size());\par
 9521       cachedLabel->pixmap.fill(Qt::transparent);\par
 9522       QCPPainter cachePainter(&cachedLabel->pixmap);\par
 9523       cachePainter.setPen(painter->pen());\par
 9524       drawTickLabel(&cachePainter, -labelData.rotatedTotalBounds.topLeft().x(), -labelData.rotatedTotalBounds.topLeft().y(), labelData);\par
 9525     \}\par
 9526     // if label would be partly clipped by widget border on sides, don't draw it (only for outside tick labels):\par
 9527     bool labelClippedByBorder = false;\par
 9528     if (tickLabelSide == QCPAxis::lsOutside)\par
 9529     \{\par
 9530       if (QCPAxis::orientation(type) == Qt::Horizontal)\par
 9531         labelClippedByBorder = labelAnchor.x()+cachedLabel->offset.x()+cachedLabel->pixmap.width()/mParentPlot->bufferDevicePixelRatio() > viewportRect.right() || labelAnchor.x()+cachedLabel->offset.x() < viewportRect.left();\par
 9532       else\par
 9533         labelClippedByBorder = labelAnchor.y()+cachedLabel->offset.y()+cachedLabel->pixmap.height()/mParentPlot->bufferDevicePixelRatio() > viewportRect.bottom() || labelAnchor.y()+cachedLabel->offset.y() < viewportRect.top();\par
 9534     \}\par
 9535     if (!labelClippedByBorder)\par
 9536     \{\par
 9537       painter->drawPixmap(labelAnchor+cachedLabel->offset, cachedLabel->pixmap);\par
 9538       finalSize = cachedLabel->pixmap.size()/mParentPlot->bufferDevicePixelRatio();\par
 9539     \}\par
 9540     mLabelCache.insert(text, cachedLabel); // return label to cache or insert for the first time if newly created\par
 9541   \} else // label caching disabled, draw text directly on surface:\par
 9542   \{\par
 9543     TickLabelData labelData = getTickLabelData(painter->font(), text);\par
 9544     QPointF finalPosition = labelAnchor + getTickLabelDrawOffset(labelData);\par
 9545     // if label would be partly clipped by widget border on sides, don't draw it (only for outside tick labels):\par
 9546      bool labelClippedByBorder = false;\par
 9547     if (tickLabelSide == QCPAxis::lsOutside)\par
 9548     \{\par
 9549       if (QCPAxis::orientation(type) == Qt::Horizontal)\par
 9550         labelClippedByBorder = finalPosition.x()+(labelData.rotatedTotalBounds.width()+labelData.rotatedTotalBounds.left()) > viewportRect.right() || finalPosition.x()+labelData.rotatedTotalBounds.left() < viewportRect.left();\par
 9551       else\par
 9552         labelClippedByBorder = finalPosition.y()+(labelData.rotatedTotalBounds.height()+labelData.rotatedTotalBounds.top()) > viewportRect.bottom() || finalPosition.y()+labelData.rotatedTotalBounds.top() < viewportRect.top();\par
 9553     \}\par
 9554     if (!labelClippedByBorder)\par
 9555     \{\par
 9556       drawTickLabel(painter, finalPosition.x(), finalPosition.y(), labelData);\par
 9557       finalSize = labelData.rotatedTotalBounds.size();\par
 9558     \}\par
 9559   \}\par
 9560   \par
 9561   // expand passed tickLabelsSize if current tick label is larger:\par
 9562   if (finalSize.width() > tickLabelsSize->width())\par
 9563     tickLabelsSize->setWidth(finalSize.width());\par
 9564   if (finalSize.height() > tickLabelsSize->height())\par
 9565     tickLabelsSize->setHeight(finalSize.height());\par
 9566 \}\par
}
}
{\xe \v size\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisPainterPrivate::size () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9406 \{\par
 9407   int result = 0;\par
 9408   \par
 9409   // get length of tick marks pointing outwards:\par
 9410   if (!tickPositions.isEmpty())\par
 9411     result += qMax(0, qMax(tickLengthOut, subTickLengthOut));\par
 9412   \par
 9413   // calculate size of tick labels:\par
 9414   if (tickLabelSide == QCPAxis::lsOutside)\par
 9415   \{\par
 9416     QSize tickLabelsSize(0, 0);\par
 9417     if (!tickLabels.isEmpty())\par
 9418     \{\par
 9419       for (int i=0; i<tickLabels.size(); ++i)\par
 9420         getMaxTickLabelSize(tickLabelFont, tickLabels.at(i), &tickLabelsSize);\par
 9421       result += QCPAxis::orientation(type) == Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width();\par
 9422     result += tickLabelPadding;\par
 9423     \}\par
 9424   \}\par
 9425   \par
 9426   // calculate size of axis label (only height needed, because left/right labels are rotated by 90 degrees):\par
 9427   if (!label.isEmpty())\par
 9428   \{\par
 9429     QFontMetrics fontMetrics(labelFont);\par
 9430     QRect bounds;\par
 9431     bounds = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip | Qt::AlignHCenter | Qt::AlignVCenter, label);\par
 9432     result += bounds.height() + labelPadding;\par
 9433   \}\par
 9434   \par
 9435   return result;\par
 9436 \}\par
}
}
{\xe \v tickLabelsSelectionBox\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickLabelsSelectionBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::tickLabelsSelectionBox () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2227 \{ return mTickLabelsSelectionBox; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v abbreviateDecimalPowers\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:abbreviateDecimalPowers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisPainterPrivate::abbreviateDecimalPowers}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v axisRect\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:axisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::axisRect}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basePen\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:basePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxisPainterPrivate::basePen}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v label\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisPainterPrivate::label}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v labelColor\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:labelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxisPainterPrivate::labelColor}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v labelFont\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:labelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxisPainterPrivate::labelFont}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v labelPadding\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:labelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisPainterPrivate::labelPadding}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lowerEnding\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:lowerEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPAxisPainterPrivate::lowerEnding}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAxisSelectionBox\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:mAxisSelectionBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::mAxisSelectionBox{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLabelCache\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:mLabelCache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCache<QString, {\b CachedLabel}> QCPAxisPainterPrivate::mLabelCache{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLabelParameterHash\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:mLabelParameterHash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QByteArray QCPAxisPainterPrivate::mLabelParameterHash{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLabelSelectionBox\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:mLabelSelectionBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::mLabelSelectionBox{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPAxisPainterPrivate::mParentPlot{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickLabelsSelectionBox\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:mTickLabelsSelectionBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::mTickLabelsSelectionBox{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v numberMultiplyCross\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:numberMultiplyCross}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisPainterPrivate::numberMultiplyCross}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisPainterPrivate::offset}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reversedEndings\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:reversedEndings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisPainterPrivate::reversedEndings}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v substituteExponent\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:substituteExponent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisPainterPrivate::substituteExponent}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v subTickLengthIn\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:subTickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisPainterPrivate::subTickLengthIn}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v subTickLengthOut\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:subTickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisPainterPrivate::subTickLengthOut}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v subTickPen\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:subTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxisPainterPrivate::subTickPen}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v subTickPositions\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:subTickPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<double> QCPAxisPainterPrivate::subTickPositions}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickLabelColor\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxisPainterPrivate::tickLabelColor}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickLabelFont\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxisPainterPrivate::tickLabelFont}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickLabelPadding\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickLabelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisPainterPrivate::tickLabelPadding}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickLabelRotation\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickLabelRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisPainterPrivate::tickLabelRotation}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickLabels\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<QString> QCPAxisPainterPrivate::tickLabels}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickLabelSide\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickLabelSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::LabelSide} QCPAxisPainterPrivate::tickLabelSide}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickLengthIn\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisPainterPrivate::tickLengthIn}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickLengthOut\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisPainterPrivate::tickLengthOut}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickPen\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxisPainterPrivate::tickPen}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tickPositions\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:tickPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<double> QCPAxisPainterPrivate::tickPositions}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v type\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::AxisType} QCPAxisPainterPrivate::type}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v upperEnding\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:upperEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPAxisPainterPrivate::upperEnding}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v viewportRect\:QCPAxisPainterPrivate}
{\xe \v QCPAxisPainterPrivate\:viewportRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::viewportRect}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisRect Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisRect}
{\xe \v QCPAxisRect}
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds multiple axes and arranges them in a rectangular shape. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAxisRect:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_rect__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAxisRect:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_rect__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} ({\b QCustomPlot} *{\b parentPlot}, bool setupDefaultAxes=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAxisRect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b background} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b backgroundBrush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b backgroundScaled} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b backgroundScaledMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientations {\b rangeDrag} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientations {\b rangeZoom} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b rangeDragAxis} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b rangeZoomAxis} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b rangeDragAxes} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b rangeZoomAxes} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b rangeZoomFactor} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QPixmap &pm)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode=Qt::KeepAspectRatioByExpanding)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QBrush &brush)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackgroundScaled} (bool scaled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackgroundScaledMode} (Qt::AspectRatioMode mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeDrag} (Qt::Orientations orientations)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoom} (Qt::Orientations orientations)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeDragAxes} ({\b QCPAxis} *horizontal, {\b QCPAxis} *vertical)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeDragAxes} (QList< {\b QCPAxis} *> {\b axes})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeDragAxes} (QList< {\b QCPAxis} *> horizontal, QList< {\b QCPAxis} *> vertical)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomAxes} ({\b QCPAxis} *horizontal, {\b QCPAxis} *vertical)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomAxes} (QList< {\b QCPAxis} *> {\b axes})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomAxes} (QList< {\b QCPAxis} *> horizontal, QList< {\b QCPAxis} *> vertical)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomFactor} (double horizontalFactor, double verticalFactor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomFactor} (double factor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b axisCount} ({\b QCPAxis::AxisType} type) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b axis} ({\b QCPAxis::AxisType} type, int index=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b axes} (QCPAxis::AxisTypes types) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b axes} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b addAxis} ({\b QCPAxis::AxisType} type, {\b QCPAxis} *{\b axis}=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b addAxes} (QCPAxis::AxisTypes types)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeAxis} ({\b QCPAxis} *{\b axis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutInset} * {\b insetLayout} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b zoom} (const QRectF &pixelRect)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b zoom} (const QRectF &pixelRect, const QList< {\b QCPAxis} *> &affectedAxes)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupFullAxesBox} (bool connectRanges=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractPlottable} * > {\b plottables} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPGraph} * > {\b graphs} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractItem} * > {\b items} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b left} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b right} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b top} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bottom} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b width} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b height} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b topLeft} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b topRight} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b bottomLeft} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b bottomRight} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b center} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b update} ({\b UpdatePhase} phase) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QList< {\b QCPLayoutElement} * > {\b elements} (bool recursive) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b calculateAutoMargin} ({\b QCP::MarginSide} side) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b layoutChanged} () {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event, const QPointF &startPos) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawBackground} ({\b QCPPainter} *painter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateAxesOffset} ({\b QCPAxis::AxisType} type)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBackgroundBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mBackgroundPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mScaledBackgroundPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mBackgroundScaled}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b mBackgroundScaledMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutInset} * {\b mInsetLayout}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientations {\b mRangeDrag}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientations {\b mRangeZoom}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QPointer< {\b QCPAxis} > > {\b mRangeDragHorzAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QPointer< {\b QCPAxis} > > {\b mRangeDragVertAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QPointer< {\b QCPAxis} > > {\b mRangeZoomHorzAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QPointer< {\b QCPAxis} > > {\b mRangeZoomVertAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mRangeZoomFactorHorz}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mRangeZoomFactorVert}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPRange} > {\b mDragStartHorzRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPRange} > {\b mDragStartVertRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mAADragBackup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mNotAADragBackup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mDragging}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QHash< {\b QCPAxis::AxisType}, QList< {\b QCPAxis} * > > {\b mAxes}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds multiple axes and arranges them in a rectangular shape. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class represents an axis rect, a rectangular area that is bounded on all sides with an arbitrary number of axes.\par
Initially {\b QCustomPlot} has one axis rect, accessible via {\b QCustomPlot::axisRect()}. However, the layout system allows to have multiple axis rects, e.g. arranged in a grid layout ({\b QCustomPlot::plotLayout}).\par
By default, {\b QCPAxisRect} comes with four axes, at bottom, top, left and right. They can be accessed via {\b axis} by providing the respective axis type ({\b QCPAxis::AxisType}) and index. If you need all axes in the axis rect, use {\b axes}. The top and right axes are set to be invisible initially ({\b QCPAxis::setVisible}). To add more axes to a side, use {\b addAxis} or {\b addAxes}. To remove an axis, use {\b removeAxis}.\par
The axis rect layerable itself only draws a background pixmap or color, if specified ({\b setBackground}). It is placed on the "background" layer initially (see {\b QCPLayer} for an explanation of the {\b QCustomPlot} layer system). The axes that are held by the axis rect can be placed on other layers, independently of the axis rect.\par
Every axis rect has a child layout of type {\b QCPLayoutInset}. It is accessible via {\b insetLayout} and can be used to have other layout elements (or even other layouts with multiple elements) hovering inside the axis rect.\par
If an axis rect is clicked and dragged, it processes this by moving certain axis ranges. The behaviour can be controlled with {\b setRangeDrag} and {\b setRangeDragAxes}. If the mouse wheel is scrolled while the cursor is on the axis rect, certain axes are scaled. This is controllable via {\b setRangeZoom}, {\b setRangeZoomAxes} and {\b setRangeZoomFactor}. These interactions are only enabled if {\b QCustomPlot::setInteractions} contains {\b QCP::iRangeDrag} and {\b QCP::iRangeZoom}.\par
 {\qc Overview of the spacings and paddings that define the geometry of an axis. The dashed line on the far left indicates the viewport/widget border.}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxisRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:QCPAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisRect::QCPAxisRect ({\b QCustomPlot} *  {\i parentPlot}, bool  {\i setupDefaultAxes} = {\f2 true}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPAxisRect} instance and sets default values. An axis is added for each of the four sides, the top and right axes are set invisible initially. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16780                                                                        :\par
16781   QCPLayoutElement(parentPlot),\par
16782   mBackgroundBrush(Qt::NoBrush),\par
16783   mBackgroundScaled(true),\par
16784   mBackgroundScaledMode(Qt::KeepAspectRatioByExpanding),\par
16785   mInsetLayout(new QCPLayoutInset),\par
16786   mRangeDrag(Qt::Horizontal|Qt::Vertical),\par
16787   mRangeZoom(Qt::Horizontal|Qt::Vertical),\par
16788   mRangeZoomFactorHorz(0.85),\par
16789   mRangeZoomFactorVert(0.85),\par
16790   mDragging(false)\par
16791 \{\par
16792   mInsetLayout->initializeParentPlot(mParentPlot);\par
16793   mInsetLayout->setParentLayerable(this);\par
16794   mInsetLayout->setParent(this);\par
16795   \par
16796   setMinimumSize(50, 50);\par
16797   setMinimumMargins(QMargins(15, 15, 15, 15));\par
16798   mAxes.insert(QCPAxis::atLeft, QList<QCPAxis*>());\par
16799   mAxes.insert(QCPAxis::atRight, QList<QCPAxis*>());\par
16800   mAxes.insert(QCPAxis::atTop, QList<QCPAxis*>());\par
16801   mAxes.insert(QCPAxis::atBottom, QList<QCPAxis*>());\par
16802   \par
16803   if (setupDefaultAxes)\par
16804   \{\par
16805     QCPAxis *xAxis = addAxis(QCPAxis::atBottom);\par
16806     QCPAxis *yAxis = addAxis(QCPAxis::atLeft);\par
16807     QCPAxis *xAxis2 = addAxis(QCPAxis::atTop);\par
16808     QCPAxis *yAxis2 = addAxis(QCPAxis::atRight);\par
16809     setRangeDragAxes(xAxis, yAxis);\par
16810     setRangeZoomAxes(xAxis, yAxis);\par
16811     xAxis2->setVisible(false);\par
16812     yAxis2->setVisible(false);\par
16813     xAxis->grid()->setVisible(true);\par
16814     yAxis->grid()->setVisible(true);\par
16815     xAxis2->grid()->setVisible(false);\par
16816     yAxis2->grid()->setVisible(false);\par
16817     xAxis2->grid()->setZeroLinePen(Qt::NoPen);\par
16818     yAxis2->grid()->setZeroLinePen(Qt::NoPen);\par
16819     xAxis2->grid()->setVisible(false);\par
16820     yAxis2->grid()->setVisible(false);\par
16821   \}\par
16822 \}\par
}
}
{\xe \v ~QCPAxisRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:~QCPAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisRect::~QCPAxisRect (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16825 \{\par
16826   delete mInsetLayout;\par
16827   mInsetLayout = 0;\par
16828   \par
16829   QList<QCPAxis*> axesList = axes();\par
16830   for (int i=0; i<axesList.size(); ++i)\par
16831     removeAxis(axesList.at(i));\par
16832 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:addAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::addAxes (QCPAxis::AxisTypes  {\i types})}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new axis with {\b addAxis} to each axis rect side specified in {\i types} . This may be an {\f2 or} -combination of {\b QCPAxis::AxisType}, so axes can be added to multiple sides at once.\par
Returns a list of the added axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addAxis}, {\b setupFullAxesBox} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16976 \{\par
16977   QList<QCPAxis*> result;\par
16978   if (types.testFlag(QCPAxis::atLeft))\par
16979     result << addAxis(QCPAxis::atLeft);\par
16980   if (types.testFlag(QCPAxis::atRight))\par
16981     result << addAxis(QCPAxis::atRight);\par
16982   if (types.testFlag(QCPAxis::atTop))\par
16983     result << addAxis(QCPAxis::atTop);\par
16984   if (types.testFlag(QCPAxis::atBottom))\par
16985     result << addAxis(QCPAxis::atBottom);\par
16986   return result;\par
16987 \}\par
}
}
{\xe \v addAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:addAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCPAxisRect::addAxis ({\b QCPAxis::AxisType}  {\i type}, {\b QCPAxis} *  {\i axis} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new axis to the axis rect side specified with {\i type} , and returns it. If {\i axis}  is 0, a new {\b QCPAxis} instance is created internally. {\b QCustomPlot} owns the returned axis, so if you want to remove an axis, use {\b removeAxis} instead of deleting it manually.\par
You may inject {\b QCPAxis} instances (or subclasses of {\b QCPAxis}) by setting {\i axis}  to an axis that was previously created outside {\b QCustomPlot}. It is important to note that {\b QCustomPlot} takes ownership of the axis, so you may not delete it afterwards. Further, the {\i axis}  must have been created with this axis rect as parent and with the same axis type as specified in {\i type} . If this is not the case, a debug output is generated, the axis is not added, and the method returns 0.\par
This method can not be used to move {\i axis}  between axis rects. The same {\i axis}  instance must not be added multiple times to the same or different axis rects.\par
If an axis rect side already contains one or more axes, the lower and upper endings of the new axis ({\b QCPAxis::setLowerEnding}, {\b QCPAxis::setUpperEnding}) are set to {\b QCPLineEnding::esHalfBar}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addAxes}, {\b setupFullAxesBox} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16921 \{\par
16922   QCPAxis *newAxis = axis;\par
16923   if (!newAxis)\par
16924   \{\par
16925     newAxis = new QCPAxis(this, type);\par
16926   \} else // user provided existing axis instance, do some sanity checks\par
16927   \{\par
16928     if (newAxis->axisType() != type)\par
16929     \{\par
16930       qDebug() << Q_FUNC_INFO << "passed axis has different axis type than specified in type parameter";\par
16931       return 0;\par
16932     \}\par
16933     if (newAxis->axisRect() != this)\par
16934     \{\par
16935       qDebug() << Q_FUNC_INFO << "passed axis doesn't have this axis rect as parent axis rect";\par
16936       return 0;\par
16937     \}\par
16938     if (axes().contains(newAxis))\par
16939     \{\par
16940       qDebug() << Q_FUNC_INFO << "passed axis is already owned by this axis rect";\par
16941       return 0;\par
16942     \}\par
16943   \}\par
16944   if (mAxes[type].size() > 0) // multiple axes on one side, add half-bar axis ending to additional axes with offset\par
16945   \{\par
16946     bool invert = (type == QCPAxis::atRight) || (type == QCPAxis::atBottom);\par
16947     newAxis->setLowerEnding(QCPLineEnding(QCPLineEnding::esHalfBar, 6, 10, !invert));\par
16948     newAxis->setUpperEnding(QCPLineEnding(QCPLineEnding::esHalfBar, 6, 10, invert));\par
16949   \}\par
16950   mAxes[type].append(newAxis);\par
16951   \par
16952   // reset convenience axis pointers on parent QCustomPlot if they are unset:\par
16953   if (mParentPlot && mParentPlot->axisRectCount() > 0 && mParentPlot->axisRect(0) == this)\par
16954   \{\par
16955     switch (type)\par
16956     \{\par
16957       case QCPAxis::atBottom: \{ if (!mParentPlot->xAxis) mParentPlot->xAxis = newAxis; break; \}\par
16958       case QCPAxis::atLeft: \{ if (!mParentPlot->yAxis) mParentPlot->yAxis = newAxis; break; \}\par
16959       case QCPAxis::atTop: \{ if (!mParentPlot->xAxis2) mParentPlot->xAxis2 = newAxis; break; \}\par
16960       case QCPAxis::atRight: \{ if (!mParentPlot->yAxis2) mParentPlot->yAxis2 = newAxis; break; \}\par
16961     \}\par
16962   \}\par
16963   \par
16964   return newAxis;\par
16965 \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPAxisRect}
{\xe \v QCPAxisRect\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17258 \{\par
17259   painter->setAntialiasing(false);\par
17260 \}\par
}
}
{\xe \v axes\:QCPAxisRect}
{\xe \v QCPAxisRect\:axes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::axes (QCPAxis::AxisTypes  {\i types}) const}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all axes on the axis rect sides specified with {\i types} .\par
{\i types}  may be a single {\b QCPAxis::AxisType} or an {\f2 or} -combination, to get the axes of multiple sides.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16871 \{\par
16872   QList<QCPAxis*> result;\par
16873   if (types.testFlag(QCPAxis::atLeft))\par
16874     result << mAxes.value(QCPAxis::atLeft);\par
16875   if (types.testFlag(QCPAxis::atRight))\par
16876     result << mAxes.value(QCPAxis::atRight);\par
16877   if (types.testFlag(QCPAxis::atTop))\par
16878     result << mAxes.value(QCPAxis::atTop);\par
16879   if (types.testFlag(QCPAxis::atBottom))\par
16880     result << mAxes.value(QCPAxis::atBottom);\par
16881   return result;\par
16882 \}\par
}
}
{\xe \v axes\:QCPAxisRect}
{\xe \v QCPAxisRect\:axes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::axes () const}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns all axes of this axis rect. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16889 \{\par
16890   QList<QCPAxis*> result;\par
16891   QHashIterator<QCPAxis::AxisType, QList<QCPAxis*> > it(mAxes);\par
16892   while (it.hasNext())\par
16893   \{\par
16894     it.next();\par
16895     result << it.value();\par
16896   \}\par
16897   return result;\par
16898 \}\par
}
}
{\xe \v axis\:QCPAxisRect}
{\xe \v QCPAxisRect\:axis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCPAxisRect::axis ({\b QCPAxis::AxisType}  {\i type}, int  {\i index} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the axis with the given {\i index}  on the axis rect side specified with {\i type} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisCount}, {\b axes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16850 \{\par
16851   QList<QCPAxis*> ax(mAxes.value(type));\par
16852   if (index >= 0 && index < ax.size())\par
16853   \{\par
16854     return ax.at(index);\par
16855   \} else\par
16856   \{\par
16857     qDebug() << Q_FUNC_INFO << "Axis index out of bounds:" << index;\par
16858     return 0;\par
16859   \}\par
16860 \}\par
}
}
{\xe \v axisCount\:QCPAxisRect}
{\xe \v QCPAxisRect\:axisCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::axisCount ({\b QCPAxis::AxisType}  {\i type}) const}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of axes on the axis rect side specified with {\i type} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16840 \{\par
16841   return mAxes.value(type).size();\par
16842 \}\par
}
}
{\xe \v background\:QCPAxisRect}
{\xe \v QCPAxisRect\:background}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPAxisRect::background () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4597 \{ return mBackgroundPixmap; \}\par
}
}
{\xe \v backgroundBrush\:QCPAxisRect}
{\xe \v QCPAxisRect\:backgroundBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAxisRect::backgroundBrush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4598 \{ return mBackgroundBrush; \}\par
}
}
{\xe \v backgroundScaled\:QCPAxisRect}
{\xe \v QCPAxisRect\:backgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisRect::backgroundScaled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4599 \{ return mBackgroundScaled; \}\par
}
}
{\xe \v backgroundScaledMode\:QCPAxisRect}
{\xe \v QCPAxisRect\:backgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCPAxisRect::backgroundScaledMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4600 \{ return mBackgroundScaledMode; \}\par
}
}
{\xe \v bottom\:QCPAxisRect}
{\xe \v QCPAxisRect\:bottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::bottom () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position of the bottom border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4647 \{ return mRect.bottom(); \}\par
}
}
{\xe \v bottomLeft\:QCPAxisRect}
{\xe \v QCPAxisRect\:bottomLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::bottomLeft () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the bottom left corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4653 \{ return mRect.bottomLeft(); \}\par
}
}
{\xe \v bottomRight\:QCPAxisRect}
{\xe \v QCPAxisRect\:bottomRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::bottomRight () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the bottom right corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4654 \{ return mRect.bottomRight(); \}\par
}
}
{\xe \v calculateAutoMargin\:QCPAxisRect}
{\xe \v QCPAxisRect\:calculateAutoMargin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::calculateAutoMargin ({\b QCP::MarginSide}  {\i side}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17720 \{\par
17721   if (!mAutoMargins.testFlag(side))\par
17722     qDebug() << Q_FUNC_INFO << "Called with side that isn't specified as auto margin";\par
17723   \par
17724   updateAxesOffset(QCPAxis::marginSideToAxisType(side));\par
17725   \par
17726   // note: only need to look at the last (outer most) axis to determine the total margin, due to updateAxisOffset call\par
17727   const QList<QCPAxis*> axesList = mAxes.value(QCPAxis::marginSideToAxisType(side));\par
17728   if (axesList.size() > 0)\par
17729     return axesList.last()->offset() + axesList.last()->calculateMargin();\par
17730   else\par
17731     return 0;\par
17732 \}\par
}
}
{\xe \v center\:QCPAxisRect}
{\xe \v QCPAxisRect\:center}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::center () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the center of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4655 \{ return mRect.center(); \}\par
}
}
{\xe \v draw\:QCPAxisRect}
{\xe \v QCPAxisRect\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b QCPColorScaleAxisRectPrivate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17264 \{\par
17265   drawBackground(painter);\par
17266 \}\par
}
}
{\xe \v drawBackground\:QCPAxisRect}
{\xe \v QCPAxisRect\:drawBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::drawBackground ({\b QCPPainter} *  {\i painter}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17665 \{\par
17666   // draw background fill:\par
17667   if (mBackgroundBrush != Qt::NoBrush)\par
17668     painter->fillRect(mRect, mBackgroundBrush);\par
17669   \par
17670   // draw background pixmap (on top of fill, if brush specified):\par
17671   if (!mBackgroundPixmap.isNull())\par
17672   \{\par
17673     if (mBackgroundScaled)\par
17674     \{\par
17675       // check whether mScaledBackground needs to be updated:\par
17676       QSize scaledSize(mBackgroundPixmap.size());\par
17677       scaledSize.scale(mRect.size(), mBackgroundScaledMode);\par
17678       if (mScaledBackgroundPixmap.size() != scaledSize)\par
17679         mScaledBackgroundPixmap = mBackgroundPixmap.scaled(mRect.size(), mBackgroundScaledMode, Qt::SmoothTransformation);\par
17680       painter->drawPixmap(mRect.topLeft()+QPoint(0, -1), mScaledBackgroundPixmap, QRect(0, 0, mRect.width(), mRect.height()) & mScaledBackgroundPixmap.rect());\par
17681     \} else\par
17682     \{\par
17683       painter->drawPixmap(mRect.topLeft()+QPoint(0, -1), mBackgroundPixmap, QRect(0, 0, mRect.width(), mRect.height()));\par
17684     \}\par
17685   \}\par
17686 \}\par
}
}
{\xe \v elements\:QCPAxisRect}
{\xe \v QCPAxisRect\:elements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLayoutElement} * > QCPAxisRect::elements (bool  {\i recursive}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all child elements in this layout element. If {\i recursive}  is true, all sub-child elements are included in the list, too.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid There may be entries with value 0 in the returned list. (For example, {\b QCPLayoutGrid} may have empty cells which yield 0 at the respective index.) \par
}}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17245 \{\par
17246   QList<QCPLayoutElement*> result;\par
17247   if (mInsetLayout)\par
17248   \{\par
17249     result << mInsetLayout;\par
17250     if (recursive)\par
17251       result << mInsetLayout->elements(recursive);\par
17252   \}\par
17253   return result;\par
17254 \}\par
}
}
{\xe \v graphs\:QCPAxisRect}
{\xe \v QCPAxisRect\:graphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPGraph} * > QCPAxisRect::graphs () const}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the graphs that are associated with this axis rect.\par
A graph is considered associated with an axis rect if its key or value axis (or both) is in this axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottables}, {\b items} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17160 \{\par
17161   // Note: don't append all QCPAxis::graphs() into a list, because we might get duplicate entries\par
17162   QList<QCPGraph*> result;\par
17163   for (int i=0; i<mParentPlot->mGraphs.size(); ++i)\par
17164   \{\par
17165     if (mParentPlot->mGraphs.at(i)->keyAxis()->axisRect() == this || mParentPlot->mGraphs.at(i)->valueAxis()->axisRect() == this)\par
17166       result.append(mParentPlot->mGraphs.at(i));\par
17167   \}\par
17168   return result;\par
17169 \}\par
}
}
{\xe \v height\:QCPAxisRect}
{\xe \v QCPAxisRect\:height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::height () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel height of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4649 \{ return mRect.height(); \}\par
}
}
{\xe \v insetLayout\:QCPAxisRect}
{\xe \v QCPAxisRect\:insetLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutInset} * QCPAxisRect::insetLayout () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the inset layout of this axis rect. It can be used to place other layout elements (or even layouts with multiple other elements) inside/on top of an axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPLayoutInset} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4634 \{ return mInsetLayout; \}\par
}
}
{\xe \v items\:QCPAxisRect}
{\xe \v QCPAxisRect\:items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractItem} * > QCPAxisRect::items () const}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the items that are associated with this axis rect.\par
An item is considered associated with an axis rect if any of its positions has key or value axis set to an axis that is in this axis rect, or if any of its positions has {\b QCPItemPosition::setAxisRect} set to the axis rect, or if the clip axis rect ({\b QCPAbstractItem::setClipAxisRect}) is set to this axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottables}, {\b graphs} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17182 \{\par
17183   // Note: don't just append all QCPAxis::items() into a list, because we might get duplicate entries\par
17184   //       and miss those items that have this axis rect as clipAxisRect.\par
17185   QList<QCPAbstractItem*> result;\par
17186   for (int itemId=0; itemId<mParentPlot->mItems.size(); ++itemId)\par
17187   \{\par
17188     if (mParentPlot->mItems.at(itemId)->clipAxisRect() == this)\par
17189     \{\par
17190       result.append(mParentPlot->mItems.at(itemId));\par
17191       continue;\par
17192     \}\par
17193     QList<QCPItemPosition*> positions = mParentPlot->mItems.at(itemId)->positions();\par
17194     for (int posId=0; posId<positions.size(); ++posId)\par
17195     \{\par
17196       if (positions.at(posId)->axisRect() == this ||\par
17197           positions.at(posId)->keyAxis()->axisRect() == this ||\par
17198           positions.at(posId)->valueAxis()->axisRect() == this)\par
17199       \{\par
17200         result.append(mParentPlot->mItems.at(itemId));\par
17201         break;\par
17202       \}\par
17203     \}\par
17204   \}\par
17205   return result;\par
17206 \}\par
}
}
{\xe \v layoutChanged\:QCPAxisRect}
{\xe \v QCPAxisRect\:layoutChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::layoutChanged (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17745 \{\par
17746   if (mParentPlot && mParentPlot->axisRectCount() > 0 && mParentPlot->axisRect(0) == this)\par
17747   \{\par
17748     if (axisCount(QCPAxis::atBottom) > 0 && !mParentPlot->xAxis)\par
17749       mParentPlot->xAxis = axis(QCPAxis::atBottom);\par
17750     if (axisCount(QCPAxis::atLeft) > 0 && !mParentPlot->yAxis)\par
17751       mParentPlot->yAxis = axis(QCPAxis::atLeft);\par
17752     if (axisCount(QCPAxis::atTop) > 0 && !mParentPlot->xAxis2)\par
17753       mParentPlot->xAxis2 = axis(QCPAxis::atTop);\par
17754     if (axisCount(QCPAxis::atRight) > 0 && !mParentPlot->yAxis2)\par
17755       mParentPlot->yAxis2 = axis(QCPAxis::atRight);\par
17756   \}\par
17757 \}\par
}
}
{\xe \v left\:QCPAxisRect}
{\xe \v QCPAxisRect\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::left () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position of the left border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4644 \{ return mRect.left(); \}\par
}
}
{\xe \v mouseMoveEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::mouseMoveEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17803 \{\par
17804   Q_UNUSED(startPos)\par
17805   // Mouse range dragging interaction:\par
17806   if (mDragging && mParentPlot->interactions().testFlag(QCP::iRangeDrag))\par
17807   \{\par
17808     \par
17809     if (mRangeDrag.testFlag(Qt::Horizontal))\par
17810     \{\par
17811       for (int i=0; i<mRangeDragHorzAxis.size(); ++i)\par
17812       \{\par
17813         QCPAxis *ax = mRangeDragHorzAxis.at(i).data();\par
17814         if (!ax)\par
17815           continue;\par
17816         if (i >= mDragStartHorzRange.size())\par
17817           break;\par
17818         if (ax->mScaleType == QCPAxis::stLinear)\par
17819         \{\par
17820           double diff = ax->pixelToCoord(startPos.x()) - ax->pixelToCoord(event->pos().x());\par
17821           ax->setRange(mDragStartHorzRange.at(i).lower+diff, mDragStartHorzRange.at(i).upper+diff);\par
17822         \} else if (ax->mScaleType == QCPAxis::stLogarithmic)\par
17823         \{\par
17824           double diff = ax->pixelToCoord(startPos.x()) / ax->pixelToCoord(event->pos().x());\par
17825           ax->setRange(mDragStartHorzRange.at(i).lower*diff, mDragStartHorzRange.at(i).upper*diff);\par
17826         \}\par
17827       \}\par
17828     \}\par
17829     \par
17830     if (mRangeDrag.testFlag(Qt::Vertical))\par
17831     \{\par
17832       for (int i=0; i<mRangeDragVertAxis.size(); ++i)\par
17833       \{\par
17834         QCPAxis *ax = mRangeDragVertAxis.at(i).data();\par
17835         if (!ax)\par
17836           continue;\par
17837         if (i >= mDragStartVertRange.size())\par
17838           break;\par
17839         if (ax->mScaleType == QCPAxis::stLinear)\par
17840         \{\par
17841           double diff = ax->pixelToCoord(startPos.y()) - ax->pixelToCoord(event->pos().y());\par
17842           ax->setRange(mDragStartVertRange.at(i).lower+diff, mDragStartVertRange.at(i).upper+diff);\par
17843         \} else if (ax->mScaleType == QCPAxis::stLogarithmic)\par
17844         \{\par
17845           double diff = ax->pixelToCoord(startPos.y()) / ax->pixelToCoord(event->pos().y());\par
17846           ax->setRange(mDragStartVertRange.at(i).lower*diff, mDragStartVertRange.at(i).upper*diff);\par
17847         \}\par
17848       \}\par
17849     \}\par
17850     \par
17851     if (mRangeDrag != 0) // if either vertical or horizontal drag was enabled, do a replot\par
17852     \{\par
17853       if (mParentPlot->noAntialiasingOnDrag())\par
17854         mParentPlot->setNotAntialiasedElements(QCP::aeAll);\par
17855       mParentPlot->replot(QCustomPlot::rpQueuedReplot);\par
17856     \}\par
17857     \par
17858   \}\par
17859 \}\par
}
}
{\xe \v mousePressEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::mousePressEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
{\b QCustomPlot} uses an event propagation system that works the same as Qt's system. If your layerable doesn't reimplement the {\b mousePressEvent} or explicitly calls {\f2 event->ignore()}  in its reimplementation, the event will be propagated to the next layerable in the stacking order.\par
Once a layerable has accepted the {\b mousePressEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} or {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17771 \{\par
17772   Q_UNUSED(details)\par
17773   if (event->buttons() & Qt::LeftButton)\par
17774   \{\par
17775     mDragging = true;\par
17776     // initialize antialiasing backup in case we start dragging:\par
17777     if (mParentPlot->noAntialiasingOnDrag())\par
17778     \{\par
17779       mAADragBackup = mParentPlot->antialiasedElements();\par
17780       mNotAADragBackup = mParentPlot->notAntialiasedElements();\par
17781     \}\par
17782     // Mouse range dragging interaction:\par
17783     if (mParentPlot->interactions().testFlag(QCP::iRangeDrag))\par
17784     \{\par
17785       mDragStartHorzRange.clear();\par
17786       for (int i=0; i<mRangeDragHorzAxis.size(); ++i)\par
17787         mDragStartHorzRange.append(mRangeDragHorzAxis.at(i).isNull() ? QCPRange() : mRangeDragHorzAxis.at(i)->range());\par
17788       mDragStartVertRange.clear();\par
17789       for (int i=0; i<mRangeDragVertAxis.size(); ++i)\par
17790         mDragStartVertRange.append(mRangeDragVertAxis.at(i).isNull() ? QCPRange() : mRangeDragVertAxis.at(i)->range());\par
17791     \}\par
17792   \}\par
17793 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::mouseReleaseEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17863 \{\par
17864   Q_UNUSED(event)\par
17865   Q_UNUSED(startPos)\par
17866   mDragging = false;\par
17867   if (mParentPlot->noAntialiasingOnDrag())\par
17868   \{\par
17869     mParentPlot->setAntialiasedElements(mAADragBackup);\par
17870     mParentPlot->setNotAntialiasedElements(mNotAADragBackup);\par
17871   \}\par
17872 \}\par
}
}
{\xe \v plottables\:QCPAxisRect}
{\xe \v QCPAxisRect\:plottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractPlottable} * > QCPAxisRect::plottables () const}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the plottables that are associated with this axis rect.\par
A plottable is considered associated with an axis rect if its key or value axis (or both) is in this axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graphs}, {\b items} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17140 \{\par
17141   // Note: don't append all QCPAxis::plottables() into a list, because we might get duplicate entries\par
17142   QList<QCPAbstractPlottable*> result;\par
17143   for (int i=0; i<mParentPlot->mPlottables.size(); ++i)\par
17144   \{\par
17145     if (mParentPlot->mPlottables.at(i)->keyAxis()->axisRect() == this || mParentPlot->mPlottables.at(i)->valueAxis()->axisRect() == this)\par
17146       result.append(mParentPlot->mPlottables.at(i));\par
17147   \}\par
17148   return result;\par
17149 \}\par
}
}
{\xe \v rangeDrag\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientations QCPAxisRect::rangeDrag () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4601 \{ return mRangeDrag; \}\par
}
}
{\xe \v rangeDragAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeDragAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::rangeDragAxes (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all range drag axes of the {\i orientation}  provided.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rangeZoomAxis}, {\b setRangeZoomAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17381 \{\par
17382   QList<QCPAxis*> result;\par
17383   if (orientation == Qt::Horizontal)\par
17384   \{\par
17385     for (int i=0; i<mRangeDragHorzAxis.size(); ++i)\par
17386     \{\par
17387       if (!mRangeDragHorzAxis.at(i).isNull())\par
17388         result.append(mRangeDragHorzAxis.at(i).data());\par
17389     \}\par
17390   \} else\par
17391   \{\par
17392     for (int i=0; i<mRangeDragVertAxis.size(); ++i)\par
17393     \{\par
17394       if (!mRangeDragVertAxis.at(i).isNull())\par
17395         result.append(mRangeDragVertAxis.at(i).data());\par
17396     \}\par
17397   \}\par
17398   return result;\par
17399 \}\par
}
}
{\xe \v rangeDragAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeDragAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCPAxisRect::rangeDragAxis (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range drag axis of the {\i orientation}  provided. If multiple axes were set, returns the first one (use {\b rangeDragAxes} to retrieve a list with all set axes).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeDragAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17354 \{\par
17355   if (orientation == Qt::Horizontal)\par
17356     return mRangeDragHorzAxis.isEmpty() ? 0 : mRangeDragHorzAxis.first().data();\par
17357   else\par
17358     return mRangeDragVertAxis.isEmpty() ? 0 : mRangeDragVertAxis.first().data();\par
17359 \}\par
}
}
{\xe \v rangeZoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientations QCPAxisRect::rangeZoom () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4602 \{ return mRangeZoom; \}\par
}
}
{\xe \v rangeZoomAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeZoomAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::rangeZoomAxes (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all range zoom axes of the {\i orientation}  provided.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rangeDragAxis}, {\b setRangeDragAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17407 \{\par
17408   QList<QCPAxis*> result;\par
17409   if (orientation == Qt::Horizontal)\par
17410   \{\par
17411     for (int i=0; i<mRangeZoomHorzAxis.size(); ++i)\par
17412     \{\par
17413       if (!mRangeZoomHorzAxis.at(i).isNull())\par
17414         result.append(mRangeZoomHorzAxis.at(i).data());\par
17415     \}\par
17416   \} else\par
17417   \{\par
17418     for (int i=0; i<mRangeZoomVertAxis.size(); ++i)\par
17419     \{\par
17420       if (!mRangeZoomVertAxis.at(i).isNull())\par
17421         result.append(mRangeZoomVertAxis.at(i).data());\par
17422     \}\par
17423   \}\par
17424   return result;\par
17425 \}\par
}
}
{\xe \v rangeZoomAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeZoomAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCPAxisRect::rangeZoomAxis (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range zoom axis of the {\i orientation}  provided. If multiple axes were set, returns the first one (use {\b rangeZoomAxes} to retrieve a list with all set axes).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoomAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17368 \{\par
17369   if (orientation == Qt::Horizontal)\par
17370     return mRangeZoomHorzAxis.isEmpty() ? 0 : mRangeZoomHorzAxis.first().data();\par
17371   else\par
17372     return mRangeZoomVertAxis.isEmpty() ? 0 : mRangeZoomVertAxis.first().data();\par
17373 \}\par
}
}
{\xe \v rangeZoomFactor\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeZoomFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisRect::rangeZoomFactor (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range zoom factor of the {\i orientation}  provided.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoomFactor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17433 \{\par
17434   return (orientation == Qt::Horizontal ? mRangeZoomFactorHorz : mRangeZoomFactorVert);\par
17435 \}\par
}
}
{\xe \v removeAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:removeAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisRect::removeAxis ({\b QCPAxis} *  {\i axis})}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i axis}  from the axis rect and deletes it.\par
Returns true on success, i.e. if {\i axis}  was a valid axis in this axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addAxis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16997 \{\par
16998   // don't access axis->axisType() to provide safety when axis is an invalid pointer, rather go through all axis containers:\par
16999   QHashIterator<QCPAxis::AxisType, QList<QCPAxis*> > it(mAxes);\par
17000   while (it.hasNext())\par
17001   \{\par
17002     it.next();\par
17003     if (it.value().contains(axis))\par
17004     \{\par
17005       if (it.value().first() == axis && it.value().size() > 1) // if removing first axis, transfer axis offset to the new first axis (which at this point is the second axis, if it exists)\par
17006         it.value()[1]->setOffset(axis->offset());\par
17007       mAxes[it.key()].removeOne(axis);\par
17008       if (qobject_cast<QCustomPlot*>(parentPlot())) // make sure this isn't called from QObject dtor when QCustomPlot is already destructed (happens when the axis rect is not in any layout and thus QObject-child of QCustomPlot)\par
17009         parentPlot()->axisRemoved(axis);\par
17010       delete axis;\par
17011       return true;\par
17012     \}\par
17013   \}\par
17014   qDebug() << Q_FUNC_INFO << "Axis isn't in axis rect:" << reinterpret_cast<quintptr>(axis);\par
17015   return false;\par
17016 \}\par
}
}
{\xe \v right\:QCPAxisRect}
{\xe \v QCPAxisRect\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::right () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position of the right border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4645 \{ return mRect.right(); \}\par
}
}
{\xe \v setBackground\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackground (const QPixmap &  {\i pm})}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets {\i pm}  as the axis background pixmap. The axis background pixmap will be drawn inside the axis rect. Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds are usually drawn below everything else.\par
For cases where the provided pixmap doesn't have the same size as the axis rect, scaling can be enabled with {\b setBackgroundScaled} and the scaling mode (i.e. whether and how the aspect ratio is preserved) can be set with {\b setBackgroundScaledMode}. To set all these options in one call, consider using the overloaded version of this function.\par
Below the pixmap, the axis rect may be optionally filled with a brush, if specified with {\b setBackground(const QBrush &brush)}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackgroundScaled}, {\b setBackgroundScaledMode}, {\b setBackground(const QBrush &brush)} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17284 \{\par
17285   mBackgroundPixmap = pm;\par
17286   mScaledBackgroundPixmap = QPixmap();\par
17287 \}\par
}
}
{\xe \v setBackground\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackground (const QPixmap &  {\i pm}, bool  {\i scaled}, Qt::AspectRatioMode  {\i mode} = {\f2 Qt::KeepAspectRatioByExpanding})}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Allows setting the background pixmap of the axis rect, whether it shall be scaled and how it shall be scaled in one call.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground(const QPixmap &pm)}, {\b setBackgroundScaled}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17315 \{\par
17316   mBackgroundPixmap = pm;\par
17317   mScaledBackgroundPixmap = QPixmap();\par
17318   mBackgroundScaled = scaled;\par
17319   mBackgroundScaledMode = mode;\par
17320 \}\par
}
}
{\xe \v setBackground\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackground (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets {\i brush}  as the background brush. The axis rect background will be filled with this brush. Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds are usually drawn below everything else.\par
The brush will be drawn before (under) any background pixmap, which may be specified with {\b setBackground(const QPixmap &pm)}.\par
To disable drawing of a background brush, set {\i brush}  to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground(const QPixmap &pm)} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17303 \{\par
17304   mBackgroundBrush = brush;\par
17305 \}\par
}
}
{\xe \v setBackgroundScaled\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackgroundScaled (bool  {\i scaled})}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the axis background pixmap shall be scaled to fit the axis rect or not. If {\i scaled}  is set to true, you may control whether and how the aspect ratio of the original pixmap is preserved with {\b setBackgroundScaledMode}.\par
Note that the scaled version of the original pixmap is buffered, so there is no performance penalty on replots. (Except when the axis rect dimensions are changed continuously.)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17333 \{\par
17334   mBackgroundScaled = scaled;\par
17335 \}\par
}
}
{\xe \v setBackgroundScaledMode\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackgroundScaledMode (Qt::AspectRatioMode  {\i mode})}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If scaling of the axis background pixmap is enabled ({\b setBackgroundScaled}), use this function to define whether and how the aspect ratio of the original pixmap passed to {\b setBackground} is preserved. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground}, {\b setBackgroundScaled} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17343 \{\par
17344   mBackgroundScaledMode = mode;\par
17345 \}\par
}
}
{\xe \v setRangeDrag\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeDrag (Qt::Orientations  {\i orientations})}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which axis orientation may be range dragged by the user with mouse interaction. What orientation corresponds to which specific axis can be set with {\b setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical)}. By default, the horizontal axis is the bottom axis (xAxis) and the vertical axis is the left axis (yAxis).\par
To disable range dragging entirely, pass 0 as {\i orientations}  or remove {\b QCP::iRangeDrag} from {\b QCustomPlot::setInteractions}. To enable range dragging for both directions, pass {\f2 Qt::Horizontal | Qt::Vertical}  as {\i orientations} .\par
In addition to setting {\i orientations}  to a non-zero value, make sure {\b QCustomPlot::setInteractions} contains {\b QCP::iRangeDrag} to enable the range dragging interaction.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoom}, {\b setRangeDragAxes}, {\b QCustomPlot::setNoAntialiasingOnDrag} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17454 \{\par
17455   mRangeDrag = orientations;\par
17456 \}\par
}
}
{\xe \v setRangeDragAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeDragAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeDragAxes ({\b QCPAxis} *  {\i horizontal}, {\b QCPAxis} *  {\i vertical})}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the axes whose range will be dragged when {\b setRangeDrag} enables mouse range dragging on the {\b QCustomPlot} widget. Pass 0 if no axis shall be dragged in the respective orientation.\par
Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall react to dragging interactions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoomAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17489 \{\par
17490   QList<QCPAxis*> horz, vert;\par
17491   if (horizontal)\par
17492     horz.append(horizontal);\par
17493   if (vertical)\par
17494     vert.append(vertical);\par
17495   setRangeDragAxes(horz, vert);\par
17496 \}\par
}
}
{\xe \v setRangeDragAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeDragAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeDragAxes (QList< {\b QCPAxis} *>  {\i axes})}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
This method allows to set up multiple axes to react to horizontal and vertical dragging. The drag orientation that the respective axis will react to is deduced from its orientation ({\b QCPAxis::orientation}).\par
In the unusual case that you wish to e.g. drag a vertically oriented axis with a horizontal drag motion, use the overload taking two separate lists for horizontal and vertical dragging. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17508 \{\par
17509   QList<QCPAxis*> horz, vert;\par
17510   foreach (QCPAxis *ax, axes)\par
17511   \{\par
17512     if (ax->orientation() == Qt::Horizontal)\par
17513       horz.append(ax);\par
17514     else\par
17515       vert.append(ax);\par
17516   \}\par
17517   setRangeDragAxes(horz, vert);\par
17518 \}\par
}
}
{\xe \v setRangeDragAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeDragAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeDragAxes (QList< {\b QCPAxis} *>  {\i horizontal}, QList< {\b QCPAxis} *>  {\i vertical})}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
This method allows to set multiple axes up to react to horizontal and vertical dragging, and define specifically which axis reacts to which drag orientation (irrespective of the axis orientation). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17527 \{\par
17528   mRangeDragHorzAxis.clear();\par
17529   foreach (QCPAxis *ax, horizontal)\par
17530   \{\par
17531     QPointer<QCPAxis> axPointer(ax);\par
17532     if (!axPointer.isNull())\par
17533       mRangeDragHorzAxis.append(axPointer);\par
17534     else\par
17535       qDebug() << Q_FUNC_INFO << "invalid axis passed in horizontal list:" << reinterpret_cast<quintptr>(ax);\par
17536   \}\par
17537   mRangeDragVertAxis.clear();\par
17538   foreach (QCPAxis *ax, vertical)\par
17539   \{\par
17540     QPointer<QCPAxis> axPointer(ax);\par
17541     if (!axPointer.isNull())\par
17542       mRangeDragVertAxis.append(axPointer);\par
17543     else\par
17544       qDebug() << Q_FUNC_INFO << "invalid axis passed in vertical list:" << reinterpret_cast<quintptr>(ax);\par
17545   \}\par
17546 \}\par
}
}
{\xe \v setRangeZoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoom (Qt::Orientations  {\i orientations})}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which axis orientation may be zoomed by the user with the mouse wheel. What orientation corresponds to which specific axis can be set with {\b setRangeZoomAxes}({\b QCPAxis} *horizontal, {\b QCPAxis} *vertical). By default, the horizontal axis is the bottom axis (xAxis) and the vertical axis is the left axis (yAxis).\par
To disable range zooming entirely, pass 0 as {\i orientations}  or remove {\b QCP::iRangeZoom} from {\b QCustomPlot::setInteractions}. To enable range zooming for both directions, pass {\f2 Qt::Horizontal | Qt::Vertical}  as {\i orientations} .\par
In addition to setting {\i orientations}  to a non-zero value, make sure {\b QCustomPlot::setInteractions} contains {\b QCP::iRangeZoom} to enable the range zooming interaction.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoomFactor}, {\b setRangeZoomAxes}, {\b setRangeDrag} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17474 \{\par
17475   mRangeZoom = orientations;\par
17476 \}\par
}
}
{\xe \v setRangeZoomAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomAxes ({\b QCPAxis} *  {\i horizontal}, {\b QCPAxis} *  {\i vertical})}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the axes whose range will be zoomed when {\b setRangeZoom} enables mouse wheel zooming on the {\b QCustomPlot} widget. Pass 0 if no axis shall be zoomed in the respective orientation.\par
The two axes can be zoomed with different strengths, when different factors are passed to {\b setRangeZoomFactor(double horizontalFactor, double verticalFactor)}.\par
Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall react to zooming interactions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeDragAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17561 \{\par
17562   QList<QCPAxis*> horz, vert;\par
17563   if (horizontal)\par
17564     horz.append(horizontal);\par
17565   if (vertical)\par
17566     vert.append(vertical);\par
17567   setRangeZoomAxes(horz, vert);\par
17568 \}\par
}
}
{\xe \v setRangeZoomAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomAxes (QList< {\b QCPAxis} *>  {\i axes})}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
This method allows to set up multiple axes to react to horizontal and vertical range zooming. The zoom orientation that the respective axis will react to is deduced from its orientation ({\b QCPAxis::orientation}).\par
In the unusual case that you wish to e.g. zoom a vertically oriented axis with a horizontal zoom interaction, use the overload taking two separate lists for horizontal and vertical zooming. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17580 \{\par
17581   QList<QCPAxis*> horz, vert;\par
17582   foreach (QCPAxis *ax, axes)\par
17583   \{\par
17584     if (ax->orientation() == Qt::Horizontal)\par
17585       horz.append(ax);\par
17586     else\par
17587       vert.append(ax);\par
17588   \}\par
17589   setRangeZoomAxes(horz, vert);\par
17590 \}\par
}
}
{\xe \v setRangeZoomAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomAxes (QList< {\b QCPAxis} *>  {\i horizontal}, QList< {\b QCPAxis} *>  {\i vertical})}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
This method allows to set multiple axes up to react to horizontal and vertical zooming, and define specifically which axis reacts to which zoom orientation (irrespective of the axis orientation). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17599 \{\par
17600   mRangeZoomHorzAxis.clear();\par
17601   foreach (QCPAxis *ax, horizontal)\par
17602   \{\par
17603     QPointer<QCPAxis> axPointer(ax);\par
17604     if (!axPointer.isNull())\par
17605       mRangeZoomHorzAxis.append(axPointer);\par
17606     else\par
17607       qDebug() << Q_FUNC_INFO << "invalid axis passed in horizontal list:" << reinterpret_cast<quintptr>(ax);\par
17608   \}\par
17609   mRangeZoomVertAxis.clear();\par
17610   foreach (QCPAxis *ax, vertical)\par
17611   \{\par
17612     QPointer<QCPAxis> axPointer(ax);\par
17613     if (!axPointer.isNull())\par
17614       mRangeZoomVertAxis.append(axPointer);\par
17615     else\par
17616       qDebug() << Q_FUNC_INFO << "invalid axis passed in vertical list:" << reinterpret_cast<quintptr>(ax);\par
17617   \}\par
17618 \}\par
}
}
{\xe \v setRangeZoomFactor\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomFactor (double  {\i horizontalFactor}, double  {\i verticalFactor})}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how strong one rotation step of the mouse wheel zooms, when range zoom was activated with {\b setRangeZoom}. The two parameters {\i horizontalFactor}  and {\i verticalFactor}  provide a way to let the horizontal axis zoom at different rates than the vertical axis. Which axis is horizontal and which is vertical, can be set with {\b setRangeZoomAxes}.\par
When the zoom factor is greater than one, scrolling the mouse wheel backwards (towards the user) will zoom in (make the currently visible range smaller). For zoom factors smaller than one, the same scrolling direction will zoom out. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17631 \{\par
17632   mRangeZoomFactorHorz = horizontalFactor;\par
17633   mRangeZoomFactorVert = verticalFactor;\par
17634 \}\par
}
}
{\xe \v setRangeZoomFactor\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomFactor (double  {\i factor})}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets both the horizontal and vertical zoom {\i factor} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17641 \{\par
17642   mRangeZoomFactorHorz = factor;\par
17643   mRangeZoomFactorVert = factor;\par
17644 \}\par
}
}
{\xe \v setupFullAxesBox\:QCPAxisRect}
{\xe \v QCPAxisRect\:setupFullAxesBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setupFullAxesBox (bool  {\i connectRanges} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function to create an axis on each side that doesn't have any axes yet and set their visibility to true. Further, the top/right axes are assigned the following properties of the bottom/left axes:\par
{
\par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range ({\b QCPAxis::setRange}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range reversed ({\b QCPAxis::setRangeReversed}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
scale type ({\b QCPAxis::setScaleType}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tick visibility ({\b QCPAxis::setTicks}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
number format ({\b QCPAxis::setNumberFormat}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
number precision ({\b QCPAxis::setNumberPrecision}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tick count of ticker ({\b QCPAxisTicker::setTickCount}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tick origin of ticker ({\b QCPAxisTicker::setTickOrigin})\par
}
Tick label visibility ({\b QCPAxis::setTickLabels}) of the right and top axes are set to false.\par
If {\i connectRanges}  is true, the {\b rangeChanged} signals of the bottom and left axes are connected to the {\b QCPAxis::setRange} slots of the top and right axes. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17077 \{\par
17078   QCPAxis *xAxis, *yAxis, *xAxis2, *yAxis2;\par
17079   if (axisCount(QCPAxis::atBottom) == 0)\par
17080     xAxis = addAxis(QCPAxis::atBottom);\par
17081   else\par
17082     xAxis = axis(QCPAxis::atBottom);\par
17083   \par
17084   if (axisCount(QCPAxis::atLeft) == 0)\par
17085     yAxis = addAxis(QCPAxis::atLeft);\par
17086   else\par
17087     yAxis = axis(QCPAxis::atLeft);\par
17088   \par
17089   if (axisCount(QCPAxis::atTop) == 0)\par
17090     xAxis2 = addAxis(QCPAxis::atTop);\par
17091   else\par
17092     xAxis2 = axis(QCPAxis::atTop);\par
17093   \par
17094   if (axisCount(QCPAxis::atRight) == 0)\par
17095     yAxis2 = addAxis(QCPAxis::atRight);\par
17096   else\par
17097     yAxis2 = axis(QCPAxis::atRight);\par
17098   \par
17099   xAxis->setVisible(true);\par
17100   yAxis->setVisible(true);\par
17101   xAxis2->setVisible(true);\par
17102   yAxis2->setVisible(true);\par
17103   xAxis2->setTickLabels(false);\par
17104   yAxis2->setTickLabels(false);\par
17105   \par
17106   xAxis2->setRange(xAxis->range());\par
17107   xAxis2->setRangeReversed(xAxis->rangeReversed());\par
17108   xAxis2->setScaleType(xAxis->scaleType());\par
17109   xAxis2->setTicks(xAxis->ticks());\par
17110   xAxis2->setNumberFormat(xAxis->numberFormat());\par
17111   xAxis2->setNumberPrecision(xAxis->numberPrecision());\par
17112   xAxis2->ticker()->setTickCount(xAxis->ticker()->tickCount());\par
17113   xAxis2->ticker()->setTickOrigin(xAxis->ticker()->tickOrigin());\par
17114   \par
17115   yAxis2->setRange(yAxis->range());\par
17116   yAxis2->setRangeReversed(yAxis->rangeReversed());\par
17117   yAxis2->setScaleType(yAxis->scaleType());\par
17118   yAxis2->setTicks(yAxis->ticks());\par
17119   yAxis2->setNumberFormat(yAxis->numberFormat());\par
17120   yAxis2->setNumberPrecision(yAxis->numberPrecision());\par
17121   yAxis2->ticker()->setTickCount(yAxis->ticker()->tickCount());\par
17122   yAxis2->ticker()->setTickOrigin(yAxis->ticker()->tickOrigin());\par
17123   \par
17124   if (connectRanges)\par
17125   \{\par
17126     connect(xAxis, SIGNAL(rangeChanged(QCPRange)), xAxis2, SLOT(setRange(QCPRange)));\par
17127     connect(yAxis, SIGNAL(rangeChanged(QCPRange)), yAxis2, SLOT(setRange(QCPRange)));\par
17128   \}\par
17129 \}\par
}
}
{\xe \v size\:QCPAxisRect}
{\xe \v QCPAxisRect\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPAxisRect::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel size of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4650 \{ return mRect.size(); \}\par
}
}
{\xe \v top\:QCPAxisRect}
{\xe \v QCPAxisRect\:top}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::top () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position of the top border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4646 \{ return mRect.top(); \}\par
}
}
{\xe \v topLeft\:QCPAxisRect}
{\xe \v QCPAxisRect\:topLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::topLeft () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the top left corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4651 \{ return mRect.topLeft(); \}\par
}
}
{\xe \v topRight\:QCPAxisRect}
{\xe \v QCPAxisRect\:topRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::topRight () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the top right corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4652 \{ return mRect.topRight(); \}\par
}
}
{\xe \v update\:QCPAxisRect}
{\xe \v QCPAxisRect\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::update ({\b UpdatePhase}  {\i phase}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is called automatically upon replot and doesn't need to be called by users of {\b QCPAxisRect}.\par
Calls the base class implementation to update the margins (see {\b QCPLayoutElement::update}), and finally passes the {\b rect} to the inset layout ({\b insetLayout}) and calls its QCPInsetLayout::update function.\par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17219 \{\par
17220   QCPLayoutElement::update(phase);\par
17221   \par
17222   switch (phase)\par
17223   \{\par
17224     case upPreparation:\par
17225     \{\par
17226       QList<QCPAxis*> allAxes = axes();\par
17227       for (int i=0; i<allAxes.size(); ++i)\par
17228         allAxes.at(i)->setupTickVectors();\par
17229       break;\par
17230     \}\par
17231     case upLayout:\par
17232     \{\par
17233       mInsetLayout->setOuterRect(rect());\par
17234       break;\par
17235     \}\par
17236     default: break;\par
17237   \}\par
17238   \par
17239   // pass update call on to inset layout (doesn't happen automatically, because QCPAxisRect doesn't derive from QCPLayout):\par
17240   mInsetLayout->update(phase);\par
17241 \}\par
}
}
{\xe \v updateAxesOffset\:QCPAxisRect}
{\xe \v QCPAxisRect\:updateAxesOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::updateAxesOffset ({\b QCPAxis::AxisType}  {\i type}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17699 \{\par
17700   const QList<QCPAxis*> axesList = mAxes.value(type);\par
17701   if (axesList.isEmpty())\par
17702     return;\par
17703   \par
17704   bool isFirstVisible = !axesList.first()->visible(); // if the first axis is visible, the second axis (which is where the loop starts) isn't the first visible axis, so initialize with false\par
17705   for (int i=1; i<axesList.size(); ++i)\par
17706   \{\par
17707     int offset = axesList.at(i-1)->offset() + axesList.at(i-1)->calculateMargin();\par
17708     if (axesList.at(i)->visible()) // only add inner tick length to offset if this axis is visible and it's not the first visible one (might happen if true first axis is invisible)\par
17709     \{\par
17710       if (!isFirstVisible)\par
17711         offset += axesList.at(i)->tickLengthIn();\par
17712       isFirstVisible = false;\par
17713     \}\par
17714     axesList.at(i)->setOffset(offset);\par
17715   \}\par
17716 \}\par
}
}
{\xe \v wheelEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} .\par
The {\f2 event->delta()}  indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making {\f2 event->delta()}  larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17889 \{\par
17890   // Mouse range zooming interaction:\par
17891   if (mParentPlot->interactions().testFlag(QCP::iRangeZoom))\par
17892   \{\par
17893     if (mRangeZoom != 0)\par
17894     \{\par
17895       double factor;\par
17896       double wheelSteps = event->delta()/120.0; // a single step delta is +/-120 usually\par
17897       if (mRangeZoom.testFlag(Qt::Horizontal))\par
17898       \{\par
17899         factor = qPow(mRangeZoomFactorHorz, wheelSteps);\par
17900         for (int i=0; i<mRangeZoomHorzAxis.size(); ++i)\par
17901         \{\par
17902           if (!mRangeZoomHorzAxis.at(i).isNull())\par
17903             mRangeZoomHorzAxis.at(i)->scaleRange(factor, mRangeZoomHorzAxis.at(i)->pixelToCoord(event->pos().x()));\par
17904         \}\par
17905       \}\par
17906       if (mRangeZoom.testFlag(Qt::Vertical))\par
17907       \{\par
17908         factor = qPow(mRangeZoomFactorVert, wheelSteps);\par
17909         for (int i=0; i<mRangeZoomVertAxis.size(); ++i)\par
17910         \{\par
17911           if (!mRangeZoomVertAxis.at(i).isNull())\par
17912             mRangeZoomVertAxis.at(i)->scaleRange(factor, mRangeZoomVertAxis.at(i)->pixelToCoord(event->pos().y()));\par
17913         \}\par
17914       \}\par
17915       mParentPlot->replot();\par
17916     \}\par
17917   \}\par
17918 \}\par
}
}
{\xe \v width\:QCPAxisRect}
{\xe \v QCPAxisRect\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::width () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel width of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4648 \{ return mRect.width(); \}\par
}
}
{\xe \v zoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:zoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::zoom (const QRectF &  {\i pixelRect})}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zooms in (or out) to the passed rectangular region {\i pixelRect} , given in pixel coordinates.\par
All axes of this axis rect will have their range zoomed accordingly. If you only wish to zoom specific axes, use the overloaded version of this method.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::setSelectionRectMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17027 \{\par
17028   zoom(pixelRect, axes());\par
17029 \}\par
}
}
{\xe \v zoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:zoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::zoom (const QRectF &  {\i pixelRect}, const QList< {\b QCPAxis} *> &  {\i affectedAxes})}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Zooms in (or out) to the passed rectangular region {\i pixelRect} , given in pixel coordinates.\par
Only the axes passed in {\i affectedAxes}  will have their ranges zoomed accordingly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::setSelectionRectMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17040 \{\par
17041   foreach (QCPAxis *axis, affectedAxes)\par
17042   \{\par
17043     if (!axis)\par
17044     \{\par
17045       qDebug() << Q_FUNC_INFO << "a passed axis was zero";\par
17046       continue;\par
17047     \}\par
17048     QCPRange pixelRange;\par
17049     if (axis->orientation() == Qt::Horizontal)\par
17050       pixelRange = QCPRange(pixelRect.left(), pixelRect.right());\par
17051     else\par
17052       pixelRange = QCPRange(pixelRect.top(), pixelRect.bottom());\par
17053     axis->setRange(axis->pixelToCoord(pixelRange.lower), axis->pixelToCoord(pixelRange.upper));\par
17054   \}\par
17055 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCustomPlot\:QCPAxisRect}
{\xe \v QCPAxisRect\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAADragBackup\:QCPAxisRect}
{\xe \v QCPAxisRect\:mAADragBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCPAxisRect::mAADragBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:mAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QHash<{\b QCPAxis::AxisType}, QList<{\b QCPAxis}*> > QCPAxisRect::mAxes{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundBrush\:QCPAxisRect}
{\xe \v QCPAxisRect\:mBackgroundBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAxisRect::mBackgroundBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundPixmap\:QCPAxisRect}
{\xe \v QCPAxisRect\:mBackgroundPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPAxisRect::mBackgroundPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundScaled\:QCPAxisRect}
{\xe \v QCPAxisRect\:mBackgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisRect::mBackgroundScaled{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundScaledMode\:QCPAxisRect}
{\xe \v QCPAxisRect\:mBackgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCPAxisRect::mBackgroundScaledMode{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragging\:QCPAxisRect}
{\xe \v QCPAxisRect\:mDragging}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisRect::mDragging{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragStartHorzRange\:QCPAxisRect}
{\xe \v QCPAxisRect\:mDragStartHorzRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPRange}> QCPAxisRect::mDragStartHorzRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragStartVertRange\:QCPAxisRect}
{\xe \v QCPAxisRect\:mDragStartVertRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPRange}> QCPAxisRect::mDragStartVertRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInsetLayout\:QCPAxisRect}
{\xe \v QCPAxisRect\:mInsetLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutInset}* QCPAxisRect::mInsetLayout{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNotAADragBackup\:QCPAxisRect}
{\xe \v QCPAxisRect\:mNotAADragBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCPAxisRect::mNotAADragBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeDrag\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientations QCPAxisRect::mRangeDrag{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeDragHorzAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeDragHorzAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QPointer<{\b QCPAxis}> > QCPAxisRect::mRangeDragHorzAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeDragVertAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeDragVertAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QPointer<{\b QCPAxis}> > QCPAxisRect::mRangeDragVertAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientations QCPAxisRect::mRangeZoom{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoomFactorHorz\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoomFactorHorz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisRect::mRangeZoomFactorHorz{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoomFactorVert\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoomFactorVert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisRect::mRangeZoomFactorVert{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoomHorzAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoomHorzAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QPointer<{\b QCPAxis}> > QCPAxisRect::mRangeZoomHorzAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoomVertAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoomVertAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QPointer<{\b QCPAxis}> > QCPAxisRect::mRangeZoomVertAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScaledBackgroundPixmap\:QCPAxisRect}
{\xe \v QCPAxisRect\:mScaledBackgroundPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPAxisRect::mScaledBackgroundPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisTicker Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisTicker}
{\xe \v QCPAxisTicker}
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The base class tick generator used by {\b QCPAxis} to create tick positions and tick labels. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAxisTicker:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAxisTicker:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b TickStepStrategy} \{ {\b tssReadability}, 
{\b tssMeetTickCount}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisTicker} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAxisTicker} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TickStepStrategy} {\b tickStepStrategy} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b tickOrigin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickStepStrategy} ({\b TickStepStrategy} strategy)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickCount} (int count)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickOrigin} (double origin)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b generate} (const {\b QCPRange} &range, const QLocale &locale, QChar formatChar, int precision, QVector< double > &ticks, QVector< double > *subTicks, QVector< QString > *tickLabels)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b getTickStep} (const {\b QCPRange} &range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b getSubTickCount} (double tickStep)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QString {\b getTickLabel} (double tick, const QLocale &locale, QChar formatChar, int precision)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QVector< double > {\b createTickVector} (double tickStep, const {\b QCPRange} &range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QVector< double > {\b createSubTickVector} (int subTickCount, const QVector< double > &ticks)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QVector< QString > {\b createLabelVector} (const QVector< double > &ticks, const QLocale &locale, QChar formatChar, int precision)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b trimTicks} (const {\b QCPRange} &range, QVector< double > &ticks, bool keepOneOutlier) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b pickClosest} (double target, const QVector< double > &candidates) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getMantissa} (double input, double *magnitude=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b cleanMantissa} (double input) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TickStepStrategy} {\b mTickStepStrategy}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mTickCount}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mTickOrigin}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The base class tick generator used by {\b QCPAxis} to create tick positions and tick labels. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Each {\b QCPAxis} has an internal {\b QCPAxisTicker} (or a subclass) in order to generate tick positions and tick labels for the current axis range. The ticker of an axis can be set via {\b QCPAxis::setTicker}. Since that method takes a {\f2 QSharedPointer<QCPAxisTicker>} , multiple axes can share the same ticker instance.\par
This base class generates normal tick coordinates and numeric labels for linear axes. It picks a reasonable tick step (the separation between ticks) which results in readable tick labels. The number of ticks that should be approximately generated can be set via {\b setTickCount}. Depending on the current tick step strategy ({\b setTickStepStrategy}), the algorithm either sacrifices readability to better match the specified tick count ({\b QCPAxisTicker::tssMeetTickCount}) or relaxes the tick count in favor of better tick steps ({\b QCPAxisTicker::tssReadability}), which is the default.\par
The following more specialized axis ticker subclasses are available, see details in the respective class documentation:\par
{\qc  \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPAxisTickerFixed}\cell }{ \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPAxisTickerLog}\cell }{ \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPAxisTickerPi}\cell }{ \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPAxisTickerText}\cell }{ \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPAxisTickerDateTime}\cell }{ \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b QCPAxisTickerTime}\cell }{  \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
} \par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Creating own axis tickers
\par}
{\tc\tcl2 \v Creating own axis tickers}
Creating own axis tickers can be achieved very easily by sublassing {\b QCPAxisTicker} and reimplementing some or all of the available virtual methods.\par
In the simplest case you might wish to just generate different tick steps than the other tickers, so you only reimplement the method {\b getTickStep}. If you additionally want control over the string that will be shown as tick label, reimplement {\b getTickLabel}.\par
If you wish to have complete control, you can generate the tick vectors and tick label vectors yourself by reimplementing {\b createTickVector} and {\b createLabelVector}. The default implementations use the previously mentioned virtual methods {\b getTickStep} and {\b getTickLabel}, but your reimplementations don't necessarily need to do so. For example in the case of unequal tick steps, the method {\b getTickStep} loses its usefulness and can be ignored.\par
The sub tick count between major ticks can be controlled with {\b getSubTickCount}. Full sub tick placement control is obtained by reimplementing {\b createSubTickVector}.\par
See the documentation of all these virtual methods in {\b QCPAxisTicker} for detailed information about the parameters and expected return values. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v TickStepStrategy\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:TickStepStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxisTicker::TickStepStrategy}}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the strategies that the axis ticker may follow when choosing the size of the tick step.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickStepStrategy} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v tssReadability\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:tssReadability}
{\qr tssReadability{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A nicely readable tick step is prioritized over matching the requested number of ticks (see {\b setTickCount}) \par
}\cell }{\row }
{\xe \v tssMeetTickCount\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:tssMeetTickCount}
{\qr tssMeetTickCount{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1543   \{\par
 1544     tssReadability    \par
 1545     ,tssMeetTickCount \par
 1546   \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxisTicker\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:QCPAxisTicker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisTicker::QCPAxisTicker ()}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to {\b QCPAxis::setTicker}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5489                              :\par
 5490   mTickStepStrategy(tssReadability),\par
 5491   mTickCount(5),\par
 5492   mTickOrigin(0)\par
 5493 \{\par
 5494 \}\par
}
}
{\xe \v ~QCPAxisTicker\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:~QCPAxisTicker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisTicker::~QCPAxisTicker (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5497 \{\par
 5498   \par
 5499 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v cleanMantissa\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:cleanMantissa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTicker::cleanMantissa (double  {\i input}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5823 \{\par
 5824   double magnitude;\par
 5825   const double mantissa = getMantissa(input, &magnitude);\par
 5826   switch (mTickStepStrategy)\par
 5827   \{\par
 5828     case tssReadability:\par
 5829     \{\par
 5830       return pickClosest(mantissa, QVector<double>() << 1.0 << 2.0 << 2.5 << 5.0 << 10.0)*magnitude;\par
 5831     \}\par
 5832     case tssMeetTickCount:\par
 5833     \{\par
 5834       // this gives effectively a mantissa of 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 6.0, 8.0, 10.0\par
 5835       if (mantissa <= 5.0)\par
 5836         return (int)(mantissa*2)/2.0*magnitude; // round digit after decimal point to 0.5\par
 5837       else\par
 5838         return (int)(mantissa/2.0)*2.0*magnitude; // round to first digit in multiples of 2\par
 5839     \}\par
 5840   \}\par
 5841   return input;\par
 5842 \}\par
}
}
{\xe \v createLabelVector\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:createLabelVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QString > QCPAxisTicker::createLabelVector (const QVector< double > &  {\i ticks}, const QLocale &  {\i locale}, QChar  {\i formatChar}, int  {\i precision}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5732 \{\par
 5733   QVector<QString> result;\par
 5734   result.reserve(ticks.size());\par
 5735   for (int i=0; i<ticks.size(); ++i)\par
 5736     result.append(getTickLabel(ticks.at(i), locale, formatChar, precision));\par
 5737   return result;\par
 5738 \}\par
}
}
{\xe \v createSubTickVector\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:createSubTickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< double > QCPAxisTicker::createSubTickVector (int  {\i subTickCount}, const QVector< double > &  {\i ticks}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5678 \{\par
 5679   QVector<double> result;\par
 5680   if (subTickCount <= 0 || ticks.size() < 2)\par
 5681     return result;\par
 5682   \par
 5683   result.reserve((ticks.size()-1)*subTickCount);\par
 5684   for (int i=1; i<ticks.size(); ++i)\par
 5685   \{\par
 5686     double subTickStep = (ticks.at(i)-ticks.at(i-1))/(double)(subTickCount+1);\par
 5687     for (int k=1; k<=subTickCount; ++k)\par
 5688       result.append(ticks.at(i-1) + k*subTickStep);\par
 5689   \}\par
 5690   return result;\par
 5691 \}\par
}
}
{\xe \v createTickVector\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:createTickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< double > QCPAxisTicker::createTickVector (double  {\i tickStep}, const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPAxisTickerLog} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAP \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxisTickerDateTime} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5709 \{\par
 5710   QVector<double> result;\par
 5711   // Generate tick positions according to tickStep:\par
 5712   qint64 firstStep = floor((range.lower-mTickOrigin)/tickStep); // do not use qFloor here, or we'll lose 64 bit precision\par
 5713   qint64 lastStep = ceil((range.upper-mTickOrigin)/tickStep); // do not use qCeil here, or we'll lose 64 bit precision\par
 5714   int tickcount = lastStep-firstStep+1;\par
 5715   if (tickcount < 0) tickcount = 0;\par
 5716   result.resize(tickcount);\par
 5717   for (int i=0; i<tickcount; ++i)\par
 5718     result[i] = mTickOrigin + (firstStep+i)*tickStep;\par
 5719   return result;\par
 5720 \}\par
}
}
{\xe \v generate\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:generate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTicker::generate (const {\b QCPRange} &  {\i range}, const QLocale &  {\i locale}, QChar  {\i formatChar}, int  {\i precision}, QVector< double > &  {\i ticks}, QVector< double > *  {\i subTicks}, QVector< QString > *  {\i tickLabels}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the method called by {\b QCPAxis} in order to actually generate tick coordinates ({\i ticks} ), tick label strings ({\i tickLabels} ) and sub tick coordinates ({\i subTicks} ).\par
The ticks are generated for the specified {\i range} . The generated labels typically follow the specified {\i locale} , {\i formatChar}  and number {\i precision} , however this might be different (or even irrelevant) for certain {\b QCPAxisTicker} subclasses.\par
The output parameter {\i ticks}  is filled with the generated tick positions in axis coordinates. The output parameters {\i subTicks}  and {\i tickLabels}  are optional (set them to 0 if not needed) and are respectively filled with sub tick coordinates, and tick label strings belonging to {\i ticks}  by index. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5553 \{\par
 5554   // generate (major) ticks:\par
 5555   double tickStep = getTickStep(range);\par
 5556   ticks = createTickVector(tickStep, range);\par
 5557   trimTicks(range, ticks, true); // trim ticks to visible range plus one outer tick on each side (incase a subclass createTickVector creates more)\par
 5558   \par
 5559   // generate sub ticks between major ticks:\par
 5560   if (subTicks)\par
 5561   \{\par
 5562     if (ticks.size() > 0)\par
 5563     \{\par
 5564       *subTicks = createSubTickVector(getSubTickCount(tickStep), ticks);\par
 5565       trimTicks(range, *subTicks, false);\par
 5566     \} else\par
 5567       *subTicks = QVector<double>();\par
 5568   \}\par
 5569   \par
 5570   // finally trim also outliers (no further clipping happens in axis drawing):\par
 5571   trimTicks(range, ticks, false);\par
 5572   // generate labels for visible ticks if requested:\par
 5573   if (tickLabels)\par
 5574     *tickLabels = createLabelVector(ticks, locale, formatChar, precision);\par
 5575 \}\par
}
}
{\xe \v getMantissa\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:getMantissa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTicker::getMantissa (double  {\i input}, double *  {\i magnitude} = {\f2 0}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5810 \{\par
 5811   const double mag = qPow(10.0, qFloor(qLn(input)/qLn(10.0)));\par
 5812   if (magnitude) *magnitude = mag;\par
 5813   return input/mag;\par
 5814 \}\par
}
}
{\xe \v getSubTickCount\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:getSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTicker::getSubTickCount (double  {\i tickStep}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPAxisTickerLog} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerPi} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerTime} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxisTickerDateTime} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5601 \{\par
 5602   int result = 1; // default to 1, if no proper value can be found\par
 5603   \par
 5604   // separate integer and fractional part of mantissa:\par
 5605   double epsilon = 0.01;\par
 5606   double intPartf;\par
 5607   int intPart;\par
 5608   double fracPart = modf(getMantissa(tickStep), &intPartf);\par
 5609   intPart = intPartf;\par
 5610   \par
 5611   // handle cases with (almost) integer mantissa:\par
 5612   if (fracPart < epsilon || 1.0-fracPart < epsilon)\par
 5613   \{\par
 5614     if (1.0-fracPart < epsilon)\par
 5615       ++intPart;\par
 5616     switch (intPart)\par
 5617     \{\par
 5618       case 1: result = 4; break; // 1.0 -> 0.2 substep\par
 5619       case 2: result = 3; break; // 2.0 -> 0.5 substep\par
 5620       case 3: result = 2; break; // 3.0 -> 1.0 substep\par
 5621       case 4: result = 3; break; // 4.0 -> 1.0 substep\par
 5622       case 5: result = 4; break; // 5.0 -> 1.0 substep\par
 5623       case 6: result = 2; break; // 6.0 -> 2.0 substep\par
 5624       case 7: result = 6; break; // 7.0 -> 1.0 substep\par
 5625       case 8: result = 3; break; // 8.0 -> 2.0 substep\par
 5626       case 9: result = 2; break; // 9.0 -> 3.0 substep\par
 5627     \}\par
 5628   \} else\par
 5629   \{\par
 5630     // handle cases with significantly fractional mantissa:\par
 5631     if (qAbs(fracPart-0.5) < epsilon) // *.5 mantissa\par
 5632     \{\par
 5633       switch (intPart)\par
 5634       \{\par
 5635         case 1: result = 2; break; // 1.5 -> 0.5 substep\par
 5636         case 2: result = 4; break; // 2.5 -> 0.5 substep\par
 5637         case 3: result = 4; break; // 3.5 -> 0.7 substep\par
 5638         case 4: result = 2; break; // 4.5 -> 1.5 substep\par
 5639         case 5: result = 4; break; // 5.5 -> 1.1 substep (won't occur with default getTickStep from here on)\par
 5640         case 6: result = 4; break; // 6.5 -> 1.3 substep\par
 5641         case 7: result = 2; break; // 7.5 -> 2.5 substep\par
 5642         case 8: result = 4; break; // 8.5 -> 1.7 substep\par
 5643         case 9: result = 4; break; // 9.5 -> 1.9 substep\par
 5644       \}\par
 5645     \}\par
 5646     // if mantissa fraction isn't 0.0 or 0.5, don't bother finding good sub tick marks, leave default\par
 5647   \}\par
 5648   \par
 5649   return result;\par
 5650 \}\par
}
}
{\xe \v getTickLabel\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:getTickLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTicker::getTickLabel (double  {\i tick}, const QLocale &  {\i locale}, QChar  {\i formatChar}, int  {\i precision}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPAxisTickerPi} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerTime} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxisTickerDateTime} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5664 \{\par
 5665   return locale.toString(tick, formatChar.toLatin1(), precision);\par
 5666 \}\par
}
}
{\xe \v getTickStep\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:getTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTicker::getTickStep (const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPAxisTickerLog} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerPi} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerFixed} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisTickerTime} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxisTickerDateTime} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5588 \{\par
 5589   double exactStep = range.size()/(double)(mTickCount+1e-10); // mTickCount ticks on average, the small addition is to prevent jitter on exact integers\par
 5590   return cleanMantissa(exactStep);\par
 5591 \}\par
}
}
{\xe \v pickClosest\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:pickClosest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTicker::pickClosest (double  {\i target}, const QVector< double > &  {\i candidates}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5790 \{\par
 5791   if (candidates.size() == 1)\par
 5792     return candidates.first();\par
 5793   QVector<double>::const_iterator it = std::lower_bound(candidates.constBegin(), candidates.constEnd(), target);\par
 5794   if (it == candidates.constEnd())\par
 5795     return *(it-1);\par
 5796   else if (it == candidates.constBegin())\par
 5797     return *it;\par
 5798   else\par
 5799     return target-*(it-1) < *it-target ? *(it-1) : *it;\par
 5800 \}\par
}
}
{\xe \v setTickCount\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:setTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTicker::setTickCount (int  {\i count})}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how many ticks this ticker shall aim to generate across the axis range. Note that {\i count}  is not guaranteed to be matched exactly, as generating readable tick intervals may conflict with the requested number of ticks.\par
Whether the readability has priority over meeting the requested {\i count}  can be specified with {\b setTickStepStrategy}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5519 \{\par
 5520   if (count > 0)\par
 5521     mTickCount = count;\par
 5522   else\par
 5523     qDebug() << Q_FUNC_INFO << "tick count must be greater than zero:" << count;\par
 5524 \}\par
}
}
{\xe \v setTickOrigin\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:setTickOrigin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTicker::setTickOrigin (double  {\i origin})}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the mathematical coordinate (or "offset") of the zeroth tick. This tick coordinate is just a concept and doesn't need to be inside the currently visible axis range.\par
By default {\i origin}  is zero, which for example yields ticks \{-5, 0, 5, 10, 15,...\} when the tick step is five. If {\i origin}  is now set to 1 instead, the correspondingly generated ticks would be \{-4, 1, 6, 11, 16,...\}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5535 \{\par
 5536   mTickOrigin = origin;\par
 5537 \}\par
}
}
{\xe \v setTickStepStrategy\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:setTickStepStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTicker::setTickStepStrategy ({\b QCPAxisTicker::TickStepStrategy}  {\i strategy})}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which strategy the axis ticker follows when choosing the size of the tick step. For the available strategies, see {\b TickStepStrategy}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5506 \{\par
 5507   mTickStepStrategy = strategy;\par
 5508 \}\par
}
}
{\xe \v tickCount\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:tickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTicker::tickCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1554 \{ return mTickCount; \}\par
}
}
{\xe \v tickOrigin\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:tickOrigin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTicker::tickOrigin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1555 \{ return mTickOrigin; \}\par
}
}
{\xe \v tickStepStrategy\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:tickStepStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TickStepStrategy} QCPAxisTicker::tickStepStrategy () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1553 \{ return mTickStepStrategy; \}\par
}
}
{\xe \v trimTicks\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:trimTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTicker::trimTicks (const {\b QCPRange} &  {\i range}, QVector< double > &  {\i ticks}, bool  {\i keepOneOutlier}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5748 \{\par
 5749   bool lowFound = false;\par
 5750   bool highFound = false;\par
 5751   int lowIndex = 0;\par
 5752   int highIndex = -1;\par
 5753   \par
 5754   for (int i=0; i < ticks.size(); ++i)\par
 5755   \{\par
 5756     if (ticks.at(i) >= range.lower)\par
 5757     \{\par
 5758       lowFound = true;\par
 5759       lowIndex = i;\par
 5760       break;\par
 5761     \}\par
 5762   \}\par
 5763   for (int i=ticks.size()-1; i >= 0; --i)\par
 5764   \{\par
 5765     if (ticks.at(i) <= range.upper)\par
 5766     \{\par
 5767       highFound = true;\par
 5768       highIndex = i;\par
 5769       break;\par
 5770     \}\par
 5771   \}\par
 5772   \par
 5773   if (highFound && lowFound)\par
 5774   \{\par
 5775     int trimFront = qMax(0, lowIndex-(keepOneOutlier ? 1 : 0));\par
 5776     int trimBack = qMax(0, ticks.size()-(keepOneOutlier ? 2 : 1)-highIndex);\par
 5777     if (trimFront > 0 || trimBack > 0)\par
 5778       ticks = ticks.mid(trimFront, ticks.size()-trimFront-trimBack);\par
 5779   \} else // all ticks are either all below or all above the range\par
 5780     ticks.clear();\par
 5781 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mTickCount\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:mTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTicker::mTickCount{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickOrigin\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:mTickOrigin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTicker::mTickOrigin{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickStepStrategy\:QCPAxisTicker}
{\xe \v QCPAxisTicker\:mTickStepStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TickStepStrategy} QCPAxisTicker::mTickStepStrategy{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisTickerDateTime Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime}
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker for calendar dates and times as axis ticks. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAxisTickerDateTime:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_date_time__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAxisTickerDateTime:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_date_time__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisTickerDateTime} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b dateTimeFormat} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::TimeSpec {\b dateTimeSpec} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDateTimeFormat} (const QString &format)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDateTimeSpec} (Qt::TimeSpec spec)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickOrigin} (double origin)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickOrigin} (const QDateTime &origin)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static QDateTime {\b keyToDateTime} (double key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b dateTimeToKey} (const QDateTime dateTime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b dateTimeToKey} (const QDate date)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b DateStrategy} \{ {\b dsNone}, 
{\b dsUniformTimeInDay}, 
{\b dsUniformDayInMonth}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b getTickStep} (const {\b QCPRange} &range) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b getSubTickCount} (double tickStep) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QString {\b getTickLabel} (double tick, const QLocale &locale, QChar formatChar, int precision) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QVector< double > {\b createTickVector} (double tickStep, const {\b QCPRange} &range) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mDateTimeFormat}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::TimeSpec {\b mDateTimeSpec}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCPAxisTickerDateTime::DateStrategy} {\b mDateStrategy}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker for calendar dates and times as axis ticks. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
This {\b QCPAxisTicker} subclass generates ticks that correspond to real calendar dates and times. The plot axis coordinate is interpreted as Unix Time, so seconds since Epoch (January 1, 1970, 00:00 UTC). This is also used for example by QDateTime in the {\f2 toTime_t()/setTime_t()}  methods with a precision of one second. Since Qt 4.7, millisecond accuracy can be obtained from QDateTime by using {\f2 QDateTime::fromMSecsSinceEpoch()/1000.0} . The static methods {\b dateTimeToKey} and {\b keyToDateTime} conveniently perform this conversion achieving a precision of one millisecond on all Qt versions.\par
The format of the date/time display in the tick labels is controlled with {\b setDateTimeFormat}. If a different time spec (time zone) shall be used, see {\b setDateTimeSpec}.\par
This ticker produces unequal tick spacing in order to provide intuitive date and time-of-day ticks. For example, if the axis range spans a few years such that there is one tick per year, ticks will be positioned on 1. January of every year. This is intuitive but, due to leap years, will result in slightly unequal tick intervals (visually unnoticeable). The same can be seen in the image above: even though the number of days varies month by month, this ticker generates ticks on the same day of each month.\par
If you would like to change the date/time that is used as a (mathematical) starting date for the ticks, use the {\b setTickOrigin(const QDateTime &origin)} method overload, which takes a QDateTime. If you pass 15. July, 9:45 to this method, the yearly ticks will end up on 15. July at 9:45 of every year.\par
The ticker can be created and assigned to an axis like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid If you rather wish to display relative times in terms of days, hours, minutes, seconds and milliseconds, and are not interested in the intricacies of real calendar dates with months and (leap) years, have a look at {\b QCPAxisTickerTime} instead. \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v DateStrategy\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:DateStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxisTickerDateTime::DateStrategy}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v dsNone\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:dsNone}
{\qr dsNone{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
\cell }{\cell }{\row }
{\xe \v dsUniformTimeInDay\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:dsUniformTimeInDay}
{\qr dsUniformTimeInDay{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
\cell }{\cell }{\row }
{\xe \v dsUniformDayInMonth\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:dsUniformDayInMonth}
{\qr dsUniformDayInMonth{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1620 \{dsNone, dsUniformTimeInDay, dsUniformDayInMonth\} mDateStrategy;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxisTickerDateTime\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:QCPAxisTickerDateTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisTickerDateTime::QCPAxisTickerDateTime ()}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to {\b QCPAxis::setTicker}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5892                                              :\par
 5893   mDateTimeFormat(QLatin1String("hh:mm:ss\\ndd.MM.yy")),\par
 5894   mDateTimeSpec(Qt::LocalTime),\par
 5895   mDateStrategy(dsNone)\par
 5896 \{\par
 5897   setTickCount(4);\par
 5898 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createTickVector\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:createTickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< double > QCPAxisTickerDateTime::createTickVector (double  {\i tickStep}, const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6051 \{\par
 6052   QVector<double> result = QCPAxisTicker::createTickVector(tickStep, range);\par
 6053   if (!result.isEmpty())\par
 6054   \{\par
 6055     if (mDateStrategy == dsUniformTimeInDay)\par
 6056     \{\par
 6057       QDateTime uniformDateTime = keyToDateTime(mTickOrigin); // the time of this datetime will be set for all other ticks, if possible\par
 6058       QDateTime tickDateTime;\par
 6059       for (int i=0; i<result.size(); ++i)\par
 6060       \{\par
 6061         tickDateTime = keyToDateTime(result.at(i));\par
 6062         tickDateTime.setTime(uniformDateTime.time());\par
 6063         result[i] = dateTimeToKey(tickDateTime);\par
 6064       \}\par
 6065     \} else if (mDateStrategy == dsUniformDayInMonth)\par
 6066     \{\par
 6067       QDateTime uniformDateTime = keyToDateTime(mTickOrigin); // this day (in month) and time will be set for all other ticks, if possible\par
 6068       QDateTime tickDateTime;\par
 6069       for (int i=0; i<result.size(); ++i)\par
 6070       \{\par
 6071         tickDateTime = keyToDateTime(result.at(i));\par
 6072         tickDateTime.setTime(uniformDateTime.time());\par
 6073         int thisUniformDay = uniformDateTime.date().day() <= tickDateTime.date().daysInMonth() ? uniformDateTime.date().day() : tickDateTime.date().daysInMonth(); // don't exceed month (e.g. try to set day 31 in February)\par
 6074         if (thisUniformDay-tickDateTime.date().day() < -15) // with leap years involved, date month may jump backwards or forwards, and needs to be corrected before setting day\par
 6075           tickDateTime = tickDateTime.addMonths(1);\par
 6076         else if (thisUniformDay-tickDateTime.date().day() > 15) // with leap years involved, date month may jump backwards or forwards, and needs to be corrected before setting day\par
 6077           tickDateTime = tickDateTime.addMonths(-1);\par
 6078         tickDateTime.setDate(QDate(tickDateTime.date().year(), tickDateTime.date().month(), thisUniformDay));\par
 6079         result[i] = dateTimeToKey(tickDateTime);\par
 6080       \}\par
 6081     \}\par
 6082   \}\par
 6083   return result;\par
 6084 \}\par
}
}
{\xe \v dateTimeFormat\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:dateTimeFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerDateTime::dateTimeFormat () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1600 \{ return mDateTimeFormat; \}\par
}
}
{\xe \v dateTimeSpec\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:dateTimeSpec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::TimeSpec QCPAxisTickerDateTime::dateTimeSpec () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1601 \{ return mDateTimeSpec; \}\par
}
}
{\xe \v dateTimeToKey\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:dateTimeToKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerDateTime::dateTimeToKey (const QDateTime  {\i dateTime}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
A convenience method which turns a QDateTime object into a double value that corresponds to seconds since Epoch (1. Jan 1970, 00:00 UTC). This is the format used as axis coordinates by {\b QCPAxisTickerDateTime}.\par
The accuracy achieved by this method is one millisecond, irrespective of the used Qt version (it works around the lack of a QDateTime::toMSecsSinceEpoch in Qt 4.6)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b keyToDateTime} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6116 \{\par
 6117 # if QT_VERSION < QT_VERSION_CHECK(4, 7, 0)\par
 6118   return dateTime.toTime_t()+dateTime.time().msec()/1000.0;\par
 6119 # else\par
 6120   return dateTime.toMSecsSinceEpoch()/1000.0;\par
 6121 # endif\par
 6122 \}\par
}
}
{\xe \v dateTimeToKey\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:dateTimeToKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerDateTime::dateTimeToKey (const QDate  {\i date}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
A convenience method which turns a QDate object into a double value that corresponds to seconds since Epoch (1. Jan 1970, 00:00 UTC). This is the format used as axis coordinates by {\b QCPAxisTickerDateTime}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b keyToDateTime} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6133 \{\par
 6134 # if QT_VERSION < QT_VERSION_CHECK(4, 7, 0)\par
 6135   return QDateTime(date).toTime_t();\par
 6136 # else\par
 6137   return QDateTime(date).toMSecsSinceEpoch()/1000.0;\par
 6138 # endif\par
 6139 \}\par
}
}
{\xe \v getSubTickCount\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:getSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerDateTime::getSubTickCount (double  {\i tickStep}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6002 \{\par
 6003   int result = QCPAxisTicker::getSubTickCount(tickStep);\par
 6004   switch (qRound(tickStep)) // hand chosen subticks for specific minute/hour/day/week/month range (as specified in getTickStep)\par
 6005   \{\par
 6006     case 5*60: result = 4; break;\par
 6007     case 10*60: result = 1; break;\par
 6008     case 15*60: result = 2; break;\par
 6009     case 30*60: result = 1; break;\par
 6010     case 60*60: result = 3; break;\par
 6011     case 3600*2: result = 3; break;\par
 6012     case 3600*3: result = 2; break;\par
 6013     case 3600*6: result = 1; break;\par
 6014     case 3600*12: result = 3; break;\par
 6015     case 3600*24: result = 3; break;\par
 6016     case 86400*2: result = 1; break;\par
 6017     case 86400*5: result = 4; break;\par
 6018     case 86400*7: result = 6; break;\par
 6019     case 86400*14: result = 1; break;\par
 6020     case (int)(86400*30.4375+0.5): result = 3; break;\par
 6021     case (int)(86400*30.4375*2+0.5): result = 1; break;\par
 6022     case (int)(86400*30.4375*3+0.5): result = 2; break;\par
 6023     case (int)(86400*30.4375*6+0.5): result = 5; break;\par
 6024     case (int)(86400*30.4375*12+0.5): result = 3; break;\par
 6025   \}\par
 6026   return result;\par
 6027 \}\par
}
}
{\xe \v getTickLabel\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:getTickLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerDateTime::getTickLabel (double  {\i tick}, const QLocale &  {\i locale}, QChar  {\i formatChar}, int  {\i precision}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6037 \{\par
 6038   Q_UNUSED(precision)\par
 6039   Q_UNUSED(formatChar)\par
 6040   return locale.toString(keyToDateTime(tick).toTimeSpec(mDateTimeSpec), mDateTimeFormat);\par
 6041 \}\par
}
}
{\xe \v getTickStep\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:getTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerDateTime::getTickStep (const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5968 \{\par
 5969   double result = range.size()/(double)(mTickCount+1e-10); // mTickCount ticks on average, the small addition is to prevent jitter on exact integers\par
 5970   \par
 5971   mDateStrategy = dsNone;\par
 5972   if (result < 1) // ideal tick step is below 1 second -> use normal clean mantissa algorithm in units of seconds\par
 5973   \{\par
 5974     result = cleanMantissa(result);\par
 5975   \} else if (result < 86400*30.4375*12) // below a year\par
 5976   \{\par
 5977     result = pickClosest(result, QVector<double>()\par
 5978                              << 1 << 2.5 << 5 << 10 << 15 << 30 << 60 << 2.5*60 << 5*60 << 10*60 << 15*60 << 30*60 << 60*60 // second, minute, hour range\par
 5979                              << 3600*2 << 3600*3 << 3600*6 << 3600*12 << 3600*24 // hour to day range\par
 5980                              << 86400*2 << 86400*5 << 86400*7 << 86400*14 << 86400*30.4375 << 86400*30.4375*2 << 86400*30.4375*3 << 86400*30.4375*6 << 86400*30.4375*12); // day, week, month range (avg. days per month includes leap years)\par
 5981     if (result > 86400*30.4375-1) // month tick intervals or larger\par
 5982       mDateStrategy = dsUniformDayInMonth;\par
 5983     else if (result > 3600*24-1) // day tick intervals or larger\par
 5984       mDateStrategy = dsUniformTimeInDay;\par
 5985   \} else // more than a year, go back to normal clean mantissa algorithm but in units of years\par
 5986   \{\par
 5987     const double secondsPerYear = 86400*30.4375*12; // average including leap years\par
 5988     result = cleanMantissa(result/secondsPerYear)*secondsPerYear;\par
 5989     mDateStrategy = dsUniformDayInMonth;\par
 5990   \}\par
 5991   return result;\par
 5992 \}\par
}
}
{\xe \v keyToDateTime\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:keyToDateTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QDateTime QCPAxisTickerDateTime::keyToDateTime (double  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A convenience method which turns {\i key}  (in seconds since Epoch 1. Jan 1970, 00:00 UTC) into a QDateTime object. This can be used to turn axis coordinates to actual QDateTimes.\par
The accuracy achieved by this method is one millisecond, irrespective of the used Qt version (it works around the lack of a QDateTime::fromMSecsSinceEpoch in Qt 4.6)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b dateTimeToKey} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6096 \{\par
 6097 # if QT_VERSION < QT_VERSION_CHECK(4, 7, 0)\par
 6098   return QDateTime::fromTime_t(key).addMSecs((key-(qint64)key)*1000);\par
 6099 # else\par
 6100   return QDateTime::fromMSecsSinceEpoch(key*1000.0);\par
 6101 # endif\par
 6102 \}\par
}
}
{\xe \v setDateTimeFormat\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:setDateTimeFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerDateTime::setDateTimeFormat (const QString &  {\i format})}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the format in which dates and times are displayed as tick labels. For details about the {\i format}  string, see the documentation of QDateTime::toString().\par
Newlines can be inserted with "\\n".\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDateTimeSpec} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5909 \{\par
 5910   mDateTimeFormat = format;\par
 5911 \}\par
}
}
{\xe \v setDateTimeSpec\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:setDateTimeSpec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerDateTime::setDateTimeSpec (Qt::TimeSpec  {\i spec})}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the time spec that is used for creating the tick labels from corresponding dates/times.\par
The default value of QDateTime objects (and also {\b QCPAxisTickerDateTime}) is {\f2 Qt::LocalTime} . However, if the date time values passed to {\b QCustomPlot} (e.g. in the form of axis ranges or keys of a plottable) are given in the UTC spec, set {\i spec}  to {\f2 Qt::UTC}  to get the correct axis labels.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDateTimeFormat} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5924 \{\par
 5925   mDateTimeSpec = spec;\par
 5926 \}\par
}
}
{\xe \v setTickOrigin\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:setTickOrigin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerDateTime::setTickOrigin (double  {\i origin})}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the tick origin (see {\b QCPAxisTicker::setTickOrigin}) in seconds since Epoch (1. Jan 1970, 00:00 UTC). For the date time ticker it might be more intuitive to use the overload which directly takes a QDateTime, see {\b setTickOrigin(const QDateTime &origin)}.\par
This is useful to define the month/day/time recurring at greater tick interval steps. For example, If you pass 15. July, 9:45 to this method and the tick interval happens to be one tick per year, the ticks will end up on 15. July at 9:45 of every year. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5938 \{\par
 5939   QCPAxisTicker::setTickOrigin(origin);\par
 5940 \}\par
}
}
{\xe \v setTickOrigin\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:setTickOrigin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerDateTime::setTickOrigin (const QDateTime &  {\i origin})}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the tick origin (see {\b QCPAxisTicker::setTickOrigin}) as a QDateTime {\i origin} .\par
This is useful to define the month/day/time recurring at greater tick interval steps. For example, If you pass 15. July, 9:45 to this method and the tick interval happens to be one tick per year, the ticks will end up on 15. July at 9:45 of every year. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5950 \{\par
 5951   setTickOrigin(dateTimeToKey(origin));\par
 5952 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mDateStrategy\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:mDateStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxisTickerDateTime::DateStrategy}  QCPAxisTickerDateTime::mDateStrategy{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDateTimeFormat\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:mDateTimeFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerDateTime::mDateTimeFormat{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDateTimeSpec\:QCPAxisTickerDateTime}
{\xe \v QCPAxisTickerDateTime\:mDateTimeSpec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::TimeSpec QCPAxisTickerDateTime::mDateTimeSpec{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisTickerFixed Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed}
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker with a fixed tick step. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAxisTickerFixed:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_fixed__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAxisTickerFixed:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_fixed__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ScaleStrategy} \{ {\b ssNone}, 
{\b ssMultiples}, 
{\b ssPowers}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisTickerFixed} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b tickStep} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScaleStrategy} {\b scaleStrategy} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickStep} (double step)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScaleStrategy} ({\b ScaleStrategy} strategy)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b getTickStep} (const {\b QCPRange} &range) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mTickStep}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScaleStrategy} {\b mScaleStrategy}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker with a fixed tick step. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
This {\b QCPAxisTicker} subclass generates ticks with a fixed tick step set with {\b setTickStep}. It is also possible to allow integer multiples and integer powers of the specified tick step with {\b setScaleStrategy}.\par
A typical application of this ticker is to make an axis only display integers, by setting the tick step of the ticker to 1.0 and the scale strategy to {\b ssMultiples}.\par
Another case is when a certain number has a special meaning and axis ticks should only appear at multiples of that value. In this case you might also want to consider {\b QCPAxisTickerPi} because despite the name it is not limited to only pi symbols/values.\par
The ticker can be created and assigned to an axis like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ScaleStrategy\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:ScaleStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxisTickerFixed::ScaleStrategy}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines how the axis ticker may modify the specified tick step ({\b setTickStep}) in order to control the number of ticks in the axis range.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setScaleStrategy} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ssNone\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:ssNone}
{\qr ssNone{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modifications are not allowed, the specified tick step is absolutely fixed. This might cause a high tick density and overlapping labels if the axis range is zoomed out. \par
}\cell }{\row }
{\xe \v ssMultiples\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:ssMultiples}
{\qr ssMultiples{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An integer multiple of the specified tick step is allowed. The used factor follows the base class properties of {\b setTickStepStrategy} and {\b setTickCount}. \par
}\cell }{\row }
{\xe \v ssPowers\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:ssPowers}
{\qr ssPowers{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An integer power of the specified tick step is allowed. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1697                      \{ ssNone      \par
 1698                        ,ssMultiples \par
 1699                        ,ssPowers    \par
 1700                      \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxisTickerFixed\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:QCPAxisTickerFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisTickerFixed::QCPAxisTickerFixed ()}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to {\b QCPAxis::setTicker}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6422                                        :\par
 6423   mTickStep(1.0),\par
 6424   mScaleStrategy(ssNone)\par
 6425 \{\par
 6426 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getTickStep\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:getTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerFixed::getTickStep (const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6468 \{\par
 6469   switch (mScaleStrategy)\par
 6470   \{\par
 6471     case ssNone:\par
 6472     \{\par
 6473       return mTickStep;\par
 6474     \}\par
 6475     case ssMultiples:\par
 6476     \{\par
 6477       double exactStep = range.size()/(double)(mTickCount+1e-10); // mTickCount ticks on average, the small addition is to prevent jitter on exact integers\par
 6478       if (exactStep < mTickStep)\par
 6479         return mTickStep;\par
 6480       else\par
 6481         return (qint64)(cleanMantissa(exactStep/mTickStep)+0.5)*mTickStep;\par
 6482     \}\par
 6483     case ssPowers:\par
 6484     \{\par
 6485       double exactStep = range.size()/(double)(mTickCount+1e-10); // mTickCount ticks on average, the small addition is to prevent jitter on exact integers\par
 6486       return qPow(mTickStep, (int)(qLn(exactStep)/qLn(mTickStep)+0.5));\par
 6487     \}\par
 6488   \}\par
 6489   return mTickStep;\par
 6490 \}\par
}
}
{\xe \v scaleStrategy\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:scaleStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScaleStrategy} QCPAxisTickerFixed::scaleStrategy () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1707 \{ return mScaleStrategy; \}\par
}
}
{\xe \v setScaleStrategy\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:setScaleStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerFixed::setScaleStrategy ({\b QCPAxisTickerFixed::ScaleStrategy}  {\i strategy})}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the specified tick step ({\b setTickStep}) is absolutely fixed or whether modifications may be applied to it before calculating the finally used tick step, such as permitting multiples or powers. See {\b ScaleStrategy} for details.\par
The default strategy is {\b ssNone}, which means the tick step is absolutely fixed. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6453 \{\par
 6454   mScaleStrategy = strategy;\par
 6455 \}\par
}
}
{\xe \v setTickStep\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:setTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerFixed::setTickStep (double  {\i step})}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the fixed tick interval to {\i step} .\par
The axis ticker will only use this tick step when generating axis ticks. This might cause a very high tick density and overlapping labels if the axis range is zoomed out. Using {\b setScaleStrategy} it is possible to relax the fixed step and also allow multiples or powers of {\i step} . This will enable the ticker to reduce the number of ticks to a reasonable amount (see {\b setTickCount}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6438 \{\par
 6439   if (step > 0)\par
 6440     mTickStep = step;\par
 6441   else\par
 6442     qDebug() << Q_FUNC_INFO << "tick step must be greater than zero:" << step;\par
 6443 \}\par
}
}
{\xe \v tickStep\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:tickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerFixed::tickStep () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1706 \{ return mTickStep; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mScaleStrategy\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:mScaleStrategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScaleStrategy} QCPAxisTickerFixed::mScaleStrategy{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickStep\:QCPAxisTickerFixed}
{\xe \v QCPAxisTickerFixed\:mTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerFixed::mTickStep{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisTickerLog Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog}
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker suited for logarithmic axes. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAxisTickerLog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_log__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAxisTickerLog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_log__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisTickerLog} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b logBase} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b subTickCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLogBase} (double base)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickCount} (int subTicks)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b getTickStep} (const {\b QCPRange} &range) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b getSubTickCount} (double tickStep) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QVector< double > {\b createTickVector} (double tickStep, const {\b QCPRange} &range) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mLogBase}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mSubTickCount}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mLogBaseLnInv}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker suited for logarithmic axes. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
This {\b QCPAxisTicker} subclass generates ticks with unequal tick intervals suited for logarithmic axis scales. The ticks are placed at powers of the specified log base ({\b setLogBase}).\par
Especially in the case of a log base equal to 10 (the default), it might be desirable to have tick labels in the form of powers of ten without mantissa display. To achieve this, set the number precision ({\b QCPAxis::setNumberPrecision}) to zero and the number format ({\b QCPAxis::setNumberFormat}) to scientific (exponential) display with beautifully typeset decimal powers, so a format string of {\f2 "eb"} . This will result in the following axis tick labels:\par
The ticker can be created and assigned to an axis like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxisTickerLog\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:QCPAxisTickerLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisTickerLog::QCPAxisTickerLog ()}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to {\b QCPAxis::setTicker}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7024                                    :\par
 7025   mLogBase(10.0),\par
 7026   mSubTickCount(8), // generates 10 intervals\par
 7027   mLogBaseLnInv(1.0/qLn(mLogBase))\par
 7028 \{\par
 7029 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v createTickVector\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:createTickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< double > QCPAxisTickerLog::createTickVector (double  {\i tickStep}, const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7100 \{\par
 7101   Q_UNUSED(tickStep)\par
 7102   QVector<double> result;\par
 7103   if (range.lower > 0 && range.upper > 0) // positive range\par
 7104   \{\par
 7105     double exactPowerStep =  qLn(range.upper/range.lower)*mLogBaseLnInv/(double)(mTickCount+1e-10);\par
 7106     double newLogBase = qPow(mLogBase, qMax((int)cleanMantissa(exactPowerStep), 1));\par
 7107     double currentTick = qPow(newLogBase, qFloor(qLn(range.lower)/qLn(newLogBase)));\par
 7108     result.append(currentTick);\par
 7109     while (currentTick < range.upper && currentTick > 0) // currentMag might be zero for ranges ~1e-300, just cancel in that case\par
 7110     \{\par
 7111       currentTick *= newLogBase;\par
 7112       result.append(currentTick);\par
 7113     \}\par
 7114   \} else if (range.lower < 0 && range.upper < 0) // negative range\par
 7115   \{\par
 7116     double exactPowerStep =  qLn(range.lower/range.upper)*mLogBaseLnInv/(double)(mTickCount+1e-10);\par
 7117     double newLogBase = qPow(mLogBase, qMax((int)cleanMantissa(exactPowerStep), 1));\par
 7118     double currentTick = -qPow(newLogBase, qCeil(qLn(-range.lower)/qLn(newLogBase)));\par
 7119     result.append(currentTick);\par
 7120     while (currentTick < range.upper && currentTick < 0) // currentMag might be zero for ranges ~1e-300, just cancel in that case\par
 7121     \{\par
 7122       currentTick /= newLogBase;\par
 7123       result.append(currentTick);\par
 7124     \}\par
 7125   \} else // invalid range for logarithmic scale, because lower and upper have different sign\par
 7126   \{\par
 7127     qDebug() << Q_FUNC_INFO << "Invalid range for logarithmic plot: " << range.lower << ".." << range.upper;\par
 7128   \}\par
 7129   \par
 7130   return result;\par
 7131 \}\par
}
}
{\xe \v getSubTickCount\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:getSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerLog::getSubTickCount (double  {\i tickStep}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7085 \{\par
 7086   Q_UNUSED(tickStep)\par
 7087   return mSubTickCount;\par
 7088 \}\par
}
}
{\xe \v getTickStep\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:getTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerLog::getTickStep (const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7071 \{\par
 7072   // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method\par
 7073   Q_UNUSED(range)\par
 7074   return 1.0;\par
 7075 \}\par
}
}
{\xe \v logBase\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:logBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerLog::logBase () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1833 \{ return mLogBase; \}\par
}
}
{\xe \v setLogBase\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:setLogBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerLog::setLogBase (double  {\i base})}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the logarithm base used for tick coordinate generation. The ticks will be placed at integer powers of {\i base} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7036 \{\par
 7037   if (base > 0)\par
 7038   \{\par
 7039     mLogBase = base;\par
 7040     mLogBaseLnInv = 1.0/qLn(mLogBase);\par
 7041   \} else\par
 7042     qDebug() << Q_FUNC_INFO << "log base has to be greater than zero:" << base;\par
 7043 \}\par
}
}
{\xe \v setSubTickCount\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:setSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerLog::setSubTickCount (int  {\i subTicks})}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of sub ticks in a tick interval. Within each interval, the sub ticks are spaced linearly to provide a better visual guide, so the sub tick density increases toward the higher tick.\par
Note that {\i subTicks}  is the number of sub ticks (not sub intervals) in one tick interval. So in the case of logarithm base 10 an intuitive sub tick spacing would be achieved with eight sub ticks (the default). This means e.g. between the ticks 10 and 100 there will be eight ticks, namely at 20, 30, 40, 50, 60, 70, 80 and 90. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7056 \{\par
 7057   if (subTicks >= 0)\par
 7058     mSubTickCount = subTicks;\par
 7059   else\par
 7060     qDebug() << Q_FUNC_INFO << "sub tick count can't be negative:" << subTicks;\par
 7061 \}\par
}
}
{\xe \v subTickCount\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:subTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerLog::subTickCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1834 \{ return mSubTickCount; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mLogBase\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:mLogBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerLog::mLogBase{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLogBaseLnInv\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:mLogBaseLnInv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerLog::mLogBaseLnInv{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSubTickCount\:QCPAxisTickerLog}
{\xe \v QCPAxisTickerLog\:mSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerLog::mSubTickCount{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisTickerPi Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi}
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker to display ticks in units of an arbitrary constant, for example pi. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAxisTickerPi:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_pi__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAxisTickerPi:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_pi__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b FractionStyle} \{ {\b fsFloatingPoint}, 
{\b fsAsciiFractions}, 
{\b fsUnicodeFractions}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisTickerPi} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b piSymbol} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b piValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b periodicity} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FractionStyle} {\b fractionStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPiSymbol} (QString symbol)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPiValue} (double pi)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPeriodicity} (int multiplesOfPi)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFractionStyle} ({\b FractionStyle} style)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b getTickStep} (const {\b QCPRange} &range) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b getSubTickCount} (double tickStep) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QString {\b getTickLabel} (double tick, const QLocale &locale, QChar formatChar, int precision) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b simplifyFraction} (int &numerator, int &denominator) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b fractionToString} (int numerator, int denominator) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b unicodeFraction} (int numerator, int denominator) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b unicodeSuperscript} (int number) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b unicodeSubscript} (int number) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mPiSymbol}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mPiValue}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mPeriodicity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FractionStyle} {\b mFractionStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mPiTickStep}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker to display ticks in units of an arbitrary constant, for example pi. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
This {\b QCPAxisTicker} subclass generates ticks that are expressed with respect to a given symbolic constant with a numerical value specified with {\b setPiValue} and an appearance in the tick labels specified with {\b setPiSymbol}.\par
Ticks may be generated at fractions of the symbolic constant. How these fractions appear in the tick label can be configured with {\b setFractionStyle}.\par
The ticker can be created and assigned to an axis like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v FractionStyle\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:FractionStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxisTickerPi::FractionStyle}}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines how fractions should be displayed in tick labels.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFractionStyle} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v fsFloatingPoint\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:fsFloatingPoint}
{\qr fsFloatingPoint{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fractions are displayed as regular decimal floating point numbers, e.g. "0.25" or "0.125". \par
}\cell }{\row }
{\xe \v fsAsciiFractions\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:fsAsciiFractions}
{\qr fsAsciiFractions{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fractions are written as rationals using ASCII characters only, e.g. "1/4" or "1/8". \par
}\cell }{\row }
{\xe \v fsUnicodeFractions\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:fsUnicodeFractions}
{\qr fsUnicodeFractions{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fractions are written using sub- and superscript UTF-8 digits and the fraction symbol. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1777                      \{ fsFloatingPoint     \par
 1778                        ,fsAsciiFractions   \par
 1779                        ,fsUnicodeFractions \par
 1780                      \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxisTickerPi\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:QCPAxisTickerPi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisTickerPi::QCPAxisTickerPi ()}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to {\b QCPAxis::setTicker}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6733                                  :\par
 6734   mPiSymbol(QLatin1String(" ")+QChar(0x03C0)),\par
 6735   mPiValue(M_PI),\par
 6736   mPeriodicity(0),\par
 6737   mFractionStyle(fsUnicodeFractions),\par
 6738   mPiTickStep(0)\par
 6739 \{\par
 6740   setTickCount(4);\par
 6741 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fractionStyle\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:fractionStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FractionStyle} QCPAxisTickerPi::fractionStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1789 \{ return mFractionStyle; \}\par
}
}
{\xe \v fractionToString\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:fractionToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerPi::fractionToString (int  {\i numerator}, int  {\i denominator}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6887 \{\par
 6888   if (denominator == 0)\par
 6889   \{\par
 6890     qDebug() << Q_FUNC_INFO << "called with zero denominator";\par
 6891     return QString();\par
 6892   \}\par
 6893   if (mFractionStyle == fsFloatingPoint) // should never be the case when calling this function\par
 6894   \{\par
 6895     qDebug() << Q_FUNC_INFO << "shouldn't be called with fraction style fsDecimal";\par
 6896     return QString::number(numerator/(double)denominator); // failsafe\par
 6897   \}\par
 6898   int sign = numerator*denominator < 0 ? -1 : 1;\par
 6899   numerator = qAbs(numerator);\par
 6900   denominator = qAbs(denominator);\par
 6901   \par
 6902   if (denominator == 1)\par
 6903   \{\par
 6904     return QString::number(sign*numerator);\par
 6905   \} else\par
 6906   \{\par
 6907     int integerPart = numerator/denominator;\par
 6908     int remainder = numerator%denominator;\par
 6909     if (remainder == 0)\par
 6910     \{\par
 6911       return QString::number(sign*integerPart);\par
 6912     \} else\par
 6913     \{\par
 6914       if (mFractionStyle == fsAsciiFractions)\par
 6915       \{\par
 6916         return QString(QLatin1String("%1%2%3/%4"))\par
 6917             .arg(sign == -1 ? QLatin1String("-") : QLatin1String(""))\par
 6918             .arg(integerPart > 0 ? QString::number(integerPart)+QLatin1String(" ") : QLatin1String(""))\par
 6919             .arg(remainder)\par
 6920             .arg(denominator);\par
 6921       \} else if (mFractionStyle == fsUnicodeFractions)\par
 6922       \{\par
 6923         return QString(QLatin1String("%1%2%3"))\par
 6924             .arg(sign == -1 ? QLatin1String("-") : QLatin1String(""))\par
 6925             .arg(integerPart > 0 ? QString::number(integerPart) : QLatin1String(""))\par
 6926             .arg(unicodeFraction(remainder, denominator));\par
 6927       \}\par
 6928     \}\par
 6929   \}\par
 6930   return QString();\par
 6931 \}\par
}
}
{\xe \v getSubTickCount\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:getSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerPi::getSubTickCount (double  {\i tickStep}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6812 \{\par
 6813   return QCPAxisTicker::getSubTickCount(tickStep/mPiValue);\par
 6814 \}\par
}
}
{\xe \v getTickLabel\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:getTickLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerPi::getTickLabel (double  {\i tick}, const QLocale &  {\i locale}, QChar  {\i formatChar}, int  {\i precision}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6825 \{\par
 6826   double tickInPis = tick/mPiValue;\par
 6827   if (mPeriodicity > 0)\par
 6828     tickInPis = fmod(tickInPis, mPeriodicity);\par
 6829   \par
 6830   if (mFractionStyle != fsFloatingPoint && mPiTickStep > 0.09 && mPiTickStep < 50)\par
 6831   \{\par
 6832     // simply construct fraction from decimal like 1.234 -> 1234/1000 and then simplify fraction, smaller digits are irrelevant due to mPiTickStep conditional above\par
 6833     int denominator = 1000;\par
 6834     int numerator = qRound(tickInPis*denominator);\par
 6835     simplifyFraction(numerator, denominator);\par
 6836     if (qAbs(numerator) == 1 && denominator == 1)\par
 6837       return (numerator < 0 ? QLatin1String("-") : QLatin1String("")) + mPiSymbol.trimmed();\par
 6838     else if (numerator == 0)\par
 6839       return QLatin1String("0");\par
 6840     else\par
 6841       return fractionToString(numerator, denominator) + mPiSymbol;\par
 6842   \} else\par
 6843   \{\par
 6844     if (qFuzzyIsNull(tickInPis))\par
 6845       return QLatin1String("0");\par
 6846     else if (qFuzzyCompare(qAbs(tickInPis), 1.0))\par
 6847       return (tickInPis < 0 ? QLatin1String("-") : QLatin1String("")) + mPiSymbol.trimmed();\par
 6848     else\par
 6849       return QCPAxisTicker::getTickLabel(tickInPis, locale, formatChar, precision) + mPiSymbol;\par
 6850   \}\par
 6851 \}\par
}
}
{\xe \v getTickStep\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:getTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerPi::getTickStep (const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6797 \{\par
 6798   mPiTickStep = range.size()/mPiValue/(double)(mTickCount+1e-10); // mTickCount ticks on average, the small addition is to prevent jitter on exact integers\par
 6799   mPiTickStep = cleanMantissa(mPiTickStep);\par
 6800   return mPiTickStep*mPiValue;\par
 6801 \}\par
}
}
{\xe \v periodicity\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:periodicity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisTickerPi::periodicity () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1788 \{ return mPeriodicity; \}\par
}
}
{\xe \v piSymbol\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:piSymbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerPi::piSymbol () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1786 \{ return mPiSymbol; \}\par
}
}
{\xe \v piValue\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:piValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerPi::piValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1787 \{ return mPiValue; \}\par
}
}
{\xe \v setFractionStyle\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:setFractionStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerPi::setFractionStyle ({\b QCPAxisTickerPi::FractionStyle}  {\i style})}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how the numerical/fractional part preceding the symbolic constant is displayed in tick labels. See {\b FractionStyle} for the various options. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6784 \{\par
 6785   mFractionStyle = style;\par
 6786 \}\par
}
}
{\xe \v setPeriodicity\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:setPeriodicity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerPi::setPeriodicity (int  {\i multiplesOfPi})}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the axis labels shall appear periodicly and if so, at which multiplicity of the symbolic constant.\par
To disable periodicity, set {\i multiplesOfPi}  to zero.\par
For example, an axis that identifies 0 with 2pi would set {\i multiplesOfPi}  to two. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6775 \{\par
 6776   mPeriodicity = qAbs(multiplesOfPi);\par
 6777 \}\par
}
}
{\xe \v setPiSymbol\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:setPiSymbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerPi::setPiSymbol (QString  {\i symbol})}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how the symbol part (which is always a suffix to the number) shall appear in the axis tick label.\par
If a space shall appear between the number and the symbol, make sure the space is contained in {\i symbol} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6751 \{\par
 6752   mPiSymbol = symbol;\par
 6753 \}\par
}
}
{\xe \v setPiValue\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:setPiValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerPi::setPiValue (double  {\i pi})}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the numerical value that the symbolic constant has.\par
This will be used to place the appropriate fractions of the symbol at the respective axis coordinates. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6762 \{\par
 6763   mPiValue = pi;\par
 6764 \}\par
}
}
{\xe \v simplifyFraction\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:simplifyFraction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerPi::simplifyFraction (int &  {\i numerator}, int &  {\i denominator}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6860 \{\par
 6861   if (numerator == 0 || denominator == 0)\par
 6862     return;\par
 6863   \par
 6864   int num = numerator;\par
 6865   int denom = denominator;\par
 6866   while (denom != 0) // euclidean gcd algorithm\par
 6867   \{\par
 6868     int oldDenom = denom;\par
 6869     denom = num % denom;\par
 6870     num = oldDenom;\par
 6871   \}\par
 6872   // num is now gcd of numerator and denominator\par
 6873   numerator /= num;\par
 6874   denominator /= num;\par
 6875 \}\par
}
}
{\xe \v unicodeFraction\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:unicodeFraction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerPi::unicodeFraction (int  {\i numerator}, int  {\i denominator}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6943 \{\par
 6944   return unicodeSuperscript(numerator)+QChar(0x2044)+unicodeSubscript(denominator);\par
 6945 \}\par
}
}
{\xe \v unicodeSubscript\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:unicodeSubscript}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerPi::unicodeSubscript (int  {\i number}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6979 \{\par
 6980   if (number == 0)\par
 6981     return QString(QChar(0x2080));\par
 6982   \par
 6983   QString result;\par
 6984   while (number > 0)\par
 6985   \{\par
 6986     result.prepend(QChar(0x2080+number%10));\par
 6987     number /= 10;\par
 6988   \}\par
 6989   return result;\par
 6990 \}\par
}
}
{\xe \v unicodeSuperscript\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:unicodeSuperscript}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerPi::unicodeSuperscript (int  {\i number}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6953 \{\par
 6954   if (number == 0)\par
 6955     return QString(QChar(0x2070));\par
 6956   \par
 6957   QString result;\par
 6958   while (number > 0)\par
 6959   \{\par
 6960     const int digit = number%10;\par
 6961     switch (digit)\par
 6962     \{\par
 6963       case 1: \{ result.prepend(QChar(0x00B9)); break; \}\par
 6964       case 2: \{ result.prepend(QChar(0x00B2)); break; \}\par
 6965       case 3: \{ result.prepend(QChar(0x00B3)); break; \}\par
 6966       default: \{ result.prepend(QChar(0x2070+digit)); break; \}\par
 6967     \}\par
 6968     number /= 10;\par
 6969   \}\par
 6970   return result;\par
 6971 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mFractionStyle\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:mFractionStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FractionStyle} QCPAxisTickerPi::mFractionStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPeriodicity\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:mPeriodicity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerPi::mPeriodicity{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPiSymbol\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:mPiSymbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerPi::mPiSymbol{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPiTickStep\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:mPiTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerPi::mPiTickStep{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPiValue\:QCPAxisTickerPi}
{\xe \v QCPAxisTickerPi\:mPiValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerPi::mPiValue{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisTickerText Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisTickerText}
{\xe \v QCPAxisTickerText}
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker which allows arbitrary labels at specified coordinates. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAxisTickerText:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_text__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAxisTickerText:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_text__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisTickerText} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMap< double, QString > & {\b ticks} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b subTickCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTicks} (const QMap< double, QString > &{\b ticks})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTicks} (const QVector< double > &positions, const QVector< QString > labels)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickCount} (int subTicks)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addTick} (double position, QString label)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addTicks} (const QMap< double, QString > &{\b ticks})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addTicks} (const QVector< double > &positions, const QVector< QString > &labels)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b getTickStep} (const {\b QCPRange} &range) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b getSubTickCount} (double tickStep) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QString {\b getTickLabel} (double tick, const QLocale &locale, QChar formatChar, int precision) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QVector< double > {\b createTickVector} (double tickStep, const {\b QCPRange} &range) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMap< double, QString > {\b mTicks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mSubTickCount}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker which allows arbitrary labels at specified coordinates. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
This {\b QCPAxisTicker} subclass generates ticks which can be directly specified by the user as coordinates and associated strings. They can be passed as a whole with {\b setTicks} or one at a time with {\b addTick}. Alternatively you can directly access the internal storage via {\b ticks} and modify the tick/label data there.\par
This is useful for cases where the axis represents categories rather than numerical values.\par
If you are updating the ticks of this ticker regularly and in a dynamic fasion (e.g. dependent on the axis range), it is a sign that you should probably create an own ticker by subclassing {\b QCPAxisTicker}, instead of using this one.\par
The ticker can be created and assigned to an axis like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxisTickerText\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:QCPAxisTickerText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisTickerText::QCPAxisTickerText ()}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to {\b QCPAxis::setTicker}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6537                                      :\par
 6538   mSubTickCount(0)\par
 6539 \{\par
 6540 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addTick\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:addTick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerText::addTick (double  {\i position}, QString  {\i label})}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a single tick to the axis at the given axis coordinate {\i position} , with the provided tick {\i label} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addTicks}, {\b setTicks}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6604 \{\par
 6605   mTicks.insert(position, label);\par
 6606 \}\par
}
}
{\xe \v addTicks\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:addTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerText::addTicks (const QMap< double, QString > &  {\i ticks})}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided {\i ticks}  to the ones already existing. The map key of {\i ticks}  corresponds to the axis coordinate, and the map value is the string that will appear as tick label.\par
An alternative to manipulate ticks is to directly access the internal storage with the {\b ticks} getter.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addTick}, {\b setTicks}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6619 \{\par
 6620   mTicks.unite(ticks);\par
 6621 \}\par
}
}
{\xe \v addTicks\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:addTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerText::addTicks (const QVector< double > &  {\i positions}, const QVector< QString > &  {\i labels})}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided ticks to the ones already existing. The entries of {\i positions}  correspond to the axis coordinates, and the entries of {\i labels}  are the respective strings that will appear as tick labels.\par
An alternative to manipulate ticks is to directly access the internal storage with the {\b ticks} getter.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addTick}, {\b setTicks}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6635 \{\par
 6636   if (positions.size() != labels.size())\par
 6637     qDebug() << Q_FUNC_INFO << "passed unequal length vectors for positions and labels:" << positions.size() << labels.size();\par
 6638   int n = qMin(positions.size(), labels.size());\par
 6639   for (int i=0; i<n; ++i)\par
 6640     mTicks.insert(positions.at(i), labels.at(i));\par
 6641 \}\par
}
}
{\xe \v clear\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerText::clear ()}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all ticks.\par
An alternative to manipulate ticks is to directly access the internal storage with the {\b ticks} getter.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTicks}, {\b addTicks}, {\b addTick} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6593 \{\par
 6594   mTicks.clear();\par
 6595 \}\par
}
}
{\xe \v createTickVector\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:createTickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< double > QCPAxisTickerText::createTickVector (double  {\i tickStep}, const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the externally provided tick coordinates which are in the specified {\i range} . If available, one tick above and below the range is provided in addition, to allow possible sub tick calculation. The parameter {\i tickStep}  is ignored.\par
}{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6688 \{\par
 6689   Q_UNUSED(tickStep)\par
 6690   QVector<double> result;\par
 6691   if (mTicks.isEmpty())\par
 6692     return result;\par
 6693   \par
 6694   QMap<double, QString>::const_iterator start = mTicks.lowerBound(range.lower);\par
 6695   QMap<double, QString>::const_iterator end = mTicks.upperBound(range.upper);\par
 6696   // this method should try to give one tick outside of range so proper subticks can be generated:\par
 6697   if (start != mTicks.constBegin()) --start;\par
 6698   if (end != mTicks.constEnd()) ++end;\par
 6699   for (QMap<double, QString>::const_iterator it = start; it != end; ++it)\par
 6700     result.append(it.key());\par
 6701   \par
 6702   return result;\par
 6703 \}\par
}
}
{\xe \v getSubTickCount\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:getSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerText::getSubTickCount (double  {\i tickStep}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the sub tick count that was configured with {\b setSubTickCount}.\par
}{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6661 \{\par
 6662   Q_UNUSED(tickStep)\par
 6663   return mSubTickCount;\par
 6664 \}\par
}
}
{\xe \v getTickLabel\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:getTickLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerText::getTickLabel (double  {\i tick}, const QLocale &  {\i locale}, QChar  {\i formatChar}, int  {\i precision}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the tick label which corresponds to the key {\i tick}  in the internal tick storage. Since the labels are provided externally, {\i locale} , {\i formatChar} , and {\i precision}  are ignored.\par
}{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6673 \{\par
 6674   Q_UNUSED(locale)\par
 6675   Q_UNUSED(formatChar)\par
 6676   Q_UNUSED(precision)\par
 6677   return mTicks.value(tick);\par
 6678 \}\par
}
}
{\xe \v getTickStep\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:getTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerText::getTickStep (const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Since the tick coordinates are provided externally, this method implementation does nothing.\par
}{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6649 \{\par
 6650   // text axis ticker has manual tick positions, so doesn't need this method\par
 6651   Q_UNUSED(range)\par
 6652   return 1.0;\par
 6653 \}\par
}
}
{\xe \v setSubTickCount\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:setSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerText::setSubTickCount (int  {\i subTicks})}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of sub ticks that shall appear between ticks. For {\b QCPAxisTickerText}, there is no automatic sub tick count calculation. So if sub ticks are needed, they must be configured with this method. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6577 \{\par
 6578   if (subTicks >= 0)\par
 6579     mSubTickCount = subTicks;\par
 6580   else\par
 6581     qDebug() << Q_FUNC_INFO << "sub tick count can't be negative:" << subTicks;\par
 6582 \}\par
}
}
{\xe \v setTicks\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:setTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerText::setTicks (const QMap< double, QString > &  {\i ticks})}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the ticks that shall appear on the axis. The map key of {\i ticks}  corresponds to the axis coordinate, and the map value is the string that will appear as tick label.\par
An alternative to manipulate ticks is to directly access the internal storage with the {\b ticks} getter.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addTicks}, {\b addTick}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6553 \{\par
 6554   mTicks = ticks;\par
 6555 \}\par
}
}
{\xe \v setTicks\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:setTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerText::setTicks (const QVector< double > &  {\i positions}, const QVector< QString >  {\i labels})}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the ticks that shall appear on the axis. The entries of {\i positions}  correspond to the axis coordinates, and the entries of {\i labels}  are the respective strings that will appear as tick labels.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addTicks}, {\b addTick}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6566 \{\par
 6567   clear();\par
 6568   addTicks(positions, labels);\par
 6569 \}\par
}
}
{\xe \v subTickCount\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:subTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerText::subTickCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1736 \{ return mSubTickCount; \}\par
}
}
{\xe \v ticks\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:ticks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMap< double, QString > & QCPAxisTickerText::ticks (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a non-const reference to the internal map which stores the tick coordinates and their labels.\par
You can access the map directly in order to add, remove or manipulate ticks, as an alternative to using the methods provided by {\b QCPAxisTickerText}, such as {\b setTicks} and {\b addTick}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1735 \{ return mTicks; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mSubTickCount\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:mSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerText::mSubTickCount{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTicks\:QCPAxisTickerText}
{\xe \v QCPAxisTickerText\:mTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMap<double, QString> QCPAxisTickerText::mTicks{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisTickerTime Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime}
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker for time spans in units of milliseconds to days. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPAxisTickerTime:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_time__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPAxisTickerTime:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_axis_ticker_time__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b TimeUnit} \{ {\b tuMilliseconds}, 
{\b tuSeconds}, 
{\b tuMinutes}, 
{\b tuHours}, 
{\b tuDays}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisTickerTime} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b timeFormat} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b fieldWidth} ({\b TimeUnit} unit) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTimeFormat} (const QString &format)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFieldWidth} ({\b TimeUnit} unit, int width)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b getTickStep} (const {\b QCPRange} &range) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b getSubTickCount} (double tickStep) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QString {\b getTickLabel} (double tick, const QLocale &locale, QChar formatChar, int precision) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b replaceUnit} (QString &text, {\b TimeUnit} unit, int value) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mTimeFormat}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QHash< {\b TimeUnit}, int > {\b mFieldWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimeUnit} {\b mSmallestUnit}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimeUnit} {\b mBiggestUnit}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QHash< {\b TimeUnit}, QString > {\b mFormatPattern}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker for time spans in units of milliseconds to days. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
This {\b QCPAxisTicker} subclass generates ticks that corresponds to time intervals.\par
The format of the time display in the tick labels is controlled with {\b setTimeFormat} and {\b setFieldWidth}. The time coordinate is in the unit of seconds with respect to the time coordinate zero. Unlike with {\b QCPAxisTickerDateTime}, the ticks don't correspond to a specific calendar date and time.\par
The time can be displayed in milliseconds, seconds, minutes, hours and days. Depending on the largest available unit in the format specified with {\b setTimeFormat}, any time spans above will be carried in that largest unit. So for example if the format string is "%m:%s" and a tick at coordinate value 7815 (being 2 hours, 10 minutes and 15 seconds) is created, the resulting tick label will show "130:15" (130 minutes, 15 seconds). If the format string is "%h:%m:%s", the hour unit will be used and the label will thus be "02:10:15". Negative times with respect to the axis zero will carry a leading minus sign.\par
The ticker can be created and assigned to an axis like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } Here is an example of a time axis providing time information in days, hours and minutes. Due to the axis range spanning a few days and the wanted tick count ({\b setTickCount}), the ticker decided to use tick steps of 12 hours:\par
The format string for this example is {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid If you rather wish to display calendar dates and times, have a look at {\b QCPAxisTickerDateTime} instead. \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v TimeUnit\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:TimeUnit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxisTickerTime::TimeUnit}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the logical units in which fractions of time spans can be expressed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFieldWidth}, {\b setTimeFormat} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v tuMilliseconds\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:tuMilliseconds}
{\qr tuMilliseconds{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Milliseconds, one thousandth of a second (%z in {\b setTimeFormat}) \par
}\cell }{\row }
{\xe \v tuSeconds\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:tuSeconds}
{\qr tuSeconds{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Seconds (%s in {\b setTimeFormat}) \par
}\cell }{\row }
{\xe \v tuMinutes\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:tuMinutes}
{\qr tuMinutes{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minutes (%m in {\b setTimeFormat}) \par
}\cell }{\row }
{\xe \v tuHours\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:tuHours}
{\qr tuHours{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hours (%h in {\b setTimeFormat}) \par
}\cell }{\row }
{\xe \v tuDays\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:tuDays}
{\qr tuDays{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Days (%d in {\b setTimeFormat}) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1644                 \{ tuMilliseconds \par
 1645                   ,tuSeconds     \par
 1646                   ,tuMinutes     \par
 1647                   ,tuHours       \par
 1648                   ,tuDays        \par
 1649                 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPAxisTickerTime\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:QCPAxisTickerTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisTickerTime::QCPAxisTickerTime ()}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to {\b QCPAxis::setTicker}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6189                                      :\par
 6190   mTimeFormat(QLatin1String("%h:%m:%s")),\par
 6191   mSmallestUnit(tuSeconds),\par
 6192   mBiggestUnit(tuHours)\par
 6193 \{\par
 6194   setTickCount(4);\par
 6195   mFieldWidth[tuMilliseconds] = 3;\par
 6196   mFieldWidth[tuSeconds] = 2;\par
 6197   mFieldWidth[tuMinutes] = 2;\par
 6198   mFieldWidth[tuHours] = 2;\par
 6199   mFieldWidth[tuDays] = 1;\par
 6200   \par
 6201   mFormatPattern[tuMilliseconds] = QLatin1String("%z");\par
 6202   mFormatPattern[tuSeconds] = QLatin1String("%s");\par
 6203   mFormatPattern[tuMinutes] = QLatin1String("%m");\par
 6204   mFormatPattern[tuHours] = QLatin1String("%h");\par
 6205   mFormatPattern[tuDays] = QLatin1String("%d");\par
 6206 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fieldWidth\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:fieldWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerTime::fieldWidth ({\b TimeUnit}  {\i unit}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1656 \{ return mFieldWidth.value(unit); \}\par
}
}
{\xe \v getSubTickCount\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:getSubTickCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisTickerTime::getSubTickCount (double  {\i tickStep}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6323 \{\par
 6324   int result = QCPAxisTicker::getSubTickCount(tickStep);\par
 6325   switch (qRound(tickStep)) // hand chosen subticks for specific minute/hour/day range (as specified in getTickStep)\par
 6326   \{\par
 6327     case 5*60: result = 4; break;\par
 6328     case 10*60: result = 1; break;\par
 6329     case 15*60: result = 2; break;\par
 6330     case 30*60: result = 1; break;\par
 6331     case 60*60: result = 3; break;\par
 6332     case 3600*2: result = 3; break;\par
 6333     case 3600*3: result = 2; break;\par
 6334     case 3600*6: result = 1; break;\par
 6335     case 3600*12: result = 3; break;\par
 6336     case 3600*24: result = 3; break;\par
 6337   \}\par
 6338   return result;\par
 6339 \}\par
}
}
{\xe \v getTickLabel\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:getTickLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerTime::getTickLabel (double  {\i tick}, const QLocale &  {\i locale}, QChar  {\i formatChar}, int  {\i precision}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6349 \{\par
 6350   Q_UNUSED(precision)\par
 6351   Q_UNUSED(formatChar)\par
 6352   Q_UNUSED(locale)\par
 6353   bool negative = tick < 0;\par
 6354   if (negative) tick *= -1;\par
 6355   double values[tuDays+1]; // contains the msec/sec/min/... value with its respective modulo (e.g. minute 0..59)\par
 6356   double restValues[tuDays+1]; // contains the msec/sec/min/... value as if it's the largest available unit and thus consumes the remaining time\par
 6357   \par
 6358   restValues[tuMilliseconds] = tick*1000;\par
 6359   values[tuMilliseconds] = modf(restValues[tuMilliseconds]/1000, &restValues[tuSeconds])*1000;\par
 6360   values[tuSeconds] = modf(restValues[tuSeconds]/60, &restValues[tuMinutes])*60;\par
 6361   values[tuMinutes] = modf(restValues[tuMinutes]/60, &restValues[tuHours])*60;\par
 6362   values[tuHours] = modf(restValues[tuHours]/24, &restValues[tuDays])*24;\par
 6363   // no need to set values[tuDays] because days are always a rest value (there is no higher unit so it consumes all remaining time)\par
 6364   \par
 6365   QString result = mTimeFormat;\par
 6366   for (int i = mSmallestUnit; i <= mBiggestUnit; ++i)\par
 6367   \{\par
 6368     TimeUnit iUnit = static_cast<TimeUnit>(i);\par
 6369     replaceUnit(result, iUnit, qRound(iUnit == mBiggestUnit ? restValues[iUnit] : values[iUnit]));\par
 6370   \}\par
 6371   if (negative)\par
 6372     result.prepend(QLatin1Char('-'));\par
 6373   return result;\par
 6374 \}\par
}
}
{\xe \v getTickStep\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:getTickStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisTickerTime::getTickStep (const {\b QCPRange} &  {\i range}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisTicker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6272 \{\par
 6273   double result = range.size()/(double)(mTickCount+1e-10); // mTickCount ticks on average, the small addition is to prevent jitter on exact integers\par
 6274   \par
 6275   if (result < 1) // ideal tick step is below 1 second -> use normal clean mantissa algorithm in units of seconds\par
 6276   \{\par
 6277     if (mSmallestUnit == tuMilliseconds)\par
 6278       result = qMax(cleanMantissa(result), 0.001); // smallest tick step is 1 millisecond\par
 6279     else // have no milliseconds available in format, so stick with 1 second tickstep\par
 6280       result = 1.0;\par
 6281   \} else if (result < 3600*24) // below a day\par
 6282   \{\par
 6283     // the filling of availableSteps seems a bit contorted but it fills in a sorted fashion and thus saves a post-fill sorting run\par
 6284     QVector<double> availableSteps;\par
 6285     // seconds range:\par
 6286     if (mSmallestUnit <= tuSeconds)\par
 6287       availableSteps << 1;\par
 6288     if (mSmallestUnit == tuMilliseconds)\par
 6289       availableSteps << 2.5; // only allow half second steps if milliseconds are there to display it\par
 6290     else if (mSmallestUnit == tuSeconds)\par
 6291       availableSteps << 2;\par
 6292     if (mSmallestUnit <= tuSeconds)\par
 6293       availableSteps << 5 << 10 << 15 << 30;\par
 6294     // minutes range:\par
 6295     if (mSmallestUnit <= tuMinutes)\par
 6296       availableSteps << 1*60;\par
 6297     if (mSmallestUnit <= tuSeconds)\par
 6298       availableSteps << 2.5*60; // only allow half minute steps if seconds are there to display it\par
 6299     else if (mSmallestUnit == tuMinutes)\par
 6300       availableSteps << 2*60;\par
 6301     if (mSmallestUnit <= tuMinutes)\par
 6302       availableSteps << 5*60 << 10*60 << 15*60 << 30*60;\par
 6303     // hours range:\par
 6304     if (mSmallestUnit <= tuHours)\par
 6305       availableSteps << 1*3600 << 2*3600 << 3*3600 << 6*3600 << 12*3600 << 24*3600;\par
 6306     // pick available step that is most appropriate to approximate ideal step:\par
 6307     result = pickClosest(result, availableSteps);\par
 6308   \} else // more than a day, go back to normal clean mantissa algorithm but in units of days\par
 6309   \{\par
 6310     const double secondsPerDay = 3600*24;\par
 6311     result = cleanMantissa(result/secondsPerDay)*secondsPerDay;\par
 6312   \}\par
 6313   return result;\par
 6314 \}\par
}
}
{\xe \v replaceUnit\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:replaceUnit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerTime::replaceUnit (QString &  {\i text}, {\b QCPAxisTickerTime::TimeUnit}  {\i unit}, int  {\i value}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6382 \{\par
 6383   QString valueStr = QString::number(value);\par
 6384   while (valueStr.size() < mFieldWidth.value(unit))\par
 6385     valueStr.prepend(QLatin1Char('0'));\par
 6386   \par
 6387   text.replace(mFormatPattern.value(unit), valueStr);\par
 6388 \}\par
}
}
{\xe \v setFieldWidth\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:setFieldWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerTime::setFieldWidth ({\b QCPAxisTickerTime::TimeUnit}  {\i unit}, int  {\i width})}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the field widh of the specified {\i unit}  to be {\i width}  digits, when displayed in the tick label. If the number for the specific unit is shorter than {\i width} , it will be padded with an according number of zeros to the left in order to reach the field width.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTimeFormat} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6258 \{\par
 6259   mFieldWidth[unit] = qMax(width, 1);\par
 6260 \}\par
}
}
{\xe \v setTimeFormat\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:setTimeFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisTickerTime::setTimeFormat (const QString &  {\i format})}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the format that will be used to display time in the tick labels.\par
The available patterns are:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
%z for milliseconds\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
%s for seconds\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
%m for minutes\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
%h for hours\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
%d for days\par}
The field width (zero padding) can be controlled for each unit with {\b setFieldWidth}.\par
The largest unit that appears in {\i format}  will carry all the remaining time of a certain tick coordinate, even if it overflows the natural limit of the unit. For example, if %m is the largest unit it might become larger than 59 in order to consume larger time values. If on the other hand %h is available, the minutes will wrap around to zero after 59 and the time will carry to the hour digit. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6227 \{\par
 6228   mTimeFormat = format;\par
 6229   \par
 6230   // determine smallest and biggest unit in format, to optimize unit replacement and allow biggest\par
 6231   // unit to consume remaining time of a tick value and grow beyond its modulo (e.g. min > 59)\par
 6232   mSmallestUnit = tuMilliseconds;\par
 6233   mBiggestUnit = tuMilliseconds;\par
 6234   bool hasSmallest = false;\par
 6235   for (int i = tuMilliseconds; i <= tuDays; ++i)\par
 6236   \{\par
 6237     TimeUnit unit = static_cast<TimeUnit>(i);\par
 6238     if (mTimeFormat.contains(mFormatPattern.value(unit)))\par
 6239     \{\par
 6240       if (!hasSmallest)\par
 6241       \{\par
 6242         mSmallestUnit = unit;\par
 6243         hasSmallest = true;\par
 6244       \}\par
 6245       mBiggestUnit = unit;\par
 6246     \}\par
 6247   \}\par
 6248 \}\par
}
}
{\xe \v timeFormat\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:timeFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerTime::timeFormat () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1655 \{ return mTimeFormat; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBiggestUnit\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:mBiggestUnit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TimeUnit} QCPAxisTickerTime::mBiggestUnit{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mFieldWidth\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:mFieldWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QHash<{\b TimeUnit}, int> QCPAxisTickerTime::mFieldWidth{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mFormatPattern\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:mFormatPattern}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QHash<{\b TimeUnit}, QString> QCPAxisTickerTime::mFormatPattern{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSmallestUnit\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:mSmallestUnit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TimeUnit} QCPAxisTickerTime::mSmallestUnit{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTimeFormat\:QCPAxisTickerTime}
{\xe \v QCPAxisTickerTime\:mTimeFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisTickerTime::mTimeFormat{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPBars Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPBars}
{\xe \v QCPBars}
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a bar chart in a plot. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPBars:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_bars__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPBars:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_bars__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b WidthType} \{ {\b wtAbsolute}, 
{\b wtAxisRectRatio}, 
{\b wtPlotCoords}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPBars} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPBars} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b width} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WidthType} {\b widthType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPBarsGroup} * {\b barsGroup} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b baseValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b stackingGap} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPBars} * {\b barBelow} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPBars} * {\b barAbove} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPBarsDataContainer} > {\b data} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (QSharedPointer< {\b QCPBarsDataContainer} > {\b data})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWidth} (double {\b width})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWidthType} ({\b WidthType} {\b widthType})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBarsGroup} ({\b QCPBarsGroup} *{\b barsGroup})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBaseValue} (double {\b baseValue})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setStackingGap} (double pixels)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (double key, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveBelow} ({\b QCPBars} *bars)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveAbove} ({\b QCPBars} *bars)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPDataSelection} {\b selectTestRect} (const QRectF &rect, bool onlySelectable) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b dataPixelPosition} (int index) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getVisibleDataBounds} ({\b QCPBarsDataContainer::const_iterator} &begin, {\b QCPBarsDataContainer::const_iterator} &end) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRectF {\b getBarRect} (double key, double value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getPixelWidth} (double key, double &lower, double &upper) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getStackedBaseValue} (double key, bool positive) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b connectBars} ({\b QCPBars} *lower, {\b QCPBars} *upper)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WidthType} {\b mWidthType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPBarsGroup} * {\b mBarsGroup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mBaseValue}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mStackingGap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPBars} > {\b mBarBelow}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPBars} > {\b mBarAbove}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPBarsGroup}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a bar chart in a plot. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
To plot data, assign it with the {\b setData} or {\b addData} functions.\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Changing the appearance
\par}
{\tc\tcl2 \v Changing the appearance}
The appearance of the bars is determined by the pen and the brush ({\b setPen}, {\b setBrush}). The width of the individual bars can be controlled with {\b setWidthType} and {\b setWidth}.\par
Bar charts are stackable. This means, two {\b QCPBars} plottables can be placed on top of each other (see {\b QCPBars::moveAbove}). So when two bars are at the same key position, they will appear stacked.\par
If you would like to group multiple {\b QCPBars} plottables together so they appear side by side as shown below, use {\b QCPBarsGroup}.\par
\par}
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
Like all data representing objects in {\b QCustomPlot}, the {\b QCPBars} is a plottable ({\b QCPAbstractPlottable}). So the plottable-interface of {\b QCustomPlot} applies ({\b QCustomPlot::plottable}, {\b QCustomPlot::removePlottable}, etc.)\par
Usually, you first create an instance: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }which registers it with the {\b QCustomPlot} instance of the passed axes. Note that this {\b QCustomPlot} instance takes ownership of the plottable, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. The newly created plottable can be modified, e.g.: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v WidthType\:QCPBars}
{\xe \v QCPBars\:WidthType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPBars::WidthType}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the ways the width of the bar can be specified. Thus it defines what the number passed to {\b setWidth} actually means.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWidthType}, {\b setWidth} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v wtAbsolute\:QCPBars}
{\xe \v QCPBars\:wtAbsolute}
{\qr wtAbsolute{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bar width is in absolute pixels. \par
}\cell }{\row }
{\xe \v wtAxisRectRatio\:QCPBars}
{\xe \v QCPBars\:wtAxisRectRatio}
{\qr wtAxisRectRatio{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bar width is given by a fraction of the axis rect size. \par
}\cell }{\row }
{\xe \v wtPlotCoords\:QCPBars}
{\xe \v QCPBars\:wtPlotCoords}
{\qr wtPlotCoords{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bar width is in key coordinates and thus scales with the key axis range. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5490                  \{ wtAbsolute       \par
 5491                    ,wtAxisRectRatio \par
 5492                    ,wtPlotCoords    \par
 5493                  \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPBars\:QCPBars}
{\xe \v QCPBars\:QCPBars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPBars::QCPBars ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a bar chart which uses {\i keyAxis}  as its key axis ("x") and {\i valueAxis}  as its value axis ("y"). {\i keyAxis}  and {\i valueAxis}  must reside in the same {\b QCustomPlot} instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.\par
The created {\b QCPBars} is automatically registered with the {\b QCustomPlot} instance inferred from {\i keyAxis} . This {\b QCustomPlot} instance takes ownership of the {\b QCPBars}, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23588                                                      :\par
23589   QCPAbstractPlottable1D<QCPBarsData>(keyAxis, valueAxis),\par
23590   mWidth(0.75),\par
23591   mWidthType(wtPlotCoords),\par
23592   mBarsGroup(0),\par
23593   mBaseValue(0),\par
23594   mStackingGap(0)\par
23595 \{\par
23596   // modify inherited properties from abstract plottable:\par
23597   mPen.setColor(Qt::blue);\par
23598   mPen.setStyle(Qt::SolidLine);\par
23599   mBrush.setColor(QColor(40, 50, 255, 30));\par
23600   mBrush.setStyle(Qt::SolidPattern);\par
23601   mSelectionDecorator->setBrush(QBrush(QColor(160, 160, 255)));\par
23602 \}\par
}
}
{\xe \v ~QCPBars\:QCPBars}
{\xe \v QCPBars\:~QCPBars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPBars::~QCPBars (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23605 \{\par
23606   setBarsGroup(0);\par
23607   if (mBarBelow || mBarAbove)\par
23608     connectBars(mBarBelow.data(), mBarAbove.data()); // take this bar out of any stacking\par
23609 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addData\:QCPBars}
{\xe \v QCPBars\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::addData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i values}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided points in {\i keys}  and {\i values}  to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23729 \{\par
23730   if (keys.size() != values.size())\par
23731     qDebug() << Q_FUNC_INFO << "keys and values have different sizes:" << keys.size() << values.size();\par
23732   const int n = qMin(keys.size(), values.size());\par
23733   QVector<QCPBarsData> tempData(n);\par
23734   QVector<QCPBarsData>::iterator it = tempData.begin();\par
23735   const QVector<QCPBarsData>::iterator itEnd = tempData.end();\par
23736   int i = 0;\par
23737   while (it != itEnd)\par
23738   \{\par
23739     it->key = keys[i];\par
23740     it->value = values[i];\par
23741     ++it;\par
23742     ++i;\par
23743   \}\par
23744   mDataContainer->add(tempData, alreadySorted); // don't modify tempData beyond this to prevent copy on write\par
23745 \}\par
}
}
{\xe \v addData\:QCPBars}
{\xe \v QCPBars\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::addData (double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Adds the provided data point as {\i key}  and {\i value}  to the current data.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23754 \{\par
23755   mDataContainer->add(QCPBarsData(key, value));\par
23756 \}\par
}
}
{\xe \v barAbove\:QCPBars}
{\xe \v QCPBars\:barAbove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPBars} * QCPBars::barAbove () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the bars plottable that is directly above this bars plottable. If there is no such plottable, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b barBelow}, {\b moveBelow}, {\b moveAbove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5506 \{ return mBarAbove.data(); \}\par
}
}
{\xe \v barBelow\:QCPBars}
{\xe \v QCPBars\:barBelow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPBars} * QCPBars::barBelow () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the bars plottable that is directly below this bars plottable. If there is no such plottable, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b barAbove}, {\b moveBelow}, {\b moveAbove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5505 \{ return mBarBelow.data(); \}\par
}
}
{\xe \v barsGroup\:QCPBars}
{\xe \v QCPBars\:barsGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPBarsGroup}* QCPBars::barsGroup () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5502 \{ return mBarsGroup; \}\par
}
}
{\xe \v baseValue\:QCPBars}
{\xe \v QCPBars\:baseValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBars::baseValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5503 \{ return mBaseValue; \}\par
}
}
{\xe \v connectBars\:QCPBars}
{\xe \v QCPBars\:connectBars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::connectBars ({\b QCPBars} *  {\i lower}, {\b QCPBars} *  {\i upper}){\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24237 \{\par
24238   if (!lower && !upper) return;\par
24239   \par
24240   if (!lower) // disconnect upper at bottom\par
24241   \{\par
24242     // disconnect old bar below upper:\par
24243     if (upper->mBarBelow && upper->mBarBelow.data()->mBarAbove.data() == upper)\par
24244       upper->mBarBelow.data()->mBarAbove = 0;\par
24245     upper->mBarBelow = 0;\par
24246   \} else if (!upper) // disconnect lower at top\par
24247   \{\par
24248     // disconnect old bar above lower:\par
24249     if (lower->mBarAbove && lower->mBarAbove.data()->mBarBelow.data() == lower)\par
24250       lower->mBarAbove.data()->mBarBelow = 0;\par
24251     lower->mBarAbove = 0;\par
24252   \} else // connect lower and upper\par
24253   \{\par
24254     // disconnect old bar above lower:\par
24255     if (lower->mBarAbove && lower->mBarAbove.data()->mBarBelow.data() == lower)\par
24256       lower->mBarAbove.data()->mBarBelow = 0;\par
24257     // disconnect old bar below upper:\par
24258     if (upper->mBarBelow && upper->mBarBelow.data()->mBarAbove.data() == upper)\par
24259       upper->mBarBelow.data()->mBarAbove = 0;\par
24260     lower->mBarAbove = upper;\par
24261     upper->mBarBelow = lower;\par
24262   \}\par
24263 \}\par
}
}
{\xe \v data\:QCPBars}
{\xe \v QCPBars\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer< {\b QCPBarsDataContainer} > QCPBars::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a shared pointer to the internal data storage of type {\b QCPBarsDataContainer}. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular {\b setData} or {\b addData} methods. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5507 \{ return mDataContainer; \}\par
}
}
{\xe \v dataPixelPosition\:QCPBars}
{\xe \v QCPBars\:dataPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPBars::dataPixelPosition (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position on the widget surface at which the data point at the given {\i index}  appears.\par
Usually this corresponds to the point of {\b dataMainKey}/{\b dataMainValue}, in pixel coordinates. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values. For example, {\b QCPBars} apparent data values can be shifted depending on their stacking, bar grouping or configured base value. \par
}{
Reimplemented from {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23958 \{\par
23959   if (index >= 0 && index < mDataContainer->size())\par
23960   \{\par
23961     QCPAxis *keyAxis = mKeyAxis.data();\par
23962     QCPAxis *valueAxis = mValueAxis.data();\par
23963     if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); \}\par
23964     \par
23965     const QCPDataContainer<QCPBarsData>::const_iterator it = mDataContainer->constBegin()+index;\par
23966     const double valuePixel = valueAxis->coordToPixel(getStackedBaseValue(it->key, it->value >= 0) + it->value);\par
23967     const double keyPixel = keyAxis->coordToPixel(it->key) + (mBarsGroup ? mBarsGroup->keyPixelOffset(this, it->key) : 0);\par
23968     if (keyAxis->orientation() == Qt::Horizontal)\par
23969       return QPointF(keyPixel, valuePixel);\par
23970     else\par
23971       return QPointF(valuePixel, keyPixel);\par
23972   \} else\par
23973   \{\par
23974     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
23975     return QPointF();\par
23976   \}\par
23977 \}\par
}
}
{\xe \v draw\:QCPBars}
{\xe \v QCPBars\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23981 \{\par
23982   if (!mKeyAxis || !mValueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
23983   if (mDataContainer->isEmpty()) return;\par
23984   \par
23985   QCPBarsDataContainer::const_iterator visibleBegin, visibleEnd;\par
23986   getVisibleDataBounds(visibleBegin, visibleEnd);\par
23987   \par
23988   // loop over and draw segments of unselected/selected data:\par
23989   QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;\par
23990   getDataSegments(selectedSegments, unselectedSegments);\par
23991   allSegments << unselectedSegments << selectedSegments;\par
23992   for (int i=0; i<allSegments.size(); ++i)\par
23993   \{\par
23994     bool isSelectedSegment = i >= unselectedSegments.size();\par
23995     QCPBarsDataContainer::const_iterator begin = visibleBegin;\par
23996     QCPBarsDataContainer::const_iterator end = visibleEnd;\par
23997     mDataContainer->limitIteratorsToDataRange(begin, end, allSegments.at(i));\par
23998     if (begin == end)\par
23999       continue;\par
24000     \par
24001     for (QCPBarsDataContainer::const_iterator it=begin; it!=end; ++it)\par
24002     \{\par
24003       // check data validity if flag set:\par
24004 #ifdef QCUSTOMPLOT_CHECK_DATA\par
24005       if (QCP::isInvalidData(it->key, it->value))\par
24006         qDebug() << Q_FUNC_INFO << "Data point at" << it->key << "of drawn range invalid." << "Plottable name:" << name();\par
24007 #endif\par
24008       // draw bar:\par
24009       if (isSelectedSegment && mSelectionDecorator)\par
24010       \{\par
24011         mSelectionDecorator->applyBrush(painter);\par
24012         mSelectionDecorator->applyPen(painter);\par
24013       \} else\par
24014       \{\par
24015         painter->setBrush(mBrush);\par
24016         painter->setPen(mPen);\par
24017       \}\par
24018       applyDefaultAntialiasingHint(painter);\par
24019       painter->drawPolygon(getBarRect(it->key, it->value));\par
24020     \}\par
24021   \}\par
24022   \par
24023   // draw other selection decoration that isn't just line/scatter pens and brushes:\par
24024   if (mSelectionDecorator)\par
24025     mSelectionDecorator->drawDecoration(painter, selection());\par
24026 \}\par
}
}
{\xe \v drawLegendIcon\:QCPBars}
{\xe \v QCPBars\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24030 \{\par
24031   // draw filled rect:\par
24032   applyDefaultAntialiasingHint(painter);\par
24033   painter->setBrush(mBrush);\par
24034   painter->setPen(mPen);\par
24035   QRectF r = QRectF(0, 0, rect.width()*0.67, rect.height()*0.67);\par
24036   r.moveCenter(rect.center());\par
24037   painter->drawRect(r);\par
24038 \}\par
}
}
{\xe \v getBarRect\:QCPBars}
{\xe \v QCPBars\:getBarRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRectF QCPBars::getBarRect (double  {\i key}, double  {\i value}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24115 \{\par
24116   QCPAxis *keyAxis = mKeyAxis.data();\par
24117   QCPAxis *valueAxis = mValueAxis.data();\par
24118   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QRectF(); \}\par
24119   \par
24120   double lowerPixelWidth, upperPixelWidth;\par
24121   getPixelWidth(key, lowerPixelWidth, upperPixelWidth);\par
24122   double base = getStackedBaseValue(key, value >= 0);\par
24123   double basePixel = valueAxis->coordToPixel(base);\par
24124   double valuePixel = valueAxis->coordToPixel(base+value);\par
24125   double keyPixel = keyAxis->coordToPixel(key);\par
24126   if (mBarsGroup)\par
24127     keyPixel += mBarsGroup->keyPixelOffset(this, key);\par
24128   double bottomOffset = (mBarBelow && mPen != Qt::NoPen ? 1 : 0)*(mPen.isCosmetic() ? 1 : mPen.widthF());\par
24129   bottomOffset += mBarBelow ? mStackingGap : 0;\par
24130   bottomOffset *= (value<0 ? -1 : 1)*valueAxis->pixelOrientation();\par
24131   if (qAbs(valuePixel-basePixel) <= qAbs(bottomOffset))\par
24132     bottomOffset = valuePixel-basePixel;\par
24133   if (keyAxis->orientation() == Qt::Horizontal)\par
24134   \{\par
24135     return QRectF(QPointF(keyPixel+lowerPixelWidth, valuePixel), QPointF(keyPixel+upperPixelWidth, basePixel+bottomOffset)).normalized();\par
24136   \} else\par
24137   \{\par
24138     return QRectF(QPointF(basePixel+bottomOffset, keyPixel+lowerPixelWidth), QPointF(valuePixel, keyPixel+upperPixelWidth)).normalized();\par
24139   \}\par
24140 \}\par
}
}
{\xe \v getKeyRange\:QCPBars}
{\xe \v QCPBars\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPBars::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23879 \{\par
23880   /* Note: If this QCPBars uses absolute pixels as width (or is in a QCPBarsGroup with spacing in\par
23881   absolute pixels), using this method to adapt the key axis range to fit the bars into the\par
23882   currently visible axis range will not work perfectly. Because in the moment the axis range is\par
23883   changed to the new range, the fixed pixel widths/spacings will represent different coordinate\par
23884   spans than before, which in turn would require a different key range to perfectly fit, and so on.\par
23885   The only solution would be to iteratively approach the perfect fitting axis range, but the\par
23886   mismatch isn't large enough in most applications, to warrant this here. If a user does need a\par
23887   better fit, he should call the corresponding axis rescale multiple times in a row.\par
23888   */\par
23889   QCPRange range;\par
23890   range = mDataContainer->keyRange(foundRange, inSignDomain);\par
23891   \par
23892   // determine exact range of bars by including bar width and barsgroup offset:\par
23893   if (foundRange && mKeyAxis)\par
23894   \{\par
23895     double lowerPixelWidth, upperPixelWidth, keyPixel;\par
23896     // lower range bound:\par
23897     getPixelWidth(range.lower, lowerPixelWidth, upperPixelWidth);\par
23898     keyPixel = mKeyAxis.data()->coordToPixel(range.lower) + lowerPixelWidth;\par
23899     if (mBarsGroup)\par
23900       keyPixel += mBarsGroup->keyPixelOffset(this, range.lower);\par
23901     const double lowerCorrected = mKeyAxis.data()->pixelToCoord(keyPixel);\par
23902     if (!qIsNaN(lowerCorrected) && qIsFinite(lowerCorrected) && range.lower > lowerCorrected)\par
23903       range.lower = lowerCorrected;\par
23904     // upper range bound:\par
23905     getPixelWidth(range.upper, lowerPixelWidth, upperPixelWidth);\par
23906     keyPixel = mKeyAxis.data()->coordToPixel(range.upper) + upperPixelWidth;\par
23907     if (mBarsGroup)\par
23908       keyPixel += mBarsGroup->keyPixelOffset(this, range.upper);\par
23909     const double upperCorrected = mKeyAxis.data()->pixelToCoord(keyPixel);\par
23910     if (!qIsNaN(upperCorrected) && qIsFinite(upperCorrected) && range.upper < upperCorrected)\par
23911       range.upper = upperCorrected;\par
23912   \}\par
23913   return range;\par
23914 \}\par
}
}
{\xe \v getPixelWidth\:QCPBars}
{\xe \v QCPBars\:getPixelWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::getPixelWidth (double  {\i key}, double &  {\i lower}, double &  {\i upper}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24152 \{\par
24153   lower = 0;\par
24154   upper = 0;\par
24155   switch (mWidthType)\par
24156   \{\par
24157     case wtAbsolute:\par
24158     \{\par
24159       upper = mWidth*0.5*mKeyAxis.data()->pixelOrientation();\par
24160       lower = -upper;\par
24161       break;\par
24162     \}\par
24163     case wtAxisRectRatio:\par
24164     \{\par
24165       if (mKeyAxis && mKeyAxis.data()->axisRect())\par
24166       \{\par
24167         if (mKeyAxis.data()->orientation() == Qt::Horizontal)\par
24168           upper = mKeyAxis.data()->axisRect()->width()*mWidth*0.5*mKeyAxis.data()->pixelOrientation();\par
24169         else\par
24170           upper = mKeyAxis.data()->axisRect()->height()*mWidth*0.5*mKeyAxis.data()->pixelOrientation();\par
24171         lower = -upper;\par
24172       \} else\par
24173         qDebug() << Q_FUNC_INFO << "No key axis or axis rect defined";\par
24174       break;\par
24175     \}\par
24176     case wtPlotCoords:\par
24177     \{\par
24178       if (mKeyAxis)\par
24179       \{\par
24180         double keyPixel = mKeyAxis.data()->coordToPixel(key);\par
24181         upper = mKeyAxis.data()->coordToPixel(key+mWidth*0.5)-keyPixel;\par
24182         lower = mKeyAxis.data()->coordToPixel(key-mWidth*0.5)-keyPixel;\par
24183         // no need to qSwap(lower, higher) when range reversed, because higher/lower are gained by\par
24184         // coordinate transform which includes range direction\par
24185       \} else\par
24186         qDebug() << Q_FUNC_INFO << "No key axis defined";\par
24187       break;\par
24188     \}\par
24189   \}\par
24190 \}\par
}
}
{\xe \v getStackedBaseValue\:QCPBars}
{\xe \v QCPBars\:getStackedBaseValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBars::getStackedBaseValue (double  {\i key}, bool  {\i positive}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24202 \{\par
24203   if (mBarBelow)\par
24204   \{\par
24205     double max = 0; // don't initialize with mBaseValue here because only base value of bottom-most bar has meaning in a bar stack\par
24206     // find bars of mBarBelow that are approximately at key and find largest one:\par
24207     double epsilon = qAbs(key)*(sizeof(key)==4 ? 1e-6 : 1e-14); // should be safe even when changed to use float at some point\par
24208     if (key == 0)\par
24209       epsilon = (sizeof(key)==4 ? 1e-6 : 1e-14);\par
24210     QCPBarsDataContainer::const_iterator it = mBarBelow.data()->mDataContainer->findBegin(key-epsilon);\par
24211     QCPBarsDataContainer::const_iterator itEnd = mBarBelow.data()->mDataContainer->findEnd(key+epsilon);\par
24212     while (it != itEnd)\par
24213     \{\par
24214       if (it->key > key-epsilon && it->key < key+epsilon)\par
24215       \{\par
24216         if ((positive && it->value > max) ||\par
24217             (!positive && it->value < max))\par
24218           max = it->value;\par
24219       \}\par
24220       ++it;\par
24221     \}\par
24222     // recurse down the bar-stack to find the total height:\par
24223     return max + mBarBelow.data()->getStackedBaseValue(key, positive);\par
24224   \} else\par
24225     return mBaseValue;\par
24226 \}\par
}
}
{\xe \v getValueRange\:QCPBars}
{\xe \v QCPBars\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPBars::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23918 \{\par
23919   // Note: can't simply use mDataContainer->valueRange here because we need to\par
23920   // take into account bar base value and possible stacking of multiple bars\par
23921   QCPRange range;\par
23922   range.lower = mBaseValue;\par
23923   range.upper = mBaseValue;\par
23924   bool haveLower = true; // set to true, because baseValue should always be visible in bar charts\par
23925   bool haveUpper = true; // set to true, because baseValue should always be visible in bar charts\par
23926   QCPBarsDataContainer::const_iterator itBegin = mDataContainer->constBegin();\par
23927   QCPBarsDataContainer::const_iterator itEnd = mDataContainer->constEnd();\par
23928   if (inKeyRange != QCPRange())\par
23929   \{\par
23930     itBegin = mDataContainer->findBegin(inKeyRange.lower);\par
23931     itEnd = mDataContainer->findEnd(inKeyRange.upper);\par
23932   \}\par
23933   for (QCPBarsDataContainer::const_iterator it = itBegin; it != itEnd; ++it)\par
23934   \{\par
23935     const double current = it->value + getStackedBaseValue(it->key, it->value >= 0);\par
23936     if (qIsNaN(current)) continue;\par
23937     if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))\par
23938     \{\par
23939       if (current < range.lower || !haveLower)\par
23940       \{\par
23941         range.lower = current;\par
23942         haveLower = true;\par
23943       \}\par
23944       if (current > range.upper || !haveUpper)\par
23945       \{\par
23946         range.upper = current;\par
23947         haveUpper = true;\par
23948       \}\par
23949     \}\par
23950   \}\par
23951   \par
23952   foundRange = true; // return true because bar charts always have the 0-line visible\par
23953   return range;\par
23954 \}\par
}
}
{\xe \v getVisibleDataBounds\:QCPBars}
{\xe \v QCPBars\:getVisibleDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::getVisibleDataBounds ({\b QCPBarsDataContainer::const_iterator} &  {\i begin}, {\b QCPBarsDataContainer::const_iterator} &  {\i end}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24055 \{\par
24056   if (!mKeyAxis)\par
24057   \{\par
24058     qDebug() << Q_FUNC_INFO << "invalid key axis";\par
24059     begin = mDataContainer->constEnd();\par
24060     end = mDataContainer->constEnd();\par
24061     return;\par
24062   \}\par
24063   if (mDataContainer->isEmpty())\par
24064   \{\par
24065     begin = mDataContainer->constEnd();\par
24066     end = mDataContainer->constEnd();\par
24067     return;\par
24068   \}\par
24069   \par
24070   // get visible data range as QMap iterators\par
24071   begin = mDataContainer->findBegin(mKeyAxis.data()->range().lower);\par
24072   end = mDataContainer->findEnd(mKeyAxis.data()->range().upper);\par
24073   double lowerPixelBound = mKeyAxis.data()->coordToPixel(mKeyAxis.data()->range().lower);\par
24074   double upperPixelBound = mKeyAxis.data()->coordToPixel(mKeyAxis.data()->range().upper);\par
24075   bool isVisible = false;\par
24076   // walk left from begin to find lower bar that actually is completely outside visible pixel range:\par
24077   QCPBarsDataContainer::const_iterator it = begin;\par
24078   while (it != mDataContainer->constBegin())\par
24079   \{\par
24080     --it;\par
24081     const QRectF barRect = getBarRect(it->key, it->value);\par
24082     if (mKeyAxis.data()->orientation() == Qt::Horizontal)\par
24083       isVisible = ((!mKeyAxis.data()->rangeReversed() && barRect.right() >= lowerPixelBound) || (mKeyAxis.data()->rangeReversed() && barRect.left() <= lowerPixelBound));\par
24084     else // keyaxis is vertical\par
24085       isVisible = ((!mKeyAxis.data()->rangeReversed() && barRect.top() <= lowerPixelBound) || (mKeyAxis.data()->rangeReversed() && barRect.bottom() >= lowerPixelBound));\par
24086     if (isVisible)\par
24087       begin = it;\par
24088     else\par
24089       break;\par
24090   \}\par
24091   // walk right from ubound to find upper bar that actually is completely outside visible pixel range:\par
24092   it = end;\par
24093   while (it != mDataContainer->constEnd())\par
24094   \{\par
24095     const QRectF barRect = getBarRect(it->key, it->value);\par
24096     if (mKeyAxis.data()->orientation() == Qt::Horizontal)\par
24097       isVisible = ((!mKeyAxis.data()->rangeReversed() && barRect.left() <= upperPixelBound) || (mKeyAxis.data()->rangeReversed() && barRect.right() >= upperPixelBound));\par
24098     else // keyaxis is vertical\par
24099       isVisible = ((!mKeyAxis.data()->rangeReversed() && barRect.bottom() >= upperPixelBound) || (mKeyAxis.data()->rangeReversed() && barRect.top() <= upperPixelBound));\par
24100     if (isVisible)\par
24101       end = it+1;\par
24102     else\par
24103       break;\par
24104     ++it;\par
24105   \}\par
24106 \}\par
}
}
{\xe \v moveAbove\:QCPBars}
{\xe \v QCPBars\:moveAbove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::moveAbove ({\b QCPBars} *  {\i bars})}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves this bars plottable above {\i bars} . In other words, the bars of this plottable will appear above the bars of {\i bars} . The move target {\i bars}  must use the same key and value axis as this plottable.\par
Inserting into and removing from existing bar stacking is handled gracefully. If {\i bars}  already has a bars object above itself, this bars object is inserted between the two. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation.\par
To remove this bars plottable from any stacking, set {\i bars}  to 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b moveBelow}, {\b barBelow}, {\b barAbove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23806 \{\par
23807   if (bars == this) return;\par
23808   if (bars && (bars->keyAxis() != mKeyAxis.data() || bars->valueAxis() != mValueAxis.data()))\par
23809   \{\par
23810     qDebug() << Q_FUNC_INFO << "passed QCPBars* doesn't have same key and value axis as this QCPBars";\par
23811     return;\par
23812   \}\par
23813   // remove from stacking:\par
23814   connectBars(mBarBelow.data(), mBarAbove.data()); // Note: also works if one (or both) of them is 0\par
23815   // if new bar given, insert this bar above it:\par
23816   if (bars)\par
23817   \{\par
23818     if (bars->mBarAbove)\par
23819       connectBars(this, bars->mBarAbove.data());\par
23820     connectBars(bars, this);\par
23821   \}\par
23822 \}\par
}
}
{\xe \v moveBelow\:QCPBars}
{\xe \v QCPBars\:moveBelow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::moveBelow ({\b QCPBars} *  {\i bars})}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves this bars plottable below {\i bars} . In other words, the bars of this plottable will appear below the bars of {\i bars} . The move target {\i bars}  must use the same key and value axis as this plottable.\par
Inserting into and removing from existing bar stacking is handled gracefully. If {\i bars}  already has a bars object below itself, this bars object is inserted between the two. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation.\par
To remove this bars plottable from any stacking, set {\i bars}  to 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b moveBelow}, {\b barAbove}, {\b barBelow} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23773 \{\par
23774   if (bars == this) return;\par
23775   if (bars && (bars->keyAxis() != mKeyAxis.data() || bars->valueAxis() != mValueAxis.data()))\par
23776   \{\par
23777     qDebug() << Q_FUNC_INFO << "passed QCPBars* doesn't have same key and value axis as this QCPBars";\par
23778     return;\par
23779   \}\par
23780   // remove from stacking:\par
23781   connectBars(mBarBelow.data(), mBarAbove.data()); // Note: also works if one (or both) of them is 0\par
23782   // if new bar given, insert this bar below it:\par
23783   if (bars)\par
23784   \{\par
23785     if (bars->mBarBelow)\par
23786       connectBars(bars->mBarBelow.data(), this);\par
23787     connectBars(this, bars);\par
23788   \}\par
23789 \}\par
}
}
{\xe \v selectTest\:QCPBars}
{\xe \v QCPBars\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBars::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Reimplemented from {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23849 \{\par
23850   Q_UNUSED(details)\par
23851   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
23852     return -1;\par
23853   if (!mKeyAxis || !mValueAxis)\par
23854     return -1;\par
23855   \par
23856   if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))\par
23857   \{\par
23858     // get visible data range:\par
23859     QCPBarsDataContainer::const_iterator visibleBegin, visibleEnd;\par
23860     getVisibleDataBounds(visibleBegin, visibleEnd);\par
23861     for (QCPBarsDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)\par
23862     \{\par
23863       if (getBarRect(it->key, it->value).contains(pos))\par
23864       \{\par
23865         if (details)\par
23866         \{\par
23867           int pointIndex = it-mDataContainer->constBegin();\par
23868           details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));\par
23869         \}\par
23870         return mParentPlot->selectionTolerance()*0.99;\par
23871       \}\par
23872     \}\par
23873   \}\par
23874   return -1;\par
23875 \}\par
}
}
{\xe \v selectTestRect\:QCPBars}
{\xe \v QCPBars\:selectTestRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPBars::selectTestRect (const QRectF &  {\i rect}, bool  {\i onlySelectable}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection containing all the data points of this plottable which are contained (or hit by) {\i rect} . This is used mainly in the selection rect interaction for data selection (data selection mechanism).\par
If {\i onlySelectable}  is true, an empty {\b QCPDataSelection} is returned if this plottable is not selectable (i.e. if {\b QCPAbstractPlottable::setSelectable} is {\b QCP::stNone}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i rect}  must be a normalized rect (positive or zero width and height). This is especially important when using the rect of {\b QCPSelectionRect::accepted}, which is not necessarily normalized. Use {\f2 QRect::normalized()}  when passing a rect which might not be normalized. \par
}}{
Reimplemented from {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23828 \{\par
23829   QCPDataSelection result;\par
23830   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
23831     return result;\par
23832   if (!mKeyAxis || !mValueAxis)\par
23833     return result;\par
23834   \par
23835   QCPBarsDataContainer::const_iterator visibleBegin, visibleEnd;\par
23836   getVisibleDataBounds(visibleBegin, visibleEnd);\par
23837   \par
23838   for (QCPBarsDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)\par
23839   \{\par
23840     if (rect.intersects(getBarRect(it->key, it->value)))\par
23841       result.addDataRange(QCPDataRange(it-mDataContainer->constBegin(), it-mDataContainer->constBegin()+1), false);\par
23842   \}\par
23843   result.simplify();\par
23844   return result;\par
23845 \}\par
}
}
{\xe \v setBarsGroup\:QCPBars}
{\xe \v QCPBars\:setBarsGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::setBarsGroup ({\b QCPBarsGroup} *  {\i barsGroup})}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets to which {\b QCPBarsGroup} this {\b QCPBars} instance belongs to. Alternatively, you can also use {\b QCPBarsGroup::append}.\par
To remove this {\b QCPBars} from any group, set {\i barsGroup}  to 0. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23679 \{\par
23680   // deregister at old group:\par
23681   if (mBarsGroup)\par
23682     mBarsGroup->unregisterBars(this);\par
23683   mBarsGroup = barsGroup;\par
23684   // register at new group:\par
23685   if (mBarsGroup)\par
23686     mBarsGroup->registerBars(this);\par
23687 \}\par
}
}
{\xe \v setBaseValue\:QCPBars}
{\xe \v QCPBars\:setBaseValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::setBaseValue (double  {\i baseValue})}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the base value of this bars plottable.\par
The base value defines where on the value coordinate the bars start. How far the bars extend from the base value is given by their individual value data. For example, if the base value is set to 1, a bar with data value 2 will have its lowest point at value coordinate 1 and highest point at 3.\par
For stacked bars, only the base value of the bottom-most {\b QCPBars} has meaning.\par
The default base value is 0. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23702 \{\par
23703   mBaseValue = baseValue;\par
23704 \}\par
}
}
{\xe \v setData\:QCPBars}
{\xe \v QCPBars\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::setData (QSharedPointer< {\b QCPBarsDataContainer} >  {\i data})}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data container with the provided {\i data}  container.\par
Since a QSharedPointer is used, multiple {\b QCPBars} may share the same data container safely. Modifying the data in the container will then affect all bars that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } If you do not wish to share containers, but create a copy from an existing container, rather use the {\b QCPDataContainer<DataType>::set} method on the bar's data container directly: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23627 \{\par
23628   mDataContainer = data;\par
23629 \}\par
}
}
{\xe \v setData\:QCPBars}
{\xe \v QCPBars\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::setData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i values}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data with the provided points in {\i keys}  and {\i values} . The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23643 \{\par
23644   mDataContainer->clear();\par
23645   addData(keys, values, alreadySorted);\par
23646 \}\par
}
}
{\xe \v setStackingGap\:QCPBars}
{\xe \v QCPBars\:setStackingGap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::setStackingGap (double  {\i pixels})}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this bars plottable is stacked on top of another bars plottable ({\b moveAbove}), this method allows specifying a distance in {\i pixels} , by which the drawn bar rectangles will be separated by the bars below it. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23712 \{\par
23713   mStackingGap = pixels;\par
23714 \}\par
}
}
{\xe \v setWidth\:QCPBars}
{\xe \v QCPBars\:setWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::setWidth (double  {\i width})}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the width of the bars.\par
How the number passed as {\i width}  is interpreted (e.g. screen pixels, plot coordinates,...), depends on the currently set width type, see {\b setWidthType} and {\b WidthType}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23655 \{\par
23656   mWidth = width;\par
23657 \}\par
}
}
{\xe \v setWidthType\:QCPBars}
{\xe \v QCPBars\:setWidthType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBars::setWidthType ({\b QCPBars::WidthType}  {\i widthType})}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how the width of the bars is defined. See the documentation of {\b WidthType} for an explanation of the possible values for {\i widthType} .\par
The default value is {\b wtPlotCoords}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWidth} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23668 \{\par
23669   mWidthType = widthType;\par
23670 \}\par
}
}
{\xe \v stackingGap\:QCPBars}
{\xe \v QCPBars\:stackingGap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBars::stackingGap () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5504 \{ return mStackingGap; \}\par
}
}
{\xe \v width\:QCPBars}
{\xe \v QCPBars\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBars::width () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5500 \{ return mWidth; \}\par
}
}
{\xe \v widthType\:QCPBars}
{\xe \v QCPBars\:widthType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WidthType} QCPBars::widthType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5501 \{ return mWidthType; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPBarsGroup\:QCPBars}
{\xe \v QCPBars\:QCPBarsGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPBarsGroup}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPLegend\:QCPBars}
{\xe \v QCPBars\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPBars}
{\xe \v QCPBars\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBarAbove\:QCPBars}
{\xe \v QCPBars\:mBarAbove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPBars}> QCPBars::mBarAbove{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBarBelow\:QCPBars}
{\xe \v QCPBars\:mBarBelow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPBars}> QCPBars::mBarBelow{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBarsGroup\:QCPBars}
{\xe \v QCPBars\:mBarsGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPBarsGroup}* QCPBars::mBarsGroup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBaseValue\:QCPBars}
{\xe \v QCPBars\:mBaseValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBars::mBaseValue{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mStackingGap\:QCPBars}
{\xe \v QCPBars\:mStackingGap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBars::mStackingGap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWidth\:QCPBars}
{\xe \v QCPBars\:mWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBars::mWidth{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWidthType\:QCPBars}
{\xe \v QCPBars\:mWidthType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WidthType} QCPBars::mWidthType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPBarsData Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPBarsData}
{\xe \v QCPBarsData}
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point (one bar) for {\b QCPBars}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPBarsData:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_bars_data__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPBarsData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPBarsData} (double {\b key}, double {\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sortKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b valueRange} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b QCPBarsData} {\b fromSortKey} (double {\b sortKey})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b sortKeyIsMainKey} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point (one bar) for {\b QCPBars}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The stored data is: {
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i key:}  coordinate on the key axis of this bar (this is the {\i mainKey}  and the {\i sortKey} ) \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i value:}  height coordinate on the value axis of this bar (this is the {\i mainValue} )\par
}
The container for storing multiple data points is {\b QCPBarsDataContainer}. It is a typedef for {\b QCPDataContainer} with {\b QCPBarsData} as the DataType template parameter. See the documentation there for an explanation regarding the data type's generic methods.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b QCPBarsDataContainer} \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPBarsData\:QCPBarsData}
{\xe \v QCPBarsData\:QCPBarsData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPBarsData::QCPBarsData ()}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a bar data point with key and value set to zero. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23498                          :\par
23499   key(0),\par
23500   value(0)\par
23501 \{\par
23502 \}\par
}
}
{\xe \v QCPBarsData\:QCPBarsData}
{\xe \v QCPBarsData\:QCPBarsData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPBarsData::QCPBarsData (double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a bar data point with the specified {\i key}  and {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23507                                                  :\par
23508   key(key),\par
23509   value(value)\par
23510 \{\par
23511 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fromSortKey\:QCPBarsData}
{\xe \v QCPBarsData\:fromSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b QCPBarsData} QCPBarsData::fromSortKey (double  {\i sortKey}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data point with the specified {\i sortKey} . All other members are set to zero.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5447 \{ return QCPBarsData(sortKey, 0); \}\par
}
}
{\xe \v mainKey\:QCPBarsData}
{\xe \v QCPBarsData\:mainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBarsData::mainKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i key}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5450 \{ return key; \}\par
}
}
{\xe \v mainValue\:QCPBarsData}
{\xe \v QCPBarsData\:mainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBarsData::mainValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i value}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5451 \{ return value; \}\par
}
}
{\xe \v sortKey\:QCPBarsData}
{\xe \v QCPBarsData\:sortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBarsData::sortKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i key}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5446 \{ return key; \}\par
}
}
{\xe \v sortKeyIsMainKey\:QCPBarsData}
{\xe \v QCPBarsData\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static static bool QCPBarsData::sortKeyIsMainKey (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Since the member {\i key}  is both the data point key coordinate and the data ordering parameter, this method returns true.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5448 \{ return true; \} \par
}
}
{\xe \v valueRange\:QCPBarsData}
{\xe \v QCPBarsData\:valueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPBarsData::valueRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPRange} with both lower and upper boundary set to {\i value}  of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5453 \{ return QCPRange(value, value); \} // note that bar base value isn't held in each QCPBarsData and thus can't/shouldn't be returned here\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v key\:QCPBarsData}
{\xe \v QCPBarsData\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBarsData::key}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:QCPBarsData}
{\xe \v QCPBarsData\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBarsData::value}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPBarsGroup Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPBarsGroup}
{\xe \v QCPBarsGroup}
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Groups multiple {\b QCPBars} together so they appear side by side. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPBarsGroup:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_bars_group__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPBarsGroup:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_bars_group__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SpacingType} \{ {\b stAbsolute}, 
{\b stAxisRectRatio}, 
{\b stPlotCoords}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPBarsGroup} ({\b QCustomPlot} *parentPlot)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPBarsGroup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SpacingType} {\b spacingType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b spacing} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpacingType} ({\b SpacingType} {\b spacingType})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpacing} (double {\b spacing})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPBars} * > {\b bars} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPBars} * {\b bars} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contains} ({\b QCPBars} *{\b bars}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b append} ({\b QCPBars} *{\b bars})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insert} (int i, {\b QCPBars} *{\b bars})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b remove} ({\b QCPBars} *{\b bars})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerBars} ({\b QCPBars} *{\b bars})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b unregisterBars} ({\b QCPBars} *{\b bars})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b keyPixelOffset} (const {\b QCPBars} *{\b bars}, double keyCoord)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getPixelSpacing} (const {\b QCPBars} *{\b bars}, double keyCoord)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SpacingType} {\b mSpacingType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mSpacing}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPBars} * > {\b mBars}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPBars}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Groups multiple {\b QCPBars} together so they appear side by side. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
When showing multiple {\b QCPBars} in one plot which have bars at identical keys, it may be desirable to have them appearing next to each other at each key. This is what adding the respective {\b QCPBars} plottables to a {\b QCPBarsGroup} achieves. (An alternative approach is to stack them on top of each other, see {\b QCPBars::moveAbove}.)\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
To add a {\b QCPBars} plottable to the group, create a new group and then add the respective bars intances: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }Alternatively to appending to the group like shown above, you can also set the group on the {\b QCPBars} plottable via {\b QCPBars::setBarsGroup}.\par
The spacing between the bars can be configured via {\b setSpacingType} and {\b setSpacing}. The bars in this group appear in the plot in the order they were appended. To insert a bars plottable at a certain index position, or to reposition a bars plottable which is already in the group, use {\b insert}.\par
To remove specific bars from the group, use either {\b remove} or call {\b QCPBars::setBarsGroup(0)} on the respective bars plottable.\par
To clear the entire group, call {\b clear}, or simply delete the group.\par}
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Example
\par}
{\tc\tcl2 \v Example}
The image above is generated with the following code: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v SpacingType\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:SpacingType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPBarsGroup::SpacingType}}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the ways the spacing between bars in the group can be specified. Thus it defines what the number passed to {\b setSpacing} actually means.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSpacingType}, {\b setSpacing} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v stAbsolute\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:stAbsolute}
{\qr stAbsolute{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bar spacing is in absolute pixels. \par
}\cell }{\row }
{\xe \v stAxisRectRatio\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:stAxisRectRatio}
{\qr stAxisRectRatio{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bar spacing is given by a fraction of the axis rect size. \par
}\cell }{\row }
{\xe \v stPlotCoords\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:stPlotCoords}
{\qr stPlotCoords{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bar spacing is in key coordinates and thus scales with the key axis range. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5389                    \{ stAbsolute       \par
 5390                      ,stAxisRectRatio \par
 5391                      ,stPlotCoords    \par
 5392                    \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPBarsGroup\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:QCPBarsGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPBarsGroup::QCPBarsGroup ({\b QCustomPlot} *  {\i parentPlot})}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new bars group for the specified {\b QCustomPlot} instance. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23174                                                   :\par
23175   QObject(parentPlot),\par
23176   mParentPlot(parentPlot),\par
23177   mSpacingType(stAbsolute),\par
23178   mSpacing(4)\par
23179 \{\par
23180 \}\par
}
}
{\xe \v ~QCPBarsGroup\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:~QCPBarsGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPBarsGroup::~QCPBarsGroup (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23183 \{\par
23184   clear();\par
23185 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v append\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBarsGroup::append ({\b QCPBars} *  {\i bars})}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the specified {\i bars}  plottable to this group. Alternatively, you can also use {\b QCPBars::setBarsGroup} on the {\i bars}  instance.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b insert}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23246 \{\par
23247   if (!bars)\par
23248   \{\par
23249     qDebug() << Q_FUNC_INFO << "bars is 0";\par
23250     return;\par
23251   \}\par
23252     \par
23253   if (!mBars.contains(bars))\par
23254     bars->setBarsGroup(this);\par
23255   else\par
23256     qDebug() << Q_FUNC_INFO << "bars plottable is already in this bars group:" << reinterpret_cast<quintptr>(bars);\par
23257 \}\par
}
}
{\xe \v bars\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:bars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPBars} * > QCPBarsGroup::bars () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all bars currently in this group.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid bars(int index) \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5407 \{ return mBars; \}\par
}
}
{\xe \v bars\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:bars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPBars} * QCPBarsGroup::bars (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b QCPBars} instance with the specified {\i index}  in this group. If no such {\b QCPBars} exists, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b bars()}, {\b size} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23217 \{\par
23218   if (index >= 0 && index < mBars.size())\par
23219   \{\par
23220     return mBars.at(index);\par
23221   \} else\par
23222   \{\par
23223     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
23224     return 0;\par
23225   \}\par
23226 \}\par
}
}
{\xe \v clear\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBarsGroup::clear ()}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all {\b QCPBars} plottables from this group.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b isEmpty} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23234 \{\par
23235   foreach (QCPBars *bars, mBars) // since foreach takes a copy, removing bars in the loop is okay\par
23236     bars->setBarsGroup(0); // removes itself via removeBars\par
23237 \}\par
}
}
{\xe \v contains\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPBarsGroup::contains ({\b QCPBars} *  {\i bars}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the specified {\i bars}  plottable is part of this group. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5412 \{ return mBars.contains(bars); \}\par
}
}
{\xe \v getPixelSpacing\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:getPixelSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBarsGroup::getPixelSpacing (const {\b QCPBars} *  {\i bars}, double  {\i keyCoord}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23400 \{\par
23401   switch (mSpacingType)\par
23402   \{\par
23403     case stAbsolute:\par
23404     \{\par
23405       return mSpacing;\par
23406     \}\par
23407     case stAxisRectRatio:\par
23408     \{\par
23409       if (bars->keyAxis()->orientation() == Qt::Horizontal)\par
23410         return bars->keyAxis()->axisRect()->width()*mSpacing;\par
23411       else\par
23412         return bars->keyAxis()->axisRect()->height()*mSpacing;\par
23413     \}\par
23414     case stPlotCoords:\par
23415     \{\par
23416       double keyPixel = bars->keyAxis()->coordToPixel(keyCoord);\par
23417       return qAbs(bars->keyAxis()->coordToPixel(keyCoord+mSpacing)-keyPixel);\par
23418     \}\par
23419   \}\par
23420   return 0;\par
23421 \}\par
}
}
{\xe \v insert\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBarsGroup::insert (int  {\i i}, {\b QCPBars} *  {\i bars})}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts the specified {\i bars}  plottable into this group at the specified index position {\i i} . This gives you full control over the ordering of the bars.\par
{\i bars}  may already be part of this group. In that case, {\i bars}  is just moved to the new index position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b append}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23269 \{\par
23270   if (!bars)\par
23271   \{\par
23272     qDebug() << Q_FUNC_INFO << "bars is 0";\par
23273     return;\par
23274   \}\par
23275   \par
23276   // first append to bars list normally:\par
23277   if (!mBars.contains(bars))\par
23278     bars->setBarsGroup(this);\par
23279   // then move to according position:\par
23280   mBars.move(mBars.indexOf(bars), qBound(0, i, mBars.size()-1));\par
23281 \}\par
}
}
{\xe \v isEmpty\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPBarsGroup::isEmpty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this bars group is empty.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b size} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5410 \{ return mBars.isEmpty(); \}\par
}
}
{\xe \v keyPixelOffset\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:keyPixelOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBarsGroup::keyPixelOffset (const {\b QCPBars} *  {\i bars}, double  {\i keyCoord}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23334 \{\par
23335   // find list of all base bars in case some mBars are stacked:\par
23336   QList<const QCPBars*> baseBars;\par
23337   foreach (const QCPBars *b, mBars)\par
23338   \{\par
23339     while (b->barBelow())\par
23340       b = b->barBelow();\par
23341     if (!baseBars.contains(b))\par
23342       baseBars.append(b);\par
23343   \}\par
23344   // find base bar this "bars" is stacked on:\par
23345   const QCPBars *thisBase = bars;\par
23346   while (thisBase->barBelow())\par
23347     thisBase = thisBase->barBelow();\par
23348   \par
23349   // determine key pixel offset of this base bars considering all other base bars in this barsgroup:\par
23350   double result = 0;\par
23351   int index = baseBars.indexOf(thisBase);\par
23352   if (index >= 0)\par
23353   \{\par
23354     if (baseBars.size() % 2 == 1 && index == (baseBars.size()-1)/2) // is center bar (int division on purpose)\par
23355     \{\par
23356       return result;\par
23357     \} else\par
23358     \{\par
23359       double lowerPixelWidth, upperPixelWidth;\par
23360       int startIndex;\par
23361       int dir = (index <= (baseBars.size()-1)/2) ? -1 : 1; // if bar is to lower keys of center, dir is negative\par
23362       if (baseBars.size() % 2 == 0) // even number of bars\par
23363       \{\par
23364         startIndex = baseBars.size()/2 + (dir < 0 ? -1 : 0);\par
23365         result += getPixelSpacing(baseBars.at(startIndex), keyCoord)*0.5; // half of middle spacing\par
23366       \} else // uneven number of bars\par
23367       \{\par
23368         startIndex = (baseBars.size()-1)/2+dir;\par
23369         baseBars.at((baseBars.size()-1)/2)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);\par
23370         result += qAbs(upperPixelWidth-lowerPixelWidth)*0.5; // half of center bar\par
23371         result += getPixelSpacing(baseBars.at((baseBars.size()-1)/2), keyCoord); // center bar spacing\par
23372       \}\par
23373       for (int i = startIndex; i != index; i += dir) // add widths and spacings of bars in between center and our bars\par
23374       \{\par
23375         baseBars.at(i)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);\par
23376         result += qAbs(upperPixelWidth-lowerPixelWidth);\par
23377         result += getPixelSpacing(baseBars.at(i), keyCoord);\par
23378       \}\par
23379       // finally half of our bars width:\par
23380       baseBars.at(index)->getPixelWidth(keyCoord, lowerPixelWidth, upperPixelWidth);\par
23381       result += qAbs(upperPixelWidth-lowerPixelWidth)*0.5;\par
23382       // correct sign of result depending on orientation and direction of key axis:\par
23383       result *= dir*thisBase->keyAxis()->pixelOrientation();\par
23384     \}\par
23385   \}\par
23386   return result;\par
23387 \}\par
}
}
{\xe \v registerBars\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:registerBars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBarsGroup::registerBars ({\b QCPBars} *  {\i bars}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23310 \{\par
23311   if (!mBars.contains(bars))\par
23312     mBars.append(bars);\par
23313 \}\par
}
}
{\xe \v remove\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBarsGroup::remove ({\b QCPBars} *  {\i bars})}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i bars}  plottable from this group.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b contains}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23289 \{\par
23290   if (!bars)\par
23291   \{\par
23292     qDebug() << Q_FUNC_INFO << "bars is 0";\par
23293     return;\par
23294   \}\par
23295   \par
23296   if (mBars.contains(bars))\par
23297     bars->setBarsGroup(0);\par
23298   else\par
23299     qDebug() << Q_FUNC_INFO << "bars plottable is not in this bars group:" << reinterpret_cast<quintptr>(bars);\par
23300 \}\par
}
}
{\xe \v setSpacing\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:setSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBarsGroup::setSpacing (double  {\i spacing})}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the spacing between adjacent bars. What the number passed as {\i spacing}  actually means, is defined by the current {\b SpacingType}, which can be set with {\b setSpacingType}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSpacingType} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23206 \{\par
23207   mSpacing = spacing;\par
23208 \}\par
}
}
{\xe \v setSpacingType\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:setSpacingType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBarsGroup::setSpacingType ({\b SpacingType}  {\i spacingType})}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how the spacing between adjacent bars is interpreted. See {\b SpacingType}.\par
The actual spacing can then be specified with {\b setSpacing}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSpacing} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23195 \{\par
23196   mSpacingType = spacingType;\par
23197 \}\par
}
}
{\xe \v size\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPBarsGroup::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of {\b QCPBars} plottables that are part of this group. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5409 \{ return mBars.size(); \}\par
}
}
{\xe \v spacing\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:spacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBarsGroup::spacing () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5400 \{ return mSpacing; \}\par
}
}
{\xe \v spacingType\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:spacingType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SpacingType} QCPBarsGroup::spacingType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5399 \{ return mSpacingType; \}\par
}
}
{\xe \v unregisterBars\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:unregisterBars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPBarsGroup::unregisterBars ({\b QCPBars} *  {\i bars}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23323 \{\par
23324   mBars.removeOne(bars);\par
23325 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPBars\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:QCPBars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPBars}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBars\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:mBars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPBars}*> QCPBarsGroup::mBars{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPBarsGroup::mParentPlot{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSpacing\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:mSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPBarsGroup::mSpacing{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSpacingType\:QCPBarsGroup}
{\xe \v QCPBarsGroup\:mSpacingType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SpacingType} QCPBarsGroup::mSpacingType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPColorGradient Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPColorGradient}
{\xe \v QCPColorGradient}
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines a color gradient for use with e.g. {\b QCPColorMap}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPColorGradient:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_color_gradient__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ColorInterpolation} \{ {\b ciRGB}, 
{\b ciHSV}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b GradientPreset} \{ {\b gpGrayscale}, 
{\b gpHot}, 
{\b gpCold}, 
{\b gpNight}, 
{\b gpCandy}, 
{\b gpGeography}, 
{\b gpIon}, 
{\b gpThermal}, 
{\b gpPolar}, 
{\b gpSpectrum}, 
{\b gpJet}, 
{\b gpHues}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} ({\b GradientPreset} preset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b QCPColorGradient} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b QCPColorGradient} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b levelCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMap< double, QColor > {\b colorStops} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ColorInterpolation} {\b colorInterpolation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b periodic} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLevelCount} (int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColorStops} (const QMap< double, QColor > &{\b colorStops})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColorStopAt} (double position, const QColor &{\b color})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColorInterpolation} ({\b ColorInterpolation} interpolation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPeriodic} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b colorize} (const double *data, const {\b QCPRange} &range, QRgb *scanLine, int n, int dataIndexFactor=1, bool logarithmic=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b colorize} (const double *data, const unsigned char *alpha, const {\b QCPRange} &range, QRgb *scanLine, int n, int dataIndexFactor=1, bool logarithmic=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRgb {\b color} (double position, const {\b QCPRange} &range, bool logarithmic=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loadPreset} ({\b GradientPreset} preset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearColorStops} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} {\b inverted} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b stopsUseAlpha} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateColorBuffer} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mLevelCount}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMap< double, QColor > {\b mColorStops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ColorInterpolation} {\b mColorInterpolation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mPeriodic}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QRgb > {\b mColorBuffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mColorBufferInvalidated}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines a color gradient for use with e.g. {\b QCPColorMap}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class describes a color gradient which can be used to encode data with color. For example, {\b QCPColorMap} and {\b QCPColorScale} have {\b setGradient} methods which take an instance of this class. Colors are set with {\b setColorStopAt(double position, const QColor &color)} with a {\i position}  from 0 to 1. In between these defined color positions, the color will be interpolated linearly either in RGB or HSV space, see {\b setColorInterpolation}.\par
Alternatively, load one of the preset color gradients shown in the image below, with {\b loadPreset}, or by directly specifying the preset in the constructor.\par
Apart from red, green and blue components, the gradient also interpolates the alpha values of the configured color stops. This allows to display some portions of the data range as transparent in the plot.\par
The {\b QCPColorGradient(GradientPreset preset)} constructor allows directly converting a {\b GradientPreset} to a {\b QCPColorGradient}. This means that you can directly pass {\b GradientPreset} to all the {\i setGradient}  methods, e.g.: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } The total number of levels used in the gradient can be set with {\b setLevelCount}. Whether the color gradient shall be applied periodically (wrapping around) to data values that lie outside the data range specified on the plottable instance can be controlled with {\b setPeriodic}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ColorInterpolation\:QCPColorGradient}
{\xe \v QCPColorGradient\:ColorInterpolation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPColorGradient::ColorInterpolation}}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the color spaces in which color interpolation between gradient stops can be performed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColorInterpolation} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ciRGB\:QCPColorGradient}
{\xe \v QCPColorGradient\:ciRGB}
{\qr ciRGB{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Color channels red, green and blue are linearly interpolated. \par
}\cell }{\row }
{\xe \v ciHSV\:QCPColorGradient}
{\xe \v QCPColorGradient\:ciHSV}
{\qr ciHSV{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Color channels hue, saturation and value are linearly interpolated (The hue is interpolated over the shortest angle distance) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4439                           \{ ciRGB  \par
 4440                             ,ciHSV \par
 4441                           \};\par
}
}
{\xe \v GradientPreset\:QCPColorGradient}
{\xe \v QCPColorGradient\:GradientPreset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPColorGradient::GradientPreset}}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the available presets that can be loaded with {\b loadPreset}. See the documentation there for an image of the presets. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v gpGrayscale\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpGrayscale}
{\qr gpGrayscale{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Continuous lightness from black to white (suited for non-biased data representation) \par
}\cell }{\row }
{\xe \v gpHot\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpHot}
{\qr gpHot{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Continuous lightness from black over firey colors to white (suited for non-biased data representation) \par
}\cell }{\row }
{\xe \v gpCold\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpCold}
{\qr gpCold{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Continuous lightness from black over icey colors to white (suited for non-biased data representation) \par
}\cell }{\row }
{\xe \v gpNight\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpNight}
{\qr gpNight{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Continuous lightness from black over weak blueish colors to white (suited for non-biased data representation) \par
}\cell }{\row }
{\xe \v gpCandy\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpCandy}
{\qr gpCandy{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blue over pink to white. \par
}\cell }{\row }
{\xe \v gpGeography\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpGeography}
{\qr gpGeography{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors suitable to represent different elevations on geographical maps. \par
}\cell }{\row }
{\xe \v gpIon\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpIon}
{\qr gpIon{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Half hue spectrum from black over purple to blue and finally green (creates banding illusion but allows more precise magnitude estimates) \par
}\cell }{\row }
{\xe \v gpThermal\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpThermal}
{\qr gpThermal{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors suitable for thermal imaging, ranging from dark blue over purple to orange, yellow and white. \par
}\cell }{\row }
{\xe \v gpPolar\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpPolar}
{\qr gpPolar{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors suitable to emphasize polarity around the center, with blue for negative, black in the middle and red for positive values. \par
}\cell }{\row }
{\xe \v gpSpectrum\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpSpectrum}
{\qr gpSpectrum{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An approximation of the visible light spectrum (creates banding illusion but allows more precise magnitude estimates) \par
}\cell }{\row }
{\xe \v gpJet\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpJet}
{\qr gpJet{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hue variation similar to a spectrum, often used in numerical visualization (creates banding illusion but allows more precise magnitude estimates) \par
}\cell }{\row }
{\xe \v gpHues\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpHues}
{\qr gpHues{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Full hue cycle, with highest and lowest color red (suitable for periodic data, such as angles and phases, see {\b setPeriodic}) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4448                       \{ gpGrayscale  \par
 4449                         ,gpHot       \par
 4450                         ,gpCold      \par
 4451                         ,gpNight     \par
 4452                         ,gpCandy     \par
 4453                         ,gpGeography \par
 4454                         ,gpIon       \par
 4455                         ,gpThermal   \par
 4456                         ,gpPolar     \par
 4457                         ,gpSpectrum  \par
 4458                         ,gpJet       \par
 4459                         ,gpHues      \par
 4460                       \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPColorGradient\:QCPColorGradient}
{\xe \v QCPColorGradient\:QCPColorGradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorGradient::QCPColorGradient ()}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new, empty {\b QCPColorGradient} with no predefined color stops. You can add own color stops with {\b setColorStopAt}.\par
The color level count is initialized to 350. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15763                                    :\par
15764   mLevelCount(350),\par
15765   mColorInterpolation(ciRGB),\par
15766   mPeriodic(false),\par
15767   mColorBufferInvalidated(true)\par
15768 \{\par
15769   mColorBuffer.fill(qRgb(0, 0, 0), mLevelCount);\par
15770 \}\par
}
}
{\xe \v QCPColorGradient\:QCPColorGradient}
{\xe \v QCPColorGradient\:QCPColorGradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorGradient::QCPColorGradient ({\b GradientPreset}  {\i preset})}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b QCPColorGradient} initialized with the colors and color interpolation according to {\i preset} .\par
The color level count is initialized to 350. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15778                                                         :\par
15779   mLevelCount(350),\par
15780   mColorInterpolation(ciRGB),\par
15781   mPeriodic(false),\par
15782   mColorBufferInvalidated(true)\par
15783 \{\par
15784   mColorBuffer.fill(qRgb(0, 0, 0), mLevelCount);\par
15785   loadPreset(preset);\par
15786 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v clearColorStops\:QCPColorGradient}
{\xe \v QCPColorGradient\:clearColorStops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::clearColorStops ()}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all color stops.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColorStops}, {\b setColorStopAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16231 \{\par
16232   mColorStops.clear();\par
16233   mColorBufferInvalidated = true;\par
16234 \}\par
}
}
{\xe \v color\:QCPColorGradient}
{\xe \v QCPColorGradient\:color}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRgb QCPColorGradient::color (double  {\i position}, const {\b QCPRange} &  {\i range}, bool  {\i logarithmic} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16090 \{\par
16091   // If you change something here, make sure to also adapt ::colorize()\par
16092   if (mColorBufferInvalidated)\par
16093     updateColorBuffer();\par
16094   int index = 0;\par
16095   if (!logarithmic)\par
16096     index = (position-range.lower)*(mLevelCount-1)/range.size();\par
16097   else\par
16098     index = qLn(position/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);\par
16099   if (mPeriodic)\par
16100   \{\par
16101     index = index % mLevelCount;\par
16102     if (index < 0)\par
16103       index += mLevelCount;\par
16104   \} else\par
16105   \{\par
16106     if (index < 0)\par
16107       index = 0;\par
16108     else if (index >= mLevelCount)\par
16109       index = mLevelCount-1;\par
16110   \}\par
16111   return mColorBuffer.at(index);\par
16112 \}\par
}
}
{\xe \v colorInterpolation\:QCPColorGradient}
{\xe \v QCPColorGradient\:colorInterpolation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ColorInterpolation} QCPColorGradient::colorInterpolation () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4471 \{ return mColorInterpolation; \}\par
}
}
{\xe \v colorize\:QCPColorGradient}
{\xe \v QCPColorGradient\:colorize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::colorize (const double *  {\i data}, const {\b QCPRange} &  {\i range}, QRgb *  {\i scanLine}, int  {\i n}, int  {\i dataIndexFactor} = {\f2 1}, bool  {\i logarithmic} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
This method is used to quickly convert a {\i data}  array to colors. The colors will be output in the array {\i scanLine} . Both {\i data}  and {\i scanLine}  must have the length {\i n}  when passed to this function. The data range that shall be used for mapping the data value to the gradient is passed in {\i range} . {\i logarithmic}  indicates whether the data values shall be mapped to colors logarithmically.\par
if {\i data}  actually contains 2D-data linearized via {\f2 [row*columnCount + column]} , you can set {\i dataIndexFactor}  to {\f2 columnCount}  to convert a column instead of a row of the data array, in {\i scanLine} . {\i scanLine}  will remain a regular (1D) array. This works because {\i data}  is addressed {\f2 data[i*dataIndexFactor]} .\par
Use the overloaded method to additionally provide alpha map data.\par
The QRgb values that are placed in {\i scanLine}  have their r, g and b components premultiplied with alpha (see QImage::Format_ARGB32_Premultiplied). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15901 \{\par
15902   // If you change something here, make sure to also adapt color() and the other colorize() overload\par
15903   if (!data)\par
15904   \{\par
15905     qDebug() << Q_FUNC_INFO << "null pointer given as data";\par
15906     return;\par
15907   \}\par
15908   if (!scanLine)\par
15909   \{\par
15910     qDebug() << Q_FUNC_INFO << "null pointer given as scanLine";\par
15911     return;\par
15912   \}\par
15913   if (mColorBufferInvalidated)\par
15914     updateColorBuffer();\par
15915   \par
15916   if (!logarithmic)\par
15917   \{\par
15918     const double posToIndexFactor = (mLevelCount-1)/range.size();\par
15919     if (mPeriodic)\par
15920     \{\par
15921       for (int i=0; i<n; ++i)\par
15922       \{\par
15923         int index = (int)((data[dataIndexFactor*i]-range.lower)*posToIndexFactor) % mLevelCount;\par
15924         if (index < 0)\par
15925           index += mLevelCount;\par
15926         scanLine[i] = mColorBuffer.at(index);\par
15927       \}\par
15928     \} else\par
15929     \{\par
15930       for (int i=0; i<n; ++i)\par
15931       \{\par
15932         int index = (data[dataIndexFactor*i]-range.lower)*posToIndexFactor;\par
15933         if (index < 0)\par
15934           index = 0;\par
15935         else if (index >= mLevelCount)\par
15936           index = mLevelCount-1;\par
15937         scanLine[i] = mColorBuffer.at(index);\par
15938       \}\par
15939     \}\par
15940   \} else // logarithmic == true\par
15941   \{\par
15942     if (mPeriodic)\par
15943     \{\par
15944       for (int i=0; i<n; ++i)\par
15945       \{\par
15946         int index = (int)(qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1)) % mLevelCount;\par
15947         if (index < 0)\par
15948           index += mLevelCount;\par
15949         scanLine[i] = mColorBuffer.at(index);\par
15950       \}\par
15951     \} else\par
15952     \{\par
15953       for (int i=0; i<n; ++i)\par
15954       \{\par
15955         int index = qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);\par
15956         if (index < 0)\par
15957           index = 0;\par
15958         else if (index >= mLevelCount)\par
15959           index = mLevelCount-1;\par
15960         scanLine[i] = mColorBuffer.at(index);\par
15961       \}\par
15962     \}\par
15963   \}\par
15964 \}\par
}
}
{\xe \v colorize\:QCPColorGradient}
{\xe \v QCPColorGradient\:colorize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::colorize (const double *  {\i data}, const unsigned char *  {\i alpha}, const {\b QCPRange} &  {\i range}, QRgb *  {\i scanLine}, int  {\i n}, int  {\i dataIndexFactor} = {\f2 1}, bool  {\i logarithmic} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Additionally to the other overload of {\b colorize}, this method takes the array {\i alpha} , which has the same size and structure as {\i data}  and encodes the alpha information per data point.\par
The QRgb values that are placed in {\i scanLine}  have their r, g and b components premultiplied with alpha (see QImage::Format_ARGB32_Premultiplied). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15975 \{\par
15976   // If you change something here, make sure to also adapt color() and the other colorize() overload\par
15977   if (!data)\par
15978   \{\par
15979     qDebug() << Q_FUNC_INFO << "null pointer given as data";\par
15980     return;\par
15981   \}\par
15982   if (!alpha)\par
15983   \{\par
15984     qDebug() << Q_FUNC_INFO << "null pointer given as alpha";\par
15985     return;\par
15986   \}\par
15987   if (!scanLine)\par
15988   \{\par
15989     qDebug() << Q_FUNC_INFO << "null pointer given as scanLine";\par
15990     return;\par
15991   \}\par
15992   if (mColorBufferInvalidated)\par
15993     updateColorBuffer();\par
15994   \par
15995   if (!logarithmic)\par
15996   \{\par
15997     const double posToIndexFactor = (mLevelCount-1)/range.size();\par
15998     if (mPeriodic)\par
15999     \{\par
16000       for (int i=0; i<n; ++i)\par
16001       \{\par
16002         int index = (int)((data[dataIndexFactor*i]-range.lower)*posToIndexFactor) % mLevelCount;\par
16003         if (index < 0)\par
16004           index += mLevelCount;\par
16005         if (alpha[dataIndexFactor*i] == 255)\par
16006         \{\par
16007           scanLine[i] = mColorBuffer.at(index);\par
16008         \} else\par
16009         \{\par
16010           const QRgb rgb = mColorBuffer.at(index);\par
16011           const float alphaF = alpha[dataIndexFactor*i]/255.0f;\par
16012           scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);\par
16013         \}\par
16014       \}\par
16015     \} else\par
16016     \{\par
16017       for (int i=0; i<n; ++i)\par
16018       \{\par
16019         int index = (data[dataIndexFactor*i]-range.lower)*posToIndexFactor;\par
16020         if (index < 0)\par
16021           index = 0;\par
16022         else if (index >= mLevelCount)\par
16023           index = mLevelCount-1;\par
16024         if (alpha[dataIndexFactor*i] == 255)\par
16025         \{\par
16026           scanLine[i] = mColorBuffer.at(index);\par
16027         \} else\par
16028         \{\par
16029           const QRgb rgb = mColorBuffer.at(index);\par
16030           const float alphaF = alpha[dataIndexFactor*i]/255.0f;\par
16031           scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);\par
16032         \}\par
16033       \}\par
16034     \}\par
16035   \} else // logarithmic == true\par
16036   \{\par
16037     if (mPeriodic)\par
16038     \{\par
16039       for (int i=0; i<n; ++i)\par
16040       \{\par
16041         int index = (int)(qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1)) % mLevelCount;\par
16042         if (index < 0)\par
16043           index += mLevelCount;\par
16044         if (alpha[dataIndexFactor*i] == 255)\par
16045         \{\par
16046           scanLine[i] = mColorBuffer.at(index);\par
16047         \} else\par
16048         \{\par
16049           const QRgb rgb = mColorBuffer.at(index);\par
16050           const float alphaF = alpha[dataIndexFactor*i]/255.0f;\par
16051           scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);\par
16052         \}\par
16053       \}\par
16054     \} else\par
16055     \{\par
16056       for (int i=0; i<n; ++i)\par
16057       \{\par
16058         int index = qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);\par
16059         if (index < 0)\par
16060           index = 0;\par
16061         else if (index >= mLevelCount)\par
16062           index = mLevelCount-1;\par
16063         if (alpha[dataIndexFactor*i] == 255)\par
16064         \{\par
16065           scanLine[i] = mColorBuffer.at(index);\par
16066         \} else\par
16067         \{\par
16068           const QRgb rgb = mColorBuffer.at(index);\par
16069           const float alphaF = alpha[dataIndexFactor*i]/255.0f;\par
16070           scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);\par
16071         \}\par
16072       \}\par
16073     \}\par
16074   \}\par
16075 \}\par
}
}
{\xe \v colorStops\:QCPColorGradient}
{\xe \v QCPColorGradient\:colorStops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMap<double, QColor> QCPColorGradient::colorStops () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4470 \{ return mColorStops; \}\par
}
}
{\xe \v inverted\:QCPColorGradient}
{\xe \v QCPColorGradient\:inverted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorGradient} QCPColorGradient::inverted () const}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an inverted gradient. The inverted gradient has all properties as this {\b QCPColorGradient}, but the order of the color stops is inverted.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColorStops}, {\b setColorStopAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16243 \{\par
16244   QCPColorGradient result(*this);\par
16245   result.clearColorStops();\par
16246   for (QMap<double, QColor>::const_iterator it=mColorStops.constBegin(); it!=mColorStops.constEnd(); ++it)\par
16247     result.setColorStopAt(1.0-it.key(), it.value());\par
16248   return result;\par
16249 \}\par
}
}
{\xe \v levelCount\:QCPColorGradient}
{\xe \v QCPColorGradient\:levelCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorGradient::levelCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4469 \{ return mLevelCount; \}\par
}
}
{\xe \v loadPreset\:QCPColorGradient}
{\xe \v QCPColorGradient\:loadPreset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::loadPreset ({\b GradientPreset}  {\i preset})}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the current color stops and loads the specified {\i preset} . A preset consists of predefined color stops and the corresponding color interpolation method.\par
The available presets are:  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16122 \{\par
16123   clearColorStops();\par
16124   switch (preset)\par
16125   \{\par
16126     case gpGrayscale:\par
16127       setColorInterpolation(ciRGB);\par
16128       setColorStopAt(0, Qt::black);\par
16129       setColorStopAt(1, Qt::white);\par
16130       break;\par
16131     case gpHot:\par
16132       setColorInterpolation(ciRGB);\par
16133       setColorStopAt(0, QColor(50, 0, 0));\par
16134       setColorStopAt(0.2, QColor(180, 10, 0));\par
16135       setColorStopAt(0.4, QColor(245, 50, 0));\par
16136       setColorStopAt(0.6, QColor(255, 150, 10));\par
16137       setColorStopAt(0.8, QColor(255, 255, 50));\par
16138       setColorStopAt(1, QColor(255, 255, 255));\par
16139       break;\par
16140     case gpCold:\par
16141       setColorInterpolation(ciRGB);\par
16142       setColorStopAt(0, QColor(0, 0, 50));\par
16143       setColorStopAt(0.2, QColor(0, 10, 180));\par
16144       setColorStopAt(0.4, QColor(0, 50, 245));\par
16145       setColorStopAt(0.6, QColor(10, 150, 255));\par
16146       setColorStopAt(0.8, QColor(50, 255, 255));\par
16147       setColorStopAt(1, QColor(255, 255, 255));\par
16148       break;\par
16149     case gpNight:\par
16150       setColorInterpolation(ciHSV);\par
16151       setColorStopAt(0, QColor(10, 20, 30));\par
16152       setColorStopAt(1, QColor(250, 255, 250));\par
16153       break;\par
16154     case gpCandy:\par
16155       setColorInterpolation(ciHSV);\par
16156       setColorStopAt(0, QColor(0, 0, 255));\par
16157       setColorStopAt(1, QColor(255, 250, 250));\par
16158       break;\par
16159     case gpGeography:\par
16160       setColorInterpolation(ciRGB);\par
16161       setColorStopAt(0, QColor(70, 170, 210));\par
16162       setColorStopAt(0.20, QColor(90, 160, 180));\par
16163       setColorStopAt(0.25, QColor(45, 130, 175));\par
16164       setColorStopAt(0.30, QColor(100, 140, 125));\par
16165       setColorStopAt(0.5, QColor(100, 140, 100));\par
16166       setColorStopAt(0.6, QColor(130, 145, 120));\par
16167       setColorStopAt(0.7, QColor(140, 130, 120));\par
16168       setColorStopAt(0.9, QColor(180, 190, 190));\par
16169       setColorStopAt(1, QColor(210, 210, 230));\par
16170       break;\par
16171     case gpIon:\par
16172       setColorInterpolation(ciHSV);\par
16173       setColorStopAt(0, QColor(50, 10, 10));\par
16174       setColorStopAt(0.45, QColor(0, 0, 255));\par
16175       setColorStopAt(0.8, QColor(0, 255, 255));\par
16176       setColorStopAt(1, QColor(0, 255, 0));\par
16177       break;\par
16178     case gpThermal:\par
16179       setColorInterpolation(ciRGB);\par
16180       setColorStopAt(0, QColor(0, 0, 50));\par
16181       setColorStopAt(0.15, QColor(20, 0, 120));\par
16182       setColorStopAt(0.33, QColor(200, 30, 140));\par
16183       setColorStopAt(0.6, QColor(255, 100, 0));\par
16184       setColorStopAt(0.85, QColor(255, 255, 40));\par
16185       setColorStopAt(1, QColor(255, 255, 255));\par
16186       break;\par
16187     case gpPolar:\par
16188       setColorInterpolation(ciRGB);\par
16189       setColorStopAt(0, QColor(50, 255, 255));\par
16190       setColorStopAt(0.18, QColor(10, 70, 255));\par
16191       setColorStopAt(0.28, QColor(10, 10, 190));\par
16192       setColorStopAt(0.5, QColor(0, 0, 0));\par
16193       setColorStopAt(0.72, QColor(190, 10, 10));\par
16194       setColorStopAt(0.82, QColor(255, 70, 10));\par
16195       setColorStopAt(1, QColor(255, 255, 50));\par
16196       break;\par
16197     case gpSpectrum:\par
16198       setColorInterpolation(ciHSV);\par
16199       setColorStopAt(0, QColor(50, 0, 50));\par
16200       setColorStopAt(0.15, QColor(0, 0, 255));\par
16201       setColorStopAt(0.35, QColor(0, 255, 255));\par
16202       setColorStopAt(0.6, QColor(255, 255, 0));\par
16203       setColorStopAt(0.75, QColor(255, 30, 0));\par
16204       setColorStopAt(1, QColor(50, 0, 0));\par
16205       break;\par
16206     case gpJet:\par
16207       setColorInterpolation(ciRGB);\par
16208       setColorStopAt(0, QColor(0, 0, 100));\par
16209       setColorStopAt(0.15, QColor(0, 50, 255));\par
16210       setColorStopAt(0.35, QColor(0, 255, 255));\par
16211       setColorStopAt(0.65, QColor(255, 255, 0));\par
16212       setColorStopAt(0.85, QColor(255, 30, 0));\par
16213       setColorStopAt(1, QColor(100, 0, 0));\par
16214       break;\par
16215     case gpHues:\par
16216       setColorInterpolation(ciHSV);\par
16217       setColorStopAt(0, QColor(255, 0, 0));\par
16218       setColorStopAt(1.0/3.0, QColor(0, 0, 255));\par
16219       setColorStopAt(2.0/3.0, QColor(0, 255, 0));\par
16220       setColorStopAt(1, QColor(255, 0, 0));\par
16221       break;\par
16222   \}\par
16223 \}\par
}
}
{\xe \v operator!=\:QCPColorGradient}
{\xe \v QCPColorGradient\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::operator!= (const {\b QCPColorGradient} &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4466 \{ return !(*this == other); \}\par
}
}
{\xe \v operator==\:QCPColorGradient}
{\xe \v QCPColorGradient\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::operator== (const {\b QCPColorGradient} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15790 \{\par
15791   return ((other.mLevelCount == this->mLevelCount) &&\par
15792           (other.mColorInterpolation == this->mColorInterpolation) &&\par
15793           (other.mPeriodic == this->mPeriodic) &&\par
15794           (other.mColorStops == this->mColorStops));\par
15795 \}\par
}
}
{\xe \v periodic\:QCPColorGradient}
{\xe \v QCPColorGradient\:periodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::periodic () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4472 \{ return mPeriodic; \}\par
}
}
{\xe \v setColorInterpolation\:QCPColorGradient}
{\xe \v QCPColorGradient\:setColorInterpolation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setColorInterpolation ({\b QCPColorGradient::ColorInterpolation}  {\i interpolation})}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the colors in between the configured color stops (see {\b setColorStopAt}) shall be interpolated linearly in RGB or in HSV color space.\par
For example, a sweep in RGB space from red to green will have a muddy brown intermediate color, whereas in HSV space the intermediate color is yellow. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15854 \{\par
15855   if (interpolation != mColorInterpolation)\par
15856   \{\par
15857     mColorInterpolation = interpolation;\par
15858     mColorBufferInvalidated = true;\par
15859   \}\par
15860 \}\par
}
}
{\xe \v setColorStopAt\:QCPColorGradient}
{\xe \v QCPColorGradient\:setColorStopAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setColorStopAt (double  {\i position}, const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i color}  the gradient will have at the specified {\i position}  (from 0 to 1). In between these color stops, the color is interpolated according to {\b setColorInterpolation}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColorStops}, {\b clearColorStops} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15841 \{\par
15842   mColorStops.insert(position, color);\par
15843   mColorBufferInvalidated = true;\par
15844 \}\par
}
}
{\xe \v setColorStops\:QCPColorGradient}
{\xe \v QCPColorGradient\:setColorStops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setColorStops (const QMap< double, QColor > &  {\i colorStops})}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets at which positions from 0 to 1 which color shall occur. The positions are the keys, the colors are the values of the passed QMap {\i colorStops} . In between these color stops, the color is interpolated according to {\b setColorInterpolation}.\par
A more convenient way to create a custom gradient may be to clear all color stops with {\b clearColorStops} (or creating a new, empty {\b QCPColorGradient}) and then adding them one by one with {\b setColorStopAt}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clearColorStops} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15829 \{\par
15830   mColorStops = colorStops;\par
15831   mColorBufferInvalidated = true;\par
15832 \}\par
}
}
{\xe \v setLevelCount\:QCPColorGradient}
{\xe \v QCPColorGradient\:setLevelCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setLevelCount (int  {\i n})}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of discretization levels of the color gradient to {\i n} . The default is 350 which is typically enough to create a smooth appearance. The minimum number of levels is 2.\par
 \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15804 \{\par
15805   if (n < 2)\par
15806   \{\par
15807     qDebug() << Q_FUNC_INFO << "n must be greater or equal 2 but was" << n;\par
15808     n = 2;\par
15809   \}\par
15810   if (n != mLevelCount)\par
15811   \{\par
15812     mLevelCount = n;\par
15813     mColorBufferInvalidated = true;\par
15814   \}\par
15815 \}\par
}
}
{\xe \v setPeriodic\:QCPColorGradient}
{\xe \v QCPColorGradient\:setPeriodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setPeriodic (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether data points that are outside the configured data range (e.g. {\b QCPColorMap::setDataRange}) are colored by periodically repeating the color gradient or whether they all have the same color, corresponding to the respective gradient boundary color.\par
As shown in the image above, gradients that have the same start and end color are especially suitable for a periodic gradient mapping, since they produce smooth color transitions throughout the color map. A preset that has this property is {\b gpHues}.\par
In practice, using periodic color gradients makes sense when the data corresponds to a periodic dimension, such as an angle or a phase. If this is not the case, the color encoding might become ambiguous, because multiple different data values are shown as the same color. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15878 \{\par
15879   mPeriodic = enabled;\par
15880 \}\par
}
}
{\xe \v stopsUseAlpha\:QCPColorGradient}
{\xe \v QCPColorGradient\:stopsUseAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::stopsUseAlpha () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16257 \{\par
16258   for (QMap<double, QColor>::const_iterator it=mColorStops.constBegin(); it!=mColorStops.constEnd(); ++it)\par
16259   \{\par
16260     if (it.value().alpha() < 255)\par
16261       return true;\par
16262   \}\par
16263   return false;\par
16264 \}\par
}
}
{\xe \v updateColorBuffer\:QCPColorGradient}
{\xe \v QCPColorGradient\:updateColorBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::updateColorBuffer (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16272 \{\par
16273   if (mColorBuffer.size() != mLevelCount)\par
16274     mColorBuffer.resize(mLevelCount);\par
16275   if (mColorStops.size() > 1)\par
16276   \{\par
16277     double indexToPosFactor = 1.0/(double)(mLevelCount-1);\par
16278     const bool useAlpha = stopsUseAlpha();\par
16279     for (int i=0; i<mLevelCount; ++i)\par
16280     \{\par
16281       double position = i*indexToPosFactor;\par
16282       QMap<double, QColor>::const_iterator it = mColorStops.lowerBound(position);\par
16283       if (it == mColorStops.constEnd()) // position is on or after last stop, use color of last stop\par
16284       \{\par
16285         mColorBuffer[i] = (it-1).value().rgba();\par
16286       \} else if (it == mColorStops.constBegin()) // position is on or before first stop, use color of first stop\par
16287       \{\par
16288         mColorBuffer[i] = it.value().rgba();\par
16289       \} else // position is in between stops (or on an intermediate stop), interpolate color\par
16290       \{\par
16291         QMap<double, QColor>::const_iterator high = it;\par
16292         QMap<double, QColor>::const_iterator low = it-1;\par
16293         double t = (position-low.key())/(high.key()-low.key()); // interpolation factor 0..1\par
16294         switch (mColorInterpolation)\par
16295         \{\par
16296           case ciRGB:\par
16297           \{\par
16298             if (useAlpha)\par
16299             \{\par
16300               const int alpha = (1-t)*low.value().alpha() + t*high.value().alpha();\par
16301               const float alphaPremultiplier = alpha/255.0f; // since we use QImage::Format_ARGB32_Premultiplied\par
16302               mColorBuffer[i] = qRgba(((1-t)*low.value().red() + t*high.value().red())*alphaPremultiplier,\par
16303                                       ((1-t)*low.value().green() + t*high.value().green())*alphaPremultiplier,\par
16304                                       ((1-t)*low.value().blue() + t*high.value().blue())*alphaPremultiplier,\par
16305                                       alpha);\par
16306             \} else\par
16307             \{\par
16308               mColorBuffer[i] = qRgb(((1-t)*low.value().red() + t*high.value().red()),\par
16309                                      ((1-t)*low.value().green() + t*high.value().green()),\par
16310                                      ((1-t)*low.value().blue() + t*high.value().blue()));\par
16311             \}\par
16312             break;\par
16313           \}\par
16314           case ciHSV:\par
16315           \{\par
16316             QColor lowHsv = low.value().toHsv();\par
16317             QColor highHsv = high.value().toHsv();\par
16318             double hue = 0;\par
16319             double hueDiff = highHsv.hueF()-lowHsv.hueF();\par
16320             if (hueDiff > 0.5)\par
16321               hue = lowHsv.hueF() - t*(1.0-hueDiff);\par
16322             else if (hueDiff < -0.5)\par
16323               hue = lowHsv.hueF() + t*(1.0+hueDiff);\par
16324             else\par
16325               hue = lowHsv.hueF() + t*hueDiff;\par
16326             if (hue < 0) hue += 1.0;\par
16327             else if (hue >= 1.0) hue -= 1.0;\par
16328             if (useAlpha)\par
16329             \{\par
16330               const QRgb rgb = QColor::fromHsvF(hue,\par
16331                                                 (1-t)*lowHsv.saturationF() + t*highHsv.saturationF(),\par
16332                                                 (1-t)*lowHsv.valueF() + t*highHsv.valueF()).rgb();\par
16333               const float alpha = (1-t)*lowHsv.alphaF() + t*highHsv.alphaF();\par
16334               mColorBuffer[i] = qRgba(qRed(rgb)*alpha, qGreen(rgb)*alpha, qBlue(rgb)*alpha, 255*alpha);\par
16335             \}\par
16336             else\par
16337             \{\par
16338               mColorBuffer[i] = QColor::fromHsvF(hue,\par
16339                                                  (1-t)*lowHsv.saturationF() + t*highHsv.saturationF(),\par
16340                                                  (1-t)*lowHsv.valueF() + t*highHsv.valueF()).rgb();\par
16341             \}\par
16342             break;\par
16343           \}\par
16344         \}\par
16345       \}\par
16346     \}\par
16347   \} else if (mColorStops.size() == 1)\par
16348   \{\par
16349     const QRgb rgb = mColorStops.constBegin().value().rgb();\par
16350     const float alpha = mColorStops.constBegin().value().alphaF();\par
16351     mColorBuffer.fill(qRgba(qRed(rgb)*alpha, qGreen(rgb)*alpha, qBlue(rgb)*alpha, 255*alpha));\par
16352   \} else // mColorStops is empty, fill color buffer with black\par
16353   \{\par
16354     mColorBuffer.fill(qRgb(0, 0, 0));\par
16355   \}\par
16356   mColorBufferInvalidated = false;\par
16357 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mColorBuffer\:QCPColorGradient}
{\xe \v QCPColorGradient\:mColorBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<QRgb> QCPColorGradient::mColorBuffer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mColorBufferInvalidated\:QCPColorGradient}
{\xe \v QCPColorGradient\:mColorBufferInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::mColorBufferInvalidated{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mColorInterpolation\:QCPColorGradient}
{\xe \v QCPColorGradient\:mColorInterpolation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ColorInterpolation} QCPColorGradient::mColorInterpolation{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mColorStops\:QCPColorGradient}
{\xe \v QCPColorGradient\:mColorStops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMap<double, QColor> QCPColorGradient::mColorStops{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLevelCount\:QCPColorGradient}
{\xe \v QCPColorGradient\:mLevelCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorGradient::mLevelCount{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPeriodic\:QCPColorGradient}
{\xe \v QCPColorGradient\:mPeriodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::mPeriodic{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPColorMap Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPColorMap}
{\xe \v QCPColorMap}
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a two-dimensional color map in a plot. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPColorMap:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_color_map__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPColorMap:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_color_map__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dataRangeChanged} (const {\b QCPRange} &newRange)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dataScaleTypeChanged} ({\b QCPAxis::ScaleType} scaleType)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gradientChanged} (const {\b QCPColorGradient} &newGradient)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorMap} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPColorMap} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorMapData} * {\b data} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b dataRange} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis::ScaleType} {\b dataScaleType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b interpolate} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b tightBoundary} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} {\b gradient} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorScale} * {\b colorScale} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} ({\b QCPColorMapData} *{\b data}, bool copy=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setDataRange} (const {\b QCPRange} &{\b dataRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setDataScaleType} ({\b QCPAxis::ScaleType} scaleType)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setGradient} (const {\b QCPColorGradient} &{\b gradient})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInterpolate} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTightBoundary} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColorScale} ({\b QCPColorScale} *{\b colorScale})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleDataRange} (bool recalculateDataBounds=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b updateLegendIcon} (Qt::TransformationMode transformMode=Qt::SmoothTransformation, const QSize &thumbSize=QSize(32, 18))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateMapImage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mDataRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis::ScaleType} {\b mDataScaleType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorMapData} * {\b mMapData}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} {\b mGradient}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mInterpolate}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mTightBoundary}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPColorScale} > {\b mColorScale}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QImage {\b mMapImage}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QImage {\b mUndersampledMapImage}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mLegendIcon}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mMapImageInvalidated}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a two-dimensional color map in a plot. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
The data is stored in the class {\b QCPColorMapData}, which can be accessed via the {\b data()} method.\par
A color map has three dimensions to represent a data point: The {\i key}  dimension, the {\i value}  dimension and the {\i data}  dimension. As with other plottables such as graphs, {\i key}  and {\i value}  correspond to two orthogonal axes on the {\b QCustomPlot} surface that you specify in the {\b QCPColorMap} constructor. The {\i data}  dimension however is encoded as the color of the point at ({\i key} , {\i value} ).\par
Set the number of points (or {\i cells} ) in the key/value dimension via {\b QCPColorMapData::setSize}. The plot coordinate range over which these points will be displayed is specified via {\b QCPColorMapData::setRange}. The first cell will be centered on the lower range boundary and the last cell will be centered on the upper range boundary. The data can be set by either accessing the cells directly with {\b QCPColorMapData::setCell} or by addressing the cells via their plot coordinates with {\b QCPColorMapData::setData}. If possible, you should prefer setCell, since it doesn't need to do any coordinate transformation and thus performs a bit better.\par
The cell with index (0, 0) is at the bottom left, if the color map uses normal (i.e. not reversed) key and value axes.\par
To show the user which colors correspond to which {\i data}  values, a {\b QCPColorScale} is typically placed to the right of the axis rect. See the documentation there for details on how to add and use a color scale.\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Changing the appearance
\par}
{\tc\tcl2 \v Changing the appearance}
The central part of the appearance is the color gradient, which can be specified via {\b setGradient}. See the documentation of {\b QCPColorGradient} for details on configuring a color gradient.\par
The {\i data}  range that is mapped to the colors of the gradient can be specified with {\b setDataRange}. To make the data range encompass the whole data set minimum to maximum, call {\b rescaleDataRange}.\par}
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Transparency
\par}
{\tc\tcl2 \v Transparency}
Transparency in color maps can be achieved by two mechanisms. On one hand, you can specify alpha values for color stops of the {\b QCPColorGradient}, via the regular QColor interface. This will cause the color map data which gets mapped to colors around those color stops to appear with the accordingly interpolated transparency.\par
On the other hand you can also directly apply an alpha value to each cell independent of its data, by using the alpha map feature of {\b QCPColorMapData}. The relevant methods are {\b QCPColorMapData::setAlpha}, {\b QCPColorMapData::fillAlpha} and {\b QCPColorMapData::clearAlpha()}.\par
The two transparencies will be joined together in the plot and otherwise not interfere with each other. They are mixed in a multiplicative matter, so an alpha of e.g. 50% (128/255) in both modes simultaneously, will result in a total transparency of 25% (64/255).\par}
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
Like all data representing objects in {\b QCustomPlot}, the {\b QCPColorMap} is a plottable ({\b QCPAbstractPlottable}). So the plottable-interface of {\b QCustomPlot} applies ({\b QCustomPlot::plottable}, {\b QCustomPlot::removePlottable}, etc.)\par
Usually, you first create an instance: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }which registers it with the {\b QCustomPlot} instance of the passed axes. Note that this {\b QCustomPlot} instance takes ownership of the plottable, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. The newly created plottable can be modified, e.g.: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The {\b QCPColorMap} always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use {\b QCPColorMap} with logarithmic axes, you shouldn't use the {\b QCPColorMapData::setData} method as it uses a linear transformation to determine the cell index. Rather directly access the cell index with {\b QCPColorMapData::setCell}. \par
}\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPColorMap\:QCPColorMap}
{\xe \v QCPColorMap\:QCPColorMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorMap::QCPColorMap ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a color map with the specified {\i keyAxis}  and {\i valueAxis} .\par
The created {\b QCPColorMap} is automatically registered with the {\b QCustomPlot} instance inferred from {\i keyAxis} . This {\b QCustomPlot} instance takes ownership of the {\b QCPColorMap}, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25575                                                              :\par
25576   QCPAbstractPlottable(keyAxis, valueAxis),\par
25577   mDataScaleType(QCPAxis::stLinear),\par
25578   mMapData(new QCPColorMapData(10, 10, QCPRange(0, 5), QCPRange(0, 5))),\par
25579   mGradient(QCPColorGradient::gpCold),\par
25580   mInterpolate(true),\par
25581   mTightBoundary(false),\par
25582   mMapImageInvalidated(true)\par
25583 \{\par
25584 \}\par
}
}
{\xe \v ~QCPColorMap\:QCPColorMap}
{\xe \v QCPColorMap\:~QCPColorMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorMap::~QCPColorMap (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25587 \{\par
25588   delete mMapData;\par
25589 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v colorScale\:QCPColorMap}
{\xe \v QCPColorMap\:colorScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorScale}* QCPColorMap::colorScale () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5759 \{ return mColorScale.data(); \}\par
}
}
{\xe \v data\:QCPColorMap}
{\xe \v QCPColorMap\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorMapData} * QCPColorMap::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the internal data storage of type {\b QCPColorMapData}. Access this to modify data points (cells) and the color map key/value range.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5753 \{ return mMapData; \}\par
}
}
{\xe \v dataRange\:QCPColorMap}
{\xe \v QCPColorMap\:dataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMap::dataRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5754 \{ return mDataRange; \}\par
}
}
{\xe \v dataRangeChanged\:QCPColorMap}
{\xe \v QCPColorMap\:dataRangeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::dataRangeChanged (const {\b QCPRange} &  {\i newRange}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the data range changes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataRange} \par
}}}
{\xe \v dataScaleType\:QCPColorMap}
{\xe \v QCPColorMap\:dataScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::ScaleType} QCPColorMap::dataScaleType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5755 \{ return mDataScaleType; \}\par
}
}
{\xe \v dataScaleTypeChanged\:QCPColorMap}
{\xe \v QCPColorMap\:dataScaleTypeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::dataScaleTypeChanged ({\b QCPAxis::ScaleType}  {\i scaleType}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the data scale type changes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataScaleType} \par
}}}
{\xe \v draw\:QCPColorMap}
{\xe \v QCPColorMap\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25967 \{\par
25968   if (mMapData->isEmpty()) return;\par
25969   if (!mKeyAxis || !mValueAxis) return;\par
25970   applyDefaultAntialiasingHint(painter);\par
25971   \par
25972   if (mMapData->mDataModified || mMapImageInvalidated)\par
25973     updateMapImage();\par
25974   \par
25975   // use buffer if painting vectorized (PDF):\par
25976   const bool useBuffer = painter->modes().testFlag(QCPPainter::pmVectorized);\par
25977   QCPPainter *localPainter = painter; // will be redirected to paint on mapBuffer if painting vectorized\par
25978   QRectF mapBufferTarget; // the rect in absolute widget coordinates where the visible map portion/buffer will end up in\par
25979   QPixmap mapBuffer;\par
25980   if (useBuffer)\par
25981   \{\par
25982     const double mapBufferPixelRatio = 3; // factor by which DPI is increased in embedded bitmaps\par
25983     mapBufferTarget = painter->clipRegion().boundingRect();\par
25984     mapBuffer = QPixmap((mapBufferTarget.size()*mapBufferPixelRatio).toSize());\par
25985     mapBuffer.fill(Qt::transparent);\par
25986     localPainter = new QCPPainter(&mapBuffer);\par
25987     localPainter->scale(mapBufferPixelRatio, mapBufferPixelRatio);\par
25988     localPainter->translate(-mapBufferTarget.topLeft());\par
25989   \}\par
25990   \par
25991   QRectF imageRect = QRectF(coordsToPixels(mMapData->keyRange().lower, mMapData->valueRange().lower),\par
25992                             coordsToPixels(mMapData->keyRange().upper, mMapData->valueRange().upper)).normalized();\par
25993   // extend imageRect to contain outer halves/quarters of bordering/cornering pixels (cells are centered on map range boundary):\par
25994   double halfCellWidth = 0; // in pixels\par
25995   double halfCellHeight = 0; // in pixels\par
25996   if (keyAxis()->orientation() == Qt::Horizontal)\par
25997   \{\par
25998     if (mMapData->keySize() > 1)\par
25999       halfCellWidth = 0.5*imageRect.width()/(double)(mMapData->keySize()-1);\par
26000     if (mMapData->valueSize() > 1)\par
26001       halfCellHeight = 0.5*imageRect.height()/(double)(mMapData->valueSize()-1);\par
26002   \} else // keyAxis orientation is Qt::Vertical\par
26003   \{\par
26004     if (mMapData->keySize() > 1)\par
26005       halfCellHeight = 0.5*imageRect.height()/(double)(mMapData->keySize()-1);\par
26006     if (mMapData->valueSize() > 1)\par
26007       halfCellWidth = 0.5*imageRect.width()/(double)(mMapData->valueSize()-1);\par
26008   \}\par
26009   imageRect.adjust(-halfCellWidth, -halfCellHeight, halfCellWidth, halfCellHeight);\par
26010   const bool mirrorX = (keyAxis()->orientation() == Qt::Horizontal ? keyAxis() : valueAxis())->rangeReversed();\par
26011   const bool mirrorY = (valueAxis()->orientation() == Qt::Vertical ? valueAxis() : keyAxis())->rangeReversed();\par
26012   const bool smoothBackup = localPainter->renderHints().testFlag(QPainter::SmoothPixmapTransform);\par
26013   localPainter->setRenderHint(QPainter::SmoothPixmapTransform, mInterpolate);\par
26014   QRegion clipBackup;\par
26015   if (mTightBoundary)\par
26016   \{\par
26017     clipBackup = localPainter->clipRegion();\par
26018     QRectF tightClipRect = QRectF(coordsToPixels(mMapData->keyRange().lower, mMapData->valueRange().lower),\par
26019                                   coordsToPixels(mMapData->keyRange().upper, mMapData->valueRange().upper)).normalized();\par
26020     localPainter->setClipRect(tightClipRect, Qt::IntersectClip);\par
26021   \}\par
26022   localPainter->drawImage(imageRect, mMapImage.mirrored(mirrorX, mirrorY));\par
26023   if (mTightBoundary)\par
26024     localPainter->setClipRegion(clipBackup);\par
26025   localPainter->setRenderHint(QPainter::SmoothPixmapTransform, smoothBackup);\par
26026   \par
26027   if (useBuffer) // localPainter painted to mapBuffer, so now draw buffer with original painter\par
26028   \{\par
26029     delete localPainter;\par
26030     painter->drawPixmap(mapBufferTarget.toRect(), mapBuffer);\par
26031   \}\par
26032 \}\par
}
}
{\xe \v drawLegendIcon\:QCPColorMap}
{\xe \v QCPColorMap\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26036 \{\par
26037   applyDefaultAntialiasingHint(painter);\par
26038   // draw map thumbnail:\par
26039   if (!mLegendIcon.isNull())\par
26040   \{\par
26041     QPixmap scaledIcon = mLegendIcon.scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::FastTransformation);\par
26042     QRectF iconRect = QRectF(0, 0, scaledIcon.width(), scaledIcon.height());\par
26043     iconRect.moveCenter(rect.center());\par
26044     painter->drawPixmap(iconRect.topLeft(), scaledIcon);\par
26045   \}\par
26046   /*\par
26047   // draw frame:\par
26048   painter->setBrush(Qt::NoBrush);\par
26049   painter->setPen(Qt::black);\par
26050   painter->drawRect(rect.adjusted(1, 1, 0, 0));\par
26051   */\par
26052 \}\par
}
}
{\xe \v getKeyRange\:QCPColorMap}
{\xe \v QCPColorMap\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMap::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25823 \{\par
25824   foundRange = true;\par
25825   QCPRange result = mMapData->keyRange();\par
25826   result.normalize();\par
25827   if (inSignDomain == QCP::sdPositive)\par
25828   \{\par
25829     if (result.lower <= 0 && result.upper > 0)\par
25830       result.lower = result.upper*1e-3;\par
25831     else if (result.lower <= 0 && result.upper <= 0)\par
25832       foundRange = false;\par
25833   \} else if (inSignDomain == QCP::sdNegative)\par
25834   \{\par
25835     if (result.upper >= 0 && result.lower < 0)\par
25836       result.upper = result.lower*1e-3;\par
25837     else if (result.upper >= 0 && result.lower >= 0)\par
25838       foundRange = false;\par
25839   \}\par
25840   return result;\par
25841 \}\par
}
}
{\xe \v getValueRange\:QCPColorMap}
{\xe \v QCPColorMap\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMap::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25845 \{\par
25846   if (inKeyRange != QCPRange())\par
25847   \{\par
25848     if (mMapData->keyRange().upper < inKeyRange.lower || mMapData->keyRange().lower > inKeyRange.upper)\par
25849     \{\par
25850       foundRange = false;\par
25851       return QCPRange();\par
25852     \}\par
25853   \}\par
25854   \par
25855   foundRange = true;\par
25856   QCPRange result = mMapData->valueRange();\par
25857   result.normalize();\par
25858   if (inSignDomain == QCP::sdPositive)\par
25859   \{\par
25860     if (result.lower <= 0 && result.upper > 0)\par
25861       result.lower = result.upper*1e-3;\par
25862     else if (result.lower <= 0 && result.upper <= 0)\par
25863       foundRange = false;\par
25864   \} else if (inSignDomain == QCP::sdNegative)\par
25865   \{\par
25866     if (result.upper >= 0 && result.lower < 0)\par
25867       result.upper = result.lower*1e-3;\par
25868     else if (result.upper >= 0 && result.lower >= 0)\par
25869       foundRange = false;\par
25870   \}\par
25871   return result;\par
25872 \}\par
}
}
{\xe \v gradient\:QCPColorMap}
{\xe \v QCPColorMap\:gradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorGradient} QCPColorMap::gradient () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5758 \{ return mGradient; \}\par
}
}
{\xe \v gradientChanged\:QCPColorMap}
{\xe \v QCPColorMap\:gradientChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::gradientChanged (const {\b QCPColorGradient} &  {\i newGradient}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the gradient changes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setGradient} \par
}}}
{\xe \v interpolate\:QCPColorMap}
{\xe \v QCPColorMap\:interpolate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMap::interpolate () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5756 \{ return mInterpolate; \}\par
}
}
{\xe \v rescaleDataRange\:QCPColorMap}
{\xe \v QCPColorMap\:rescaleDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::rescaleDataRange (bool  {\i recalculateDataBounds} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the data range ({\b setDataRange}) to span the minimum and maximum values that occur in the current data set. This corresponds to the {\b rescaleKeyAxis} or {\b rescaleValueAxis} methods, only for the third data dimension of the color map.\par
The minimum and maximum values of the data set are buffered in the internal {\b QCPColorMapData} instance ({\b data}). As data is updated via its {\b QCPColorMapData::setCell} or {\b QCPColorMapData::setData}, the buffered minimum and maximum values are updated, too. For performance reasons, however, they are only updated in an expanding fashion. So the buffered maximum can only increase and the buffered minimum can only decrease. In consequence, changes to the data that actually lower the maximum of the data set (by overwriting the cell holding the current maximum with a smaller value), aren't recognized and the buffered maximum overestimates the true maximum of the data set. The same happens for the buffered minimum. To recalculate the true minimum and maximum by explicitly looking at each cell, the method {\b QCPColorMapData::recalculateDataBounds} can be used. For convenience, setting the parameter {\i recalculateDataBounds}  calls this method before setting the data range to the buffered minimum and maximum.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25765 \{\par
25766   if (recalculateDataBounds)\par
25767     mMapData->recalculateDataBounds();\par
25768   setDataRange(mMapData->dataBounds());\par
25769 \}\par
}
}
{\xe \v selectTest\:QCPColorMap}
{\xe \v QCPColorMap\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPColorMap::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25800 \{\par
25801   Q_UNUSED(details)\par
25802   if ((onlySelectable && mSelectable == QCP::stNone) || mMapData->isEmpty())\par
25803     return -1;\par
25804   if (!mKeyAxis || !mValueAxis)\par
25805     return -1;\par
25806   \par
25807   if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))\par
25808   \{\par
25809     double posKey, posValue;\par
25810     pixelsToCoords(pos, posKey, posValue);\par
25811     if (mMapData->keyRange().contains(posKey) && mMapData->valueRange().contains(posValue))\par
25812     \{\par
25813       if (details)\par
25814         details->setValue(QCPDataSelection(QCPDataRange(0, 1))); // temporary solution, to facilitate whole-plottable selection. Replace in future version with segmented 2D selection.\par
25815       return mParentPlot->selectionTolerance()*0.99;\par
25816     \}\par
25817   \}\par
25818   return -1;\par
25819 \}\par
}
}
{\xe \v setColorScale\:QCPColorMap}
{\xe \v QCPColorMap\:setColorScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::setColorScale ({\b QCPColorScale} *  {\i colorScale})}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Associates the color scale {\i colorScale}  with this color map.\par
This means that both the color scale and the color map synchronize their gradient, data range and data scale type ({\b setGradient}, {\b setDataRange}, {\b setDataScaleType}). Multiple color maps can be associated with one single color scale. This causes the color maps to also synchronize those properties, via the mutual color scale.\par
This function causes the color map to adopt the current color gradient, data range and data scale type of {\i colorScale} . After this call, you may change these properties at either the color map or the color scale, and the setting will be applied to both.\par
Pass 0 as {\i colorScale}  to disconnect the color scale from this color map again. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25719 \{\par
25720   if (mColorScale) // unconnect signals from old color scale\par
25721   \{\par
25722     disconnect(this, SIGNAL(dataRangeChanged(QCPRange)), mColorScale.data(), SLOT(setDataRange(QCPRange)));\par
25723     disconnect(this, SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), mColorScale.data(), SLOT(setDataScaleType(QCPAxis::ScaleType)));\par
25724     disconnect(this, SIGNAL(gradientChanged(QCPColorGradient)), mColorScale.data(), SLOT(setGradient(QCPColorGradient)));\par
25725     disconnect(mColorScale.data(), SIGNAL(dataRangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));\par
25726     disconnect(mColorScale.data(), SIGNAL(gradientChanged(QCPColorGradient)), this, SLOT(setGradient(QCPColorGradient)));\par
25727     disconnect(mColorScale.data(), SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));\par
25728   \}\par
25729   mColorScale = colorScale;\par
25730   if (mColorScale) // connect signals to new color scale\par
25731   \{\par
25732     setGradient(mColorScale.data()->gradient());\par
25733     setDataRange(mColorScale.data()->dataRange());\par
25734     setDataScaleType(mColorScale.data()->dataScaleType());\par
25735     connect(this, SIGNAL(dataRangeChanged(QCPRange)), mColorScale.data(), SLOT(setDataRange(QCPRange)));\par
25736     connect(this, SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), mColorScale.data(), SLOT(setDataScaleType(QCPAxis::ScaleType)));\par
25737     connect(this, SIGNAL(gradientChanged(QCPColorGradient)), mColorScale.data(), SLOT(setGradient(QCPColorGradient)));\par
25738     connect(mColorScale.data(), SIGNAL(dataRangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));\par
25739     connect(mColorScale.data(), SIGNAL(gradientChanged(QCPColorGradient)), this, SLOT(setGradient(QCPColorGradient)));\par
25740     connect(mColorScale.data(), SIGNAL(dataScaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));\par
25741   \}\par
25742 \}\par
}
}
{\xe \v setData\:QCPColorMap}
{\xe \v QCPColorMap\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::setData ({\b QCPColorMapData} *  {\i data}, bool  {\i copy} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces the current {\b data} with the provided {\i data} .\par
If {\i copy}  is set to true, the {\i data}  object will only be copied. if false, the color map takes ownership of the passed data and replaces the internal data pointer with it. This is significantly faster than copying for large datasets. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25599 \{\par
25600   if (mMapData == data)\par
25601   \{\par
25602     qDebug() << Q_FUNC_INFO << "The data pointer is already in (and owned by) this plottable" << reinterpret_cast<quintptr>(data);\par
25603     return;\par
25604   \}\par
25605   if (copy)\par
25606   \{\par
25607     *mMapData = *data;\par
25608   \} else\par
25609   \{\par
25610     delete mMapData;\par
25611     mMapData = data;\par
25612   \}\par
25613   mMapImageInvalidated = true;\par
25614 \}\par
}
}
{\xe \v setDataRange\:QCPColorMap}
{\xe \v QCPColorMap\:setDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::setDataRange (const {\b QCPRange} &  {\i dataRange})}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the data range of this color map to {\i dataRange} . The data range defines which data values are mapped to the color gradient.\par
To make the data range span the full range of the data set, use {\b rescaleDataRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPColorScale::setDataRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25625 \{\par
25626   if (!QCPRange::validRange(dataRange)) return;\par
25627   if (mDataRange.lower != dataRange.lower || mDataRange.upper != dataRange.upper)\par
25628   \{\par
25629     if (mDataScaleType == QCPAxis::stLogarithmic)\par
25630       mDataRange = dataRange.sanitizedForLogScale();\par
25631     else\par
25632       mDataRange = dataRange.sanitizedForLinScale();\par
25633     mMapImageInvalidated = true;\par
25634     emit dataRangeChanged(mDataRange);\par
25635   \}\par
25636 \}\par
}
}
{\xe \v setDataScaleType\:QCPColorMap}
{\xe \v QCPColorMap\:setDataScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::setDataScaleType ({\b QCPAxis::ScaleType}  {\i scaleType})}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the data is correlated with the color gradient linearly or logarithmically.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPColorScale::setDataScaleType} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25644 \{\par
25645   if (mDataScaleType != scaleType)\par
25646   \{\par
25647     mDataScaleType = scaleType;\par
25648     mMapImageInvalidated = true;\par
25649     emit dataScaleTypeChanged(mDataScaleType);\par
25650     if (mDataScaleType == QCPAxis::stLogarithmic)\par
25651       setDataRange(mDataRange.sanitizedForLogScale());\par
25652   \}\par
25653 \}\par
}
}
{\xe \v setGradient\:QCPColorMap}
{\xe \v QCPColorMap\:setGradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::setGradient (const {\b QCPColorGradient} &  {\i gradient})}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color gradient that is used to represent the data. For more details on how to create an own gradient or use one of the preset gradients, see {\b QCPColorGradient}.\par
The colors defined by the gradient will be used to represent data values in the currently set data range, see {\b setDataRange}. Data points that are outside this data range will either be colored uniformly with the respective gradient boundary color, or the gradient will repeat, depending on {\b QCPColorGradient::setPeriodic}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPColorScale::setGradient} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25667 \{\par
25668   if (mGradient != gradient)\par
25669   \{\par
25670     mGradient = gradient;\par
25671     mMapImageInvalidated = true;\par
25672     emit gradientChanged(mGradient);\par
25673   \}\par
25674 \}\par
}
}
{\xe \v setInterpolate\:QCPColorMap}
{\xe \v QCPColorMap\:setInterpolate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::setInterpolate (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the color map image shall use bicubic interpolation when displaying the color map shrinked or expanded, and not at a 1:1 pixel-to-data scale.\par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25683 \{\par
25684   mInterpolate = enabled;\par
25685   mMapImageInvalidated = true; // because oversampling factors might need to change\par
25686 \}\par
}
}
{\xe \v setTightBoundary\:QCPColorMap}
{\xe \v QCPColorMap\:setTightBoundary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::setTightBoundary (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the outer most data rows and columns are clipped to the specified key and value range (see {\b QCPColorMapData::setKeyRange}, {\b QCPColorMapData::setValueRange}).\par
if {\i enabled}  is set to false, the data points at the border of the color map are drawn with the same width and height as all other data points. Since the data points are represented by rectangles of one color centered on the data coordinate, this means that the shown color map extends by half a data point over the specified key/value range in each direction.\par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25700 \{\par
25701   mTightBoundary = enabled;\par
25702 \}\par
}
}
{\xe \v tightBoundary\:QCPColorMap}
{\xe \v QCPColorMap\:tightBoundary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMap::tightBoundary () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5757 \{ return mTightBoundary; \}\par
}
}
{\xe \v updateLegendIcon\:QCPColorMap}
{\xe \v QCPColorMap\:updateLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::updateLegendIcon (Qt::TransformationMode  {\i transformMode} = {\f2 Qt::SmoothTransformation}, const QSize &  {\i thumbSize} = {\f2 QSize(32,\~ 18)})}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes the current appearance of the color map and updates the legend icon, which is used to represent this color map in the legend (see {\b QCPLegend}).\par
The {\i transformMode}  specifies whether the rescaling is done by a faster, low quality image scaling algorithm (Qt::FastTransformation) or by a slower, higher quality algorithm (Qt::SmoothTransformation).\par
The current color map appearance is scaled down to {\i thumbSize} . Ideally, this should be equal to the size of the legend icon (see {\b QCPLegend::setIconSize}). If it isn't exactly the configured legend icon size, the thumb will be rescaled during drawing of the legend item.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25786 \{\par
25787   if (mMapImage.isNull() && !data()->isEmpty())\par
25788     updateMapImage(); // try to update map image if it's null (happens if no draw has happened yet)\par
25789   \par
25790   if (!mMapImage.isNull()) // might still be null, e.g. if data is empty, so check here again\par
25791   \{\par
25792     bool mirrorX = (keyAxis()->orientation() == Qt::Horizontal ? keyAxis() : valueAxis())->rangeReversed();\par
25793     bool mirrorY = (valueAxis()->orientation() == Qt::Vertical ? valueAxis() : keyAxis())->rangeReversed();\par
25794     mLegendIcon = QPixmap::fromImage(mMapImage.mirrored(mirrorX, mirrorY)).scaled(thumbSize, Qt::KeepAspectRatio, transformMode);\par
25795   \}\par
25796 \}\par
}
}
{\xe \v updateMapImage\:QCPColorMap}
{\xe \v QCPColorMap\:updateMapImage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMap::updateMapImage (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25889 \{\par
25890   QCPAxis *keyAxis = mKeyAxis.data();\par
25891   if (!keyAxis) return;\par
25892   if (mMapData->isEmpty()) return;\par
25893   \par
25894   const QImage::Format format = QImage::Format_ARGB32_Premultiplied;\par
25895   const int keySize = mMapData->keySize();\par
25896   const int valueSize = mMapData->valueSize();\par
25897   int keyOversamplingFactor = mInterpolate ? 1 : (int)(1.0+100.0/(double)keySize); // make mMapImage have at least size 100, factor becomes 1 if size > 200 or interpolation is on\par
25898   int valueOversamplingFactor = mInterpolate ? 1 : (int)(1.0+100.0/(double)valueSize); // make mMapImage have at least size 100, factor becomes 1 if size > 200 or interpolation is on\par
25899   \par
25900   // resize mMapImage to correct dimensions including possible oversampling factors, according to key/value axes orientation:\par
25901   if (keyAxis->orientation() == Qt::Horizontal && (mMapImage.width() != keySize*keyOversamplingFactor || mMapImage.height() != valueSize*valueOversamplingFactor))\par
25902     mMapImage = QImage(QSize(keySize*keyOversamplingFactor, valueSize*valueOversamplingFactor), format);\par
25903   else if (keyAxis->orientation() == Qt::Vertical && (mMapImage.width() != valueSize*valueOversamplingFactor || mMapImage.height() != keySize*keyOversamplingFactor))\par
25904     mMapImage = QImage(QSize(valueSize*valueOversamplingFactor, keySize*keyOversamplingFactor), format);\par
25905   \par
25906   if (mMapImage.isNull())\par
25907   \{\par
25908     qDebug() << Q_FUNC_INFO << "Couldn't create map image (possibly too large for memory)";\par
25909     mMapImage = QImage(QSize(10, 10), format);\par
25910     mMapImage.fill(Qt::black);\par
25911   \} else\par
25912   \{\par
25913     QImage *localMapImage = &mMapImage; // this is the image on which the colorization operates. Either the final mMapImage, or if we need oversampling, mUndersampledMapImage\par
25914     if (keyOversamplingFactor > 1 || valueOversamplingFactor > 1)\par
25915     \{\par
25916       // resize undersampled map image to actual key/value cell sizes:\par
25917       if (keyAxis->orientation() == Qt::Horizontal && (mUndersampledMapImage.width() != keySize || mUndersampledMapImage.height() != valueSize))\par
25918         mUndersampledMapImage = QImage(QSize(keySize, valueSize), format);\par
25919       else if (keyAxis->orientation() == Qt::Vertical && (mUndersampledMapImage.width() != valueSize || mUndersampledMapImage.height() != keySize))\par
25920         mUndersampledMapImage = QImage(QSize(valueSize, keySize), format);\par
25921       localMapImage = &mUndersampledMapImage; // make the colorization run on the undersampled image\par
25922     \} else if (!mUndersampledMapImage.isNull())\par
25923       mUndersampledMapImage = QImage(); // don't need oversampling mechanism anymore (map size has changed) but mUndersampledMapImage still has nonzero size, free it\par
25924     \par
25925     const double *rawData = mMapData->mData;\par
25926     const unsigned char *rawAlpha = mMapData->mAlpha;\par
25927     if (keyAxis->orientation() == Qt::Horizontal)\par
25928     \{\par
25929       const int lineCount = valueSize;\par
25930       const int rowCount = keySize;\par
25931       for (int line=0; line<lineCount; ++line)\par
25932       \{\par
25933         QRgb* pixels = reinterpret_cast<QRgb*>(localMapImage->scanLine(lineCount-1-line)); // invert scanline index because QImage counts scanlines from top, but our vertical index counts from bottom (mathematical coordinate system)\par
25934         if (rawAlpha)\par
25935           mGradient.colorize(rawData+line*rowCount, rawAlpha+line*rowCount, mDataRange, pixels, rowCount, 1, mDataScaleType==QCPAxis::stLogarithmic);\par
25936         else\par
25937           mGradient.colorize(rawData+line*rowCount, mDataRange, pixels, rowCount, 1, mDataScaleType==QCPAxis::stLogarithmic);\par
25938       \}\par
25939     \} else // keyAxis->orientation() == Qt::Vertical\par
25940     \{\par
25941       const int lineCount = keySize;\par
25942       const int rowCount = valueSize;\par
25943       for (int line=0; line<lineCount; ++line)\par
25944       \{\par
25945         QRgb* pixels = reinterpret_cast<QRgb*>(localMapImage->scanLine(lineCount-1-line)); // invert scanline index because QImage counts scanlines from top, but our vertical index counts from bottom (mathematical coordinate system)\par
25946         if (rawAlpha)\par
25947           mGradient.colorize(rawData+line, rawAlpha+line, mDataRange, pixels, rowCount, lineCount, mDataScaleType==QCPAxis::stLogarithmic);\par
25948         else\par
25949           mGradient.colorize(rawData+line, mDataRange, pixels, rowCount, lineCount, mDataScaleType==QCPAxis::stLogarithmic);\par
25950       \}\par
25951     \}\par
25952     \par
25953     if (keyOversamplingFactor > 1 || valueOversamplingFactor > 1)\par
25954     \{\par
25955       if (keyAxis->orientation() == Qt::Horizontal)\par
25956         mMapImage = mUndersampledMapImage.scaled(keySize*keyOversamplingFactor, valueSize*valueOversamplingFactor, Qt::IgnoreAspectRatio, Qt::FastTransformation);\par
25957       else\par
25958         mMapImage = mUndersampledMapImage.scaled(valueSize*valueOversamplingFactor, keySize*keyOversamplingFactor, Qt::IgnoreAspectRatio, Qt::FastTransformation);\par
25959     \}\par
25960   \}\par
25961   mMapData->mDataModified = false;\par
25962   mMapImageInvalidated = false;\par
25963 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLegend\:QCPColorMap}
{\xe \v QCPColorMap\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPColorMap}
{\xe \v QCPColorMap\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mColorScale\:QCPColorMap}
{\xe \v QCPColorMap\:mColorScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPColorScale}> QCPColorMap::mColorScale{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataRange\:QCPColorMap}
{\xe \v QCPColorMap\:mDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMap::mDataRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataScaleType\:QCPColorMap}
{\xe \v QCPColorMap\:mDataScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::ScaleType} QCPColorMap::mDataScaleType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mGradient\:QCPColorMap}
{\xe \v QCPColorMap\:mGradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorGradient} QCPColorMap::mGradient{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInterpolate\:QCPColorMap}
{\xe \v QCPColorMap\:mInterpolate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMap::mInterpolate{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLegendIcon\:QCPColorMap}
{\xe \v QCPColorMap\:mLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPColorMap::mLegendIcon{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMapData\:QCPColorMap}
{\xe \v QCPColorMap\:mMapData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorMapData}* QCPColorMap::mMapData{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMapImage\:QCPColorMap}
{\xe \v QCPColorMap\:mMapImage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QImage QCPColorMap::mMapImage{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMapImageInvalidated\:QCPColorMap}
{\xe \v QCPColorMap\:mMapImageInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMap::mMapImageInvalidated{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTightBoundary\:QCPColorMap}
{\xe \v QCPColorMap\:mTightBoundary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMap::mTightBoundary{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mUndersampledMapImage\:QCPColorMap}
{\xe \v QCPColorMap\:mUndersampledMapImage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QImage QCPColorMap::mUndersampledMapImage{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPColorMapData Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPColorMapData}
{\xe \v QCPColorMapData}
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the two-dimensional data of a {\b QCPColorMap} plottable. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPColorMapData:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_color_map_data__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorMapData} (int {\b keySize}, int {\b valueSize}, const {\b QCPRange} &{\b keyRange}, const {\b QCPRange} &{\b valueRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~QCPColorMapData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorMapData} (const {\b QCPColorMapData} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorMapData} & {\b operator=} (const {\b QCPColorMapData} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b keySize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b valueSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b keyRange} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b valueRange} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b dataBounds} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b data} (double key, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b cell} (int keyIndex, int valueIndex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b alpha} (int keyIndex, int valueIndex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSize} (int {\b keySize}, int {\b valueSize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setKeySize} (int {\b keySize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValueSize} (int {\b valueSize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRange} (const {\b QCPRange} &{\b keyRange}, const {\b QCPRange} &{\b valueRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setKeyRange} (const {\b QCPRange} &{\b keyRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValueRange} (const {\b QCPRange} &{\b valueRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (double key, double value, double z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCell} (int keyIndex, int valueIndex, double z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAlpha} (int keyIndex, int valueIndex, unsigned char {\b alpha})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b recalculateDataBounds} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearAlpha} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fill} (double z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fillAlpha} (unsigned char {\b alpha})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b coordToCell} (double key, double value, int *keyIndex, int *valueIndex) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cellToCoord} (int keyIndex, int valueIndex, double *key, double *value) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b createAlpha} (bool initializeOpaque=true)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mKeySize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mValueSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mKeyRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mValueRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mIsEmpty}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double * {\b mData}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char * {\b mAlpha}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mDataBounds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mDataModified}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPColorMap}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the two-dimensional data of a {\b QCPColorMap} plottable. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a data storage for {\b QCPColorMap}. It holds a two-dimensional array, which {\b QCPColorMap} then displays as a 2D image in the plot, where the array values are represented by a color, depending on the value.\par
The size of the array can be controlled via {\b setSize} (or {\b setKeySize}, {\b setValueSize}). Which plot coordinates these cells correspond to can be configured with {\b setRange} (or {\b setKeyRange}, {\b setValueRange}).\par
The data cells can be accessed in two ways: They can be directly addressed by an integer index with {\b setCell}. This is the fastest method. Alternatively, they can be addressed by their plot coordinate with {\b setData}. plot coordinate to cell index transformations and vice versa are provided by the functions {\b coordToCell} and {\b cellToCoord}.\par
A {\b QCPColorMapData} also holds an on-demand two-dimensional array of alpha values which (if allocated) has the same size as the data map. It can be accessed via {\b setAlpha}, {\b fillAlpha} and {\b clearAlpha}. The memory for the alpha map is only allocated if needed, i.e. on the first call of {\b setAlpha}. {\b clearAlpha} restores full opacity and frees the alpha map.\par
This class also buffers the minimum and maximum values that are in the data set, to provide {\b QCPColorMap::rescaleDataRange} with the necessary information quickly. Setting a cell to a value that is greater than the current maximum increases this maximum to the new value. However, setting the cell that currently holds the maximum value to a smaller value doesn't decrease the maximum again, because finding the true new maximum would require going through the entire data array, which might be time consuming. The same holds for the data minimum. This functionality is given by {\b recalculateDataBounds}, such that you can decide when it is sensible to find the true current minimum and maximum. The method {\b QCPColorMap::rescaleDataRange} offers a convenience parameter {\i recalculateDataBounds}  which may be set to true to automatically call {\b recalculateDataBounds} internally. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPColorMapData\:QCPColorMapData}
{\xe \v QCPColorMapData\:QCPColorMapData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorMapData::QCPColorMapData (int  {\i keySize}, int  {\i valueSize}, const {\b QCPRange} &  {\i keyRange}, const {\b QCPRange} &  {\i valueRange})}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b QCPColorMapData} instance. The instance has {\i keySize}  cells in the key direction and {\i valueSize}  cells in the value direction. These cells will be displayed by the {\b QCPColorMap} at the coordinates {\i keyRange}  and {\i valueRange} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSize}, {\b setKeySize}, {\b setValueSize}, {\b setRange}, {\b setKeyRange}, {\b setValueRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24978                                                                                                                  :\par
24979   mKeySize(0),\par
24980   mValueSize(0),\par
24981   mKeyRange(keyRange),\par
24982   mValueRange(valueRange),\par
24983   mIsEmpty(true),\par
24984   mData(0),\par
24985   mAlpha(0),\par
24986   mDataModified(true)\par
24987 \{\par
24988   setSize(keySize, valueSize);\par
24989   fill(0);\par
24990 \}\par
}
}
{\xe \v ~QCPColorMapData\:QCPColorMapData}
{\xe \v QCPColorMapData\:~QCPColorMapData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorMapData::~QCPColorMapData ()}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24993 \{\par
24994   if (mData)\par
24995     delete[] mData;\par
24996   if (mAlpha)\par
24997     delete[] mAlpha;\par
24998 \}\par
}
}
{\xe \v QCPColorMapData\:QCPColorMapData}
{\xe \v QCPColorMapData\:QCPColorMapData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorMapData::QCPColorMapData (const {\b QCPColorMapData} &  {\i other})}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b QCPColorMapData} instance copying the data and range of {\i other} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25003                                                              :\par
25004   mKeySize(0),\par
25005   mValueSize(0),\par
25006   mIsEmpty(true),\par
25007   mData(0),\par
25008   mAlpha(0),\par
25009   mDataModified(true)\par
25010 \{\par
25011   *this = other;\par
25012 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v alpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:alpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char QCPColorMapData::alpha (int  {\i keyIndex}, int  {\i valueIndex})}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the alpha map value of the cell with the indices {\i keyIndex}  and {\i valueIndex} .\par
If this color map data doesn't have an alpha map (because {\b setAlpha} was never called after creation or after a call to {\b clearAlpha}), returns 255, which corresponds to full opacity.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAlpha} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25071 \{\par
25072   if (mAlpha && keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)\par
25073     return mAlpha[valueIndex*mKeySize + keyIndex];\par
25074   else\par
25075     return 255;\par
25076 \}\par
}
}
{\xe \v cell\:QCPColorMapData}
{\xe \v QCPColorMapData\:cell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPColorMapData::cell (int  {\i keyIndex}, int  {\i valueIndex})}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25055 \{\par
25056   if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)\par
25057     return mData[valueIndex*mKeySize + keyIndex];\par
25058   else\par
25059     return 0;\par
25060 \}\par
}
}
{\xe \v cellToCoord\:QCPColorMapData}
{\xe \v QCPColorMapData\:cellToCoord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::cellToCoord (int  {\i keyIndex}, int  {\i valueIndex}, double *  {\i key}, double *  {\i value}) const}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms cell indices given by {\i keyIndex}  and {\i valueIndex}  to cell indices of this {\b QCPColorMapData} instance. The resulting coordinates are returned via the output parameters {\i key}  and {\i value} .\par
If you are only interested in a key or value coordinate, you may pass 0 as {\i key}  or {\i value} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\b QCPColorMap} always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use {\b QCPColorMap} with logarithmic axes, you shouldn't use the {\b QCPColorMapData::cellToCoord} method as it uses a linear transformation to determine the cell index.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b coordToCell}, {\b QCPAxis::pixelToCoord} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25406 \{\par
25407   if (key)\par
25408     *key = keyIndex/(double)(mKeySize-1)*(mKeyRange.upper-mKeyRange.lower)+mKeyRange.lower;\par
25409   if (value)\par
25410     *value = valueIndex/(double)(mValueSize-1)*(mValueRange.upper-mValueRange.lower)+mValueRange.lower;\par
25411 \}\par
}
}
{\xe \v clear\:QCPColorMapData}
{\xe \v QCPColorMapData\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::clear ()}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees the internal data memory.\par
This is equivalent to calling {\b setSize(0, 0)}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25316 \{\par
25317   setSize(0, 0);\par
25318 \}\par
}
}
{\xe \v clearAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:clearAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::clearAlpha ()}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees the internal alpha map. The color map will have full opacity again. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25324 \{\par
25325   if (mAlpha)\par
25326   \{\par
25327     delete[] mAlpha;\par
25328     mAlpha = 0;\par
25329     mDataModified = true;\par
25330   \}\par
25331 \}\par
}
}
{\xe \v coordToCell\:QCPColorMapData}
{\xe \v QCPColorMapData\:coordToCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::coordToCell (double  {\i key}, double  {\i value}, int *  {\i keyIndex}, int *  {\i valueIndex}) const}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms plot coordinates given by {\i key}  and {\i value}  to cell indices of this {\b QCPColorMapData} instance. The resulting cell indices are returned via the output parameters {\i keyIndex}  and {\i valueIndex} .\par
The retrieved key/value cell indices can then be used for example with {\b setCell}.\par
If you are only interested in a key or value index, you may pass 0 as {\i valueIndex}  or {\i keyIndex} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\b QCPColorMap} always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use {\b QCPColorMap} with logarithmic axes, you shouldn't use the {\b QCPColorMapData::coordToCell} method as it uses a linear transformation to determine the cell index.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b cellToCoord}, {\b QCPAxis::coordToPixel} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25383 \{\par
25384   if (keyIndex)\par
25385     *keyIndex = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;\par
25386   if (valueIndex)\par
25387     *valueIndex = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;\par
25388 \}\par
}
}
{\xe \v createAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:createAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMapData::createAlpha (bool  {\i initializeOpaque} = {\f2 true}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25427 \{\par
25428   clearAlpha();\par
25429   if (isEmpty())\par
25430     return false;\par
25431   \par
25432 #ifdef __EXCEPTIONS\par
25433   try \{ // 2D arrays get memory intensive fast. So if the allocation fails, at least output debug message\par
25434 #endif\par
25435     mAlpha = new unsigned char[mKeySize*mValueSize];\par
25436 #ifdef __EXCEPTIONS\par
25437   \} catch (...) \{ mAlpha = 0; \}\par
25438 #endif\par
25439   if (mAlpha)\par
25440   \{\par
25441     if (initializeOpaque)\par
25442       fillAlpha(255);\par
25443     return true;\par
25444   \} else\par
25445   \{\par
25446     qDebug() << Q_FUNC_INFO << "out of memory for data dimensions "<< mKeySize << "*" << mValueSize;\par
25447     return false;\par
25448   \}\par
25449 \}\par
}
}
{\xe \v data\:QCPColorMapData}
{\xe \v QCPColorMapData\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPColorMapData::data (double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25044 \{\par
25045   int keyCell = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;\par
25046   int valueCell = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;\par
25047   if (keyCell >= 0 && keyCell < mKeySize && valueCell >= 0 && valueCell < mValueSize)\par
25048     return mData[valueCell*mKeySize + keyCell];\par
25049   else\par
25050     return 0;\par
25051 \}\par
}
}
{\xe \v dataBounds\:QCPColorMapData}
{\xe \v QCPColorMapData\:dataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::dataBounds () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5693 \{ return mDataBounds; \}\par
}
}
{\xe \v fill\:QCPColorMapData}
{\xe \v QCPColorMapData\:fill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::fill (double  {\i z})}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets all cells to the value {\i z} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25337 \{\par
25338   const int dataCount = mValueSize*mKeySize;\par
25339   for (int i=0; i<dataCount; ++i)\par
25340     mData[i] = z;\par
25341   mDataBounds = QCPRange(z, z);\par
25342   mDataModified = true;\par
25343 \}\par
}
}
{\xe \v fillAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:fillAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::fillAlpha (unsigned char  {\i alpha})}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the opacity of all color map cells to {\i alpha} . A value of 0 for {\i alpha}  results in a fully transparent color map, and a value of 255 results in a fully opaque color map.\par
If you wish to restore opacity to 100% and free any used memory for the alpha map, rather use {\b clearAlpha}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAlpha} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25355 \{\par
25356   if (mAlpha || createAlpha(false))\par
25357   \{\par
25358     const int dataCount = mValueSize*mKeySize;\par
25359     for (int i=0; i<dataCount; ++i)\par
25360       mAlpha[i] = alpha;\par
25361     mDataModified = true;\par
25362   \}\par
25363 \}\par
}
}
{\xe \v isEmpty\:QCPColorMapData}
{\xe \v QCPColorMapData\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMapData::isEmpty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this instance carries no data. This is equivalent to having a size where at least one of the dimensions is 0 (see {\b setSize}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5715 \{ return mIsEmpty; \}\par
}
}
{\xe \v keyRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:keyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::keyRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5691 \{ return mKeyRange; \}\par
}
}
{\xe \v keySize\:QCPColorMapData}
{\xe \v QCPColorMapData\:keySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorMapData::keySize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5689 \{ return mKeySize; \}\par
}
}
{\xe \v operator=\:QCPColorMapData}
{\xe \v QCPColorMapData\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorMapData} & QCPColorMapData::operator= (const {\b QCPColorMapData} &  {\i other})}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overwrites this color map data instance with the data stored in {\i other} . The alpha map state is transferred, too. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25019 \{\par
25020   if (&other != this)\par
25021   \{\par
25022     const int keySize = other.keySize();\par
25023     const int valueSize = other.valueSize();\par
25024     if (!other.mAlpha && mAlpha)\par
25025       clearAlpha();\par
25026     setSize(keySize, valueSize);\par
25027     if (other.mAlpha && !mAlpha)\par
25028       createAlpha(false);\par
25029     setRange(other.keyRange(), other.valueRange());\par
25030     if (!isEmpty())\par
25031     \{\par
25032       memcpy(mData, other.mData, sizeof(mData[0])*keySize*valueSize);\par
25033       if (mAlpha)\par
25034         memcpy(mAlpha, other.mAlpha, sizeof(mAlpha[0])*keySize*valueSize);\par
25035     \}\par
25036     mDataBounds = other.mDataBounds;\par
25037     mDataModified = true;\par
25038   \}\par
25039   return *this;\par
25040 \}\par
}
}
{\xe \v recalculateDataBounds\:QCPColorMapData}
{\xe \v QCPColorMapData\:recalculateDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::recalculateDataBounds ()}}
\par
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Goes through the data and updates the buffered minimum and maximum data values.\par
Calling this method is only advised if you are about to call {\b QCPColorMap::rescaleDataRange} and can not guarantee that the cells holding the maximum or minimum data haven't been overwritten with a smaller or larger value respectively, since the buffered maximum/minimum values have been updated the last time. Why this is the case is explained in the class description ({\b QCPColorMapData}).\par
Note that the method {\b QCPColorMap::rescaleDataRange} provides a parameter {\i recalculateDataBounds}  for convenience. Setting this to true will call this method for you, before doing the rescale. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25292 \{\par
25293   if (mKeySize > 0 && mValueSize > 0)\par
25294   \{\par
25295     double minHeight = mData[0];\par
25296     double maxHeight = mData[0];\par
25297     const int dataCount = mValueSize*mKeySize;\par
25298     for (int i=0; i<dataCount; ++i)\par
25299     \{\par
25300       if (mData[i] > maxHeight)\par
25301         maxHeight = mData[i];\par
25302       if (mData[i] < minHeight)\par
25303         minHeight = mData[i];\par
25304     \}\par
25305     mDataBounds.lower = minHeight;\par
25306     mDataBounds.upper = maxHeight;\par
25307   \}\par
25308 \}\par
}
}
{\xe \v setAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:setAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setAlpha (int  {\i keyIndex}, int  {\i valueIndex}, unsigned char  {\i alpha})}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the alpha of the color map cell given by {\i keyIndex}  and {\i valueIndex}  to {\i alpha} . A value of 0 for {\i alpha}  results in a fully transparent cell, and a value of 255 results in a fully opaque cell.\par
If an alpha map doesn't exist yet for this color map data, it will be created here. If you wish to restore full opacity and free any allocated memory of the alpha map, call {\b clearAlpha}.\par
Note that the cell-wise alpha which can be configured here is independent of any alpha configured in the color map's gradient ({\b QCPColorGradient}). If a cell is affected both by the cell-wise and gradient alpha, the alpha values will be blended accordingly during rendering of the color map.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b fillAlpha}, {\b clearAlpha} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25266 \{\par
25267   if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)\par
25268   \{\par
25269     if (mAlpha || createAlpha())\par
25270     \{\par
25271       mAlpha[valueIndex*mKeySize + keyIndex] = alpha;\par
25272       mDataModified = true;\par
25273     \}\par
25274   \} else\par
25275     qDebug() << Q_FUNC_INFO << "index out of bounds:" << keyIndex << valueIndex;\par
25276 \}\par
}
}
{\xe \v setCell\:QCPColorMapData}
{\xe \v QCPColorMapData\:setCell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setCell (int  {\i keyIndex}, int  {\i valueIndex}, double  {\i z})}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the data of the cell with indices {\i keyIndex}  and {\i valueIndex}  to {\i z} . The indices enumerate the cells starting from zero, up to the map's size-1 in the respective dimension (see {\b setSize}).\par
In the standard plot configuration (horizontal key axis and vertical value axis, both not range-reversed), the cell with indices (0, 0) is in the bottom left corner and the cell with indices (keySize-1, valueSize-1) is in the top right corner of the color map.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setData}, {\b setSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25237 \{\par
25238   if (keyIndex >= 0 && keyIndex < mKeySize && valueIndex >= 0 && valueIndex < mValueSize)\par
25239   \{\par
25240     mData[valueIndex*mKeySize + keyIndex] = z;\par
25241     if (z < mDataBounds.lower)\par
25242       mDataBounds.lower = z;\par
25243     if (z > mDataBounds.upper)\par
25244       mDataBounds.upper = z;\par
25245      mDataModified = true;\par
25246   \} else\par
25247     qDebug() << Q_FUNC_INFO << "index out of bounds:" << keyIndex << valueIndex;\par
25248 \}\par
}
}
{\xe \v setData\:QCPColorMapData}
{\xe \v QCPColorMapData\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setData (double  {\i key}, double  {\i value}, double  {\i z})}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the data of the cell, which lies at the plot coordinates given by {\i key}  and {\i value} , to {\i z} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The {\b QCPColorMap} always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use {\b QCPColorMap} with logarithmic axes, you shouldn't use the {\b QCPColorMapData::setData} method as it uses a linear transformation to determine the cell index. Rather directly access the cell index with {\b QCPColorMapData::setCell}.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setCell}, {\b setRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25211 \{\par
25212   int keyCell = (key-mKeyRange.lower)/(mKeyRange.upper-mKeyRange.lower)*(mKeySize-1)+0.5;\par
25213   int valueCell = (value-mValueRange.lower)/(mValueRange.upper-mValueRange.lower)*(mValueSize-1)+0.5;\par
25214   if (keyCell >= 0 && keyCell < mKeySize && valueCell >= 0 && valueCell < mValueSize)\par
25215   \{\par
25216     mData[valueCell*mKeySize + keyCell] = z;\par
25217     if (z < mDataBounds.lower)\par
25218       mDataBounds.lower = z;\par
25219     if (z > mDataBounds.upper)\par
25220       mDataBounds.upper = z;\par
25221      mDataModified = true;\par
25222   \}\par
25223 \}\par
}
}
{\xe \v setKeyRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:setKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setKeyRange (const {\b QCPRange} &  {\i keyRange})}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the coordinate range the data shall be distributed over in the key dimension. Together with the value range, This defines the rectangular area covered by the color map in plot coordinates.\par
The outer cells will be centered on the range boundaries given to this function. For example, if the key size ({\b setKeySize}) is 3 and {\i keyRange}  is set to {\f2 {\b QCPRange(2, 3)}}  there will be cells centered on the key coordinates 2, 2.5 and 3.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange}, {\b setValueRange}, {\b setSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25179 \{\par
25180   mKeyRange = keyRange;\par
25181 \}\par
}
}
{\xe \v setKeySize\:QCPColorMapData}
{\xe \v QCPColorMapData\:setKeySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setKeySize (int  {\i keySize})}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the data array to have {\i keySize}  cells in the key dimension.\par
The current data is discarded and the map cells are set to 0, unless the map had already the requested size.\par
Setting {\i keySize}  to zero frees the internal data array and {\b isEmpty} returns true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setKeyRange}, {\b setSize}, {\b setValueSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25133 \{\par
25134   setSize(keySize, mValueSize);\par
25135 \}\par
}
}
{\xe \v setRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:setRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setRange (const {\b QCPRange} &  {\i keyRange}, const {\b QCPRange} &  {\i valueRange})}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the coordinate ranges the data shall be distributed over. This defines the rectangular area covered by the color map in plot coordinates.\par
The outer cells will be centered on the range boundaries given to this function. For example, if the key size ({\b setKeySize}) is 3 and {\i keyRange}  is set to {\f2 {\b QCPRange(2, 3)}}  there will be cells centered on the key coordinates 2, 2.5 and 3.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25163 \{\par
25164   setKeyRange(keyRange);\par
25165   setValueRange(valueRange);\par
25166 \}\par
}
}
{\xe \v setSize\:QCPColorMapData}
{\xe \v QCPColorMapData\:setSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setSize (int  {\i keySize}, int  {\i valueSize})}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the data array to have {\i keySize}  cells in the key dimension and {\i valueSize}  cells in the value dimension.\par
The current data is discarded and the map cells are set to 0, unless the map had already the requested size.\par
Setting at least one of {\i keySize}  or {\i valueSize}  to zero frees the internal data array and {\b isEmpty} returns true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange}, {\b setKeySize}, {\b setValueSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25091 \{\par
25092   if (keySize != mKeySize || valueSize != mValueSize)\par
25093   \{\par
25094     mKeySize = keySize;\par
25095     mValueSize = valueSize;\par
25096     if (mData)\par
25097       delete[] mData;\par
25098     mIsEmpty = mKeySize == 0 || mValueSize == 0;\par
25099     if (!mIsEmpty)\par
25100     \{\par
25101 #ifdef __EXCEPTIONS\par
25102       try \{ // 2D arrays get memory intensive fast. So if the allocation fails, at least output debug message\par
25103 #endif\par
25104       mData = new double[mKeySize*mValueSize];\par
25105 #ifdef __EXCEPTIONS\par
25106       \} catch (...) \{ mData = 0; \}\par
25107 #endif\par
25108       if (mData)\par
25109         fill(0);\par
25110       else\par
25111         qDebug() << Q_FUNC_INFO << "out of memory for data dimensions "<< mKeySize << "*" << mValueSize;\par
25112     \} else\par
25113       mData = 0;\par
25114     \par
25115     if (mAlpha) // if we had an alpha map, recreate it with new size\par
25116       createAlpha();\par
25117     \par
25118     mDataModified = true;\par
25119   \}\par
25120 \}\par
}
}
{\xe \v setValueRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:setValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setValueRange (const {\b QCPRange} &  {\i valueRange})}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the coordinate range the data shall be distributed over in the value dimension. Together with the key range, This defines the rectangular area covered by the color map in plot coordinates.\par
The outer cells will be centered on the range boundaries given to this function. For example, if the value size ({\b setValueSize}) is 3 and {\i valueRange}  is set to {\f2 {\b QCPRange(2, 3)}}  there will be cells centered on the value coordinates 2, 2.5 and 3.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange}, {\b setKeyRange}, {\b setSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25194 \{\par
25195   mValueRange = valueRange;\par
25196 \}\par
}
}
{\xe \v setValueSize\:QCPColorMapData}
{\xe \v QCPColorMapData\:setValueSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorMapData::setValueSize (int  {\i valueSize})}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the data array to have {\i valueSize}  cells in the value dimension.\par
The current data is discarded and the map cells are set to 0, unless the map had already the requested size.\par
Setting {\i valueSize}  to zero frees the internal data array and {\b isEmpty} returns true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setValueRange}, {\b setSize}, {\b setKeySize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25148 \{\par
25149   setSize(mKeySize, valueSize);\par
25150 \}\par
}
}
{\xe \v valueRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:valueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::valueRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5692 \{ return mValueRange; \}\par
}
}
{\xe \v valueSize\:QCPColorMapData}
{\xe \v QCPColorMapData\:valueSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorMapData::valueSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5690 \{ return mValueSize; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPColorMap\:QCPColorMapData}
{\xe \v QCPColorMapData\:QCPColorMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPColorMap}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAlpha\:QCPColorMapData}
{\xe \v QCPColorMapData\:mAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char* QCPColorMapData::mAlpha{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mData\:QCPColorMapData}
{\xe \v QCPColorMapData\:mData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double* QCPColorMapData::mData{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataBounds\:QCPColorMapData}
{\xe \v QCPColorMapData\:mDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::mDataBounds{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataModified\:QCPColorMapData}
{\xe \v QCPColorMapData\:mDataModified}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMapData::mDataModified{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mIsEmpty\:QCPColorMapData}
{\xe \v QCPColorMapData\:mIsEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorMapData::mIsEmpty{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mKeyRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:mKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::mKeyRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mKeySize\:QCPColorMapData}
{\xe \v QCPColorMapData\:mKeySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorMapData::mKeySize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mValueRange\:QCPColorMapData}
{\xe \v QCPColorMapData\:mValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorMapData::mValueRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mValueSize\:QCPColorMapData}
{\xe \v QCPColorMapData\:mValueSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorMapData::mValueSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPColorScale Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPColorScale}
{\xe \v QCPColorScale}
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A color scale for use with color coding data such as {\b QCPColorMap}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPColorScale:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_color_scale__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPColorScale:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_color_scale__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dataRangeChanged} (const {\b QCPRange} &newRange)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dataScaleTypeChanged} ({\b QCPAxis::ScaleType} scaleType)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gradientChanged} (const {\b QCPColorGradient} &newGradient)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorScale} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPColorScale} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b axis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis::AxisType} {\b type} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b dataRange} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis::ScaleType} {\b dataScaleType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} {\b gradient} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b label} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b barWidth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rangeDrag} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rangeZoom} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setType} ({\b QCPAxis::AxisType} {\b type})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setDataRange} (const {\b QCPRange} &{\b dataRange})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setDataScaleType} ({\b QCPAxis::ScaleType} scaleType)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setGradient} (const {\b QCPColorGradient} &{\b gradient})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLabel} (const QString &str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBarWidth} (int width)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeDrag} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoom} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPColorMap} * > {\b colorMaps} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleDataRange} (bool onlyVisibleMaps)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b update} ({\b UpdatePhase} phase) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event, const QPointF &startPos) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis::AxisType} {\b mType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mDataRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis::ScaleType} {\b mDataScaleType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} {\b mGradient}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mBarWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPColorScaleAxisRectPrivate} > {\b mAxisRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxis} > {\b mColorAxis}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPColorScaleAxisRectPrivate}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A color scale for use with color coding data such as {\b QCPColorMap}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This layout element can be placed on the plot to correlate a color gradient with data values. It is usually used in combination with one or multiple {\b QCPColorMaps}.\par
The color scale can be either horizontal or vertical, as shown in the image above. The orientation and the side where the numbers appear is controlled with {\b setType}.\par
Use {\b QCPColorMap::setColorScale} to connect a color map with a color scale. Once they are connected, they share their gradient, data range and data scale type ({\b setGradient}, {\b setDataRange}, {\b setDataScaleType}). Multiple color maps may be associated with a single color scale, to make them all synchronize these properties.\par
To have finer control over the number display and axis behaviour, you can directly access the {\b axis}. See the documentation of {\b QCPAxis} for details about configuring axes. For example, if you want to change the number of automatically generated ticks, call {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } Placing a color scale next to the main axis rect works like with any other layout element: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }In this case we have placed it to the right of the default axis rect, so it wasn't necessary to call {\b setType}, since {\b QCPAxis::atRight} is already the default. The text next to the color scale can be set with {\b setLabel}.\par
For optimum appearance (like in the image above), it may be desirable to line up the axis rect and the borders of the color scale. Use a {\b QCPMarginGroup} to achieve this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } Color scales are initialized with a non-zero minimum top and bottom margin ({\b setMinimumMargins}), because vertical color scales are most common and the minimum top/bottom margin makes sure it keeps some distance to the top/bottom widget border. So if you change to a horizontal color scale by setting {\b setType} to {\b QCPAxis::atBottom} or {\b QCPAxis::atTop}, you might want to also change the minimum margins accordingly, e.g. {\f2 setMinimumMargins(QMargins(6, 0, 6, 0))} . \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPColorScale\:QCPColorScale}
{\xe \v QCPColorScale\:QCPColorScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorScale::QCPColorScale ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b QCPColorScale}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19332                                                     :\par
19333   QCPLayoutElement(parentPlot),\par
19334   mType(QCPAxis::atTop), // set to atTop such that setType(QCPAxis::atRight) below doesn't skip work because it thinks it's already atRight\par
19335   mDataScaleType(QCPAxis::stLinear),\par
19336   mBarWidth(20),\par
19337   mAxisRect(new QCPColorScaleAxisRectPrivate(this))\par
19338 \{\par
19339   setMinimumMargins(QMargins(0, 6, 0, 6)); // for default right color scale types, keep some room at bottom and top (important if no margin group is used)\par
19340   setType(QCPAxis::atRight);\par
19341   setDataRange(QCPRange(0, 6));\par
19342 \}\par
}
}
{\xe \v ~QCPColorScale\:QCPColorScale}
{\xe \v QCPColorScale\:~QCPColorScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorScale::~QCPColorScale (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19345 \{\par
19346   delete mAxisRect;\par
19347 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v applyDefaultAntialiasingHint\:QCPColorScale}
{\xe \v QCPColorScale\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19684 \{\par
19685   painter->setAntialiasing(false);\par
19686 \}\par
}
}
{\xe \v axis\:QCPColorScale}
{\xe \v QCPColorScale\:axis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCPColorScale::axis () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the internal {\b QCPAxis} instance of this color scale. You can access it to alter the appearance and behaviour of the axis. {\b QCPColorScale} duplicates some properties in its interface for convenience. Those are {\b setDataRange} ({\b QCPAxis::setRange}), {\b setDataScaleType} ({\b QCPAxis::setScaleType}), and the method {\b setLabel} ({\b QCPAxis::setLabel}). As they each are connected, it does not matter whether you use the method on the {\b QCPColorScale} or on its {\b QCPAxis}.\par
If the type of the color scale is changed with {\b setType}, the axis returned by this method will change, too, to either the left, right, bottom or top axis, depending on which type was set. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5056 \{ return mColorAxis.data(); \}\par
}
}
{\xe \v barWidth\:QCPColorScale}
{\xe \v QCPColorScale\:barWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorScale::barWidth () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5062 \{ return mBarWidth; \}\par
}
}
{\xe \v colorMaps\:QCPColorScale}
{\xe \v QCPColorScale\:colorMaps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPColorMap} * > QCPColorScale::colorMaps () const}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the color maps associated with this color scale. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19570 \{\par
19571   QList<QCPColorMap*> result;\par
19572   for (int i=0; i<mParentPlot->plottableCount(); ++i)\par
19573   \{\par
19574     if (QCPColorMap *cm = qobject_cast<QCPColorMap*>(mParentPlot->plottable(i)))\par
19575       if (cm->colorScale() == this)\par
19576         result.append(cm);\par
19577   \}\par
19578   return result;\par
19579 \}\par
}
}
{\xe \v dataRange\:QCPColorScale}
{\xe \v QCPColorScale\:dataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorScale::dataRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5058 \{ return mDataRange; \}\par
}
}
{\xe \v dataRangeChanged\:QCPColorScale}
{\xe \v QCPColorScale\:dataRangeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::dataRangeChanged (const {\b QCPRange} &  {\i newRange}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the data range changes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataRange} \par
}}}
{\xe \v dataScaleType\:QCPColorScale}
{\xe \v QCPColorScale\:dataScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::ScaleType} QCPColorScale::dataScaleType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5059 \{ return mDataScaleType; \}\par
}
}
{\xe \v dataScaleTypeChanged\:QCPColorScale}
{\xe \v QCPColorScale\:dataScaleTypeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::dataScaleTypeChanged ({\b QCPAxis::ScaleType}  {\i scaleType}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the data scale type changes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataScaleType} \par
}}}
{\xe \v gradient\:QCPColorScale}
{\xe \v QCPColorScale\:gradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorGradient} QCPColorScale::gradient () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5060 \{ return mGradient; \}\par
}
}
{\xe \v gradientChanged\:QCPColorScale}
{\xe \v QCPColorScale\:gradientChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::gradientChanged (const {\b QCPColorGradient} &  {\i newGradient}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the gradient changes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setGradient} \par
}}}
{\xe \v label\:QCPColorScale}
{\xe \v QCPColorScale\:label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPColorScale::label () const}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19351 \{\par
19352   if (!mColorAxis)\par
19353   \{\par
19354     qDebug() << Q_FUNC_INFO << "internal color axis undefined";\par
19355     return QString();\par
19356   \}\par
19357   \par
19358   return mColorAxis.data()->label();\par
19359 \}\par
}
}
{\xe \v mouseMoveEvent\:QCPColorScale}
{\xe \v QCPColorScale\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::mouseMoveEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19701 \{\par
19702   if (!mAxisRect)\par
19703   \{\par
19704     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19705     return;\par
19706   \}\par
19707   mAxisRect.data()->mouseMoveEvent(event, startPos);\par
19708 \}\par
}
}
{\xe \v mousePressEvent\:QCPColorScale}
{\xe \v QCPColorScale\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::mousePressEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
{\b QCustomPlot} uses an event propagation system that works the same as Qt's system. If your layerable doesn't reimplement the {\b mousePressEvent} or explicitly calls {\f2 event->ignore()}  in its reimplementation, the event will be propagated to the next layerable in the stacking order.\par
Once a layerable has accepted the {\b mousePressEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} or {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19690 \{\par
19691   if (!mAxisRect)\par
19692   \{\par
19693     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19694     return;\par
19695   \}\par
19696   mAxisRect.data()->mousePressEvent(event, details);\par
19697 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPColorScale}
{\xe \v QCPColorScale\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::mouseReleaseEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19712 \{\par
19713   if (!mAxisRect)\par
19714   \{\par
19715     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19716     return;\par
19717   \}\par
19718   mAxisRect.data()->mouseReleaseEvent(event, startPos);\par
19719 \}\par
}
}
{\xe \v rangeDrag\:QCPColorScale}
{\xe \v QCPColorScale\:rangeDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorScale::rangeDrag () const}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19363 \{\par
19364   if (!mAxisRect)\par
19365   \{\par
19366     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19367     return false;\par
19368   \}\par
19369   \par
19370   return mAxisRect.data()->rangeDrag().testFlag(QCPAxis::orientation(mType)) &&\par
19371       mAxisRect.data()->rangeDragAxis(QCPAxis::orientation(mType)) &&\par
19372       mAxisRect.data()->rangeDragAxis(QCPAxis::orientation(mType))->orientation() == QCPAxis::orientation(mType);\par
19373 \}\par
}
}
{\xe \v rangeZoom\:QCPColorScale}
{\xe \v QCPColorScale\:rangeZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorScale::rangeZoom () const}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19377 \{\par
19378   if (!mAxisRect)\par
19379   \{\par
19380     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19381     return false;\par
19382   \}\par
19383   \par
19384   return mAxisRect.data()->rangeZoom().testFlag(QCPAxis::orientation(mType)) &&\par
19385       mAxisRect.data()->rangeZoomAxis(QCPAxis::orientation(mType)) &&\par
19386       mAxisRect.data()->rangeZoomAxis(QCPAxis::orientation(mType))->orientation() == QCPAxis::orientation(mType);\par
19387 \}\par
}
}
{\xe \v rescaleDataRange\:QCPColorScale}
{\xe \v QCPColorScale\:rescaleDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::rescaleDataRange (bool  {\i onlyVisibleMaps})}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Changes the data range such that all color maps associated with this color scale are fully mapped to the gradient in the data dimension.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19588 \{\par
19589   QList<QCPColorMap*> maps = colorMaps();\par
19590   QCPRange newRange;\par
19591   bool haveRange = false;\par
19592   QCP::SignDomain sign = QCP::sdBoth;\par
19593   if (mDataScaleType == QCPAxis::stLogarithmic)\par
19594     sign = (mDataRange.upper < 0 ? QCP::sdNegative : QCP::sdPositive);\par
19595   for (int i=0; i<maps.size(); ++i)\par
19596   \{\par
19597     if (!maps.at(i)->realVisibility() && onlyVisibleMaps)\par
19598       continue;\par
19599     QCPRange mapRange;\par
19600     if (maps.at(i)->colorScale() == this)\par
19601     \{\par
19602       bool currentFoundRange = true;\par
19603       mapRange = maps.at(i)->data()->dataBounds();\par
19604       if (sign == QCP::sdPositive)\par
19605       \{\par
19606         if (mapRange.lower <= 0 && mapRange.upper > 0)\par
19607           mapRange.lower = mapRange.upper*1e-3;\par
19608         else if (mapRange.lower <= 0 && mapRange.upper <= 0)\par
19609           currentFoundRange = false;\par
19610       \} else if (sign == QCP::sdNegative)\par
19611       \{\par
19612         if (mapRange.upper >= 0 && mapRange.lower < 0)\par
19613           mapRange.upper = mapRange.lower*1e-3;\par
19614         else if (mapRange.upper >= 0 && mapRange.lower >= 0)\par
19615           currentFoundRange = false;\par
19616       \}\par
19617       if (currentFoundRange)\par
19618       \{\par
19619         if (!haveRange)\par
19620           newRange = mapRange;\par
19621         else\par
19622           newRange.expand(mapRange);\par
19623         haveRange = true;\par
19624       \}\par
19625     \}\par
19626   \}\par
19627   if (haveRange)\par
19628   \{\par
19629     if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this dimension), shift current range to at least center the data\par
19630     \{\par
19631       double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason\par
19632       if (mDataScaleType == QCPAxis::stLinear)\par
19633       \{\par
19634         newRange.lower = center-mDataRange.size()/2.0;\par
19635         newRange.upper = center+mDataRange.size()/2.0;\par
19636       \} else // mScaleType == stLogarithmic\par
19637       \{\par
19638         newRange.lower = center/qSqrt(mDataRange.upper/mDataRange.lower);\par
19639         newRange.upper = center*qSqrt(mDataRange.upper/mDataRange.lower);\par
19640       \}\par
19641     \}\par
19642     setDataRange(newRange);\par
19643   \}\par
19644 \}\par
}
}
{\xe \v setBarWidth\:QCPColorScale}
{\xe \v QCPColorScale\:setBarWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::setBarWidth (int  {\i width})}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the width (or height, for horizontal color scales) the bar where the gradient is displayed will have. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19522 \{\par
19523   mBarWidth = width;\par
19524 \}\par
}
}
{\xe \v setDataRange\:QCPColorScale}
{\xe \v QCPColorScale\:setDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::setDataRange (const {\b QCPRange} &  {\i dataRange})}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the range spanned by the color gradient and that is shown by the axis in the color scale.\par
It is equivalent to calling {\b QCPColorMap::setDataRange} on any of the connected color maps. It is also equivalent to directly accessing the {\b axis} and setting its range with {\b QCPAxis::setRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataScaleType}, {\b setGradient}, {\b rescaleDataRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19451 \{\par
19452   if (mDataRange.lower != dataRange.lower || mDataRange.upper != dataRange.upper)\par
19453   \{\par
19454     mDataRange = dataRange;\par
19455     if (mColorAxis)\par
19456       mColorAxis.data()->setRange(mDataRange);\par
19457     emit dataRangeChanged(mDataRange);\par
19458   \}\par
19459 \}\par
}
}
{\xe \v setDataScaleType\:QCPColorScale}
{\xe \v QCPColorScale\:setDataScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::setDataScaleType ({\b QCPAxis::ScaleType}  {\i scaleType})}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the scale type of the color scale, i.e. whether values are linearly associated with colors or logarithmically.\par
It is equivalent to calling {\b QCPColorMap::setDataScaleType} on any of the connected color maps. It is also equivalent to directly accessing the {\b axis} and setting its scale type with {\b QCPAxis::setScaleType}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataRange}, {\b setGradient} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19472 \{\par
19473   if (mDataScaleType != scaleType)\par
19474   \{\par
19475     mDataScaleType = scaleType;\par
19476     if (mColorAxis)\par
19477       mColorAxis.data()->setScaleType(mDataScaleType);\par
19478     if (mDataScaleType == QCPAxis::stLogarithmic)\par
19479       setDataRange(mDataRange.sanitizedForLogScale());\par
19480     emit dataScaleTypeChanged(mDataScaleType);\par
19481   \}\par
19482 \}\par
}
}
{\xe \v setGradient\:QCPColorScale}
{\xe \v QCPColorScale\:setGradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::setGradient (const {\b QCPColorGradient} &  {\i gradient})}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color gradient that will be used to represent data values.\par
It is equivalent to calling {\b QCPColorMap::setGradient} on any of the connected color maps.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setDataRange}, {\b setDataScaleType} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19492 \{\par
19493   if (mGradient != gradient)\par
19494   \{\par
19495     mGradient = gradient;\par
19496     if (mAxisRect)\par
19497       mAxisRect.data()->mGradientImageInvalidated = true;\par
19498     emit gradientChanged(mGradient);\par
19499   \}\par
19500 \}\par
}
}
{\xe \v setLabel\:QCPColorScale}
{\xe \v QCPColorScale\:setLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::setLabel (const QString &  {\i str})}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the axis label of the color scale. This is equivalent to calling {\b QCPAxis::setLabel} on the internal {\b axis}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19507 \{\par
19508   if (!mColorAxis)\par
19509   \{\par
19510     qDebug() << Q_FUNC_INFO << "internal color axis undefined";\par
19511     return;\par
19512   \}\par
19513   \par
19514   mColorAxis.data()->setLabel(str);\par
19515 \}\par
}
}
{\xe \v setRangeDrag\:QCPColorScale}
{\xe \v QCPColorScale\:setRangeDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::setRangeDrag (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the user can drag the data range ({\b setDataRange}).\par
Note that {\b QCP::iRangeDrag} must be in the {\b QCustomPlot}'s interactions ({\b QCustomPlot::setInteractions}) to allow range dragging. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19533 \{\par
19534   if (!mAxisRect)\par
19535   \{\par
19536     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19537     return;\par
19538   \}\par
19539   \par
19540   if (enabled)\par
19541     mAxisRect.data()->setRangeDrag(QCPAxis::orientation(mType));\par
19542   else\par
19543     mAxisRect.data()->setRangeDrag(0);\par
19544 \}\par
}
}
{\xe \v setRangeZoom\:QCPColorScale}
{\xe \v QCPColorScale\:setRangeZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::setRangeZoom (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the user can zoom the data range ({\b setDataRange}) by scrolling the mouse wheel.\par
Note that {\b QCP::iRangeZoom} must be in the {\b QCustomPlot}'s interactions ({\b QCustomPlot::setInteractions}) to allow range dragging. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19553 \{\par
19554   if (!mAxisRect)\par
19555   \{\par
19556     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19557     return;\par
19558   \}\par
19559   \par
19560   if (enabled)\par
19561     mAxisRect.data()->setRangeZoom(QCPAxis::orientation(mType));\par
19562   else\par
19563     mAxisRect.data()->setRangeZoom(0);\par
19564 \}\par
}
}
{\xe \v setType\:QCPColorScale}
{\xe \v QCPColorScale\:setType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::setType ({\b QCPAxis::AxisType}  {\i type})}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets at which side of the color scale the axis is placed, and thus also its orientation.\par
Note that after setting {\i type}  to a different value, the axis returned by {\b axis()} will be a different one. The new axis will adopt the following properties from the previous axis: The range, scale type, label and ticker (the latter will be shared and not copied). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19397 \{\par
19398   if (!mAxisRect)\par
19399   \{\par
19400     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19401     return;\par
19402   \}\par
19403   if (mType != type)\par
19404   \{\par
19405     mType = type;\par
19406     QCPRange rangeTransfer(0, 6);\par
19407     QString labelTransfer;\par
19408     QSharedPointer<QCPAxisTicker> tickerTransfer;\par
19409     // transfer/revert some settings on old axis if it exists:\par
19410     bool doTransfer = (bool)mColorAxis;\par
19411     if (doTransfer)\par
19412     \{\par
19413       rangeTransfer = mColorAxis.data()->range();\par
19414       labelTransfer = mColorAxis.data()->label();\par
19415       tickerTransfer = mColorAxis.data()->ticker();\par
19416       mColorAxis.data()->setLabel(QString());\par
19417       disconnect(mColorAxis.data(), SIGNAL(rangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));\par
19418       disconnect(mColorAxis.data(), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));\par
19419     \}\par
19420     QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atLeft << QCPAxis::atRight << QCPAxis::atBottom << QCPAxis::atTop;\par
19421     foreach (QCPAxis::AxisType atype, allAxisTypes)\par
19422     \{\par
19423       mAxisRect.data()->axis(atype)->setTicks(atype == mType);\par
19424       mAxisRect.data()->axis(atype)->setTickLabels(atype== mType);\par
19425     \}\par
19426     // set new mColorAxis pointer:\par
19427     mColorAxis = mAxisRect.data()->axis(mType);\par
19428     // transfer settings to new axis:\par
19429     if (doTransfer)\par
19430     \{\par
19431       mColorAxis.data()->setRange(rangeTransfer); // range transfer necessary if axis changes from vertical to horizontal or vice versa (axes with same orientation are synchronized via signals)\par
19432       mColorAxis.data()->setLabel(labelTransfer);\par
19433       mColorAxis.data()->setTicker(tickerTransfer);\par
19434     \}\par
19435     connect(mColorAxis.data(), SIGNAL(rangeChanged(QCPRange)), this, SLOT(setDataRange(QCPRange)));\par
19436     connect(mColorAxis.data(), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), this, SLOT(setDataScaleType(QCPAxis::ScaleType)));\par
19437     mAxisRect.data()->setRangeDragAxes(QList<QCPAxis*>() << mColorAxis.data());\par
19438   \}\par
19439 \}\par
}
}
{\xe \v type\:QCPColorScale}
{\xe \v QCPColorScale\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::AxisType} QCPColorScale::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5057 \{ return mType; \}\par
}
}
{\xe \v update\:QCPColorScale}
{\xe \v QCPColorScale\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::update ({\b UpdatePhase}  {\i phase}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates the layout element and sub-elements. This function is automatically called before every replot by the parent layout element. It is called multiple times, once for every {\b UpdatePhase}. The phases are run through in the order of the enum values. For details about what happens at the different phases, see the documentation of {\b UpdatePhase}.\par
Layout elements that have child elements should call the {\b update} method of their child elements, and pass the current {\i phase}  unchanged.\par
The default implementation executes the automatic margin mechanism in the {\b upMargins} phase. Subclasses should make sure to call the base class implementation. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19648 \{\par
19649   QCPLayoutElement::update(phase);\par
19650   if (!mAxisRect)\par
19651   \{\par
19652     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19653     return;\par
19654   \}\par
19655   \par
19656   mAxisRect.data()->update(phase);\par
19657   \par
19658   switch (phase)\par
19659   \{\par
19660     case upMargins:\par
19661     \{\par
19662       if (mType == QCPAxis::atBottom || mType == QCPAxis::atTop)\par
19663       \{\par
19664         setMaximumSize(QWIDGETSIZE_MAX, mBarWidth+mAxisRect.data()->margins().top()+mAxisRect.data()->margins().bottom());\par
19665         setMinimumSize(0,               mBarWidth+mAxisRect.data()->margins().top()+mAxisRect.data()->margins().bottom());\par
19666       \} else\par
19667       \{\par
19668         setMaximumSize(mBarWidth+mAxisRect.data()->margins().left()+mAxisRect.data()->margins().right(), QWIDGETSIZE_MAX);\par
19669         setMinimumSize(mBarWidth+mAxisRect.data()->margins().left()+mAxisRect.data()->margins().right(), 0);\par
19670       \}\par
19671       break;\par
19672     \}\par
19673     case upLayout:\par
19674     \{\par
19675       mAxisRect.data()->setOuterRect(rect());\par
19676       break;\par
19677     \}\par
19678     default: break;\par
19679   \}\par
19680 \}\par
}
}
{\xe \v wheelEvent\:QCPColorScale}
{\xe \v QCPColorScale\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScale::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} .\par
The {\f2 event->delta()}  indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making {\f2 event->delta()}  larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent} \par
}}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19723 \{\par
19724   if (!mAxisRect)\par
19725   \{\par
19726     qDebug() << Q_FUNC_INFO << "internal axis rect was deleted";\par
19727     return;\par
19728   \}\par
19729   mAxisRect.data()->wheelEvent(event);\par
19730 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPColorScaleAxisRectPrivate\:QCPColorScale}
{\xe \v QCPColorScale\:QCPColorScaleAxisRectPrivate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPColorScaleAxisRectPrivate}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAxisRect\:QCPColorScale}
{\xe \v QCPColorScale\:mAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPColorScaleAxisRectPrivate}> QCPColorScale::mAxisRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBarWidth\:QCPColorScale}
{\xe \v QCPColorScale\:mBarWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorScale::mBarWidth{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mColorAxis\:QCPColorScale}
{\xe \v QCPColorScale\:mColorAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxis}> QCPColorScale::mColorAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataRange\:QCPColorScale}
{\xe \v QCPColorScale\:mDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPColorScale::mDataRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataScaleType\:QCPColorScale}
{\xe \v QCPColorScale\:mDataScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::ScaleType} QCPColorScale::mDataScaleType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mGradient\:QCPColorScale}
{\xe \v QCPColorScale\:mGradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorGradient} QCPColorScale::mGradient{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mType\:QCPColorScale}
{\xe \v QCPColorScale\:mType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::AxisType} QCPColorScale::mType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPColorScaleAxisRectPrivate Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate}
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPColorScaleAxisRectPrivate:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_color_scale_axis_rect_private__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPColorScaleAxisRectPrivate:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_color_scale_axis_rect_private__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorScaleAxisRectPrivate} ({\b QCPColorScale} *parentColorScale)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateGradientImage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b axisSelectionChanged} (QCPAxis::SelectableParts selectedParts)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b axisSelectableChanged} (QCPAxis::SelectableParts selectableParts)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b calculateAutoMargin} ({\b QCP::MarginSide} side) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event, const QPointF &startPos) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b update} ({\b UpdatePhase} phase) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorScale} * {\b mParentColorScale}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QImage {\b mGradientImage}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mGradientImageInvalidated}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPColorScale}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPColorScaleAxisRectPrivate\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:QCPColorScaleAxisRectPrivate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorScaleAxisRectPrivate::QCPColorScaleAxisRectPrivate ({\b QCPColorScale} *  {\i parentColorScale}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new instance, as a child of {\i parentColorScale} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19750                                                                                           :\par
19751   QCPAxisRect(parentColorScale->parentPlot(), true),\par
19752   mParentColorScale(parentColorScale),\par
19753   mGradientImageInvalidated(true)\par
19754 \{\par
19755   setParentLayerable(parentColorScale);\par
19756   setMinimumMargins(QMargins(0, 0, 0, 0));\par
19757   QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atBottom << QCPAxis::atTop << QCPAxis::atLeft << QCPAxis::atRight;\par
19758   foreach (QCPAxis::AxisType type, allAxisTypes)\par
19759   \{\par
19760     axis(type)->setVisible(true);\par
19761     axis(type)->grid()->setVisible(false);\par
19762     axis(type)->setPadding(0);\par
19763     connect(axis(type), SIGNAL(selectionChanged(QCPAxis::SelectableParts)), this, SLOT(axisSelectionChanged(QCPAxis::SelectableParts)));\par
19764     connect(axis(type), SIGNAL(selectableChanged(QCPAxis::SelectableParts)), this, SLOT(axisSelectableChanged(QCPAxis::SelectableParts)));\par
19765   \}\par
19766 \par
19767   connect(axis(QCPAxis::atLeft), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atRight), SLOT(setRange(QCPRange)));\par
19768   connect(axis(QCPAxis::atRight), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atLeft), SLOT(setRange(QCPRange)));\par
19769   connect(axis(QCPAxis::atBottom), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atTop), SLOT(setRange(QCPRange)));\par
19770   connect(axis(QCPAxis::atTop), SIGNAL(rangeChanged(QCPRange)), axis(QCPAxis::atBottom), SLOT(setRange(QCPRange)));\par
19771   connect(axis(QCPAxis::atLeft), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atRight), SLOT(setScaleType(QCPAxis::ScaleType)));\par
19772   connect(axis(QCPAxis::atRight), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atLeft), SLOT(setScaleType(QCPAxis::ScaleType)));\par
19773   connect(axis(QCPAxis::atBottom), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atTop), SLOT(setScaleType(QCPAxis::ScaleType)));\par
19774   connect(axis(QCPAxis::atTop), SIGNAL(scaleTypeChanged(QCPAxis::ScaleType)), axis(QCPAxis::atBottom), SLOT(setScaleType(QCPAxis::ScaleType)));\par
19775   \par
19776   // make layer transfers of color scale transfer to axis rect and axes\par
19777   // the axes must be set after axis rect, such that they appear above color gradient drawn by axis rect:\par
19778   connect(parentColorScale, SIGNAL(layerChanged(QCPLayer*)), this, SLOT(setLayer(QCPLayer*)));\par
19779   foreach (QCPAxis::AxisType type, allAxisTypes)\par
19780     connect(parentColorScale, SIGNAL(layerChanged(QCPLayer*)), axis(type), SLOT(setLayer(QCPLayer*)));\par
19781 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v axisSelectableChanged\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:axisSelectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScaleAxisRectPrivate::axisSelectableChanged (QCPAxis::SelectableParts  {\i selectableParts}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19881 \{\par
19882   // synchronize axis base selectability:\par
19883   QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atBottom << QCPAxis::atTop << QCPAxis::atLeft << QCPAxis::atRight;\par
19884   foreach (QCPAxis::AxisType type, allAxisTypes)\par
19885   \{\par
19886     if (QCPAxis *senderAxis = qobject_cast<QCPAxis*>(sender()))\par
19887       if (senderAxis->axisType() == type)\par
19888         continue;\par
19889     \par
19890     if (axis(type)->selectableParts().testFlag(QCPAxis::spAxis))\par
19891     \{\par
19892       if (selectableParts.testFlag(QCPAxis::spAxis))\par
19893         axis(type)->setSelectableParts(axis(type)->selectableParts() | QCPAxis::spAxis);\par
19894       else\par
19895         axis(type)->setSelectableParts(axis(type)->selectableParts() & ~QCPAxis::spAxis);\par
19896     \}\par
19897   \}\par
19898 \}\par
}
}
{\xe \v axisSelectionChanged\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:axisSelectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScaleAxisRectPrivate::axisSelectionChanged (QCPAxis::SelectableParts  {\i selectedParts}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19856 \{\par
19857   // axis bases of four axes shall always (de-)selected synchronously:\par
19858   QList<QCPAxis::AxisType> allAxisTypes = QList<QCPAxis::AxisType>() << QCPAxis::atBottom << QCPAxis::atTop << QCPAxis::atLeft << QCPAxis::atRight;\par
19859   foreach (QCPAxis::AxisType type, allAxisTypes)\par
19860   \{\par
19861     if (QCPAxis *senderAxis = qobject_cast<QCPAxis*>(sender()))\par
19862       if (senderAxis->axisType() == type)\par
19863         continue;\par
19864     \par
19865     if (axis(type)->selectableParts().testFlag(QCPAxis::spAxis))\par
19866     \{\par
19867       if (selectedParts.testFlag(QCPAxis::spAxis))\par
19868         axis(type)->setSelectedParts(axis(type)->selectedParts() | QCPAxis::spAxis);\par
19869       else\par
19870         axis(type)->setSelectedParts(axis(type)->selectedParts() & ~QCPAxis::spAxis);\par
19871     \}\par
19872   \}\par
19873 \}\par
}
}
{\xe \v calculateAutoMargin\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:calculateAutoMargin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::calculateAutoMargin{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17720 \{\par
17721   if (!mAutoMargins.testFlag(side))\par
17722     qDebug() << Q_FUNC_INFO << "Called with side that isn't specified as auto margin";\par
17723   \par
17724   updateAxesOffset(QCPAxis::marginSideToAxisType(side));\par
17725   \par
17726   // note: only need to look at the last (outer most) axis to determine the total margin, due to updateAxisOffset call\par
17727   const QList<QCPAxis*> axesList = mAxes.value(QCPAxis::marginSideToAxisType(side));\par
17728   if (axesList.size() > 0)\par
17729     return axesList.last()->offset() + axesList.last()->calculateMargin();\par
17730   else\par
17731     return 0;\par
17732 \}\par
}
}
{\xe \v draw\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScaleAxisRectPrivate::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19791 \{\par
19792   if (mGradientImageInvalidated)\par
19793     updateGradientImage();\par
19794   \par
19795   bool mirrorHorz = false;\par
19796   bool mirrorVert = false;\par
19797   if (mParentColorScale->mColorAxis)\par
19798   \{\par
19799     mirrorHorz = mParentColorScale->mColorAxis.data()->rangeReversed() && (mParentColorScale->type() == QCPAxis::atBottom || mParentColorScale->type() == QCPAxis::atTop);\par
19800     mirrorVert = mParentColorScale->mColorAxis.data()->rangeReversed() && (mParentColorScale->type() == QCPAxis::atLeft || mParentColorScale->type() == QCPAxis::atRight);\par
19801   \}\par
19802   \par
19803   painter->drawImage(rect().adjusted(0, -1, 0, -1), mGradientImage.mirrored(mirrorHorz, mirrorVert));\par
19804   QCPAxisRect::draw(painter);\par
19805 \}\par
}
}
{\xe \v mouseMoveEvent\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::mouseMoveEvent{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17803 \{\par
17804   Q_UNUSED(startPos)\par
17805   // Mouse range dragging interaction:\par
17806   if (mDragging && mParentPlot->interactions().testFlag(QCP::iRangeDrag))\par
17807   \{\par
17808     \par
17809     if (mRangeDrag.testFlag(Qt::Horizontal))\par
17810     \{\par
17811       for (int i=0; i<mRangeDragHorzAxis.size(); ++i)\par
17812       \{\par
17813         QCPAxis *ax = mRangeDragHorzAxis.at(i).data();\par
17814         if (!ax)\par
17815           continue;\par
17816         if (i >= mDragStartHorzRange.size())\par
17817           break;\par
17818         if (ax->mScaleType == QCPAxis::stLinear)\par
17819         \{\par
17820           double diff = ax->pixelToCoord(startPos.x()) - ax->pixelToCoord(event->pos().x());\par
17821           ax->setRange(mDragStartHorzRange.at(i).lower+diff, mDragStartHorzRange.at(i).upper+diff);\par
17822         \} else if (ax->mScaleType == QCPAxis::stLogarithmic)\par
17823         \{\par
17824           double diff = ax->pixelToCoord(startPos.x()) / ax->pixelToCoord(event->pos().x());\par
17825           ax->setRange(mDragStartHorzRange.at(i).lower*diff, mDragStartHorzRange.at(i).upper*diff);\par
17826         \}\par
17827       \}\par
17828     \}\par
17829     \par
17830     if (mRangeDrag.testFlag(Qt::Vertical))\par
17831     \{\par
17832       for (int i=0; i<mRangeDragVertAxis.size(); ++i)\par
17833       \{\par
17834         QCPAxis *ax = mRangeDragVertAxis.at(i).data();\par
17835         if (!ax)\par
17836           continue;\par
17837         if (i >= mDragStartVertRange.size())\par
17838           break;\par
17839         if (ax->mScaleType == QCPAxis::stLinear)\par
17840         \{\par
17841           double diff = ax->pixelToCoord(startPos.y()) - ax->pixelToCoord(event->pos().y());\par
17842           ax->setRange(mDragStartVertRange.at(i).lower+diff, mDragStartVertRange.at(i).upper+diff);\par
17843         \} else if (ax->mScaleType == QCPAxis::stLogarithmic)\par
17844         \{\par
17845           double diff = ax->pixelToCoord(startPos.y()) / ax->pixelToCoord(event->pos().y());\par
17846           ax->setRange(mDragStartVertRange.at(i).lower*diff, mDragStartVertRange.at(i).upper*diff);\par
17847         \}\par
17848       \}\par
17849     \}\par
17850     \par
17851     if (mRangeDrag != 0) // if either vertical or horizontal drag was enabled, do a replot\par
17852     \{\par
17853       if (mParentPlot->noAntialiasingOnDrag())\par
17854         mParentPlot->setNotAntialiasedElements(QCP::aeAll);\par
17855       mParentPlot->replot(QCustomPlot::rpQueuedReplot);\par
17856     \}\par
17857     \par
17858   \}\par
17859 \}\par
}
}
{\xe \v mousePressEvent\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::mousePressEvent{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17771 \{\par
17772   Q_UNUSED(details)\par
17773   if (event->buttons() & Qt::LeftButton)\par
17774   \{\par
17775     mDragging = true;\par
17776     // initialize antialiasing backup in case we start dragging:\par
17777     if (mParentPlot->noAntialiasingOnDrag())\par
17778     \{\par
17779       mAADragBackup = mParentPlot->antialiasedElements();\par
17780       mNotAADragBackup = mParentPlot->notAntialiasedElements();\par
17781     \}\par
17782     // Mouse range dragging interaction:\par
17783     if (mParentPlot->interactions().testFlag(QCP::iRangeDrag))\par
17784     \{\par
17785       mDragStartHorzRange.clear();\par
17786       for (int i=0; i<mRangeDragHorzAxis.size(); ++i)\par
17787         mDragStartHorzRange.append(mRangeDragHorzAxis.at(i).isNull() ? QCPRange() : mRangeDragHorzAxis.at(i)->range());\par
17788       mDragStartVertRange.clear();\par
17789       for (int i=0; i<mRangeDragVertAxis.size(); ++i)\par
17790         mDragStartVertRange.append(mRangeDragVertAxis.at(i).isNull() ? QCPRange() : mRangeDragVertAxis.at(i)->range());\par
17791     \}\par
17792   \}\par
17793 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::mouseReleaseEvent{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17863 \{\par
17864   Q_UNUSED(event)\par
17865   Q_UNUSED(startPos)\par
17866   mDragging = false;\par
17867   if (mParentPlot->noAntialiasingOnDrag())\par
17868   \{\par
17869     mParentPlot->setAntialiasedElements(mAADragBackup);\par
17870     mParentPlot->setNotAntialiasedElements(mNotAADragBackup);\par
17871   \}\par
17872 \}\par
}
}
{\xe \v update\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::update{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is called automatically upon replot and doesn't need to be called by users of {\b QCPAxisRect}.\par
Calls the base class implementation to update the margins (see {\b QCPLayoutElement::update}), and finally passes the {\b rect} to the inset layout ({\b insetLayout}) and calls its QCPInsetLayout::update function.\par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17219 \{\par
17220   QCPLayoutElement::update(phase);\par
17221   \par
17222   switch (phase)\par
17223   \{\par
17224     case upPreparation:\par
17225     \{\par
17226       QList<QCPAxis*> allAxes = axes();\par
17227       for (int i=0; i<allAxes.size(); ++i)\par
17228         allAxes.at(i)->setupTickVectors();\par
17229       break;\par
17230     \}\par
17231     case upLayout:\par
17232     \{\par
17233       mInsetLayout->setOuterRect(rect());\par
17234       break;\par
17235     \}\par
17236     default: break;\par
17237   \}\par
17238   \par
17239   // pass update call on to inset layout (doesn't happen automatically, because QCPAxisRect doesn't derive from QCPLayout):\par
17240   mInsetLayout->update(phase);\par
17241 \}\par
}
}
{\xe \v updateGradientImage\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:updateGradientImage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorScaleAxisRectPrivate::updateGradientImage (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19813 \{\par
19814   if (rect().isEmpty())\par
19815     return;\par
19816   \par
19817   const QImage::Format format = QImage::Format_ARGB32_Premultiplied;\par
19818   int n = mParentColorScale->mGradient.levelCount();\par
19819   int w, h;\par
19820   QVector<double> data(n);\par
19821   for (int i=0; i<n; ++i)\par
19822     data[i] = i;\par
19823   if (mParentColorScale->mType == QCPAxis::atBottom || mParentColorScale->mType == QCPAxis::atTop)\par
19824   \{\par
19825     w = n;\par
19826     h = rect().height();\par
19827     mGradientImage = QImage(w, h, format);\par
19828     QVector<QRgb*> pixels;\par
19829     for (int y=0; y<h; ++y)\par
19830       pixels.append(reinterpret_cast<QRgb*>(mGradientImage.scanLine(y)));\par
19831     mParentColorScale->mGradient.colorize(data.constData(), QCPRange(0, n-1), pixels.first(), n);\par
19832     for (int y=1; y<h; ++y)\par
19833       memcpy(pixels.at(y), pixels.first(), n*sizeof(QRgb));\par
19834   \} else\par
19835   \{\par
19836     w = rect().width();\par
19837     h = n;\par
19838     mGradientImage = QImage(w, h, format);\par
19839     for (int y=0; y<h; ++y)\par
19840     \{\par
19841       QRgb *pixels = reinterpret_cast<QRgb*>(mGradientImage.scanLine(y));\par
19842       const QRgb lineColor = mParentColorScale->mGradient.color(data[h-1-y], QCPRange(0, n-1));\par
19843       for (int x=0; x<w; ++x)\par
19844         pixels[x] = lineColor;\par
19845     \}\par
19846   \}\par
19847   mGradientImageInvalidated = false;\par
19848 \}\par
}
}
{\xe \v wheelEvent\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::wheelEvent{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17889 \{\par
17890   // Mouse range zooming interaction:\par
17891   if (mParentPlot->interactions().testFlag(QCP::iRangeZoom))\par
17892   \{\par
17893     if (mRangeZoom != 0)\par
17894     \{\par
17895       double factor;\par
17896       double wheelSteps = event->delta()/120.0; // a single step delta is +/-120 usually\par
17897       if (mRangeZoom.testFlag(Qt::Horizontal))\par
17898       \{\par
17899         factor = qPow(mRangeZoomFactorHorz, wheelSteps);\par
17900         for (int i=0; i<mRangeZoomHorzAxis.size(); ++i)\par
17901         \{\par
17902           if (!mRangeZoomHorzAxis.at(i).isNull())\par
17903             mRangeZoomHorzAxis.at(i)->scaleRange(factor, mRangeZoomHorzAxis.at(i)->pixelToCoord(event->pos().x()));\par
17904         \}\par
17905       \}\par
17906       if (mRangeZoom.testFlag(Qt::Vertical))\par
17907       \{\par
17908         factor = qPow(mRangeZoomFactorVert, wheelSteps);\par
17909         for (int i=0; i<mRangeZoomVertAxis.size(); ++i)\par
17910         \{\par
17911           if (!mRangeZoomVertAxis.at(i).isNull())\par
17912             mRangeZoomVertAxis.at(i)->scaleRange(factor, mRangeZoomVertAxis.at(i)->pixelToCoord(event->pos().y()));\par
17913         \}\par
17914       \}\par
17915       mParentPlot->replot();\par
17916     \}\par
17917   \}\par
17918 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPColorScale\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:QCPColorScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPColorScale}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mGradientImage\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:mGradientImage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QImage QCPColorScaleAxisRectPrivate::mGradientImage{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mGradientImageInvalidated\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:mGradientImageInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorScaleAxisRectPrivate::mGradientImageInvalidated{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentColorScale\:QCPColorScaleAxisRectPrivate}
{\xe \v QCPColorScaleAxisRectPrivate\:mParentColorScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorScale}* QCPColorScaleAxisRectPrivate::mParentColorScale{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPCurve Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPCurve}
{\xe \v QCPCurve}
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a parametric curve in a plot. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPCurve:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_curve__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPCurve:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_curve__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LineStyle} \{ {\b lsNone}, 
{\b lsLine}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPCurve} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPCurve} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPCurveDataContainer} > {\b data} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b scatterStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b scatterSkip} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LineStyle} {\b lineStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (QSharedPointer< {\b QCPCurveDataContainer} > {\b data})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (const QVector< double > &t, const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (const QVector< double > &keys, const QVector< double > &values)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScatterStyle} (const {\b QCPScatterStyle} &style)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScatterSkip} (int skip)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLineStyle} ({\b LineStyle} style)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (const QVector< double > &t, const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (const QVector< double > &keys, const QVector< double > &values)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (double t, double key, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (double key, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawCurveLine} ({\b QCPPainter} *painter, const QVector< QPointF > &lines) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawScatterPlot} ({\b QCPPainter} *painter, const QVector< QPointF > &points, const {\b QCPScatterStyle} &style) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getCurveLines} (QVector< QPointF > *lines, const {\b QCPDataRange} &dataRange, double penWidth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getScatters} (QVector< QPointF > *scatters, const {\b QCPDataRange} &dataRange, double scatterWidth) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getRegion} (double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointF {\b getOptimizedPoint} (int prevRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b getOptimizedCornerPoints} (int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mayTraverse} (int prevRegion, int currentRegion) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTraverse} (double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin, QPointF &crossA, QPointF &crossB) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getTraverseCornerPoints} (int prevRegion, int currentRegion, double keyMin, double valueMax, double keyMax, double valueMin, QVector< QPointF > &beforeTraverse, QVector< QPointF > &afterTraverse) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b pointDistance} (const QPointF &pixelPoint, {\b QCPCurveDataContainer::const_iterator} &closestData) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b mScatterStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mScatterSkip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LineStyle} {\b mLineStyle}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a parametric curve in a plot. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
Unlike {\b QCPGraph}, plottables of this type may have multiple points with the same key coordinate, so their visual representation can have {\i loops} . This is realized by introducing a third coordinate {\i t} , which defines the order of the points described by the other two coordinates {\i x}  and {\i y} .\par
To plot data, assign it with the {\b setData} or {\b addData} functions. Alternatively, you can also access and modify the curve's data via the {\b data} method, which returns a pointer to the internal {\b QCPCurveDataContainer}.\par
Gaps in the curve can be created by adding data points with NaN as key and value ({\f2 qQNaN()}  or {\f2 std::numeric_limits<double>::quiet_NaN()} ) in between the two data points that shall be separated.\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Changing the appearance
\par}
{\tc\tcl2 \v Changing the appearance}
The appearance of the curve is determined by the pen and the brush ({\b setPen}, {\b setBrush}).\par}
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
Like all data representing objects in {\b QCustomPlot}, the {\b QCPCurve} is a plottable ({\b QCPAbstractPlottable}). So the plottable-interface of {\b QCustomPlot} applies ({\b QCustomPlot::plottable}, {\b QCustomPlot::removePlottable}, etc.)\par
Usually, you first create an instance: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }which registers it with the {\b QCustomPlot} instance of the passed axes. Note that this {\b QCustomPlot} instance takes ownership of the plottable, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. The newly created plottable can be modified, e.g.: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v LineStyle\:QCPCurve}
{\xe \v QCPCurve\:LineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPCurve::LineStyle}}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines how the curve's line is represented visually in the plot. The line is drawn with the current pen of the curve ({\b setPen}). \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLineStyle} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v lsNone\:QCPCurve}
{\xe \v QCPCurve\:lsNone}
{\qr lsNone{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No line is drawn between data points (e.g. only scatters) \par
}\cell }{\row }
{\xe \v lsLine\:QCPCurve}
{\xe \v QCPCurve\:lsLine}
{\qr lsLine{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data points are connected with a straight line. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5306                  \{ lsNone  \par
 5307                    ,lsLine \par
 5308                  \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPCurve\:QCPCurve}
{\xe \v QCPCurve\:QCPCurve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPCurve::QCPCurve ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a curve which uses {\i keyAxis}  as its key axis ("x") and {\i valueAxis}  as its value axis ("y"). {\i keyAxis}  and {\i valueAxis}  must reside in the same {\b QCustomPlot} instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.\par
The created {\b QCPCurve} is automatically registered with the {\b QCustomPlot} instance inferred from {\i keyAxis} . This {\b QCustomPlot} instance takes ownership of the {\b QCPCurve}, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21808                                                        :\par
21809   QCPAbstractPlottable1D<QCPCurveData>(keyAxis, valueAxis)\par
21810 \{\par
21811   // modify inherited properties from abstract plottable:\par
21812   setPen(QPen(Qt::blue, 0));\par
21813   setBrush(Qt::NoBrush);\par
21814   \par
21815   setScatterStyle(QCPScatterStyle());\par
21816   setLineStyle(lsLine);\par
21817   setScatterSkip(0);\par
21818 \}\par
}
}
{\xe \v ~QCPCurve\:QCPCurve}
{\xe \v QCPCurve\:~QCPCurve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPCurve::~QCPCurve (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21821 \{\par
21822 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addData\:QCPCurve}
{\xe \v QCPCurve\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::addData (const QVector< double > &  {\i t}, const QVector< double > &  {\i keys}, const QVector< double > &  {\i values}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided points in {\i t} , {\i keys}  and {\i values}  to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21932 \{\par
21933   if (t.size() != keys.size() || t.size() != values.size())\par
21934     qDebug() << Q_FUNC_INFO << "ts, keys and values have different sizes:" << t.size() << keys.size() << values.size();\par
21935   const int n = qMin(qMin(t.size(), keys.size()), values.size());\par
21936   QVector<QCPCurveData> tempData(n);\par
21937   QVector<QCPCurveData>::iterator it = tempData.begin();\par
21938   const QVector<QCPCurveData>::iterator itEnd = tempData.end();\par
21939   int i = 0;\par
21940   while (it != itEnd)\par
21941   \{\par
21942     it->t = t[i];\par
21943     it->key = keys[i];\par
21944     it->value = values[i];\par
21945     ++it;\par
21946     ++i;\par
21947   \}\par
21948   mDataContainer->add(tempData, alreadySorted); // don't modify tempData beyond this to prevent copy on write\par
21949 \}\par
}
}
{\xe \v addData\:QCPCurve}
{\xe \v QCPCurve\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::addData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i values})}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided points in {\i keys}  and {\i values}  to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
The t parameter of each data point will be set to the integer index of the respective key/value pair.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21964 \{\par
21965   if (keys.size() != values.size())\par
21966     qDebug() << Q_FUNC_INFO << "keys and values have different sizes:" << keys.size() << values.size();\par
21967   const int n = qMin(keys.size(), values.size());\par
21968   double tStart;\par
21969   if (!mDataContainer->isEmpty())\par
21970     tStart = (mDataContainer->constEnd()-1)->t + 1.0;\par
21971   else\par
21972     tStart = 0;\par
21973   QVector<QCPCurveData> tempData(n);\par
21974   QVector<QCPCurveData>::iterator it = tempData.begin();\par
21975   const QVector<QCPCurveData>::iterator itEnd = tempData.end();\par
21976   int i = 0;\par
21977   while (it != itEnd)\par
21978   \{\par
21979     it->t = tStart + i;\par
21980     it->key = keys[i];\par
21981     it->value = values[i];\par
21982     ++it;\par
21983     ++i;\par
21984   \}\par
21985   mDataContainer->add(tempData, true); // don't modify tempData beyond this to prevent copy on write\par
21986 \}\par
}
}
{\xe \v addData\:QCPCurve}
{\xe \v QCPCurve\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::addData (double  {\i t}, double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Adds the provided data point as {\i t} , {\i key}  and {\i value}  to the current data.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21995 \{\par
21996   mDataContainer->add(QCPCurveData(t, key, value));\par
21997 \}\par
}
}
{\xe \v addData\:QCPCurve}
{\xe \v QCPCurve\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::addData (double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided data point as {\i key}  and {\i value}  to the current data.\par
The t parameter is generated automatically by increments of 1 for each point, starting at the highest t of previously existing data or 0, if the curve data is empty.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22010 \{\par
22011   if (!mDataContainer->isEmpty())\par
22012     mDataContainer->add(QCPCurveData((mDataContainer->constEnd()-1)->t + 1.0, key, value));\par
22013   else\par
22014     mDataContainer->add(QCPCurveData(0.0, key, value));\par
22015 \}\par
}
}
{\xe \v data\:QCPCurve}
{\xe \v QCPCurve\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer< {\b QCPCurveDataContainer} > QCPCurve::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a shared pointer to the internal data storage of type {\b QCPCurveDataContainer}. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular {\b setData} or {\b addData} methods. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5315 \{ return mDataContainer; \}\par
}
}
{\xe \v draw\:QCPCurve}
{\xe \v QCPCurve\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22053 \{\par
22054   if (mDataContainer->isEmpty()) return;\par
22055   \par
22056   // allocate line vector:\par
22057   QVector<QPointF> lines, scatters;\par
22058   \par
22059   // loop over and draw segments of unselected/selected data:\par
22060   QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;\par
22061   getDataSegments(selectedSegments, unselectedSegments);\par
22062   allSegments << unselectedSegments << selectedSegments;\par
22063   for (int i=0; i<allSegments.size(); ++i)\par
22064   \{\par
22065     bool isSelectedSegment = i >= unselectedSegments.size();\par
22066     \par
22067     // fill with curve data:\par
22068     QPen finalCurvePen = mPen; // determine the final pen already here, because the line optimization depends on its stroke width\par
22069     if (isSelectedSegment && mSelectionDecorator)\par
22070       finalCurvePen = mSelectionDecorator->pen();\par
22071     \par
22072     QCPDataRange lineDataRange = isSelectedSegment ? allSegments.at(i) : allSegments.at(i).adjusted(-1, 1); // unselected segments extend lines to bordering selected data point (safe to exceed total data bounds in first/last segment, getCurveLines takes care)\par
22073     getCurveLines(&lines, lineDataRange, finalCurvePen.widthF());\par
22074     \par
22075     // check data validity if flag set:\par
22076   #ifdef QCUSTOMPLOT_CHECK_DATA\par
22077     for (QCPCurveDataContainer::const_iterator it = mDataContainer->constBegin(); it != mDataContainer->constEnd(); ++it)\par
22078     \{\par
22079       if (QCP::isInvalidData(it->t) ||\par
22080           QCP::isInvalidData(it->key, it->value))\par
22081         qDebug() << Q_FUNC_INFO << "Data point at" << it->key << "invalid." << "Plottable name:" << name();\par
22082     \}\par
22083   #endif\par
22084     \par
22085     // draw curve fill:\par
22086     applyFillAntialiasingHint(painter);\par
22087     if (isSelectedSegment && mSelectionDecorator)\par
22088       mSelectionDecorator->applyBrush(painter);\par
22089     else\par
22090       painter->setBrush(mBrush);\par
22091     painter->setPen(Qt::NoPen);\par
22092     if (painter->brush().style() != Qt::NoBrush && painter->brush().color().alpha() != 0)\par
22093       painter->drawPolygon(QPolygonF(lines));\par
22094     \par
22095     // draw curve line:\par
22096     if (mLineStyle != lsNone)\par
22097     \{\par
22098       painter->setPen(finalCurvePen);\par
22099       painter->setBrush(Qt::NoBrush);\par
22100       drawCurveLine(painter, lines);\par
22101     \}\par
22102     \par
22103     // draw scatters:\par
22104     QCPScatterStyle finalScatterStyle = mScatterStyle;\par
22105     if (isSelectedSegment && mSelectionDecorator)\par
22106       finalScatterStyle = mSelectionDecorator->getFinalScatterStyle(mScatterStyle);\par
22107     if (!finalScatterStyle.isNone())\par
22108     \{\par
22109       getScatters(&scatters, allSegments.at(i), finalScatterStyle.size());\par
22110       drawScatterPlot(painter, scatters, finalScatterStyle);\par
22111     \}\par
22112   \}\par
22113   \par
22114   // draw other selection decoration that isn't just line/scatter pens and brushes:\par
22115   if (mSelectionDecorator)\par
22116     mSelectionDecorator->drawDecoration(painter, selection());\par
22117 \}\par
}
}
{\xe \v drawCurveLine\:QCPCurve}
{\xe \v QCPCurve\:drawCurveLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::drawCurveLine ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i lines}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22161 \{\par
22162   if (painter->pen().style() != Qt::NoPen && painter->pen().color().alpha() != 0)\par
22163   \{\par
22164     applyDefaultAntialiasingHint(painter);\par
22165     drawPolyline(painter, lines);\par
22166   \}\par
22167 \}\par
}
}
{\xe \v drawLegendIcon\:QCPCurve}
{\xe \v QCPCurve\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22121 \{\par
22122   // draw fill:\par
22123   if (mBrush.style() != Qt::NoBrush)\par
22124   \{\par
22125     applyFillAntialiasingHint(painter);\par
22126     painter->fillRect(QRectF(rect.left(), rect.top()+rect.height()/2.0, rect.width(), rect.height()/3.0), mBrush);\par
22127   \}\par
22128   // draw line vertically centered:\par
22129   if (mLineStyle != lsNone)\par
22130   \{\par
22131     applyDefaultAntialiasingHint(painter);\par
22132     painter->setPen(mPen);\par
22133     painter->drawLine(QLineF(rect.left(), rect.top()+rect.height()/2.0, rect.right()+5, rect.top()+rect.height()/2.0)); // +5 on x2 else last segment is missing from dashed/dotted pens\par
22134   \}\par
22135   // draw scatter symbol:\par
22136   if (!mScatterStyle.isNone())\par
22137   \{\par
22138     applyScattersAntialiasingHint(painter);\par
22139     // scale scatter pixmap if it's too large to fit in legend icon rect:\par
22140     if (mScatterStyle.shape() == QCPScatterStyle::ssPixmap && (mScatterStyle.pixmap().size().width() > rect.width() || mScatterStyle.pixmap().size().height() > rect.height()))\par
22141     \{\par
22142       QCPScatterStyle scaledStyle(mScatterStyle);\par
22143       scaledStyle.setPixmap(scaledStyle.pixmap().scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::SmoothTransformation));\par
22144       scaledStyle.applyTo(painter, mPen);\par
22145       scaledStyle.drawShape(painter, QRectF(rect).center());\par
22146     \} else\par
22147     \{\par
22148       mScatterStyle.applyTo(painter, mPen);\par
22149       mScatterStyle.drawShape(painter, QRectF(rect).center());\par
22150     \}\par
22151   \}\par
22152 \}\par
}
}
{\xe \v drawScatterPlot\:QCPCurve}
{\xe \v QCPCurve\:drawScatterPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::drawScatterPlot ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i points}, const {\b QCPScatterStyle} &  {\i style}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22177 \{\par
22178   // draw scatter point symbols:\par
22179   applyScattersAntialiasingHint(painter);\par
22180   style.applyTo(painter, mPen);\par
22181   for (int i=0; i<points.size(); ++i)\par
22182     if (!qIsNaN(points.at(i).x()) && !qIsNaN(points.at(i).y()))\par
22183       style.drawShape(painter,  points.at(i));\par
22184 \}\par
}
}
{\xe \v getCurveLines\:QCPCurve}
{\xe \v QCPCurve\:getCurveLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::getCurveLines (QVector< QPointF > *  {\i lines}, const {\b QCPDataRange} &  {\i dataRange}, double  {\i penWidth}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22215 \{\par
22216   if (!lines) return;\par
22217   lines->clear();\par
22218   QCPAxis *keyAxis = mKeyAxis.data();\par
22219   QCPAxis *valueAxis = mValueAxis.data();\par
22220   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
22221   \par
22222   // add margins to rect to compensate for stroke width\par
22223   const double strokeMargin = qMax(qreal(1.0), qreal(penWidth*0.75)); // stroke radius + 50% safety\par
22224   const double keyMin = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyAxis->range().lower)-strokeMargin*keyAxis->pixelOrientation());\par
22225   const double keyMax = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyAxis->range().upper)+strokeMargin*keyAxis->pixelOrientation());\par
22226   const double valueMin = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueAxis->range().lower)-strokeMargin*valueAxis->pixelOrientation());\par
22227   const double valueMax = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueAxis->range().upper)+strokeMargin*valueAxis->pixelOrientation());\par
22228   QCPCurveDataContainer::const_iterator itBegin = mDataContainer->constBegin();\par
22229   QCPCurveDataContainer::const_iterator itEnd = mDataContainer->constEnd();\par
22230   mDataContainer->limitIteratorsToDataRange(itBegin, itEnd, dataRange);\par
22231   if (itBegin == itEnd)\par
22232     return;\par
22233   QCPCurveDataContainer::const_iterator it = itBegin;\par
22234   QCPCurveDataContainer::const_iterator prevIt = itEnd-1;\par
22235   int prevRegion = getRegion(prevIt->key, prevIt->value, keyMin, valueMax, keyMax, valueMin);\par
22236   QVector<QPointF> trailingPoints; // points that must be applied after all other points (are generated only when handling first point to get virtual segment between last and first point right)\par
22237   while (it != itEnd)\par
22238   \{\par
22239     const int currentRegion = getRegion(it->key, it->value, keyMin, valueMax, keyMax, valueMin);\par
22240     if (currentRegion != prevRegion) // changed region, possibly need to add some optimized edge points or original points if entering R\par
22241     \{\par
22242       if (currentRegion != 5) // segment doesn't end in R, so it's a candidate for removal\par
22243       \{\par
22244         QPointF crossA, crossB;\par
22245         if (prevRegion == 5) // we're coming from R, so add this point optimized\par
22246         \{\par
22247           lines->append(getOptimizedPoint(currentRegion, it->key, it->value, prevIt->key, prevIt->value, keyMin, valueMax, keyMax, valueMin));\par
22248           // in the situations 5->1/7/9/3 the segment may leave R and directly cross through two outer regions. In these cases we need to add an additional corner point\par
22249           *lines << getOptimizedCornerPoints(prevRegion, currentRegion, prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin);\par
22250         \} else if (mayTraverse(prevRegion, currentRegion) &&\par
22251                    getTraverse(prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin, crossA, crossB))\par
22252         \{\par
22253           // add the two cross points optimized if segment crosses R and if segment isn't virtual zeroth segment between last and first curve point:\par
22254           QVector<QPointF> beforeTraverseCornerPoints, afterTraverseCornerPoints;\par
22255           getTraverseCornerPoints(prevRegion, currentRegion, keyMin, valueMax, keyMax, valueMin, beforeTraverseCornerPoints, afterTraverseCornerPoints);\par
22256           if (it != itBegin)\par
22257           \{\par
22258             *lines << beforeTraverseCornerPoints;\par
22259             lines->append(crossA);\par
22260             lines->append(crossB);\par
22261             *lines << afterTraverseCornerPoints;\par
22262           \} else\par
22263           \{\par
22264             lines->append(crossB);\par
22265             *lines << afterTraverseCornerPoints;\par
22266             trailingPoints << beforeTraverseCornerPoints << crossA ;\par
22267           \}\par
22268         \} else // doesn't cross R, line is just moving around in outside regions, so only need to add optimized point(s) at the boundary corner(s)\par
22269         \{\par
22270           *lines << getOptimizedCornerPoints(prevRegion, currentRegion, prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin);\par
22271         \}\par
22272       \} else // segment does end in R, so we add previous point optimized and this point at original position\par
22273       \{\par
22274         if (it == itBegin) // it is first point in curve and prevIt is last one. So save optimized point for adding it to the lineData in the end\par
22275           trailingPoints << getOptimizedPoint(prevRegion, prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin);\par
22276         else\par
22277           lines->append(getOptimizedPoint(prevRegion, prevIt->key, prevIt->value, it->key, it->value, keyMin, valueMax, keyMax, valueMin));\par
22278         lines->append(coordsToPixels(it->key, it->value));\par
22279       \}\par
22280     \} else // region didn't change\par
22281     \{\par
22282       if (currentRegion == 5) // still in R, keep adding original points\par
22283       \{\par
22284         lines->append(coordsToPixels(it->key, it->value));\par
22285       \} else // still outside R, no need to add anything\par
22286       \{\par
22287         // see how this is not doing anything? That's the main optimization...\par
22288       \}\par
22289     \}\par
22290     prevIt = it;\par
22291     prevRegion = currentRegion;\par
22292     ++it;\par
22293   \}\par
22294   *lines << trailingPoints;\par
22295 \}\par
}
}
{\xe \v getKeyRange\:QCPCurve}
{\xe \v QCPCurve\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPCurve::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22041 \{\par
22042   return mDataContainer->keyRange(foundRange, inSignDomain);\par
22043 \}\par
}
}
{\xe \v getOptimizedCornerPoints\:QCPCurve}
{\xe \v QCPCurve\:getOptimizedCornerPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPCurve::getOptimizedCornerPoints (int  {\i prevRegion}, int  {\i currentRegion}, double  {\i prevKey}, double  {\i prevValue}, double  {\i key}, double  {\i value}, double  {\i keyMin}, double  {\i valueMax}, double  {\i keyMax}, double  {\i valueMin}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22576 \{\par
22577   QVector<QPointF> result;\par
22578   switch (prevRegion)\par
22579   \{\par
22580     case 1:\par
22581     \{\par
22582       switch (currentRegion)\par
22583       \{\par
22584         case 2: \{ result << coordsToPixels(keyMin, valueMax); break; \}\par
22585         case 4: \{ result << coordsToPixels(keyMin, valueMax); break; \}\par
22586         case 3: \{ result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMin, valueMin); break; \}\par
22587         case 7: \{ result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMax, valueMax); break; \}\par
22588         case 6: \{ result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMin, valueMin); result.append(result.last()); break; \}\par
22589         case 8: \{ result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMax, valueMax); result.append(result.last()); break; \}\par
22590         case 9: \{ // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points\par
22591           if ((value-prevValue)/(key-prevKey)*(keyMin-key)+value < valueMin) // segment passes below R\par
22592           \{ result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMin, valueMin); result.append(result.last()); result << coordsToPixels(keyMax, valueMin); \}\par
22593           else\par
22594           \{ result << coordsToPixels(keyMin, valueMax) << coordsToPixels(keyMax, valueMax); result.append(result.last()); result << coordsToPixels(keyMax, valueMin); \}\par
22595           break;\par
22596         \}\par
22597       \}\par
22598       break;\par
22599     \}\par
22600     case 2:\par
22601     \{\par
22602       switch (currentRegion)\par
22603       \{\par
22604         case 1: \{ result << coordsToPixels(keyMin, valueMax); break; \}\par
22605         case 3: \{ result << coordsToPixels(keyMin, valueMin); break; \}\par
22606         case 4: \{ result << coordsToPixels(keyMin, valueMax); result.append(result.last()); break; \}\par
22607         case 6: \{ result << coordsToPixels(keyMin, valueMin); result.append(result.last()); break; \}\par
22608         case 7: \{ result << coordsToPixels(keyMin, valueMax); result.append(result.last()); result << coordsToPixels(keyMax, valueMax); break; \}\par
22609         case 9: \{ result << coordsToPixels(keyMin, valueMin); result.append(result.last()); result << coordsToPixels(keyMax, valueMin); break; \}\par
22610       \}\par
22611       break;\par
22612     \}\par
22613     case 3:\par
22614     \{\par
22615       switch (currentRegion)\par
22616       \{\par
22617         case 2: \{ result << coordsToPixels(keyMin, valueMin); break; \}\par
22618         case 6: \{ result << coordsToPixels(keyMin, valueMin); break; \}\par
22619         case 1: \{ result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMin, valueMax); break; \}\par
22620         case 9: \{ result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMax, valueMin); break; \}\par
22621         case 4: \{ result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMin, valueMax); result.append(result.last()); break; \}\par
22622         case 8: \{ result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMax, valueMin); result.append(result.last()); break; \}\par
22623         case 7: \{ // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points\par
22624           if ((value-prevValue)/(key-prevKey)*(keyMax-key)+value < valueMin) // segment passes below R\par
22625           \{ result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMax, valueMin); result.append(result.last()); result << coordsToPixels(keyMax, valueMax); \}\par
22626           else\par
22627           \{ result << coordsToPixels(keyMin, valueMin) << coordsToPixels(keyMin, valueMax); result.append(result.last()); result << coordsToPixels(keyMax, valueMax); \}\par
22628           break;\par
22629         \}\par
22630       \}\par
22631       break;\par
22632     \}\par
22633     case 4:\par
22634     \{\par
22635       switch (currentRegion)\par
22636       \{\par
22637         case 1: \{ result << coordsToPixels(keyMin, valueMax); break; \}\par
22638         case 7: \{ result << coordsToPixels(keyMax, valueMax); break; \}\par
22639         case 2: \{ result << coordsToPixels(keyMin, valueMax); result.append(result.last()); break; \}\par
22640         case 8: \{ result << coordsToPixels(keyMax, valueMax); result.append(result.last()); break; \}\par
22641         case 3: \{ result << coordsToPixels(keyMin, valueMax); result.append(result.last()); result << coordsToPixels(keyMin, valueMin); break; \}\par
22642         case 9: \{ result << coordsToPixels(keyMax, valueMax); result.append(result.last()); result << coordsToPixels(keyMax, valueMin); break; \}\par
22643       \}\par
22644       break;\par
22645     \}\par
22646     case 5:\par
22647     \{\par
22648       switch (currentRegion)\par
22649       \{\par
22650         case 1: \{ result << coordsToPixels(keyMin, valueMax); break; \}\par
22651         case 7: \{ result << coordsToPixels(keyMax, valueMax); break; \}\par
22652         case 9: \{ result << coordsToPixels(keyMax, valueMin); break; \}\par
22653         case 3: \{ result << coordsToPixels(keyMin, valueMin); break; \}\par
22654       \}\par
22655       break;\par
22656     \}\par
22657     case 6:\par
22658     \{\par
22659       switch (currentRegion)\par
22660       \{\par
22661         case 3: \{ result << coordsToPixels(keyMin, valueMin); break; \}\par
22662         case 9: \{ result << coordsToPixels(keyMax, valueMin); break; \}\par
22663         case 2: \{ result << coordsToPixels(keyMin, valueMin); result.append(result.last()); break; \}\par
22664         case 8: \{ result << coordsToPixels(keyMax, valueMin); result.append(result.last()); break; \}\par
22665         case 1: \{ result << coordsToPixels(keyMin, valueMin); result.append(result.last()); result << coordsToPixels(keyMin, valueMax); break; \}\par
22666         case 7: \{ result << coordsToPixels(keyMax, valueMin); result.append(result.last()); result << coordsToPixels(keyMax, valueMax); break; \}\par
22667       \}\par
22668       break;\par
22669     \}\par
22670     case 7:\par
22671     \{\par
22672       switch (currentRegion)\par
22673       \{\par
22674         case 4: \{ result << coordsToPixels(keyMax, valueMax); break; \}\par
22675         case 8: \{ result << coordsToPixels(keyMax, valueMax); break; \}\par
22676         case 1: \{ result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMin, valueMax); break; \}\par
22677         case 9: \{ result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMax, valueMin); break; \}\par
22678         case 2: \{ result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMin, valueMax); result.append(result.last()); break; \}\par
22679         case 6: \{ result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMax, valueMin); result.append(result.last()); break; \}\par
22680         case 3: \{ // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points\par
22681           if ((value-prevValue)/(key-prevKey)*(keyMax-key)+value < valueMin) // segment passes below R\par
22682           \{ result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMax, valueMin); result.append(result.last()); result << coordsToPixels(keyMin, valueMin); \}\par
22683           else\par
22684           \{ result << coordsToPixels(keyMax, valueMax) << coordsToPixels(keyMin, valueMax); result.append(result.last()); result << coordsToPixels(keyMin, valueMin); \}\par
22685           break;\par
22686         \}\par
22687       \}\par
22688       break;\par
22689     \}\par
22690     case 8:\par
22691     \{\par
22692       switch (currentRegion)\par
22693       \{\par
22694         case 7: \{ result << coordsToPixels(keyMax, valueMax); break; \}\par
22695         case 9: \{ result << coordsToPixels(keyMax, valueMin); break; \}\par
22696         case 4: \{ result << coordsToPixels(keyMax, valueMax); result.append(result.last()); break; \}\par
22697         case 6: \{ result << coordsToPixels(keyMax, valueMin); result.append(result.last()); break; \}\par
22698         case 1: \{ result << coordsToPixels(keyMax, valueMax); result.append(result.last()); result << coordsToPixels(keyMin, valueMax); break; \}\par
22699         case 3: \{ result << coordsToPixels(keyMax, valueMin); result.append(result.last()); result << coordsToPixels(keyMin, valueMin); break; \}\par
22700       \}\par
22701       break;\par
22702     \}\par
22703     case 9:\par
22704     \{\par
22705       switch (currentRegion)\par
22706       \{\par
22707         case 6: \{ result << coordsToPixels(keyMax, valueMin); break; \}\par
22708         case 8: \{ result << coordsToPixels(keyMax, valueMin); break; \}\par
22709         case 3: \{ result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMin, valueMin); break; \}\par
22710         case 7: \{ result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMax, valueMax); break; \}\par
22711         case 2: \{ result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMin, valueMin); result.append(result.last()); break; \}\par
22712         case 4: \{ result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMax, valueMax); result.append(result.last()); break; \}\par
22713         case 1: \{ // in this case we need another distinction of cases: segment may pass below or above rect, requiring either bottom right or top left corner points\par
22714           if ((value-prevValue)/(key-prevKey)*(keyMin-key)+value < valueMin) // segment passes below R\par
22715           \{ result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMin, valueMin); result.append(result.last()); result << coordsToPixels(keyMin, valueMax); \}\par
22716           else\par
22717           \{ result << coordsToPixels(keyMax, valueMin) << coordsToPixels(keyMax, valueMax); result.append(result.last()); result << coordsToPixels(keyMin, valueMax); \}\par
22718           break;\par
22719         \}\par
22720       \}\par
22721       break;\par
22722     \}\par
22723   \}\par
22724   return result;\par
22725 \}\par
}
}
{\xe \v getOptimizedPoint\:QCPCurve}
{\xe \v QCPCurve\:getOptimizedPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPCurve::getOptimizedPoint (int  {\i prevRegion}, double  {\i prevKey}, double  {\i prevValue}, double  {\i key}, double  {\i value}, double  {\i keyMin}, double  {\i valueMax}, double  {\i keyMax}, double  {\i valueMin}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22460 \{\par
22461   // The intersection point interpolation here is done in pixel coordinates, so we don't need to\par
22462   // differentiate between different axis scale types. Note that the nomenclature\par
22463   // top/left/bottom/right/min/max is with respect to the rect in plot coordinates, wich may be\par
22464   // different in pixel coordinates (horz/vert key axes, reversed ranges)\par
22465   \par
22466   const double keyMinPx = mKeyAxis->coordToPixel(keyMin);\par
22467   const double keyMaxPx = mKeyAxis->coordToPixel(keyMax);\par
22468   const double valueMinPx = mValueAxis->coordToPixel(valueMin);\par
22469   const double valueMaxPx = mValueAxis->coordToPixel(valueMax);\par
22470   const double otherValuePx = mValueAxis->coordToPixel(otherValue);\par
22471   const double valuePx = mValueAxis->coordToPixel(value);\par
22472   const double otherKeyPx = mKeyAxis->coordToPixel(otherKey);\par
22473   const double keyPx = mKeyAxis->coordToPixel(key);\par
22474   double intersectKeyPx = keyMinPx; // initial key just a fail-safe\par
22475   double intersectValuePx = valueMinPx; // initial value just a fail-safe\par
22476   switch (otherRegion)\par
22477   \{\par
22478     case 1: // top and left edge\par
22479     \{\par
22480       intersectValuePx = valueMaxPx;\par
22481       intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);\par
22482       if (intersectKeyPx < qMin(keyMinPx, keyMaxPx) || intersectKeyPx > qMax(keyMinPx, keyMaxPx)) // check whether top edge is not intersected, then it must be left edge (qMin/qMax necessary since axes may be reversed)\par
22483       \{\par
22484         intersectKeyPx = keyMinPx;\par
22485         intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);\par
22486       \}\par
22487       break;\par
22488     \}\par
22489     case 2: // left edge\par
22490     \{\par
22491       intersectKeyPx = keyMinPx;\par
22492       intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);\par
22493       break;\par
22494     \}\par
22495     case 3: // bottom and left edge\par
22496     \{\par
22497       intersectValuePx = valueMinPx;\par
22498       intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);\par
22499       if (intersectKeyPx < qMin(keyMinPx, keyMaxPx) || intersectKeyPx > qMax(keyMinPx, keyMaxPx)) // check whether bottom edge is not intersected, then it must be left edge (qMin/qMax necessary since axes may be reversed)\par
22500       \{\par
22501         intersectKeyPx = keyMinPx;\par
22502         intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);\par
22503       \}\par
22504       break;\par
22505     \}\par
22506     case 4: // top edge\par
22507     \{\par
22508       intersectValuePx = valueMaxPx;\par
22509       intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);\par
22510       break;\par
22511     \}\par
22512     case 5:\par
22513     \{\par
22514       break; // case 5 shouldn't happen for this function but we add it anyway to prevent potential discontinuity in branch table\par
22515     \}\par
22516     case 6: // bottom edge\par
22517     \{\par
22518       intersectValuePx = valueMinPx;\par
22519       intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);\par
22520       break;\par
22521     \}\par
22522     case 7: // top and right edge\par
22523     \{\par
22524       intersectValuePx = valueMaxPx;\par
22525       intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);\par
22526       if (intersectKeyPx < qMin(keyMinPx, keyMaxPx) || intersectKeyPx > qMax(keyMinPx, keyMaxPx)) // check whether top edge is not intersected, then it must be right edge (qMin/qMax necessary since axes may be reversed)\par
22527       \{\par
22528         intersectKeyPx = keyMaxPx;\par
22529         intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);\par
22530       \}\par
22531       break;\par
22532     \}\par
22533     case 8: // right edge\par
22534     \{\par
22535       intersectKeyPx = keyMaxPx;\par
22536       intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);\par
22537       break;\par
22538     \}\par
22539     case 9: // bottom and right edge\par
22540     \{\par
22541       intersectValuePx = valueMinPx;\par
22542       intersectKeyPx = otherKeyPx + (keyPx-otherKeyPx)/(valuePx-otherValuePx)*(intersectValuePx-otherValuePx);\par
22543       if (intersectKeyPx < qMin(keyMinPx, keyMaxPx) || intersectKeyPx > qMax(keyMinPx, keyMaxPx)) // check whether bottom edge is not intersected, then it must be right edge (qMin/qMax necessary since axes may be reversed)\par
22544       \{\par
22545         intersectKeyPx = keyMaxPx;\par
22546         intersectValuePx = otherValuePx + (valuePx-otherValuePx)/(keyPx-otherKeyPx)*(intersectKeyPx-otherKeyPx);\par
22547       \}\par
22548       break;\par
22549     \}\par
22550   \}\par
22551   if (mKeyAxis->orientation() == Qt::Horizontal)\par
22552     return QPointF(intersectKeyPx, intersectValuePx);\par
22553   else\par
22554     return QPointF(intersectValuePx, intersectKeyPx);\par
22555 \}\par
}
}
{\xe \v getRegion\:QCPCurve}
{\xe \v QCPCurve\:getRegion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPCurve::getRegion (double  {\i key}, double  {\i value}, double  {\i keyMin}, double  {\i valueMax}, double  {\i keyMax}, double  {\i valueMin}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22416 \{\par
22417   if (key < keyMin) // region 123\par
22418   \{\par
22419     if (value > valueMax)\par
22420       return 1;\par
22421     else if (value < valueMin)\par
22422       return 3;\par
22423     else\par
22424       return 2;\par
22425   \} else if (key > keyMax) // region 789\par
22426   \{\par
22427     if (value > valueMax)\par
22428       return 7;\par
22429     else if (value < valueMin)\par
22430       return 9;\par
22431     else\par
22432       return 8;\par
22433   \} else // region 456\par
22434   \{\par
22435     if (value > valueMax)\par
22436       return 4;\par
22437     else if (value < valueMin)\par
22438       return 6;\par
22439     else\par
22440       return 5;\par
22441   \}\par
22442 \}\par
}
}
{\xe \v getScatters\:QCPCurve}
{\xe \v QCPCurve\:getScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::getScatters (QVector< QPointF > *  {\i scatters}, const {\b QCPDataRange} &  {\i dataRange}, double  {\i scatterWidth}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22318 \{\par
22319   if (!scatters) return;\par
22320   scatters->clear();\par
22321   QCPAxis *keyAxis = mKeyAxis.data();\par
22322   QCPAxis *valueAxis = mValueAxis.data();\par
22323   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
22324   \par
22325   QCPCurveDataContainer::const_iterator begin = mDataContainer->constBegin();\par
22326   QCPCurveDataContainer::const_iterator end = mDataContainer->constEnd();\par
22327   mDataContainer->limitIteratorsToDataRange(begin, end, dataRange);\par
22328   if (begin == end)\par
22329     return;\par
22330   const int scatterModulo = mScatterSkip+1;\par
22331   const bool doScatterSkip = mScatterSkip > 0;\par
22332   int endIndex = end-mDataContainer->constBegin();\par
22333   \par
22334   QCPRange keyRange = keyAxis->range();\par
22335   QCPRange valueRange = valueAxis->range();\par
22336   // extend range to include width of scatter symbols:\par
22337   keyRange.lower = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyRange.lower)-scatterWidth*keyAxis->pixelOrientation());\par
22338   keyRange.upper = keyAxis->pixelToCoord(keyAxis->coordToPixel(keyRange.upper)+scatterWidth*keyAxis->pixelOrientation());\par
22339   valueRange.lower = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueRange.lower)-scatterWidth*valueAxis->pixelOrientation());\par
22340   valueRange.upper = valueAxis->pixelToCoord(valueAxis->coordToPixel(valueRange.upper)+scatterWidth*valueAxis->pixelOrientation());\par
22341   \par
22342   QCPCurveDataContainer::const_iterator it = begin;\par
22343   int itIndex = begin-mDataContainer->constBegin();\par
22344   while (doScatterSkip && it != end && itIndex % scatterModulo != 0) // advance begin iterator to first non-skipped scatter\par
22345   \{\par
22346     ++itIndex;\par
22347     ++it;\par
22348   \}\par
22349   if (keyAxis->orientation() == Qt::Vertical)\par
22350   \{\par
22351     while (it != end)\par
22352     \{\par
22353       if (!qIsNaN(it->value) && keyRange.contains(it->key) && valueRange.contains(it->value))\par
22354         scatters->append(QPointF(valueAxis->coordToPixel(it->value), keyAxis->coordToPixel(it->key)));\par
22355       \par
22356       // advance iterator to next (non-skipped) data point:\par
22357       if (!doScatterSkip)\par
22358         ++it;\par
22359       else\par
22360       \{\par
22361         itIndex += scatterModulo;\par
22362         if (itIndex < endIndex) // make sure we didn't jump over end\par
22363           it += scatterModulo;\par
22364         else\par
22365         \{\par
22366           it = end;\par
22367           itIndex = endIndex;\par
22368         \}\par
22369       \}\par
22370     \}\par
22371   \} else\par
22372   \{\par
22373     while (it != end)\par
22374     \{\par
22375       if (!qIsNaN(it->value) && keyRange.contains(it->key) && valueRange.contains(it->value))\par
22376         scatters->append(QPointF(keyAxis->coordToPixel(it->key), valueAxis->coordToPixel(it->value)));\par
22377       \par
22378       // advance iterator to next (non-skipped) data point:\par
22379       if (!doScatterSkip)\par
22380         ++it;\par
22381       else\par
22382       \{\par
22383         itIndex += scatterModulo;\par
22384         if (itIndex < endIndex) // make sure we didn't jump over end\par
22385           it += scatterModulo;\par
22386         else\par
22387         \{\par
22388           it = end;\par
22389           itIndex = endIndex;\par
22390         \}\par
22391       \}\par
22392     \}\par
22393   \}\par
22394 \}\par
}
}
{\xe \v getTraverse\:QCPCurve}
{\xe \v QCPCurve\:getTraverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPCurve::getTraverse (double  {\i prevKey}, double  {\i prevValue}, double  {\i key}, double  {\i value}, double  {\i keyMin}, double  {\i valueMax}, double  {\i keyMax}, double  {\i valueMin}, QPointF &  {\i crossA}, QPointF &  {\i crossB}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22843 \{\par
22844   // The intersection point interpolation here is done in pixel coordinates, so we don't need to\par
22845   // differentiate between different axis scale types. Note that the nomenclature\par
22846   // top/left/bottom/right/min/max is with respect to the rect in plot coordinates, wich may be\par
22847   // different in pixel coordinates (horz/vert key axes, reversed ranges)\par
22848   \par
22849   QList<QPointF> intersections;\par
22850   const double valueMinPx = mValueAxis->coordToPixel(valueMin);\par
22851   const double valueMaxPx = mValueAxis->coordToPixel(valueMax);\par
22852   const double keyMinPx = mKeyAxis->coordToPixel(keyMin);\par
22853   const double keyMaxPx = mKeyAxis->coordToPixel(keyMax);\par
22854   const double keyPx = mKeyAxis->coordToPixel(key);\par
22855   const double valuePx = mValueAxis->coordToPixel(value);\par
22856   const double prevKeyPx = mKeyAxis->coordToPixel(prevKey);\par
22857   const double prevValuePx = mValueAxis->coordToPixel(prevValue);\par
22858   if (qFuzzyIsNull(key-prevKey)) // line is parallel to value axis\par
22859   \{\par
22860     // due to region filter in mayTraverse(), if line is parallel to value or key axis, region 5 is traversed here\par
22861     intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyPx, valueMinPx) : QPointF(valueMinPx, keyPx)); // direction will be taken care of at end of method\par
22862     intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyPx, valueMaxPx) : QPointF(valueMaxPx, keyPx));\par
22863   \} else if (qFuzzyIsNull(value-prevValue)) // line is parallel to key axis\par
22864   \{\par
22865     // due to region filter in mayTraverse(), if line is parallel to value or key axis, region 5 is traversed here\par
22866     intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyMinPx, valuePx) : QPointF(valuePx, keyMinPx)); // direction will be taken care of at end of method\par
22867     intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyMaxPx, valuePx) : QPointF(valuePx, keyMaxPx));\par
22868   \} else // line is skewed\par
22869   \{\par
22870     double gamma;\par
22871     double keyPerValuePx = (keyPx-prevKeyPx)/(valuePx-prevValuePx);\par
22872     // check top of rect:\par
22873     gamma = prevKeyPx + (valueMaxPx-prevValuePx)*keyPerValuePx;\par
22874     if (gamma >= qMin(keyMinPx, keyMaxPx) && gamma <= qMax(keyMinPx, keyMaxPx)) // qMin/qMax necessary since axes may be reversed\par
22875       intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(gamma, valueMaxPx) : QPointF(valueMaxPx, gamma));\par
22876     // check bottom of rect:\par
22877     gamma = prevKeyPx + (valueMinPx-prevValuePx)*keyPerValuePx;\par
22878     if (gamma >= qMin(keyMinPx, keyMaxPx) && gamma <= qMax(keyMinPx, keyMaxPx)) // qMin/qMax necessary since axes may be reversed\par
22879       intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(gamma, valueMinPx) : QPointF(valueMinPx, gamma));\par
22880     const double valuePerKeyPx = 1.0/keyPerValuePx;\par
22881     // check left of rect:\par
22882     gamma = prevValuePx + (keyMinPx-prevKeyPx)*valuePerKeyPx;\par
22883     if (gamma >= qMin(valueMinPx, valueMaxPx) && gamma <= qMax(valueMinPx, valueMaxPx)) // qMin/qMax necessary since axes may be reversed\par
22884       intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyMinPx, gamma) : QPointF(gamma, keyMinPx));\par
22885     // check right of rect:\par
22886     gamma = prevValuePx + (keyMaxPx-prevKeyPx)*valuePerKeyPx;\par
22887     if (gamma >= qMin(valueMinPx, valueMaxPx) && gamma <= qMax(valueMinPx, valueMaxPx)) // qMin/qMax necessary since axes may be reversed\par
22888       intersections.append(mKeyAxis->orientation() == Qt::Horizontal ? QPointF(keyMaxPx, gamma) : QPointF(gamma, keyMaxPx));\par
22889   \}\par
22890   \par
22891   // handle cases where found points isn't exactly 2:\par
22892   if (intersections.size() > 2)\par
22893   \{\par
22894     // line probably goes through corner of rect, and we got duplicate points there. single out the point pair with greatest distance in between:\par
22895     double distSqrMax = 0;\par
22896     QPointF pv1, pv2;\par
22897     for (int i=0; i<intersections.size()-1; ++i)\par
22898     \{\par
22899       for (int k=i+1; k<intersections.size(); ++k)\par
22900       \{\par
22901         QPointF distPoint = intersections.at(i)-intersections.at(k);\par
22902         double distSqr = distPoint.x()*distPoint.x()+distPoint.y()+distPoint.y();\par
22903         if (distSqr > distSqrMax)\par
22904         \{\par
22905           pv1 = intersections.at(i);\par
22906           pv2 = intersections.at(k);\par
22907           distSqrMax = distSqr;\par
22908         \}\par
22909       \}\par
22910     \}\par
22911     intersections = QList<QPointF>() << pv1 << pv2;\par
22912   \} else if (intersections.size() != 2)\par
22913   \{\par
22914     // one or even zero points found (shouldn't happen unless line perfectly tangent to corner), no need to draw segment\par
22915     return false;\par
22916   \}\par
22917   \par
22918   // possibly re-sort points so optimized point segment has same direction as original segment:\par
22919   double xDelta = keyPx-prevKeyPx;\par
22920   double yDelta = valuePx-prevValuePx;\par
22921   if (mKeyAxis->orientation() != Qt::Horizontal)\par
22922     qSwap(xDelta, yDelta);\par
22923   if (xDelta*(intersections.at(1).x()-intersections.at(0).x()) + yDelta*(intersections.at(1).y()-intersections.at(0).y()) < 0) // scalar product of both segments < 0 -> opposite direction\par
22924     intersections.move(0, 1);\par
22925   crossA = intersections.at(0);\par
22926   crossB = intersections.at(1);\par
22927   return true;\par
22928 \}\par
}
}
{\xe \v getTraverseCornerPoints\:QCPCurve}
{\xe \v QCPCurve\:getTraverseCornerPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::getTraverseCornerPoints (int  {\i prevRegion}, int  {\i currentRegion}, double  {\i keyMin}, double  {\i valueMax}, double  {\i keyMax}, double  {\i valueMin}, QVector< QPointF > &  {\i beforeTraverse}, QVector< QPointF > &  {\i afterTraverse}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22956 \{\par
22957   switch (prevRegion)\par
22958   \{\par
22959     case 1:\par
22960     \{\par
22961       switch (currentRegion)\par
22962       \{\par
22963         case 6: \{ beforeTraverse << coordsToPixels(keyMin, valueMax); break; \}\par
22964         case 9: \{ beforeTraverse << coordsToPixels(keyMin, valueMax); afterTraverse << coordsToPixels(keyMax, valueMin); break; \}\par
22965         case 8: \{ beforeTraverse << coordsToPixels(keyMin, valueMax); break; \}\par
22966       \}\par
22967       break;\par
22968     \}\par
22969     case 2:\par
22970     \{\par
22971       switch (currentRegion)\par
22972       \{\par
22973         case 7: \{ afterTraverse << coordsToPixels(keyMax, valueMax); break; \}\par
22974         case 9: \{ afterTraverse << coordsToPixels(keyMax, valueMin); break; \}\par
22975       \}\par
22976       break;\par
22977     \}\par
22978     case 3:\par
22979     \{\par
22980       switch (currentRegion)\par
22981       \{\par
22982         case 4: \{ beforeTraverse << coordsToPixels(keyMin, valueMin); break; \}\par
22983         case 7: \{ beforeTraverse << coordsToPixels(keyMin, valueMin); afterTraverse << coordsToPixels(keyMax, valueMax); break; \}\par
22984         case 8: \{ beforeTraverse << coordsToPixels(keyMin, valueMin); break; \}\par
22985       \}\par
22986       break;\par
22987     \}\par
22988     case 4:\par
22989     \{\par
22990       switch (currentRegion)\par
22991       \{\par
22992         case 3: \{ afterTraverse << coordsToPixels(keyMin, valueMin); break; \}\par
22993         case 9: \{ afterTraverse << coordsToPixels(keyMax, valueMin); break; \}\par
22994       \}\par
22995       break;\par
22996     \}\par
22997     case 5: \{ break; \} // shouldn't happen because this method only handles full traverses\par
22998     case 6:\par
22999     \{\par
23000       switch (currentRegion)\par
23001       \{\par
23002         case 1: \{ afterTraverse << coordsToPixels(keyMin, valueMax); break; \}\par
23003         case 7: \{ afterTraverse << coordsToPixels(keyMax, valueMax); break; \}\par
23004       \}\par
23005       break;\par
23006     \}\par
23007     case 7:\par
23008     \{\par
23009       switch (currentRegion)\par
23010       \{\par
23011         case 2: \{ beforeTraverse << coordsToPixels(keyMax, valueMax); break; \}\par
23012         case 3: \{ beforeTraverse << coordsToPixels(keyMax, valueMax); afterTraverse << coordsToPixels(keyMin, valueMin); break; \}\par
23013         case 6: \{ beforeTraverse << coordsToPixels(keyMax, valueMax); break; \}\par
23014       \}\par
23015       break;\par
23016     \}\par
23017     case 8:\par
23018     \{\par
23019       switch (currentRegion)\par
23020       \{\par
23021         case 1: \{ afterTraverse << coordsToPixels(keyMin, valueMax); break; \}\par
23022         case 3: \{ afterTraverse << coordsToPixels(keyMin, valueMin); break; \}\par
23023       \}\par
23024       break;\par
23025     \}\par
23026     case 9:\par
23027     \{\par
23028       switch (currentRegion)\par
23029       \{\par
23030         case 2: \{ beforeTraverse << coordsToPixels(keyMax, valueMin); break; \}\par
23031         case 1: \{ beforeTraverse << coordsToPixels(keyMax, valueMin); afterTraverse << coordsToPixels(keyMin, valueMax); break; \}\par
23032         case 4: \{ beforeTraverse << coordsToPixels(keyMax, valueMin); break; \}\par
23033       \}\par
23034       break;\par
23035     \}\par
23036   \}\par
23037 \}\par
}
}
{\xe \v getValueRange\:QCPCurve}
{\xe \v QCPCurve\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPCurve::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22047 \{\par
22048   return mDataContainer->valueRange(foundRange, inSignDomain, inKeyRange);\par
22049 \}\par
}
}
{\xe \v lineStyle\:QCPCurve}
{\xe \v QCPCurve\:lineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LineStyle} QCPCurve::lineStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5318 \{ return mLineStyle; \}\par
}
}
{\xe \v mayTraverse\:QCPCurve}
{\xe \v QCPCurve\:mayTraverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPCurve::mayTraverse (int  {\i prevRegion}, int  {\i currentRegion}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22740 \{\par
22741   switch (prevRegion)\par
22742   \{\par
22743     case 1:\par
22744     \{\par
22745       switch (currentRegion)\par
22746       \{\par
22747         case 4:\par
22748         case 7:\par
22749         case 2:\par
22750         case 3: return false;\par
22751         default: return true;\par
22752       \}\par
22753     \}\par
22754     case 2:\par
22755     \{\par
22756       switch (currentRegion)\par
22757       \{\par
22758         case 1:\par
22759         case 3: return false;\par
22760         default: return true;\par
22761       \}\par
22762     \}\par
22763     case 3:\par
22764     \{\par
22765       switch (currentRegion)\par
22766       \{\par
22767         case 1:\par
22768         case 2:\par
22769         case 6:\par
22770         case 9: return false;\par
22771         default: return true;\par
22772       \}\par
22773     \}\par
22774     case 4:\par
22775     \{\par
22776       switch (currentRegion)\par
22777       \{\par
22778         case 1:\par
22779         case 7: return false;\par
22780         default: return true;\par
22781       \}\par
22782     \}\par
22783     case 5: return false; // should never occur\par
22784     case 6:\par
22785     \{\par
22786       switch (currentRegion)\par
22787       \{\par
22788         case 3:\par
22789         case 9: return false;\par
22790         default: return true;\par
22791       \}\par
22792     \}\par
22793     case 7:\par
22794     \{\par
22795       switch (currentRegion)\par
22796       \{\par
22797         case 1:\par
22798         case 4:\par
22799         case 8:\par
22800         case 9: return false;\par
22801         default: return true;\par
22802       \}\par
22803     \}\par
22804     case 8:\par
22805     \{\par
22806       switch (currentRegion)\par
22807       \{\par
22808         case 7:\par
22809         case 9: return false;\par
22810         default: return true;\par
22811       \}\par
22812     \}\par
22813     case 9:\par
22814     \{\par
22815       switch (currentRegion)\par
22816       \{\par
22817         case 3:\par
22818         case 6:\par
22819         case 8:\par
22820         case 7: return false;\par
22821         default: return true;\par
22822       \}\par
22823     \}\par
22824     default: return true;\par
22825   \}\par
22826 \}\par
}
}
{\xe \v pointDistance\:QCPCurve}
{\xe \v QCPCurve\:pointDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPCurve::pointDistance (const QPointF &  {\i pixelPoint}, {\b QCPCurveDataContainer::const_iterator} &  {\i closestData}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23052 \{\par
23053   closestData = mDataContainer->constEnd();\par
23054   if (mDataContainer->isEmpty())\par
23055     return -1.0;\par
23056   if (mLineStyle == lsNone && mScatterStyle.isNone())\par
23057     return -1.0;\par
23058   \par
23059   if (mDataContainer->size() == 1)\par
23060   \{\par
23061     QPointF dataPoint = coordsToPixels(mDataContainer->constBegin()->key, mDataContainer->constBegin()->value);\par
23062     closestData = mDataContainer->constBegin();\par
23063     return QCPVector2D(dataPoint-pixelPoint).length();\par
23064   \}\par
23065   \par
23066   // calculate minimum distances to curve data points and find closestData iterator:\par
23067   double minDistSqr = std::numeric_limits<double>::max();\par
23068   // iterate over found data points and then choose the one with the shortest distance to pos:\par
23069   QCPCurveDataContainer::const_iterator begin = mDataContainer->constBegin();\par
23070   QCPCurveDataContainer::const_iterator end = mDataContainer->constEnd();\par
23071   for (QCPCurveDataContainer::const_iterator it=begin; it!=end; ++it)\par
23072   \{\par
23073     const double currentDistSqr = QCPVector2D(coordsToPixels(it->key, it->value)-pixelPoint).lengthSquared();\par
23074     if (currentDistSqr < minDistSqr)\par
23075     \{\par
23076       minDistSqr = currentDistSqr;\par
23077       closestData = it;\par
23078     \}\par
23079   \}\par
23080   \par
23081   // calculate distance to line if there is one (if so, will probably be smaller than distance to closest data point):\par
23082   if (mLineStyle != lsNone)\par
23083   \{\par
23084     QVector<QPointF> lines;\par
23085     getCurveLines(&lines, QCPDataRange(0, dataCount()), mParentPlot->selectionTolerance()*1.2); // optimized lines outside axis rect shouldn't respond to clicks at the edge, so use 1.2*tolerance as pen width\par
23086     for (int i=0; i<lines.size()-1; ++i)\par
23087     \{\par
23088       double currentDistSqr = QCPVector2D(pixelPoint).distanceSquaredToLine(lines.at(i), lines.at(i+1));\par
23089       if (currentDistSqr < minDistSqr)\par
23090         minDistSqr = currentDistSqr;\par
23091     \}\par
23092   \}\par
23093   \par
23094   return qSqrt(minDistSqr);\par
23095 \}\par
}
}
{\xe \v scatterSkip\:QCPCurve}
{\xe \v QCPCurve\:scatterSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPCurve::scatterSkip () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5317 \{ return mScatterSkip; \}\par
}
}
{\xe \v scatterStyle\:QCPCurve}
{\xe \v QCPCurve\:scatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPCurve::scatterStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5316 \{ return mScatterStyle; \}\par
}
}
{\xe \v selectTest\:QCPCurve}
{\xe \v QCPCurve\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPCurve::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Reimplemented from {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22019 \{\par
22020   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
22021     return -1;\par
22022   if (!mKeyAxis || !mValueAxis)\par
22023     return -1;\par
22024   \par
22025   if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))\par
22026   \{\par
22027     QCPCurveDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();\par
22028     double result = pointDistance(pos, closestDataPoint);\par
22029     if (details)\par
22030     \{\par
22031       int pointIndex = closestDataPoint-mDataContainer->constBegin();\par
22032       details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));\par
22033     \}\par
22034     return result;\par
22035   \} else\par
22036     return -1;\par
22037 \}\par
}
}
{\xe \v setData\:QCPCurve}
{\xe \v QCPCurve\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::setData (QSharedPointer< {\b QCPCurveDataContainer} >  {\i data})}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data container with the provided {\i data}  container.\par
Since a QSharedPointer is used, multiple QCPCurves may share the same data container safely. Modifying the data in the container will then affect all curves that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } If you do not wish to share containers, but create a copy from an existing container, rather use the {\b QCPDataContainer<DataType>::set} method on the curve's data container directly: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21840 \{\par
21841   mDataContainer = data;\par
21842 \}\par
}
}
{\xe \v setData\:QCPCurve}
{\xe \v QCPCurve\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::setData (const QVector< double > &  {\i t}, const QVector< double > &  {\i keys}, const QVector< double > &  {\i values}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data with the provided points in {\i t} , {\i keys}  and {\i values} . The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i t}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21856 \{\par
21857   mDataContainer->clear();\par
21858   addData(t, keys, values, alreadySorted);\par
21859 \}\par
}
}
{\xe \v setData\:QCPCurve}
{\xe \v QCPCurve\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::setData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i values})}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data with the provided points in {\i keys}  and {\i values} . The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
The t parameter of each data point will be set to the integer index of the respective key/value pair.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21874 \{\par
21875   mDataContainer->clear();\par
21876   addData(keys, values);\par
21877 \}\par
}
}
{\xe \v setLineStyle\:QCPCurve}
{\xe \v QCPCurve\:setLineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::setLineStyle ({\b QCPCurve::LineStyle}  {\i style})}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how the single data points are connected in the plot or how they are represented visually apart from the scatter symbol. For scatter-only plots, set {\i style}  to {\b lsNone} and {\b setScatterStyle} to the desired scatter style.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setScatterStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21915 \{\par
21916   mLineStyle = style;\par
21917 \}\par
}
}
{\xe \v setScatterSkip\:QCPCurve}
{\xe \v QCPCurve\:setScatterSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::setScatterSkip (int  {\i skip})}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If scatters are displayed (scatter style not {\b QCPScatterStyle::ssNone}), {\i skip}  number of scatter points are skipped/not drawn after every drawn scatter point.\par
This can be used to make the data appear sparser while for example still having a smooth line, and to improve performance for very high density plots.\par
If {\i skip}  is set to 0 (default), all scatter points are drawn.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setScatterStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21903 \{\par
21904   mScatterSkip = qMax(0, skip);\par
21905 \}\par
}
}
{\xe \v setScatterStyle\:QCPCurve}
{\xe \v QCPCurve\:setScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPCurve::setScatterStyle (const {\b QCPScatterStyle} &  {\i style})}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the visual appearance of single data points in the plot. If set to {\b QCPScatterStyle::ssNone}, no scatter points are drawn (e.g. for line-only plots with appropriate line style).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPScatterStyle}, {\b setLineStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21887 \{\par
21888   mScatterStyle = style;\par
21889 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLegend\:QCPCurve}
{\xe \v QCPCurve\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPCurve}
{\xe \v QCPCurve\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mLineStyle\:QCPCurve}
{\xe \v QCPCurve\:mLineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LineStyle} QCPCurve::mLineStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScatterSkip\:QCPCurve}
{\xe \v QCPCurve\:mScatterSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPCurve::mScatterSkip{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScatterStyle\:QCPCurve}
{\xe \v QCPCurve\:mScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPCurve::mScatterStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPCurveData Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPCurveData}
{\xe \v QCPCurveData}
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPCurve}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPCurveData:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_curve_data__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPCurveData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPCurveData} (double {\b t}, double {\b key}, double {\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sortKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b valueRange} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b QCPCurveData} {\b fromSortKey} (double {\b sortKey})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b sortKeyIsMainKey} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPCurve}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The stored data is: {
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i t:}  the free ordering parameter of this curve point, like in the mathematical vector {\i (x(t), y(t))} . (This is the {\i sortKey} ) \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i key:}  coordinate on the key axis of this curve point (this is the {\i mainKey} ) \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i value:}  coordinate on the value axis of this curve point (this is the {\i mainValue} )\par
}
The container for storing multiple data points is {\b QCPCurveDataContainer}. It is a typedef for {\b QCPDataContainer} with {\b QCPCurveData} as the DataType template parameter. See the documentation there for an explanation regarding the data type's generic methods.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b QCPCurveDataContainer} \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPCurveData\:QCPCurveData}
{\xe \v QCPCurveData\:QCPCurveData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPCurveData::QCPCurveData ()}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a curve data point with t, key and value set to zero. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21729                            :\par
21730   t(0),\par
21731   key(0),\par
21732   value(0)\par
21733 \{\par
21734 \}\par
}
}
{\xe \v QCPCurveData\:QCPCurveData}
{\xe \v QCPCurveData\:QCPCurveData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPCurveData::QCPCurveData (double  {\i t}, double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a curve data point with the specified {\i t} , {\i key}  and {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21739                                                              :\par
21740   t(t),\par
21741   key(key),\par
21742   value(value)\par
21743 \{\par
21744 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fromSortKey\:QCPCurveData}
{\xe \v QCPCurveData\:fromSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b QCPCurveData} QCPCurveData::fromSortKey (double  {\i sortKey}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data point with the specified {\i sortKey}  (assigned to the data point's {\i t}  member). All other members are set to zero.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5267 \{ return QCPCurveData(sortKey, 0, 0); \}\par
}
}
{\xe \v mainKey\:QCPCurveData}
{\xe \v QCPCurveData\:mainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPCurveData::mainKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i key}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5270 \{ return key; \}\par
}
}
{\xe \v mainValue\:QCPCurveData}
{\xe \v QCPCurveData\:mainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPCurveData::mainValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i value}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5271 \{ return value; \}\par
}
}
{\xe \v sortKey\:QCPCurveData}
{\xe \v QCPCurveData\:sortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPCurveData::sortKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i t}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5266 \{ return t; \}\par
}
}
{\xe \v sortKeyIsMainKey\:QCPCurveData}
{\xe \v QCPCurveData\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static static bool QCPCurveData::sortKeyIsMainKey (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Since the member {\i key}  is the data point key coordinate and the member {\i t}  is the data ordering parameter, this method returns false.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5268 \{ return false; \}\par
}
}
{\xe \v valueRange\:QCPCurveData}
{\xe \v QCPCurveData\:valueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPCurveData::valueRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPRange} with both lower and upper boundary set to {\i value}  of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5273 \{ return QCPRange(value, value); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v key\:QCPCurveData}
{\xe \v QCPCurveData\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPCurveData::key}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v t\:QCPCurveData}
{\xe \v QCPCurveData\:t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPCurveData::t}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:QCPCurveData}
{\xe \v QCPCurveData\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPCurveData::value}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPDataContainer< DataType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v QCPDataContainer< DataType >}
{\xe \v QCPDataContainer< DataType >}
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The generic data container for one-dimensional plottables. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPDataContainer< DataType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_data_container__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef QVector< DataType >::{\b const_iterator} {\b const_iterator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef QVector< DataType >::{\b iterator} {\b iterator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataContainer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b autoSqueeze} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAutoSqueeze} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const {\b QCPDataContainer}< DataType > &data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const QVector< DataType > &data, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add} (const {\b QCPDataContainer}< DataType > &data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add} (const QVector< DataType > &data, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add} (const DataType &data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeBefore} (double sortKey)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAfter} (double sortKey)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b remove} (double sortKeyFrom, double sortKeyTo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b remove} (double sortKey)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sort} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b squeeze} (bool preAllocation=true, bool postAllocation=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b constBegin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b constEnd} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b findBegin} (double sortKey, bool expandedRange=true) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b findEnd} (double sortKey, bool expandedRange=true) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b at} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b keyRange} (bool &foundRange, {\b QCP::SignDomain} signDomain={\b QCP::sdBoth})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b valueRange} (bool &foundRange, {\b QCP::SignDomain} signDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b dataRange} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b limitIteratorsToDataRange} ({\b const_iterator} &{\b begin}, {\b const_iterator} &{\b end}, const {\b QCPDataRange} &{\b dataRange}) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b preallocateGrow} (int minimumPreallocSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b performAutoSqueeze} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAutoSqueeze}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< DataType > {\b mData}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mPreallocSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mPreallocIteration}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Related Functions\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Note that these are not member functions.) \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class DataType > bool {\b qcpLessThanSortKey} (const DataType &a, const DataType &b)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class DataType>\par
class QCPDataContainer< DataType >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The generic data container for one-dimensional plottables. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class template provides a fast container for data storage of one-dimensional data. The data type is specified as template parameter (called {\i DataType}  in the following) and must provide some methods as described in the {\b next section}.\par
The data is stored in a sorted fashion, which allows very quick lookups by the sorted key as well as retrieval of ranges (see {\b findBegin}, {\b findEnd}, {\b keyRange}) using binary search. The container uses a preallocation and a postallocation scheme, such that appending and prepending data (with respect to the sort key) is very fast and minimizes reallocations. If data is added which needs to be inserted between existing keys, the merge usually can be done quickly too, using the fact that existing data is always sorted. The user can further improve performance by specifying that added data is already itself sorted by key, if he can guarantee that this is the case (see for example {\b add(const QVector<DataType> &data, bool alreadySorted)}).\par
The data can be accessed with the provided const iterators ({\b constBegin}, {\b constEnd}). If it is necessary to alter existing data in-place, the non-const iterators can be used ({\b begin}, {\b end}). Changing data members that are not the sort key (for most data types called {\i key} ) is safe from the container's perspective.\par
Great care must be taken however if the sort key is modified through the non-const iterators. For performance reasons, the iterators don't automatically cause a re-sorting upon their manipulation. It is thus the responsibility of the user to leave the container in a sorted state when finished with the data manipulation, before calling any other methods on the container. A complete re-sort (e.g. after finishing all sort key manipulation) can be done by calling {\b sort}. Failing to do so can not be detected by the container efficiently and will cause both rendering artifacts and potential data loss.\par
Implementing one-dimensional plottables that make use of a {\b QCPDataContainer<T>} is usually done by subclassing from {\b QCPAbstractPlottable1D<T>}, which introduces an according {\i mDataContainer}  member and some convenience methods.\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Requirements for the DataType template parameter
\par}
{\tc\tcl2 \v Requirements for the DataType template parameter}
The template parameter {\f2 DataType}  is the type of the stored data points. It must be trivially copyable and have the following public methods, preferably inline:\par
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 double sortKey() const} \par
 Returns the member variable of this data point that is the sort key, defining the ordering in the container. Often this variable is simply called {\i key} .\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 static DataType fromSortKey(double sortKey)} \par
 Returns a new instance of the data type initialized with its sort key set to {\i sortKey} .\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 static bool sortKeyIsMainKey()} \par
 Returns true if the sort key is equal to the main key (see method {\f2 mainKey}  below). For most plottables this is the case. It is not the case for example for {\b QCPCurve}, which uses {\i t}  as sort key and {\i key}  as main key. This is the reason why {\b QCPCurve} unlike {\b QCPGraph} can display parametric curves with loops.\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 double mainKey() const} \par
 Returns the variable of this data point considered the main key. This is commonly the variable that is used as the coordinate of this data point on the key axis of the plottable. This method is used for example when determining the automatic axis rescaling of key axes ({\b QCPAxis::rescale}).\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 double mainValue() const} \par
 Returns the variable of this data point considered the main value. This is commonly the variable that is used as the coordinate of this data point on the value axis of the plottable.\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 {\b QCPRange} valueRange() const} \par
 Returns the range this data point spans in the value axis coordinate. If the data is single-valued (e.g. {\b QCPGraphData}), this is simply a range with both lower and upper set to the main data point value. However if the data points can represent multiple values at once (e.g {\b QCPFinancialData} with its {\i high} , {\i low} , {\i open}  and {\i close}  values at each {\i key} ) this method should return the range those values span. This method is used for example when determining the automatic axis rescaling of value axes ({\b QCPAxis::rescale}). \par
}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v const_iterator\:QCPDataContainer}
{\xe \v QCPDataContainer\:const_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> typedef QVector<DataType>::{\b const_iterator} {\b QCPDataContainer}< DataType >::{\b const_iterator}}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iterator\:QCPDataContainer}
{\xe \v QCPDataContainer\:iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> typedef QVector<DataType>::{\b iterator} {\b QCPDataContainer}< DataType >::{\b iterator}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPDataContainer\:QCPDataContainer}
{\xe \v QCPDataContainer\:QCPDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPDataContainer}< DataType >::{\b QCPDataContainer} ()}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b QCPDataContainer} used for plottable classes that represent a series of key-sorted data \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2599                                              :\par
 2600   mAutoSqueeze(true),\par
 2601   mPreallocSize(0),\par
 2602   mPreallocIteration(0)\par
 2603 \{\par
 2604 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:QCPDataContainer}
{\xe \v QCPDataContainer\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::add (const {\b QCPDataContainer}< DataType > &  {\i data})}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided {\i data}  to the current data in this container.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b set}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2665 \{\par
 2666   if (data.isEmpty())\par
 2667     return;\par
 2668   \par
 2669   const int n = data.size();\par
 2670   const int oldSize = size();\par
 2671   \par
 2672   if (oldSize > 0 && !qcpLessThanSortKey<DataType>(*constBegin(), *(data.constEnd()-1))) // prepend if new data keys are all smaller than or equal to existing ones\par
 2673   \{\par
 2674     if (mPreallocSize < n)\par
 2675       preallocateGrow(n);\par
 2676     mPreallocSize -= n;\par
 2677     std::copy(data.constBegin(), data.constEnd(), begin());\par
 2678   \} else // don't need to prepend, so append and merge if necessary\par
 2679   \{\par
 2680     mData.resize(mData.size()+n);\par
 2681     std::copy(data.constBegin(), data.constEnd(), end()-n);\par
 2682     if (oldSize > 0 && !qcpLessThanSortKey<DataType>(*(constEnd()-n-1), *(constEnd()-n))) // if appended range keys aren't all greater than existing ones, merge the two partitions\par
 2683       std::inplace_merge(begin(), end()-n, end(), qcpLessThanSortKey<DataType>);\par
 2684   \}\par
 2685 \}\par
}
}
{\xe \v add\:QCPDataContainer}
{\xe \v QCPDataContainer\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::add (const QVector< DataType > &  {\i data}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the provided data points in {\i data}  to the current data.\par
If you can guarantee that the data points in {\i data}  have ascending order with respect to the DataType's sort key, set {\i alreadySorted}  to true to avoid an unnecessary sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b set}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2697 \{\par
 2698   if (data.isEmpty())\par
 2699     return;\par
 2700   if (isEmpty())\par
 2701   \{\par
 2702     set(data, alreadySorted);\par
 2703     return;\par
 2704   \}\par
 2705   \par
 2706   const int n = data.size();\par
 2707   const int oldSize = size();\par
 2708   \par
 2709   if (alreadySorted && oldSize > 0 && !qcpLessThanSortKey<DataType>(*constBegin(), *(data.constEnd()-1))) // prepend if new data is sorted and keys are all smaller than or equal to existing ones\par
 2710   \{\par
 2711     if (mPreallocSize < n)\par
 2712       preallocateGrow(n);\par
 2713     mPreallocSize -= n;\par
 2714     std::copy(data.constBegin(), data.constEnd(), begin());\par
 2715   \} else // don't need to prepend, so append and then sort and merge if necessary\par
 2716   \{\par
 2717     mData.resize(mData.size()+n);\par
 2718     std::copy(data.constBegin(), data.constEnd(), end()-n);\par
 2719     if (!alreadySorted) // sort appended subrange if it wasn't already sorted\par
 2720       std::sort(end()-n, end(), qcpLessThanSortKey<DataType>);\par
 2721     if (oldSize > 0 && !qcpLessThanSortKey<DataType>(*(constEnd()-n-1), *(constEnd()-n))) // if appended range keys aren't all greater than existing ones, merge the two partitions\par
 2722       std::inplace_merge(begin(), end()-n, end(), qcpLessThanSortKey<DataType>);\par
 2723   \}\par
 2724 \}\par
}
}
{\xe \v add\:QCPDataContainer}
{\xe \v QCPDataContainer\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::add (const DataType &  {\i data})}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided single data point to the current data.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2734 \{\par
 2735   if (isEmpty() || !qcpLessThanSortKey<DataType>(data, *(constEnd()-1))) // quickly handle appends if new data key is greater or equal to existing ones\par
 2736   \{\par
 2737     mData.append(data);\par
 2738   \} else if (qcpLessThanSortKey<DataType>(data, *constBegin()))  // quickly handle prepends using preallocated space\par
 2739   \{\par
 2740     if (mPreallocSize < 1)\par
 2741       preallocateGrow(1);\par
 2742     --mPreallocSize;\par
 2743     *begin() = data;\par
 2744   \} else // handle inserts, maintaining sorted keys\par
 2745   \{\par
 2746     QCPDataContainer<DataType>::iterator insertionPoint = std::lower_bound(begin(), end(), data, qcpLessThanSortKey<DataType>);\par
 2747     mData.insert(insertionPoint, data);\par
 2748   \}\par
 2749 \}\par
}
}
{\xe \v at\:QCPDataContainer}
{\xe \v QCPDataContainer\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::const_iterator} {\b QCPDataContainer}< DataType >::at (int  {\i index}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the element with the specified {\i index} . If {\i index}  points beyond the available elements in this container, returns {\b constEnd}, i.e. an iterator past the last valid element.\par
You can use this method to easily obtain iterators from a {\b QCPDataRange}, see the data selection page for an example. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2440 \{ return constBegin()+qBound(0, index, size()); \}\par
}
}
{\xe \v autoSqueeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:autoSqueeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> bool {\b QCPDataContainer}< DataType >::autoSqueeze () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2415 \{ return mAutoSqueeze; \}\par
}
}
{\xe \v begin\:QCPDataContainer}
{\xe \v QCPDataContainer\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::iterator} {\b QCPDataContainer}< DataType >::begin (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a non-const iterator to the first data point in this container.\par
You can manipulate the data points in-place through the non-const iterators, but great care must be taken when manipulating the sort key of a data point, see {\b sort}, or the detailed description of this class. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2436 \{ return mData.begin()+mPreallocSize; \}\par
}
}
{\xe \v clear\:QCPDataContainer}
{\xe \v QCPDataContainer\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::clear ()}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data points.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b remove}, {\b removeAfter}, {\b removeBefore} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2832 \{\par
 2833   mData.clear();\par
 2834   mPreallocIteration = 0;\par
 2835   mPreallocSize = 0;\par
 2836 \}\par
}
}
{\xe \v constBegin\:QCPDataContainer}
{\xe \v QCPDataContainer\:constBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::const_iterator} {\b QCPDataContainer}< DataType >::constBegin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the first data point in this container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2434 \{ return mData.constBegin()+mPreallocSize; \}\par
}
}
{\xe \v constEnd\:QCPDataContainer}
{\xe \v QCPDataContainer\:constEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::const_iterator} {\b QCPDataContainer}< DataType >::constEnd () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the element past the last data point in this container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2435 \{ return mData.constEnd(); \}\par
}
}
{\xe \v dataRange\:QCPDataContainer}
{\xe \v QCPDataContainer\:dataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataRange} {\b QCPDataContainer}< DataType >::dataRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPDataRange} encompassing the entire data set of this container. This means the begin index of the returned range is 0, and the end index is {\b size}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2443 \{ return QCPDataRange(0, size()); \}\par
}
}
{\xe \v end\:QCPDataContainer}
{\xe \v QCPDataContainer\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPDataContainer::iterator} {\b QCPDataContainer}< DataType >::end (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a non-const iterator to the element past the last data point in this container.\par
You can manipulate the data points in-place through the non-const iterators, but great care must be taken when manipulating the sort key of a data point, see {\b sort}, or the detailed description of this class. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2437 \{ return mData.end(); \}\par
}
}
{\xe \v findBegin\:QCPDataContainer}
{\xe \v QCPDataContainer\:findBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPDataContainer}< DataType >::{\b const_iterator} {\b QCPDataContainer}< DataType >::findBegin (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an iterator to the data point with a (sort-)key that is equal to, just below, or just above {\i sortKey} . If {\i expandedRange}  is true, the data point just below {\i sortKey}  will be considered, otherwise the one just above.\par
This can be used in conjunction with {\b findEnd} to iterate over data points within a given key range, including or excluding the bounding data points that are just beyond the specified range.\par
If {\i expandedRange}  is true but there are no data points below {\i sortKey} , {\b constBegin} is returned.\par
If the container is empty, returns {\b constEnd}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findEnd}, {\b QCPPlottableInterface1D::findBegin} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2899 \{\par
 2900   if (isEmpty())\par
 2901     return constEnd();\par
 2902   \par
 2903   QCPDataContainer<DataType>::const_iterator it = std::lower_bound(constBegin(), constEnd(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2904   if (expandedRange && it != constBegin()) // also covers it == constEnd case, and we know --constEnd is valid because mData isn't empty\par
 2905     --it;\par
 2906   return it;\par
 2907 \}\par
}
}
{\xe \v findEnd\:QCPDataContainer}
{\xe \v QCPDataContainer\:findEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPDataContainer}< DataType >::{\b const_iterator} {\b QCPDataContainer}< DataType >::findEnd (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an iterator to the element after the data point with a (sort-)key that is equal to, just above or just below {\i sortKey} . If {\i expandedRange}  is true, the data point just above {\i sortKey}  will be considered, otherwise the one just below.\par
This can be used in conjunction with {\b findBegin} to iterate over data points within a given key range, including the bounding data points that are just below and above the specified range.\par
If {\i expandedRange}  is true but there are no data points above {\i sortKey} , {\b constEnd} is returned.\par
If the container is empty, {\b constEnd} is returned.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findBegin}, {\b QCPPlottableInterface1D::findEnd} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2926 \{\par
 2927   if (isEmpty())\par
 2928     return constEnd();\par
 2929   \par
 2930   QCPDataContainer<DataType>::const_iterator it = std::upper_bound(constBegin(), constEnd(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2931   if (expandedRange && it != constEnd())\par
 2932     ++it;\par
 2933   return it;\par
 2934 \}\par
}
}
{\xe \v isEmpty\:QCPDataContainer}
{\xe \v QCPDataContainer\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> bool {\b QCPDataContainer}< DataType >::isEmpty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this container holds no data points. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2414 \{ return size() == 0; \}\par
}
}
{\xe \v keyRange\:QCPDataContainer}
{\xe \v QCPDataContainer\:keyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPRange} {\b QCPDataContainer}< DataType >::keyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i signDomain} = {\f2 {\b QCP::sdBoth}})}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range encompassed by the (main-)key coordinate of all data points. The output parameter {\i foundRange}  indicates whether a sensible range was found. If this is false, you should not use the returned {\b QCPRange} (e.g. the data container is empty or all points have the same key).\par
Use {\i signDomain}  to control which sign of the key coordinates should be considered. This is relevant e.g. for logarithmic plots which can mathematically only display one sign domain at a time.\par
If the DataType reports that its main key is equal to the sort key ({\i sortKeyIsMainKey} ), as is the case for most plottables, this method uses this fact and finds the range very quickly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b valueRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2953 \{\par
 2954   if (isEmpty())\par
 2955   \{\par
 2956     foundRange = false;\par
 2957     return QCPRange();\par
 2958   \}\par
 2959   QCPRange range;\par
 2960   bool haveLower = false;\par
 2961   bool haveUpper = false;\par
 2962   double current;\par
 2963   \par
 2964   QCPDataContainer<DataType>::const_iterator it = constBegin();\par
 2965   QCPDataContainer<DataType>::const_iterator itEnd = constEnd();\par
 2966   if (signDomain == QCP::sdBoth) // range may be anywhere\par
 2967   \{\par
 2968     if (DataType::sortKeyIsMainKey()) // if DataType is sorted by main key (e.g. QCPGraph, but not QCPCurve), use faster algorithm by finding just first and last key with non-NaN value\par
 2969     \{\par
 2970       while (it != itEnd) // find first non-nan going up from left\par
 2971       \{\par
 2972         if (!qIsNaN(it->mainValue()))\par
 2973         \{\par
 2974           range.lower = it->mainKey();\par
 2975           haveLower = true;\par
 2976           break;\par
 2977         \}\par
 2978         ++it;\par
 2979       \}\par
 2980       it = itEnd;\par
 2981       while (it != constBegin()) // find first non-nan going down from right\par
 2982       \{\par
 2983         --it;\par
 2984         if (!qIsNaN(it->mainValue()))\par
 2985         \{\par
 2986           range.upper = it->mainKey();\par
 2987           haveUpper = true;\par
 2988           break;\par
 2989         \}\par
 2990       \}\par
 2991     \} else // DataType is not sorted by main key, go through all data points and accordingly expand range\par
 2992     \{\par
 2993       while (it != itEnd)\par
 2994       \{\par
 2995         if (!qIsNaN(it->mainValue()))\par
 2996         \{\par
 2997           current = it->mainKey();\par
 2998           if (current < range.lower || !haveLower)\par
 2999           \{\par
 3000             range.lower = current;\par
 3001             haveLower = true;\par
 3002           \}\par
 3003           if (current > range.upper || !haveUpper)\par
 3004           \{\par
 3005             range.upper = current;\par
 3006             haveUpper = true;\par
 3007           \}\par
 3008         \}\par
 3009         ++it;\par
 3010       \}\par
 3011     \}\par
 3012   \} else if (signDomain == QCP::sdNegative) // range may only be in the negative sign domain\par
 3013   \{\par
 3014     while (it != itEnd)\par
 3015     \{\par
 3016       if (!qIsNaN(it->mainValue()))\par
 3017       \{\par
 3018         current = it->mainKey();\par
 3019         if ((current < range.lower || !haveLower) && current < 0)\par
 3020         \{\par
 3021           range.lower = current;\par
 3022           haveLower = true;\par
 3023         \}\par
 3024         if ((current > range.upper || !haveUpper) && current < 0)\par
 3025         \{\par
 3026           range.upper = current;\par
 3027           haveUpper = true;\par
 3028         \}\par
 3029       \}\par
 3030       ++it;\par
 3031     \}\par
 3032   \} else if (signDomain == QCP::sdPositive) // range may only be in the positive sign domain\par
 3033   \{\par
 3034     while (it != itEnd)\par
 3035     \{\par
 3036       if (!qIsNaN(it->mainValue()))\par
 3037       \{\par
 3038         current = it->mainKey();\par
 3039         if ((current < range.lower || !haveLower) && current > 0)\par
 3040         \{\par
 3041           range.lower = current;\par
 3042           haveLower = true;\par
 3043         \}\par
 3044         if ((current > range.upper || !haveUpper) && current > 0)\par
 3045         \{\par
 3046           range.upper = current;\par
 3047           haveUpper = true;\par
 3048         \}\par
 3049       \}\par
 3050       ++it;\par
 3051     \}\par
 3052   \}\par
 3053   \par
 3054   foundRange = haveLower && haveUpper;\par
 3055   return range;\par
 3056 \}\par
}
}
{\xe \v limitIteratorsToDataRange\:QCPDataContainer}
{\xe \v QCPDataContainer\:limitIteratorsToDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::limitIteratorsToDataRange ({\b const_iterator} &  {\i begin}, {\b const_iterator} &  {\i end}, const {\b QCPDataRange} &  {\i dataRange}) const}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes sure {\i begin}  and {\i end}  mark a data range that is both within the bounds of this data container's data, as well as within the specified {\i dataRange} . The initial range described by the passed iterators {\i begin}  and {\i end}  is never expanded, only contracted if necessary.\par
This function doesn't require for {\i dataRange}  to be within the bounds of this data container's valid range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3164 \{\par
 3165   QCPDataRange iteratorRange(begin-constBegin(), end-constBegin());\par
 3166   iteratorRange = iteratorRange.bounded(dataRange.bounded(this->dataRange()));\par
 3167   begin = constBegin()+iteratorRange.begin();\par
 3168   end = constBegin()+iteratorRange.end();\par
 3169 \}\par
}
}
{\xe \v performAutoSqueeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:performAutoSqueeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::performAutoSqueeze (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3212 \{\par
 3213   const int totalAlloc = mData.capacity();\par
 3214   const int postAllocSize = totalAlloc-mData.size();\par
 3215   const int usedSize = size();\par
 3216   bool shrinkPostAllocation = false;\par
 3217   bool shrinkPreAllocation = false;\par
 3218   if (totalAlloc > 650000) // if allocation is larger, shrink earlier with respect to total used size\par
 3219   \{\par
 3220     shrinkPostAllocation = postAllocSize > usedSize*1.5; // QVector grow strategy is 2^n for static data. Watch out not to oscillate!\par
 3221     shrinkPreAllocation = mPreallocSize*10 > usedSize;\par
 3222   \} else if (totalAlloc > 1000) // below 10 MiB raw data be generous with preallocated memory, below 1k points don't even bother\par
 3223   \{\par
 3224     shrinkPostAllocation = postAllocSize > usedSize*5;\par
 3225     shrinkPreAllocation = mPreallocSize > usedSize*1.5; // preallocation can grow into postallocation, so can be smaller\par
 3226   \}\par
 3227   \par
 3228   if (shrinkPreAllocation || shrinkPostAllocation)\par
 3229     squeeze(shrinkPreAllocation, shrinkPostAllocation);\par
 3230 \}\par
}
}
{\xe \v preallocateGrow\:QCPDataContainer}
{\xe \v QCPDataContainer\:preallocateGrow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::preallocateGrow (int  {\i minimumPreallocSize}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3182 \{\par
 3183   if (minimumPreallocSize <= mPreallocSize)\par
 3184     return;\par
 3185   \par
 3186   int newPreallocSize = minimumPreallocSize;\par
 3187   newPreallocSize += (1u<<qBound(4, mPreallocIteration+4, 15)) - 12; // do 4 up to 32768-12 preallocation, doubling in each intermediate iteration\par
 3188   ++mPreallocIteration;\par
 3189   \par
 3190   int sizeDifference = newPreallocSize-mPreallocSize;\par
 3191   mData.resize(mData.size()+sizeDifference);\par
 3192   std::copy_backward(mData.begin()+mPreallocSize, mData.end()-sizeDifference, mData.end());\par
 3193   mPreallocSize = newPreallocSize;\par
 3194 \}\par
}
}
{\xe \v remove\:QCPDataContainer}
{\xe \v QCPDataContainer\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::remove (double  {\i sortKeyFrom}, double  {\i sortKeyTo})}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data points with (sort-)keys between {\i sortKeyFrom}  and {\i sortKeyTo} . if {\i sortKeyFrom}  is greater or equal to {\i sortKeyTo} , the function does nothing. To remove a single data point with known (sort-)key, use {\b remove(double sortKey)}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeBefore}, {\b removeAfter}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2790 \{\par
 2791   if (sortKeyFrom >= sortKeyTo || isEmpty())\par
 2792     return;\par
 2793   \par
 2794   QCPDataContainer<DataType>::iterator it = std::lower_bound(begin(), end(), DataType::fromSortKey(sortKeyFrom), qcpLessThanSortKey<DataType>);\par
 2795   QCPDataContainer<DataType>::iterator itEnd = std::upper_bound(it, end(), DataType::fromSortKey(sortKeyTo), qcpLessThanSortKey<DataType>);\par
 2796   mData.erase(it, itEnd);\par
 2797   if (mAutoSqueeze)\par
 2798     performAutoSqueeze();\par
 2799 \}\par
}
}
{\xe \v remove\:QCPDataContainer}
{\xe \v QCPDataContainer\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::remove (double  {\i sortKey})}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Removes a single data point at {\i sortKey} . If the position is not known with absolute (binary) precision, consider using {\b remove(double sortKeyFrom, double sortKeyTo)} with a small fuzziness interval around the suspected position, depeding on the precision with which the (sort-)key is known.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeBefore}, {\b removeAfter}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2812 \{\par
 2813   QCPDataContainer::iterator it = std::lower_bound(begin(), end(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2814   if (it != end() && it->sortKey() == sortKey)\par
 2815   \{\par
 2816     if (it == begin())\par
 2817       ++mPreallocSize; // don't actually delete, just add it to the preallocated block (if it gets too large, squeeze will take care of it)\par
 2818     else\par
 2819       mData.erase(it);\par
 2820   \}\par
 2821   if (mAutoSqueeze)\par
 2822     performAutoSqueeze();\par
 2823 \}\par
}
}
{\xe \v removeAfter\:QCPDataContainer}
{\xe \v QCPDataContainer\:removeAfter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::removeAfter (double  {\i sortKey})}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data points with (sort-)keys greater than or equal to {\i sortKey} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeBefore}, {\b remove}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2773 \{\par
 2774   QCPDataContainer<DataType>::iterator it = std::upper_bound(begin(), end(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2775   QCPDataContainer<DataType>::iterator itEnd = end();\par
 2776   mData.erase(it, itEnd); // typically adds it to the postallocated block\par
 2777   if (mAutoSqueeze)\par
 2778     performAutoSqueeze();\par
 2779 \}\par
}
}
{\xe \v removeBefore\:QCPDataContainer}
{\xe \v QCPDataContainer\:removeBefore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::removeBefore (double  {\i sortKey})}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data points with (sort-)keys smaller than or equal to {\i sortKey} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeAfter}, {\b remove}, {\b clear} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2758 \{\par
 2759   QCPDataContainer<DataType>::iterator it = begin();\par
 2760   QCPDataContainer<DataType>::iterator itEnd = std::lower_bound(begin(), end(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
 2761   mPreallocSize += itEnd-it; // don't actually delete, just add it to the preallocated block (if it gets too large, squeeze will take care of it)\par
 2762   if (mAutoSqueeze)\par
 2763     performAutoSqueeze();\par
 2764 \}\par
}
}
{\xe \v set\:QCPDataContainer}
{\xe \v QCPDataContainer\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::set (const {\b QCPDataContainer}< DataType > &  {\i data})}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data in this container with the provided {\i data} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b add}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2633 \{\par
 2634   clear();\par
 2635   add(data);\par
 2636 \}\par
}
}
{\xe \v set\:QCPDataContainer}
{\xe \v QCPDataContainer\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::set (const QVector< DataType > &  {\i data}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data in this container with the provided {\i data}  \par
If you can guarantee that the data points in {\i data}  have ascending order with respect to the DataType's sort key, set {\i alreadySorted}  to true to avoid an unnecessary sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b add}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2649 \{\par
 2650   mData = data;\par
 2651   mPreallocSize = 0;\par
 2652   mPreallocIteration = 0;\par
 2653   if (!alreadySorted)\par
 2654     sort();\par
 2655 \}\par
}
}
{\xe \v setAutoSqueeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:setAutoSqueeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::setAutoSqueeze (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the container automatically decides when to release memory from its post- and preallocation pools when data points are removed. By default this is enabled and for typical applications shouldn't be changed.\par
If auto squeeze is disabled, you can manually decide when to release pre-/postallocation with {\b squeeze}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2616 \{\par
 2617   if (mAutoSqueeze != enabled)\par
 2618   \{\par
 2619     mAutoSqueeze = enabled;\par
 2620     if (mAutoSqueeze)\par
 2621       performAutoSqueeze();\par
 2622   \}\par
 2623 \}\par
}
}
{\xe \v size\:QCPDataContainer}
{\xe \v QCPDataContainer\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> int {\b QCPDataContainer}< DataType >::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data points in the container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2413 \{ return mData.size()-mPreallocSize; \}\par
}
}
{\xe \v sort\:QCPDataContainer}
{\xe \v QCPDataContainer\:sort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::sort ()}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Re-sorts all data points in the container by their sort key.\par
When setting, adding or removing points using the {\b QCPDataContainer} interface ({\b set}, {\b add}, {\b remove}, etc.), the container makes sure to always stay in a sorted state such that a full resort is never necessary. However, if you choose to directly manipulate the sort key on data points by accessing and modifying it through the non-const iterators ({\b begin}, {\b end}), it is your responsibility to bring the container back into a sorted state before any other methods are called on it. This can be achieved by calling this method immediately after finishing the sort key manipulation. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2851 \{\par
 2852   std::sort(begin(), end(), qcpLessThanSortKey<DataType>);\par
 2853 \}\par
}
}
{\xe \v squeeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:squeeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPDataContainer}< DataType >::squeeze (bool  {\i preAllocation} = {\f2 true}, bool  {\i postAllocation} = {\f2 true})}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees all unused memory that is currently in the preallocation and postallocation pools.\par
Note that {\b QCPDataContainer} automatically decides whether squeezing is necessary, if {\b setAutoSqueeze} is left enabled. It should thus not be necessary to use this method for typical applications.\par
The parameters {\i preAllocation}  and {\i postAllocation}  control whether pre- and/or post allocation should be freed, respectively. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2867 \{\par
 2868   if (preAllocation)\par
 2869   \{\par
 2870     if (mPreallocSize > 0)\par
 2871     \{\par
 2872       std::copy(begin(), end(), mData.begin());\par
 2873       mData.resize(size());\par
 2874       mPreallocSize = 0;\par
 2875     \}\par
 2876     mPreallocIteration = 0;\par
 2877   \}\par
 2878   if (postAllocation)\par
 2879     mData.squeeze();\par
 2880 \}\par
}
}
{\xe \v valueRange\:QCPDataContainer}
{\xe \v QCPDataContainer\:valueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPRange} {\b QCPDataContainer}< DataType >::valueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i signDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()})}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range encompassed by the value coordinates of the data points in the specified key range ({\i inKeyRange} ), using the full {\i DataType::valueRange}  reported by the data points. The output parameter {\i foundRange}  indicates whether a sensible range was found. If this is false, you should not use the returned {\b QCPRange} (e.g. the data container is empty or all points have the same value).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Use {\i signDomain}  to control which sign of the value coordinates should be considered. This is relevant e.g. for logarithmic plots which can mathematically only display one sign domain at a time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b keyRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3076 \{\par
 3077   if (isEmpty())\par
 3078   \{\par
 3079     foundRange = false;\par
 3080     return QCPRange();\par
 3081   \}\par
 3082   QCPRange range;\par
 3083   const bool restrictKeyRange = inKeyRange != QCPRange();\par
 3084   bool haveLower = false;\par
 3085   bool haveUpper = false;\par
 3086   QCPRange current;\par
 3087   QCPDataContainer<DataType>::const_iterator itBegin = constBegin();\par
 3088   QCPDataContainer<DataType>::const_iterator itEnd = constEnd();\par
 3089   if (DataType::sortKeyIsMainKey() && restrictKeyRange)\par
 3090   \{\par
 3091     itBegin = findBegin(inKeyRange.lower);\par
 3092     itEnd = findEnd(inKeyRange.upper);\par
 3093   \}\par
 3094   if (signDomain == QCP::sdBoth) // range may be anywhere\par
 3095   \{\par
 3096     for (QCPDataContainer<DataType>::const_iterator it = itBegin; it != itEnd; ++it)\par
 3097     \{\par
 3098       if (restrictKeyRange && (it->mainKey() < inKeyRange.lower || it->mainKey() > inKeyRange.upper))\par
 3099         continue;\par
 3100       current = it->valueRange();\par
 3101       if ((current.lower < range.lower || !haveLower) && !qIsNaN(current.lower))\par
 3102       \{\par
 3103         range.lower = current.lower;\par
 3104         haveLower = true;\par
 3105       \}\par
 3106       if ((current.upper > range.upper || !haveUpper) && !qIsNaN(current.upper))\par
 3107       \{\par
 3108         range.upper = current.upper;\par
 3109         haveUpper = true;\par
 3110       \}\par
 3111     \}\par
 3112   \} else if (signDomain == QCP::sdNegative) // range may only be in the negative sign domain\par
 3113   \{\par
 3114     for (QCPDataContainer<DataType>::const_iterator it = itBegin; it != itEnd; ++it)\par
 3115     \{\par
 3116       if (restrictKeyRange && (it->mainKey() < inKeyRange.lower || it->mainKey() > inKeyRange.upper))\par
 3117         continue;\par
 3118       current = it->valueRange();\par
 3119       if ((current.lower < range.lower || !haveLower) && current.lower < 0 && !qIsNaN(current.lower))\par
 3120       \{\par
 3121         range.lower = current.lower;\par
 3122         haveLower = true;\par
 3123       \}\par
 3124       if ((current.upper > range.upper || !haveUpper) && current.upper < 0 && !qIsNaN(current.upper))\par
 3125       \{\par
 3126         range.upper = current.upper;\par
 3127         haveUpper = true;\par
 3128       \}\par
 3129     \}\par
 3130   \} else if (signDomain == QCP::sdPositive) // range may only be in the positive sign domain\par
 3131   \{\par
 3132     for (QCPDataContainer<DataType>::const_iterator it = itBegin; it != itEnd; ++it)\par
 3133     \{\par
 3134       if (restrictKeyRange && (it->mainKey() < inKeyRange.lower || it->mainKey() > inKeyRange.upper))\par
 3135         continue;\par
 3136       current = it->valueRange();\par
 3137       if ((current.lower < range.lower || !haveLower) && current.lower > 0 && !qIsNaN(current.lower))\par
 3138       \{\par
 3139         range.lower = current.lower;\par
 3140         haveLower = true;\par
 3141       \}\par
 3142       if ((current.upper > range.upper || !haveUpper) && current.upper > 0 && !qIsNaN(current.upper))\par
 3143       \{\par
 3144         range.upper = current.upper;\par
 3145         haveUpper = true;\par
 3146       \}\par
 3147     \}\par
 3148   \}\par
 3149   \par
 3150   foundRange = haveLower && haveUpper;\par
 3151   return range;\par
 3152 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v qcpLessThanSortKey\:QCPDataContainer}
{\xe \v QCPDataContainer\:qcpLessThanSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > bool qcpLessThanSortKey (const DataType &  {\i a}, const DataType &  {\i b}){\f2 [related]}}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the sort key of {\i a}  is less than the sort key of {\i b} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPDataContainer::sort} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2401 \{ return a.sortKey() < b.sortKey(); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAutoSqueeze\:QCPDataContainer}
{\xe \v QCPDataContainer\:mAutoSqueeze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> bool {\b QCPDataContainer}< DataType >::mAutoSqueeze{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mData\:QCPDataContainer}
{\xe \v QCPDataContainer\:mData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> QVector<DataType> {\b QCPDataContainer}< DataType >::mData{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPreallocIteration\:QCPDataContainer}
{\xe \v QCPDataContainer\:mPreallocIteration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> int {\b QCPDataContainer}< DataType >::mPreallocIteration{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPreallocSize\:QCPDataContainer}
{\xe \v QCPDataContainer\:mPreallocSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> int {\b QCPDataContainer}< DataType >::mPreallocSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPDataRange Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPDataRange}
{\xe \v QCPDataRange}
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data range given by begin and end index. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPDataRange:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_data_range__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} (int {\b begin}, int {\b end})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b QCPDataRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b QCPDataRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b begin} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b end} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b length} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBegin} (int {\b begin})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEnd} (int {\b end})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isValid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b bounded} (const {\b QCPDataRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b expanded} (const {\b QCPDataRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b intersection} (const {\b QCPDataRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b adjusted} (int changeBegin, int changeEnd) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b intersects} (const {\b QCPDataRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contains} (const {\b QCPDataRange} &other) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Related Functions\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Note that these are not member functions.) \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QDebug {\b operator<<} (QDebug d, const {\b QCPDataRange} &dataRange)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data range given by begin and end index. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b QCPDataRange} holds two integers describing the begin ({\b setBegin}) and end ({\b setEnd}) index of a contiguous set of data points. The end index points to the data point above the last data point that's part of the data range, similarly to the nomenclature used in standard iterators.\par
Data Ranges are not bound to a certain plottable, thus they can be freely exchanged, created and modified. If a non-contiguous data set shall be described, the class {\b QCPDataSelection} is used, which holds and manages multiple instances of {\b QCPDataRange}. In most situations, {\b QCPDataSelection} is thus used.\par
Both {\b QCPDataRange} and {\b QCPDataSelection} offer convenience methods to work with them, e.g. {\b bounded}, {\b expanded}, {\b intersects}, {\b intersection}, {\b adjusted}, {\b contains}. Further, addition and subtraction operators (defined in {\b QCPDataSelection}) can be used to join/subtract data ranges and data selections (or mixtures), to retrieve a corresponding {\b QCPDataSelection}.\par
QCustomPlot's data selection mechanism is based on {\b QCPDataSelection} and {\b QCPDataRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Do not confuse {\b QCPDataRange} with {\b QCPRange}. A {\b QCPRange} describes an interval in floating point plot coordinates, e.g. the current axis range. \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPDataRange\:QCPDataRange}
{\xe \v QCPDataRange\:QCPDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPDataRange::QCPDataRange ()}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an empty {\b QCPDataRange}, with begin and end set to 0. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2225                            :\par
 2226   mBegin(0),\par
 2227   mEnd(0)\par
 2228 \{\par
 2229 \}\par
}
}
{\xe \v QCPDataRange\:QCPDataRange}
{\xe \v QCPDataRange\:QCPDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPDataRange::QCPDataRange (int  {\i begin}, int  {\i end})}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPDataRange}, initialized with the specified {\i begin}  and {\i end} .\par
No checks or corrections are made to ensure the resulting range is valid ({\b isValid}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2236                                              :\par
 2237   mBegin(begin),\par
 2238   mEnd(end)\par
 2239 \{\par
 2240 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v adjusted\:QCPDataRange}
{\xe \v QCPDataRange\:adjusted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataRange} QCPDataRange::adjusted (int  {\i changeBegin}, int  {\i changeEnd}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data range where {\i changeBegin}  and {\i changeEnd}  were added to the begin and end indices, respectively. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   915 \{ return QCPDataRange(mBegin+changeBegin, mEnd+changeEnd); \}\par
}
}
{\xe \v begin\:QCPDataRange}
{\xe \v QCPDataRange\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPDataRange::begin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   900 \{ return mBegin; \}\par
}
}
{\xe \v bounded\:QCPDataRange}
{\xe \v QCPDataRange\:bounded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataRange} QCPDataRange::bounded (const {\b QCPDataRange} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data range that matches this data range, except that parts exceeding {\i other}  are excluded.\par
This method is very similar to {\b intersection}, with one distinction: If this range and the {\i other}  range share no intersection, the returned data range will be empty with begin and end set to the respective boundary side of {\i other} , at which this range is residing. ({\b intersection} would just return a range with begin and end set to 0.) \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2252 \{\par
 2253   QCPDataRange result(intersection(other));\par
 2254   if (result.isEmpty()) // no intersection, preserve respective bounding side of otherRange as both begin and end of return value\par
 2255   \{\par
 2256     if (mEnd <= other.mBegin)\par
 2257       result = QCPDataRange(other.mBegin, other.mBegin);\par
 2258     else\par
 2259       result = QCPDataRange(other.mEnd, other.mEnd);\par
 2260   \}\par
 2261   return result;\par
 2262 \}\par
}
}
{\xe \v contains\:QCPDataRange}
{\xe \v QCPDataRange\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataRange::contains (const {\b QCPDataRange} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether all data points described by this data range are also in {\i other} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b intersects} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2308 \{\par
 2309   return mBegin <= other.mBegin && mEnd >= other.mEnd;\par
 2310 \}\par
}
}
{\xe \v end\:QCPDataRange}
{\xe \v QCPDataRange\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPDataRange::end () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   901 \{ return mEnd; \}\par
}
}
{\xe \v expanded\:QCPDataRange}
{\xe \v QCPDataRange\:expanded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataRange} QCPDataRange::expanded (const {\b QCPDataRange} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data range that contains both this data range as well as {\i other} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2268 \{\par
 2269   return QCPDataRange(qMin(mBegin, other.mBegin), qMax(mEnd, other.mEnd));\par
 2270 \}\par
}
}
{\xe \v intersection\:QCPDataRange}
{\xe \v QCPDataRange\:intersection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataRange} QCPDataRange::intersection (const {\b QCPDataRange} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the data range which is contained in both this data range and {\i other} .\par
This method is very similar to {\b bounded}, with one distinction: If this range and the {\i other}  range share no intersection, the returned data range will be empty with begin and end set to 0. ({\b bounded} would return a range with begin and end set to one of the boundaries of {\i other} , depending on which side this range is on.)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPDataSelection::intersection} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2283 \{\par
 2284   QCPDataRange result(qMax(mBegin, other.mBegin), qMin(mEnd, other.mEnd));\par
 2285   if (result.isValid())\par
 2286     return result;\par
 2287   else\par
 2288     return QCPDataRange();\par
 2289 \}\par
}
}
{\xe \v intersects\:QCPDataRange}
{\xe \v QCPDataRange\:intersects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataRange::intersects (const {\b QCPDataRange} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this data range and {\i other}  share common data points.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b intersection}, {\b contains} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2297 \{\par
 2298    return !( (mBegin > other.mBegin && mBegin >= other.mEnd) ||\par
 2299              (mEnd <= other.mBegin && mEnd < other.mEnd) );\par
 2300 \}\par
}
}
{\xe \v isEmpty\:QCPDataRange}
{\xe \v QCPDataRange\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataRange::isEmpty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this range is empty, i.e. whether its begin index equals its end index.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b size}, {\b length} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   911 \{ return length() == 0; \}\par
}
}
{\xe \v isValid\:QCPDataRange}
{\xe \v QCPDataRange\:isValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataRange::isValid () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this range is valid. A valid range has a begin index greater or equal to 0, and an end index greater or equal to the begin index.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Invalid ranges should be avoided and are never the result of any of {\b QCustomPlot}'s methods (unless they are themselves fed with invalid ranges). Do not pass invalid ranges to {\b QCustomPlot}'s methods. The invalid range is not inherently prevented in {\b QCPDataRange}, to allow temporary invalid begin/end values while manipulating the range. An invalid range is not necessarily empty ({\b isEmpty}), since its {\b length} can be negative and thus non-zero. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   910 \{ return (mEnd >= mBegin) && (mBegin >= 0); \}\par
}
}
{\xe \v length\:QCPDataRange}
{\xe \v QCPDataRange\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPDataRange::length () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data points described by this data range. Equivalent to {\b size}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   903 \{ return size(); \}\par
}
}
{\xe \v operator!=\:QCPDataRange}
{\xe \v QCPDataRange\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataRange::operator!= (const {\b QCPDataRange} &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   897 \{ return !(*this == other); \}\par
}
}
{\xe \v operator==\:QCPDataRange}
{\xe \v QCPDataRange\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataRange::operator== (const {\b QCPDataRange} &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   896 \{ return mBegin == other.mBegin && mEnd == other.mEnd; \}\par
}
}
{\xe \v setBegin\:QCPDataRange}
{\xe \v QCPDataRange\:setBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataRange::setBegin (int  {\i begin}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the begin of this data range. The {\i begin}  index points to the first data point that is part of the data range.\par
No checks or corrections are made to ensure the resulting range is valid ({\b isValid}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setEnd} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   906 \{ mBegin = begin; \}\par
}
}
{\xe \v setEnd\:QCPDataRange}
{\xe \v QCPDataRange\:setEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataRange::setEnd (int  {\i end}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the end of this data range. The {\i end}  index points to the data point just above the last data point that is part of the data range.\par
No checks or corrections are made to ensure the resulting range is valid ({\b isValid}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBegin} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   907 \{ mEnd = end; \}\par
}
}
{\xe \v size\:QCPDataRange}
{\xe \v QCPDataRange\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPDataRange::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data points described by this data range. This is equal to the end index minus the begin index.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b length} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   902 \{ return mEnd-mBegin; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:QCPDataRange}
{\xe \v QCPDataRange\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QDebug operator<< (QDebug  {\i d}, const {\b QCPDataRange} &  {\i dataRange}){\f2 [related]}}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints {\i dataRange}  in a human readable format to the qDebug output. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1064 \{\par
 1065     d.nospace() << "[" << dataRange.begin() << ".." << dataRange.end()-1 << "]";\par
 1066     return d.space();\par
 1067 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPDataSelection Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPDataSelection}
{\xe \v QCPDataSelection}
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data set by holding multiple {\b QCPDataRange} instances. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPDataSelection:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_data_selection__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} (const {\b QCPDataRange} &range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b QCPDataSelection} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b QCPDataSelection} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} & {\b operator+=} (const {\b QCPDataSelection} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} & {\b operator+=} (const {\b QCPDataRange} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} & {\b operator-=} (const {\b QCPDataSelection} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} & {\b operator-=} (const {\b QCPDataRange} &other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dataRangeCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dataPointCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b dataRange} (int index=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPDataRange} > {\b dataRanges} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataRange} {\b span} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addDataRange} (const {\b QCPDataRange} &{\b dataRange}, bool {\b simplify}=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b simplify} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enforceType} ({\b QCP::SelectionType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contains} (const {\b QCPDataSelection} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b intersection} (const {\b QCPDataRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b intersection} (const {\b QCPDataSelection} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b inverse} (const {\b QCPDataRange} &outerRange) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataSelection} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataRange} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataSelection} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataRange} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataSelection} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataRange} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataSelection} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataRange} &a, const {\b QCPDataRange} &b)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Related Functions\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Note that these are not member functions.) \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QDebug {\b operator<<} (QDebug d, const {\b QCPDataSelection} &selection)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data set by holding multiple {\b QCPDataRange} instances. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b QCPDataSelection} manages multiple instances of {\b QCPDataRange} in order to represent any (possibly disjoint) set of data selection.\par
The data selection can be modified with addition and subtraction operators which take {\b QCPDataSelection} and {\b QCPDataRange} instances, as well as methods such as {\b addDataRange} and {\b clear}. Read access is provided by {\b dataRange}, {\b dataRanges}, {\b dataRangeCount}, etc.\par
The method {\b simplify} is used to join directly adjacent or even overlapping {\b QCPDataRange} instances. {\b QCPDataSelection} automatically simplifies when using the addition/subtraction operators. The only case when {\b simplify} is left to the user, is when calling {\b addDataRange}, with the parameter {\i simplify}  explicitly set to false. This is useful if many data ranges will be added to the selection successively and the overhead for simplifying after each iteration shall be avoided. In this case, you should make sure to call {\b simplify} after completing the operation.\par
Use {\b enforceType} to bring the data selection into a state complying with the constraints for selections defined in {\b QCP::SelectionType}.\par
QCustomPlot's data selection mechanism is based on {\b QCPDataSelection} and {\b QCPDataRange}.\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Iterating over a data selection
\par}
{\tc\tcl2 \v Iterating over a data selection}
As an example, the following code snippet calculates the average value of a graph's data {\b selection}:\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPDataSelection\:QCPDataSelection}
{\xe \v QCPDataSelection\:QCPDataSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPDataSelection::QCPDataSelection (){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an empty {\b QCPDataSelection}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2384 \{\par
 2385 \}\par
}
}
{\xe \v QCPDataSelection\:QCPDataSelection}
{\xe \v QCPDataSelection\:QCPDataSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPDataSelection::QCPDataSelection (const {\b QCPDataRange} &  {\i range}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPDataSelection} containing the provided {\i range} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2391 \{\par
 2392   mDataRanges.append(range);\par
 2393 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addDataRange\:QCPDataSelection}
{\xe \v QCPDataSelection\:addDataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataSelection::addDataRange (const {\b QCPDataRange} &  {\i dataRange}, bool  {\i simplify} = {\f2 true})}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the given {\i dataRange}  to this data selection. This is equivalent to the += operator but allows disabling immediate simplification by setting {\i simplify}  to false. This can improve performance if adding a very large amount of data ranges successively. In this case, make sure to call {\b simplify} manually, after the operation. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2543 \{\par
 2544   mDataRanges.append(dataRange);\par
 2545   if (simplify)\par
 2546     this->simplify();\par
 2547 \}\par
}
}
{\xe \v clear\:QCPDataSelection}
{\xe \v QCPDataSelection\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataSelection::clear ()}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data ranges. The data selection then contains no data points.\par
{\b isEmpty} \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2555 \{\par
 2556   mDataRanges.clear();\par
 2557 \}\par
}
}
{\xe \v contains\:QCPDataSelection}
{\xe \v QCPDataSelection\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataSelection::contains (const {\b QCPDataSelection} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the data selection {\i other}  is contained entirely in this data selection, i.e. all data point indices that are in {\i other}  are also in this data selection.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPDataRange::contains} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2652 \{\par
 2653   if (other.isEmpty()) return false;\par
 2654   \par
 2655   int otherIndex = 0;\par
 2656   int thisIndex = 0;\par
 2657   while (thisIndex < mDataRanges.size() && otherIndex < other.mDataRanges.size())\par
 2658   \{\par
 2659     if (mDataRanges.at(thisIndex).contains(other.mDataRanges.at(otherIndex)))\par
 2660       ++otherIndex;\par
 2661     else\par
 2662       ++thisIndex;\par
 2663   \}\par
 2664   return thisIndex < mDataRanges.size(); // if thisIndex ran all the way to the end to find a containing range for the current otherIndex, other is not contained in this\par
 2665 \}\par
}
}
{\xe \v dataPointCount\:QCPDataSelection}
{\xe \v QCPDataSelection\:dataPointCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPDataSelection::dataPointCount () const}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total number of data points contained in all data ranges that make up this data selection. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2497 \{\par
 2498   int result = 0;\par
 2499   for (int i=0; i<mDataRanges.size(); ++i)\par
 2500     result += mDataRanges.at(i).length();\par
 2501   return result;\par
 2502 \}\par
}
}
{\xe \v dataRange\:QCPDataSelection}
{\xe \v QCPDataSelection\:dataRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataRange} QCPDataSelection::dataRange (int  {\i index} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the data range with the specified {\i index} .\par
If the data selection is simplified (the usual state of the selection, see {\b simplify}), the ranges are sorted by ascending data point index.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b dataRangeCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2513 \{\par
 2514   if (index >= 0 && index < mDataRanges.size())\par
 2515   \{\par
 2516     return mDataRanges.at(index);\par
 2517   \} else\par
 2518   \{\par
 2519     qDebug() << Q_FUNC_INFO << "index out of range:" << index;\par
 2520     return QCPDataRange();\par
 2521   \}\par
 2522 \}\par
}
}
{\xe \v dataRangeCount\:QCPDataSelection}
{\xe \v QCPDataSelection\:dataRangeCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPDataSelection::dataRangeCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of ranges that make up the data selection. The ranges can be accessed by {\b dataRange} via their index.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b dataRange}, {\b dataPointCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   949 \{ return mDataRanges.size(); \}\par
}
}
{\xe \v dataRanges\:QCPDataSelection}
{\xe \v QCPDataSelection\:dataRanges}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPDataRange} > QCPDataSelection::dataRanges () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all data ranges that make up the data selection. If the data selection is simplified (the usual state of the selection, see {\b simplify}), the ranges are sorted by ascending data point index.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b dataRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   952 \{ return mDataRanges; \}\par
}
}
{\xe \v enforceType\:QCPDataSelection}
{\xe \v QCPDataSelection\:enforceType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataSelection::enforceType ({\b QCP::SelectionType}  {\i type})}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes sure this data selection conforms to the specified {\i type}  selection type. Before the type is enforced, {\b simplify} is called.\par
Depending on {\i type} , enforcing means adding new data points that were previously not part of the selection, or removing data points from the selection. If the current selection already conforms to {\i type} , the data selection is not changed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCP::SelectionType} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2606 \{\par
 2607   simplify();\par
 2608   switch (type)\par
 2609   \{\par
 2610     case QCP::stNone:\par
 2611     \{\par
 2612       mDataRanges.clear();\par
 2613       break;\par
 2614     \}\par
 2615     case QCP::stWhole:\par
 2616     \{\par
 2617       // whole selection isn't defined by data range, so don't change anything (is handled in plottable methods)\par
 2618       break;\par
 2619     \}\par
 2620     case QCP::stSingleData:\par
 2621     \{\par
 2622       // reduce all data ranges to the single first data point:\par
 2623       if (!mDataRanges.isEmpty())\par
 2624       \{\par
 2625         if (mDataRanges.size() > 1)\par
 2626           mDataRanges = QList<QCPDataRange>() << mDataRanges.first();\par
 2627         if (mDataRanges.first().length() > 1)\par
 2628           mDataRanges.first().setEnd(mDataRanges.first().begin()+1);\par
 2629       \}\par
 2630       break;\par
 2631     \}\par
 2632     case QCP::stDataRange:\par
 2633     \{\par
 2634       mDataRanges = QList<QCPDataRange>() << span();\par
 2635       break;\par
 2636     \}\par
 2637     case QCP::stMultipleDataRanges:\par
 2638     \{\par
 2639       // this is the selection type that allows all concievable combinations of ranges, so do nothing\par
 2640       break;\par
 2641     \}\par
 2642   \}\par
 2643 \}\par
}
}
{\xe \v intersection\:QCPDataSelection}
{\xe \v QCPDataSelection\:intersection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPDataSelection::intersection (const {\b QCPDataRange} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection containing the points which are both in this data selection and in the data range {\i other} .\par
A common use case is to limit an unknown data selection to the valid range of a data container, using {\b QCPDataContainer::dataRange} as {\i other} . One can then safely iterate over the returned data selection without exceeding the data container's bounds. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2676 \{\par
 2677   QCPDataSelection result;\par
 2678   for (int i=0; i<mDataRanges.size(); ++i)\par
 2679     result.addDataRange(mDataRanges.at(i).intersection(other), false);\par
 2680   result.simplify();\par
 2681   return result;\par
 2682 \}\par
}
}
{\xe \v intersection\:QCPDataSelection}
{\xe \v QCPDataSelection\:intersection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPDataSelection::intersection (const {\b QCPDataSelection} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection containing the points which are both in this data selection and in the data selection {\i other} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2689 \{\par
 2690   QCPDataSelection result;\par
 2691   for (int i=0; i<other.dataRangeCount(); ++i)\par
 2692     result += intersection(other.dataRange(i));\par
 2693   result.simplify();\par
 2694   return result;\par
 2695 \}\par
}
}
{\xe \v inverse\:QCPDataSelection}
{\xe \v QCPDataSelection\:inverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPDataSelection::inverse (const {\b QCPDataRange} &  {\i outerRange}) const}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection which is the exact inverse of this data selection, with {\i outerRange}  defining the base range on which to invert. If {\i outerRange}  is smaller than the {\b span} of this data selection, it is expanded accordingly.\par
For example, this method can be used to retrieve all unselected segments by setting {\i outerRange}  to the full data range of the plottable, and calling this method on a data selection holding the selected segments. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2707 \{\par
 2708   if (isEmpty())\par
 2709     return QCPDataSelection(outerRange);\par
 2710   QCPDataRange fullRange = outerRange.expanded(span());\par
 2711   \par
 2712   QCPDataSelection result;\par
 2713   // first unselected segment:\par
 2714   if (mDataRanges.first().begin() != fullRange.begin())\par
 2715     result.addDataRange(QCPDataRange(fullRange.begin(), mDataRanges.first().begin()), false);\par
 2716   // intermediate unselected segments:\par
 2717   for (int i=1; i<mDataRanges.size(); ++i)\par
 2718     result.addDataRange(QCPDataRange(mDataRanges.at(i-1).end(), mDataRanges.at(i).begin()), false);\par
 2719   // last unselected segment:\par
 2720   if (mDataRanges.last().end() != fullRange.end())\par
 2721     result.addDataRange(QCPDataRange(mDataRanges.last().end(), fullRange.end()), false);\par
 2722   result.simplify();\par
 2723   return result;\par
 2724 \}\par
}
}
{\xe \v isEmpty\:QCPDataSelection}
{\xe \v QCPDataSelection\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataSelection::isEmpty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if there are no data ranges, and thus no data points, in this {\b QCPDataSelection} instance.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b dataRangeCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   958 \{ return mDataRanges.isEmpty(); \}\par
}
}
{\xe \v operator!=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataSelection::operator!= (const {\b QCPDataSelection} &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   934 \{ return !(*this == other); \}\par
}
}
{\xe \v operator+=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} & QCPDataSelection::operator+= (const {\b QCPDataSelection} &  {\i other})}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the data selection of {\i other}  to this data selection, and then simplifies this data selection (see {\b simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2419 \{\par
 2420   mDataRanges << other.mDataRanges;\par
 2421   simplify();\par
 2422   return *this;\par
 2423 \}\par
}
}
{\xe \v operator+=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} & QCPDataSelection::operator+= (const {\b QCPDataRange} &  {\i other})}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the data range {\i other}  to this data selection, and then simplifies this data selection (see {\b simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2430 \{\par
 2431   addDataRange(other);\par
 2432   return *this;\par
 2433 \}\par
}
}
{\xe \v operator-=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} & QCPDataSelection::operator-= (const {\b QCPDataSelection} &  {\i other})}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data point indices that are described by {\i other}  from this data selection. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2439 \{\par
 2440   for (int i=0; i<other.dataRangeCount(); ++i)\par
 2441     *this -= other.dataRange(i);\par
 2442   \par
 2443   return *this;\par
 2444 \}\par
}
}
{\xe \v operator-=\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} & QCPDataSelection::operator-= (const {\b QCPDataRange} &  {\i other})}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all data point indices that are described by {\i other}  from this data selection. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2450 \{\par
 2451   if (other.isEmpty() || isEmpty())\par
 2452     return *this;\par
 2453   \par
 2454   simplify();\par
 2455   int i=0;\par
 2456   while (i < mDataRanges.size())\par
 2457   \{\par
 2458     const int thisBegin = mDataRanges.at(i).begin();\par
 2459     const int thisEnd = mDataRanges.at(i).end();\par
 2460     if (thisBegin >= other.end())\par
 2461       break; // since data ranges are sorted after the simplify() call, no ranges which contain other will come after this\par
 2462     \par
 2463     if (thisEnd > other.begin()) // ranges which don't fulfill this are entirely before other and can be ignored\par
 2464     \{\par
 2465       if (thisBegin >= other.begin()) // range leading segment is encompassed\par
 2466       \{\par
 2467         if (thisEnd <= other.end()) // range fully encompassed, remove completely\par
 2468         \{\par
 2469           mDataRanges.removeAt(i);\par
 2470           continue;\par
 2471         \} else // only leading segment is encompassed, trim accordingly\par
 2472           mDataRanges[i].setBegin(other.end());\par
 2473       \} else // leading segment is not encompassed\par
 2474       \{\par
 2475         if (thisEnd <= other.end()) // only trailing segment is encompassed, trim accordingly\par
 2476         \{\par
 2477           mDataRanges[i].setEnd(other.begin());\par
 2478         \} else // other lies inside this range, so split range\par
 2479         \{\par
 2480           mDataRanges[i].setEnd(other.begin());\par
 2481           mDataRanges.insert(i+1, QCPDataRange(other.end(), thisEnd));\par
 2482           break; // since data ranges are sorted (and don't overlap) after simplify() call, we're done here\par
 2483         \}\par
 2484       \}\par
 2485     \}\par
 2486     ++i;\par
 2487   \}\par
 2488   \par
 2489   return *this;\par
 2490 \}\par
}
}
{\xe \v operator==\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPDataSelection::operator== (const {\b QCPDataSelection} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this selection is identical (contains the same data ranges with the same begin and end indices) to {\i other} .\par
Note that both data selections must be in simplified state (the usual state of the selection, see {\b simplify}) for this operator to return correct results. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2403 \{\par
 2404   if (mDataRanges.size() != other.mDataRanges.size())\par
 2405     return false;\par
 2406   for (int i=0; i<mDataRanges.size(); ++i)\par
 2407   \{\par
 2408     if (mDataRanges.at(i) != other.mDataRanges.at(i))\par
 2409       return false;\par
 2410   \}\par
 2411   return true;\par
 2412 \}\par
}
}
{\xe \v simplify\:QCPDataSelection}
{\xe \v QCPDataSelection\:simplify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPDataSelection::simplify ()}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sorts all data ranges by range begin index in ascending order, and then joins directly adjacent or overlapping ranges. This can reduce the number of individual data ranges in the selection, and prevents possible double-counting when iterating over the data points held by the data ranges.\par
This method is automatically called when using the addition/subtraction operators. The only case when {\b simplify} is left to the user, is when calling {\b addDataRange}, with the parameter {\i simplify}  explicitly set to false. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2569 \{\par
 2570   // remove any empty ranges:\par
 2571   for (int i=mDataRanges.size()-1; i>=0; --i)\par
 2572   \{\par
 2573     if (mDataRanges.at(i).isEmpty())\par
 2574       mDataRanges.removeAt(i);\par
 2575   \}\par
 2576   if (mDataRanges.isEmpty())\par
 2577     return;\par
 2578   \par
 2579   // sort ranges by starting value, ascending:\par
 2580   std::sort(mDataRanges.begin(), mDataRanges.end(), lessThanDataRangeBegin);\par
 2581   \par
 2582   // join overlapping/contiguous ranges:\par
 2583   int i = 1;\par
 2584   while (i < mDataRanges.size())\par
 2585   \{\par
 2586     if (mDataRanges.at(i-1).end() >= mDataRanges.at(i).begin()) // range i overlaps/joins with i-1, so expand range i-1 appropriately and remove range i from list\par
 2587     \{\par
 2588       mDataRanges[i-1].setEnd(qMax(mDataRanges.at(i-1).end(), mDataRanges.at(i).end()));\par
 2589       mDataRanges.removeAt(i);\par
 2590     \} else\par
 2591       ++i;\par
 2592   \}\par
 2593 \}\par
}
}
{\xe \v span\:QCPDataSelection}
{\xe \v QCPDataSelection\:span}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataRange} QCPDataSelection::span () const}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPDataRange} which spans the entire data selection, including possible intermediate segments which are not part of the original data selection. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2529 \{\par
 2530   if (isEmpty())\par
 2531     return QCPDataRange();\par
 2532   else\par
 2533     return QCPDataRange(mDataRanges.first().begin(), mDataRanges.last().end());\par
 2534 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator+\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   980 \{\par
  981   QCPDataSelection result(a);\par
  982   result += b;\par
  983   return result;\par
  984 \}\par
}
}
{\xe \v operator+\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   991 \{\par
  992   QCPDataSelection result(a);\par
  993   result += b;\par
  994   return result;\par
  995 \}\par
}
}
{\xe \v operator+\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1002 \{\par
 1003   QCPDataSelection result(a);\par
 1004   result += b;\par
 1005   return result;\par
 1006 \}\par
}
}
{\xe \v operator+\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1013 \{\par
 1014   QCPDataSelection result(a);\par
 1015   result += b;\par
 1016   return result;\par
 1017 \}\par
}
}
{\xe \v operator-\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1023 \{\par
 1024   QCPDataSelection result(a);\par
 1025   result -= b;\par
 1026   return result;\par
 1027 \}\par
}
}
{\xe \v operator-\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1033 \{\par
 1034   QCPDataSelection result(a);\par
 1035   result -= b;\par
 1036   return result;\par
 1037 \}\par
}
}
{\xe \v operator-\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1043 \{\par
 1044   QCPDataSelection result(a);\par
 1045   result -= b;\par
 1046   return result;\par
 1047 \}\par
}
}
{\xe \v operator-\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1053 \{\par
 1054   QCPDataSelection result(a);\par
 1055   result -= b;\par
 1056   return result;\par
 1057 \}\par
}
}
{\xe \v operator<<\:QCPDataSelection}
{\xe \v QCPDataSelection\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QDebug operator<< (QDebug  {\i d}, const {\b QCPDataSelection} &  {\i selection}){\f2 [related]}}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints {\i selection}  in a human readable format to the qDebug output. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1074 \{\par
 1075     d.nospace() << "QCPDataSelection(";\par
 1076     for (int i=0; i<selection.dataRangeCount(); ++i)\par
 1077     \{\par
 1078       if (i != 0)\par
 1079         d << ", ";\par
 1080       d << selection.dataRange(i);\par
 1081     \}\par
 1082     d << ")";\par
 1083     return d.space();\par
 1084 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPErrorBars Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPErrorBars}
{\xe \v QCPErrorBars}
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable that adds a set of error bars to other plottables. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPErrorBars:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_error_bars__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPErrorBars:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_error_bars__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ErrorType} \{ {\b etKeyError}, 
{\b etValueError}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPErrorBars} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPErrorBars} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPErrorBarsDataContainer} > {\b data} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b dataPlottable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b errorType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b whiskerWidth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b symbolGap} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (QSharedPointer< {\b QCPErrorBarsDataContainer} > {\b data})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (const QVector< double > &error)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (const QVector< double > &errorMinus, const QVector< double > &errorPlus)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDataPlottable} ({\b QCPAbstractPlottable} *plottable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setErrorType} ({\b ErrorType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWhiskerWidth} (double pixels)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSymbolGap} (double pixels)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (const QVector< double > &error)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (const QVector< double > &errorMinus, const QVector< double > &errorPlus)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (double error)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (double errorMinus, double errorPlus)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b dataCount} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainKey} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataSortKey} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainValue} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b dataValueRange} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b dataPixelPosition} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b sortKeyIsMainKey} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPDataSelection} {\b selectTestRect} (const QRectF &rect, bool onlySelectable) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findBegin} (double sortKey, bool expandedRange=true) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findEnd} (double sortKey, bool expandedRange=true) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPPlottableInterface1D} * {\b interface1D} () {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getErrorBarLines} (QCPErrorBarsDataContainer::const_iterator it, QVector< QLineF > &backbones, QVector< QLineF > &whiskers) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getVisibleDataBounds} (QCPErrorBarsDataContainer::const_iterator &begin, QCPErrorBarsDataContainer::const_iterator &end, const {\b QCPDataRange} &rangeRestriction) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b pointDistance} (const QPointF &pixelPoint, QCPErrorBarsDataContainer::const_iterator &closestData) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getDataSegments} (QList< {\b QCPDataRange} > &selectedSegments, QList< {\b QCPDataRange} > &unselectedSegments) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b errorBarVisible} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rectIntersectsLine} (const QRectF &pixelRect, const QLineF &line) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPErrorBarsDataContainer} > {\b mDataContainer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAbstractPlottable} > {\b mDataPlottable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ErrorType} {\b mErrorType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mWhiskerWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mSymbolGap}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable that adds a set of error bars to other plottables. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
The {\b QCPErrorBars} plottable can be attached to other one-dimensional plottables (e.g. {\b QCPGraph}, {\b QCPCurve}, {\b QCPBars}, etc.) and equips them with error bars.\par
Use {\b setDataPlottable} to define for which plottable the {\b QCPErrorBars} shall display the error bars. The orientation of the error bars can be controlled with {\b setErrorType}.\par
By using {\b setData}, you can supply the actual error data, either as symmetric error or plus/minus asymmetric errors. {\b QCPErrorBars} only stores the error data. The absolute key/value position of each error bar will be adopted from the configured data plottable. The error data of the {\b QCPErrorBars} are associated one-to-one via their index to the data points of the data plottable. You can directly access and manipulate the error bar data via {\b data}.\par
Set either of the plus/minus errors to NaN ({\f2 qQNaN()}  or {\f2 std::numeric_limits<double>::quiet_NaN()} ) to not show the respective error bar on the data point at that index.\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Changing the appearance
\par}
{\tc\tcl2 \v Changing the appearance}
The appearance of the error bars is defined by the pen ({\b setPen}), and the width of the whiskers ({\b setWhiskerWidth}). Further, the error bar backbones may leave a gap around the data point center to prevent that error bars are drawn too close to or even through scatter points. This gap size can be controlled via {\b setSymbolGap}. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ErrorType\:QCPErrorBars}
{\xe \v QCPErrorBars\:ErrorType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPErrorBars::ErrorType}}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines in which orientation the error bars shall appear. If your data needs both error dimensions, create two {\b QCPErrorBars} with different {\b ErrorType}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setErrorType} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v etKeyError\:QCPErrorBars}
{\xe \v QCPErrorBars\:etKeyError}
{\qr etKeyError{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The errors are for the key dimension (bars appear parallel to the key axis) \par
}\cell }{\row }
{\xe \v etValueError\:QCPErrorBars}
{\xe \v QCPErrorBars\:etValueError}
{\qr etValueError{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The errors are for the value dimension (bars appear parallel to the value axis) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6002                  \{ etKeyError    \par
 6003                    ,etValueError \par
 6004   \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPErrorBars\:QCPErrorBars}
{\xe \v QCPErrorBars\:QCPErrorBars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPErrorBars::QCPErrorBars ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an error bars plottable which uses {\i keyAxis}  as its key axis ("x") and {\i valueAxis}  as its value axis ("y"). {\i keyAxis}  and {\i valueAxis}  must reside in the same {\b QCustomPlot} instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.\par
It is also important that the {\i keyAxis}  and {\i valueAxis}  are the same for the error bars plottable and the data plottable that the error bars shall be drawn on ({\b setDataPlottable}).\par
The created {\b QCPErrorBars} is automatically registered with the {\b QCustomPlot} instance inferred from {\i keyAxis} . This {\b QCustomPlot} instance takes ownership of the {\b QCPErrorBars}, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27119                                                                :\par
27120   QCPAbstractPlottable(keyAxis, valueAxis),\par
27121   mDataContainer(new QVector<QCPErrorBarsData>),\par
27122   mErrorType(etValueError),\par
27123   mWhiskerWidth(9),\par
27124   mSymbolGap(10)\par
27125 \{\par
27126   setPen(QPen(Qt::black, 0));\par
27127   setBrush(Qt::NoBrush);\par
27128 \}\par
}
}
{\xe \v ~QCPErrorBars\:QCPErrorBars}
{\xe \v QCPErrorBars\:~QCPErrorBars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPErrorBars::~QCPErrorBars (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27131 \{\par
27132 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addData\:QCPErrorBars}
{\xe \v QCPErrorBars\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::addData (const QVector< double > &  {\i error})}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds symmetrical error values as specified in {\i error} . The errors will be associated one-to-one by the data point index to the associated data plottable ({\b setDataPlottable}).\par
You can directly access and manipulate the error bar data via {\b data}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27258 \{\par
27259   addData(error, error);\par
27260 \}\par
}
}
{\xe \v addData\:QCPErrorBars}
{\xe \v QCPErrorBars\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::addData (const QVector< double > &  {\i errorMinus}, const QVector< double > &  {\i errorPlus})}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds asymmetrical errors as specified in {\i errorMinus}  and {\i errorPlus} . The errors will be associated one-to-one by the data point index to the associated data plottable ({\b setDataPlottable}).\par
You can directly access and manipulate the error bar data via {\b data}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27273 \{\par
27274   if (errorMinus.size() != errorPlus.size())\par
27275     qDebug() << Q_FUNC_INFO << "minus and plus error vectors have different sizes:" << errorMinus.size() << errorPlus.size();\par
27276   const int n = qMin(errorMinus.size(), errorPlus.size());\par
27277   mDataContainer->reserve(n);\par
27278   for (int i=0; i<n; ++i)\par
27279     mDataContainer->append(QCPErrorBarsData(errorMinus.at(i), errorPlus.at(i)));\par
27280 \}\par
}
}
{\xe \v addData\:QCPErrorBars}
{\xe \v QCPErrorBars\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::addData (double  {\i error})}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds a single symmetrical error bar as specified in {\i error} . The errors will be associated one-to-one by the data point index to the associated data plottable ({\b setDataPlottable}).\par
You can directly access and manipulate the error bar data via {\b data}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27292 \{\par
27293   mDataContainer->append(QCPErrorBarsData(error));\par
27294 \}\par
}
}
{\xe \v addData\:QCPErrorBars}
{\xe \v QCPErrorBars\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::addData (double  {\i errorMinus}, double  {\i errorPlus})}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds a single asymmetrical error bar as specified in {\i errorMinus}  and {\i errorPlus} . The errors will be associated one-to-one by the data point index to the associated data plottable ({\b setDataPlottable}).\par
You can directly access and manipulate the error bar data via {\b data}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27307 \{\par
27308   mDataContainer->append(QCPErrorBarsData(errorMinus, errorPlus));\par
27309 \}\par
}
}
{\xe \v data\:QCPErrorBars}
{\xe \v QCPErrorBars\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer< {\b QCPErrorBarsDataContainer} > QCPErrorBars::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a shared pointer to the internal data storage of type {\b QCPErrorBarsDataContainer}. You may use it to directly manipulate the error values, which may be more convenient and faster than using the regular {\b setData} methods. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6010 \{ return mDataContainer; \}\par
}
}
{\xe \v dataCount\:QCPErrorBars}
{\xe \v QCPErrorBars\:dataCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPErrorBars::dataCount () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data points of the plottable. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27313 \{\par
27314   return mDataContainer->size();\par
27315 \}\par
}
}
{\xe \v dataMainKey\:QCPErrorBars}
{\xe \v QCPErrorBars\:dataMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBars::dataMainKey (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main key of the data point at the given {\i index} .\par
What the main key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27319 \{\par
27320   if (mDataPlottable)\par
27321     return mDataPlottable->interface1D()->dataMainKey(index);\par
27322   else\par
27323     qDebug() << Q_FUNC_INFO << "no data plottable set";\par
27324   return 0;\par
27325 \}\par
}
}
{\xe \v dataMainValue\:QCPErrorBars}
{\xe \v QCPErrorBars\:dataMainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBars::dataMainValue (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main value of the data point at the given {\i index} .\par
What the main value is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27339 \{\par
27340   if (mDataPlottable)\par
27341     return mDataPlottable->interface1D()->dataMainValue(index);\par
27342   else\par
27343     qDebug() << Q_FUNC_INFO << "no data plottable set";\par
27344   return 0;\par
27345 \}\par
}
}
{\xe \v dataPixelPosition\:QCPErrorBars}
{\xe \v QCPErrorBars\:dataPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPErrorBars::dataPixelPosition (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position on the widget surface at which the data point at the given {\i index}  appears.\par
Usually this corresponds to the point of {\b dataMainKey}/{\b dataMainValue}, in pixel coordinates. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values. For example, {\b QCPBars} apparent data values can be shifted depending on their stacking, bar grouping or configured base value. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27366 \{\par
27367   if (mDataPlottable)\par
27368     return mDataPlottable->interface1D()->dataPixelPosition(index);\par
27369   else\par
27370     qDebug() << Q_FUNC_INFO << "no data plottable set";\par
27371   return QPointF();\par
27372 \}\par
}
}
{\xe \v dataPlottable\:QCPErrorBars}
{\xe \v QCPErrorBars\:dataPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable}* QCPErrorBars::dataPlottable () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6011 \{ return mDataPlottable.data(); \}\par
}
}
{\xe \v dataSortKey\:QCPErrorBars}
{\xe \v QCPErrorBars\:dataSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBars::dataSortKey (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the sort key of the data point at the given {\i index} .\par
What the sort key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27329 \{\par
27330   if (mDataPlottable)\par
27331     return mDataPlottable->interface1D()->dataSortKey(index);\par
27332   else\par
27333     qDebug() << Q_FUNC_INFO << "no data plottable set";\par
27334   return 0;\par
27335 \}\par
}
}
{\xe \v dataValueRange\:QCPErrorBars}
{\xe \v QCPErrorBars\:dataValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPErrorBars::dataValueRange (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the value range of the data point at the given {\i index} .\par
What the value range is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27349 \{\par
27350   if (mDataPlottable)\par
27351   \{\par
27352     const double value = mDataPlottable->interface1D()->dataMainValue(index);\par
27353     if (index >= 0 && index < mDataContainer->size() && mErrorType == etValueError)\par
27354       return QCPRange(value-mDataContainer->at(index).errorMinus, value+mDataContainer->at(index).errorPlus);\par
27355     else\par
27356       return QCPRange(value, value);\par
27357   \} else\par
27358   \{\par
27359     qDebug() << Q_FUNC_INFO << "no data plottable set";\par
27360     return QCPRange();\par
27361   \}\par
27362 \}\par
}
}
{\xe \v draw\:QCPErrorBars}
{\xe \v QCPErrorBars\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27480 \{\par
27481   if (!mDataPlottable) return;\par
27482   if (!mKeyAxis || !mValueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
27483   if (mKeyAxis.data()->range().size() <= 0 || mDataContainer->isEmpty()) return;\par
27484   \par
27485   // if the sort key isn't the main key, we must check the visibility for each data point/error bar individually\par
27486   // (getVisibleDataBounds applies range restriction, but otherwise can only return full data range):\par
27487   bool checkPointVisibility = !mDataPlottable->interface1D()->sortKeyIsMainKey();\par
27488       \par
27489     // check data validity if flag set:\par
27490 #ifdef QCUSTOMPLOT_CHECK_DATA\par
27491   QCPErrorBarsDataContainer::const_iterator it;\par
27492   for (it = mDataContainer->constBegin(); it != mDataContainer->constEnd(); ++it)\par
27493   \{\par
27494     if (QCP::isInvalidData(it->errorMinus, it->errorPlus))\par
27495       qDebug() << Q_FUNC_INFO << "Data point at index" << it-mDataContainer->constBegin() << "invalid." << "Plottable name:" << name();\par
27496   \}\par
27497 #endif\par
27498   \par
27499   applyDefaultAntialiasingHint(painter);\par
27500   painter->setBrush(Qt::NoBrush);\par
27501   // loop over and draw segments of unselected/selected data:\par
27502   QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;\par
27503   getDataSegments(selectedSegments, unselectedSegments);\par
27504   allSegments << unselectedSegments << selectedSegments;\par
27505   QVector<QLineF> backbones, whiskers;\par
27506   for (int i=0; i<allSegments.size(); ++i)\par
27507   \{\par
27508     QCPErrorBarsDataContainer::const_iterator begin, end;\par
27509     getVisibleDataBounds(begin, end, allSegments.at(i));\par
27510     if (begin == end)\par
27511       continue;\par
27512     \par
27513     bool isSelectedSegment = i >= unselectedSegments.size();\par
27514     if (isSelectedSegment && mSelectionDecorator)\par
27515       mSelectionDecorator->applyPen(painter);\par
27516     else\par
27517       painter->setPen(mPen);\par
27518     if (painter->pen().capStyle() == Qt::SquareCap)\par
27519     \{\par
27520       QPen capFixPen(painter->pen());\par
27521       capFixPen.setCapStyle(Qt::FlatCap);\par
27522       painter->setPen(capFixPen);\par
27523     \}\par
27524     backbones.clear();\par
27525     whiskers.clear();\par
27526     for (QCPErrorBarsDataContainer::const_iterator it=begin; it!=end; ++it)\par
27527     \{\par
27528       if (!checkPointVisibility || errorBarVisible(it-mDataContainer->constBegin()))\par
27529         getErrorBarLines(it, backbones, whiskers);\par
27530     \}\par
27531     painter->drawLines(backbones);\par
27532     painter->drawLines(whiskers);\par
27533   \}\par
27534   \par
27535   // draw other selection decoration that isn't just line/scatter pens and brushes:\par
27536   if (mSelectionDecorator)\par
27537     mSelectionDecorator->drawDecoration(painter, selection());\par
27538 \}\par
}
}
{\xe \v drawLegendIcon\:QCPErrorBars}
{\xe \v QCPErrorBars\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27542 \{\par
27543   applyDefaultAntialiasingHint(painter);\par
27544   painter->setPen(mPen);\par
27545   if (mErrorType == etValueError && mValueAxis && mValueAxis->orientation() == Qt::Vertical)\par
27546   \{\par
27547     painter->drawLine(QLineF(rect.center().x(), rect.top()+2, rect.center().x(), rect.bottom()-1));\par
27548     painter->drawLine(QLineF(rect.center().x()-4, rect.top()+2, rect.center().x()+4, rect.top()+2));\par
27549     painter->drawLine(QLineF(rect.center().x()-4, rect.bottom()-1, rect.center().x()+4, rect.bottom()-1));\par
27550   \} else\par
27551   \{\par
27552     painter->drawLine(QLineF(rect.left()+2, rect.center().y(), rect.right()-2, rect.center().y()));\par
27553     painter->drawLine(QLineF(rect.left()+2, rect.center().y()-4, rect.left()+2, rect.center().y()+4));\par
27554     painter->drawLine(QLineF(rect.right()-2, rect.center().y()-4, rect.right()-2, rect.center().y()+4));\par
27555   \}\par
27556 \}\par
}
}
{\xe \v errorBarVisible\:QCPErrorBars}
{\xe \v QCPErrorBars\:errorBarVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPErrorBars::errorBarVisible (int  {\i index}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27927 \{\par
27928   QPointF centerPixel = mDataPlottable->interface1D()->dataPixelPosition(index);\par
27929   const double centerKeyPixel = mKeyAxis->orientation() == Qt::Horizontal ? centerPixel.x() : centerPixel.y();\par
27930   if (qIsNaN(centerKeyPixel))\par
27931     return false;\par
27932   \par
27933   double keyMin, keyMax;\par
27934   if (mErrorType == etKeyError)\par
27935   \{\par
27936     const double centerKey = mKeyAxis->pixelToCoord(centerKeyPixel);\par
27937     const double errorPlus = mDataContainer->at(index).errorPlus;\par
27938     const double errorMinus = mDataContainer->at(index).errorMinus;\par
27939     keyMax = centerKey+(qIsNaN(errorPlus) ? 0 : errorPlus);\par
27940     keyMin = centerKey-(qIsNaN(errorMinus) ? 0 : errorMinus);\par
27941   \} else // mErrorType == etValueError\par
27942   \{\par
27943     keyMax = mKeyAxis->pixelToCoord(centerKeyPixel+mWhiskerWidth*0.5*mKeyAxis->pixelOrientation());\par
27944     keyMin = mKeyAxis->pixelToCoord(centerKeyPixel-mWhiskerWidth*0.5*mKeyAxis->pixelOrientation());\par
27945   \}\par
27946   return ((keyMax > mKeyAxis->range().lower) && (keyMin < mKeyAxis->range().upper));\par
27947 \}\par
}
}
{\xe \v errorType\:QCPErrorBars}
{\xe \v QCPErrorBars\:errorType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} QCPErrorBars::errorType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6012 \{ return mErrorType; \}\par
}
}
{\xe \v findBegin\:QCPErrorBars}
{\xe \v QCPErrorBars\:findBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPErrorBars::findBegin (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index of the data point with a (sort-)key that is equal to, just below, or just above {\i sortKey} . If {\i expandedRange}  is true, the data point just below {\i sortKey}  will be considered, otherwise the one just above.\par
This can be used in conjunction with {\b findEnd} to iterate over data points within a given key range, including or excluding the bounding data points that are just beyond the specified range.\par
If {\i expandedRange}  is true but there are no data points below {\i sortKey} , 0 is returned.\par
If the container is empty, returns 0 (in that case, {\b findEnd} will also return 0, so a loop using these methods will not iterate over the index 0).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findEnd}, {\b QCPDataContainer::findBegin} \par
}}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27424 \{\par
27425   if (mDataPlottable)\par
27426   \{\par
27427     if (mDataContainer->isEmpty())\par
27428       return 0;\par
27429     int beginIndex = mDataPlottable->interface1D()->findBegin(sortKey, expandedRange);\par
27430     if (beginIndex >= mDataContainer->size())\par
27431       beginIndex = mDataContainer->size()-1;\par
27432     return beginIndex;\par
27433   \} else\par
27434     qDebug() << Q_FUNC_INFO << "no data plottable set";\par
27435   return 0;\par
27436 \}\par
}
}
{\xe \v findEnd\:QCPErrorBars}
{\xe \v QCPErrorBars\:findEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPErrorBars::findEnd (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index one after the data point with a (sort-)key that is equal to, just above, or just below {\i sortKey} . If {\i expandedRange}  is true, the data point just above {\i sortKey}  will be considered, otherwise the one just below.\par
This can be used in conjunction with {\b findBegin} to iterate over data points within a given key range, including the bounding data points that are just below and above the specified range.\par
If {\i expandedRange}  is true but there are no data points above {\i sortKey} , the index just above the highest data point is returned.\par
If the container is empty, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findBegin}, {\b QCPDataContainer::findEnd} \par
}}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27440 \{\par
27441   if (mDataPlottable)\par
27442   \{\par
27443     if (mDataContainer->isEmpty())\par
27444       return 0;\par
27445     int endIndex = mDataPlottable->interface1D()->findEnd(sortKey, expandedRange);\par
27446     if (endIndex > mDataContainer->size())\par
27447       endIndex = mDataContainer->size();\par
27448     return endIndex;\par
27449   \} else\par
27450     qDebug() << Q_FUNC_INFO << "no data plottable set";\par
27451   return 0;\par
27452 \}\par
}
}
{\xe \v getDataSegments\:QCPErrorBars}
{\xe \v QCPErrorBars\:getDataSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::getDataSegments (QList< {\b QCPDataRange} > &  {\i selectedSegments}, QList< {\b QCPDataRange} > &  {\i unselectedSegments}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27899 \{\par
27900   selectedSegments.clear();\par
27901   unselectedSegments.clear();\par
27902   if (mSelectable == QCP::stWhole) // stWhole selection type draws the entire plottable with selected style if mSelection isn't empty\par
27903   \{\par
27904     if (selected())\par
27905       selectedSegments << QCPDataRange(0, dataCount());\par
27906     else\par
27907       unselectedSegments << QCPDataRange(0, dataCount());\par
27908   \} else\par
27909   \{\par
27910     QCPDataSelection sel(selection());\par
27911     sel.simplify();\par
27912     selectedSegments = sel.dataRanges();\par
27913     unselectedSegments = sel.inverse(QCPDataRange(0, dataCount())).dataRanges();\par
27914   \}\par
27915 \}\par
}
}
{\xe \v getErrorBarLines\:QCPErrorBars}
{\xe \v QCPErrorBars\:getErrorBarLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::getErrorBarLines (QCPErrorBarsDataContainer::const_iterator  {\i it}, QVector< QLineF > &  {\i backbones}, QVector< QLineF > &  {\i whiskers}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27731 \{\par
27732   if (!mDataPlottable) return;\par
27733   \par
27734   int index = it-mDataContainer->constBegin();\par
27735   QPointF centerPixel = mDataPlottable->interface1D()->dataPixelPosition(index);\par
27736   if (qIsNaN(centerPixel.x()) || qIsNaN(centerPixel.y()))\par
27737     return;\par
27738   QCPAxis *errorAxis = mErrorType == etValueError ? mValueAxis.data() : mKeyAxis.data();\par
27739   QCPAxis *orthoAxis = mErrorType == etValueError ? mKeyAxis.data() : mValueAxis.data();\par
27740   const double centerErrorAxisPixel = errorAxis->orientation() == Qt::Horizontal ? centerPixel.x() : centerPixel.y();\par
27741   const double centerOrthoAxisPixel = orthoAxis->orientation() == Qt::Horizontal ? centerPixel.x() : centerPixel.y();\par
27742   const double centerErrorAxisCoord = errorAxis->pixelToCoord(centerErrorAxisPixel); // depending on plottable, this might be different from just mDataPlottable->interface1D()->dataMainKey/Value\par
27743   const double symbolGap = mSymbolGap*0.5*errorAxis->pixelOrientation();\par
27744   // plus error:\par
27745   double errorStart, errorEnd;\par
27746   if (!qIsNaN(it->errorPlus))\par
27747   \{\par
27748     errorStart = centerErrorAxisPixel+symbolGap;\par
27749     errorEnd = errorAxis->coordToPixel(centerErrorAxisCoord+it->errorPlus);\par
27750     if (errorAxis->orientation() == Qt::Vertical)\par
27751     \{\par
27752       if ((errorStart > errorEnd) != errorAxis->rangeReversed())\par
27753         backbones.append(QLineF(centerOrthoAxisPixel, errorStart, centerOrthoAxisPixel, errorEnd));\par
27754       whiskers.append(QLineF(centerOrthoAxisPixel-mWhiskerWidth*0.5, errorEnd, centerOrthoAxisPixel+mWhiskerWidth*0.5, errorEnd));\par
27755     \} else\par
27756     \{\par
27757       if ((errorStart < errorEnd) != errorAxis->rangeReversed())\par
27758         backbones.append(QLineF(errorStart, centerOrthoAxisPixel, errorEnd, centerOrthoAxisPixel));\par
27759       whiskers.append(QLineF(errorEnd, centerOrthoAxisPixel-mWhiskerWidth*0.5, errorEnd, centerOrthoAxisPixel+mWhiskerWidth*0.5));\par
27760     \}\par
27761   \}\par
27762   // minus error:\par
27763   if (!qIsNaN(it->errorMinus))\par
27764   \{\par
27765     errorStart = centerErrorAxisPixel-symbolGap;\par
27766     errorEnd = errorAxis->coordToPixel(centerErrorAxisCoord-it->errorMinus);\par
27767     if (errorAxis->orientation() == Qt::Vertical)\par
27768     \{\par
27769       if ((errorStart < errorEnd) != errorAxis->rangeReversed())\par
27770         backbones.append(QLineF(centerOrthoAxisPixel, errorStart, centerOrthoAxisPixel, errorEnd));\par
27771       whiskers.append(QLineF(centerOrthoAxisPixel-mWhiskerWidth*0.5, errorEnd, centerOrthoAxisPixel+mWhiskerWidth*0.5, errorEnd));\par
27772     \} else\par
27773     \{\par
27774       if ((errorStart > errorEnd) != errorAxis->rangeReversed())\par
27775         backbones.append(QLineF(errorStart, centerOrthoAxisPixel, errorEnd, centerOrthoAxisPixel));\par
27776       whiskers.append(QLineF(errorEnd, centerOrthoAxisPixel-mWhiskerWidth*0.5, errorEnd, centerOrthoAxisPixel+mWhiskerWidth*0.5));\par
27777     \}\par
27778   \}\par
27779 \}\par
}
}
{\xe \v getKeyRange\:QCPErrorBars}
{\xe \v QCPErrorBars\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPErrorBars::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27560 \{\par
27561   if (!mDataPlottable)\par
27562   \{\par
27563     foundRange = false;\par
27564     return QCPRange();\par
27565   \}\par
27566   \par
27567   QCPRange range;\par
27568   bool haveLower = false;\par
27569   bool haveUpper = false;\par
27570   QCPErrorBarsDataContainer::const_iterator it;\par
27571   for (it = mDataContainer->constBegin(); it != mDataContainer->constEnd(); ++it)\par
27572   \{\par
27573     if (mErrorType == etValueError)\par
27574     \{\par
27575       // error bar doesn't extend in key dimension (except whisker but we ignore that here), so only use data point center\par
27576       const double current = mDataPlottable->interface1D()->dataMainKey(it-mDataContainer->constBegin());\par
27577       if (qIsNaN(current)) continue;\par
27578       if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))\par
27579       \{\par
27580         if (current < range.lower || !haveLower)\par
27581         \{\par
27582           range.lower = current;\par
27583           haveLower = true;\par
27584         \}\par
27585         if (current > range.upper || !haveUpper)\par
27586         \{\par
27587           range.upper = current;\par
27588           haveUpper = true;\par
27589         \}\par
27590       \}\par
27591     \} else // mErrorType == etKeyError\par
27592     \{\par
27593       const double dataKey = mDataPlottable->interface1D()->dataMainKey(it-mDataContainer->constBegin());\par
27594       if (qIsNaN(dataKey)) continue;\par
27595       // plus error:\par
27596       double current = dataKey + (qIsNaN(it->errorPlus) ? 0 : it->errorPlus);\par
27597       if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))\par
27598       \{\par
27599         if (current > range.upper || !haveUpper)\par
27600         \{\par
27601           range.upper = current;\par
27602           haveUpper = true;\par
27603         \}\par
27604       \}\par
27605       // minus error:\par
27606       current = dataKey - (qIsNaN(it->errorMinus) ? 0 : it->errorMinus);\par
27607       if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))\par
27608       \{\par
27609         if (current < range.lower || !haveLower)\par
27610         \{\par
27611           range.lower = current;\par
27612           haveLower = true;\par
27613         \}\par
27614       \}\par
27615     \}\par
27616   \}\par
27617   \par
27618   if (haveUpper && !haveLower)\par
27619   \{\par
27620     range.lower = range.upper;\par
27621     haveLower = true;\par
27622   \} else if (haveLower && !haveUpper)\par
27623   \{\par
27624     range.upper = range.lower;\par
27625     haveUpper = true;\par
27626   \}\par
27627   \par
27628   foundRange = haveLower && haveUpper;\par
27629   return range;\par
27630 \}\par
}
}
{\xe \v getValueRange\:QCPErrorBars}
{\xe \v QCPErrorBars\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPErrorBars::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27634 \{\par
27635   if (!mDataPlottable)\par
27636   \{\par
27637     foundRange = false;\par
27638     return QCPRange();\par
27639   \}\par
27640   \par
27641   QCPRange range;\par
27642   const bool restrictKeyRange = inKeyRange != QCPRange();\par
27643   bool haveLower = false;\par
27644   bool haveUpper = false;\par
27645   QCPErrorBarsDataContainer::const_iterator itBegin = mDataContainer->constBegin();\par
27646   QCPErrorBarsDataContainer::const_iterator itEnd = mDataContainer->constEnd();\par
27647   if (mDataPlottable->interface1D()->sortKeyIsMainKey() && restrictKeyRange)\par
27648   \{\par
27649     itBegin = mDataContainer->constBegin()+findBegin(inKeyRange.lower);\par
27650     itEnd = mDataContainer->constBegin()+findEnd(inKeyRange.upper);\par
27651   \}\par
27652   for (QCPErrorBarsDataContainer::const_iterator it = itBegin; it != itEnd; ++it)\par
27653   \{\par
27654     if (restrictKeyRange)\par
27655     \{\par
27656       const double dataKey = mDataPlottable->interface1D()->dataMainKey(it-mDataContainer->constBegin());\par
27657       if (dataKey < inKeyRange.lower || dataKey > inKeyRange.upper)\par
27658         continue;\par
27659     \}\par
27660     if (mErrorType == etValueError)\par
27661     \{\par
27662       const double dataValue = mDataPlottable->interface1D()->dataMainValue(it-mDataContainer->constBegin());\par
27663       if (qIsNaN(dataValue)) continue;\par
27664       // plus error:\par
27665       double current = dataValue + (qIsNaN(it->errorPlus) ? 0 : it->errorPlus);\par
27666       if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))\par
27667       \{\par
27668         if (current > range.upper || !haveUpper)\par
27669         \{\par
27670           range.upper = current;\par
27671           haveUpper = true;\par
27672         \}\par
27673       \}\par
27674       // minus error:\par
27675       current = dataValue - (qIsNaN(it->errorMinus) ? 0 : it->errorMinus);\par
27676       if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))\par
27677       \{\par
27678         if (current < range.lower || !haveLower)\par
27679         \{\par
27680           range.lower = current;\par
27681           haveLower = true;\par
27682         \}\par
27683       \}\par
27684     \} else // mErrorType == etKeyError\par
27685     \{\par
27686       // error bar doesn't extend in value dimension (except whisker but we ignore that here), so only use data point center\par
27687       const double current = mDataPlottable->interface1D()->dataMainValue(it-mDataContainer->constBegin());\par
27688       if (qIsNaN(current)) continue;\par
27689       if (inSignDomain == QCP::sdBoth || (inSignDomain == QCP::sdNegative && current < 0) || (inSignDomain == QCP::sdPositive && current > 0))\par
27690       \{\par
27691         if (current < range.lower || !haveLower)\par
27692         \{\par
27693           range.lower = current;\par
27694           haveLower = true;\par
27695         \}\par
27696         if (current > range.upper || !haveUpper)\par
27697         \{\par
27698           range.upper = current;\par
27699           haveUpper = true;\par
27700         \}\par
27701       \}\par
27702     \}\par
27703   \}\par
27704   \par
27705   if (haveUpper && !haveLower)\par
27706   \{\par
27707     range.lower = range.upper;\par
27708     haveLower = true;\par
27709   \} else if (haveLower && !haveUpper)\par
27710   \{\par
27711     range.upper = range.lower;\par
27712     haveUpper = true;\par
27713   \}\par
27714   \par
27715   foundRange = haveLower && haveUpper;\par
27716   return range;\par
27717 \}\par
}
}
{\xe \v getVisibleDataBounds\:QCPErrorBars}
{\xe \v QCPErrorBars\:getVisibleDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::getVisibleDataBounds (QCPErrorBarsDataContainer::const_iterator &  {\i begin}, QCPErrorBarsDataContainer::const_iterator &  {\i end}, const {\b QCPDataRange} &  {\i rangeRestriction}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27800 \{\par
27801   QCPAxis *keyAxis = mKeyAxis.data();\par
27802   QCPAxis *valueAxis = mValueAxis.data();\par
27803   if (!keyAxis || !valueAxis)\par
27804   \{\par
27805     qDebug() << Q_FUNC_INFO << "invalid key or value axis";\par
27806     end = mDataContainer->constEnd();\par
27807     begin = end;\par
27808     return;\par
27809   \}\par
27810   if (!mDataPlottable || rangeRestriction.isEmpty())\par
27811   \{\par
27812     end = mDataContainer->constEnd();\par
27813     begin = end;\par
27814     return;\par
27815   \}\par
27816   if (!mDataPlottable->interface1D()->sortKeyIsMainKey())\par
27817   \{\par
27818     // if the sort key isn't the main key, it's not possible to find a contiguous range of visible\par
27819     // data points, so this method then only applies the range restriction and otherwise returns\par
27820     // the full data range. Visibility checks must be done on a per-datapoin-basis during drawing\par
27821     QCPDataRange dataRange(0, mDataContainer->size());\par
27822     dataRange = dataRange.bounded(rangeRestriction);\par
27823     begin = mDataContainer->constBegin()+dataRange.begin();\par
27824     end = mDataContainer->constBegin()+dataRange.end();\par
27825     return;\par
27826   \}\par
27827   \par
27828   // get visible data range via interface from data plottable, and then restrict to available error data points:\par
27829   const int n = qMin(mDataContainer->size(), mDataPlottable->interface1D()->dataCount());\par
27830   int beginIndex = mDataPlottable->interface1D()->findBegin(keyAxis->range().lower);\par
27831   int endIndex = mDataPlottable->interface1D()->findEnd(keyAxis->range().upper);\par
27832   int i = beginIndex;\par
27833   while (i > 0 && i < n && i > rangeRestriction.begin())\par
27834   \{\par
27835     if (errorBarVisible(i))\par
27836       beginIndex = i;\par
27837     --i;\par
27838   \}\par
27839   i = endIndex;\par
27840   while (i >= 0 && i < n && i < rangeRestriction.end())\par
27841   \{\par
27842     if (errorBarVisible(i))\par
27843       endIndex = i+1;\par
27844     ++i;\par
27845   \}\par
27846   QCPDataRange dataRange(beginIndex, endIndex);\par
27847   dataRange = dataRange.bounded(rangeRestriction.bounded(QCPDataRange(0, mDataContainer->size())));\par
27848   begin = mDataContainer->constBegin()+dataRange.begin();\par
27849   end = mDataContainer->constBegin()+dataRange.end();\par
27850 \}\par
}
}
{\xe \v interface1D\:QCPErrorBars}
{\xe \v QCPErrorBars\:interface1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b QCPPlottableInterface1D}* QCPErrorBars::interface1D (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this plottable is a one-dimensional plottable, i.e. it implements the {\b QCPPlottableInterface1D}, returns the {\i this}  pointer with that type. Otherwise (e.g. in the case of a {\b QCPColorMap}) returns zero.\par
You can use this method to gain read access to data coordinates while holding a pointer to the abstract base class only. \par
}{
Reimplemented from {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6045 \{ return this; \}\par
}
}
{\xe \v pointDistance\:QCPErrorBars}
{\xe \v QCPErrorBars\:pointDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBars::pointDistance (const QPointF &  {\i pixelPoint}, QCPErrorBarsDataContainer::const_iterator &  {\i closestData}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27859 \{\par
27860   closestData = mDataContainer->constEnd();\par
27861   if (!mDataPlottable || mDataContainer->isEmpty())\par
27862     return -1.0;\par
27863   if (!mKeyAxis || !mValueAxis)\par
27864   \{\par
27865     qDebug() << Q_FUNC_INFO << "invalid key or value axis";\par
27866     return -1.0;\par
27867   \}\par
27868   \par
27869   QCPErrorBarsDataContainer::const_iterator begin, end;\par
27870   getVisibleDataBounds(begin, end, QCPDataRange(0, dataCount()));\par
27871   \par
27872   // calculate minimum distances to error backbones (whiskers are ignored for speed) and find closestData iterator:\par
27873   double minDistSqr = std::numeric_limits<double>::max();\par
27874   QVector<QLineF> backbones, whiskers;\par
27875   for (QCPErrorBarsDataContainer::const_iterator it=begin; it!=end; ++it)\par
27876   \{\par
27877     getErrorBarLines(it, backbones, whiskers);\par
27878     for (int i=0; i<backbones.size(); ++i)\par
27879     \{\par
27880       const double currentDistSqr = QCPVector2D(pixelPoint).distanceSquaredToLine(backbones.at(i));\par
27881       if (currentDistSqr < minDistSqr)\par
27882       \{\par
27883         minDistSqr = currentDistSqr;\par
27884         closestData = it;\par
27885       \}\par
27886     \}\par
27887   \}\par
27888   return qSqrt(minDistSqr);\par
27889 \}\par
}
}
{\xe \v rectIntersectsLine\:QCPErrorBars}
{\xe \v QCPErrorBars\:rectIntersectsLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPErrorBars::rectIntersectsLine (const QRectF &  {\i pixelRect}, const QLineF &  {\i line}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27957 \{\par
27958   if (pixelRect.left() > line.x1() && pixelRect.left() > line.x2())\par
27959     return false;\par
27960   else if (pixelRect.right() < line.x1() && pixelRect.right() < line.x2())\par
27961     return false;\par
27962   else if (pixelRect.top() > line.y1() && pixelRect.top() > line.y2())\par
27963     return false;\par
27964   else if (pixelRect.bottom() < line.y1() && pixelRect.bottom() < line.y2())\par
27965     return false;\par
27966   else\par
27967     return true;\par
27968 \}\par
}
}
{\xe \v selectTest\:QCPErrorBars}
{\xe \v QCPErrorBars\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBars::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27456 \{\par
27457   if (!mDataPlottable) return -1;\par
27458   \par
27459   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
27460     return -1;\par
27461   if (!mKeyAxis || !mValueAxis)\par
27462     return -1;\par
27463   \par
27464   if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))\par
27465   \{\par
27466     QCPErrorBarsDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();\par
27467     double result = pointDistance(pos, closestDataPoint);\par
27468     if (details)\par
27469     \{\par
27470       int pointIndex = closestDataPoint-mDataContainer->constBegin();\par
27471       details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));\par
27472     \}\par
27473     return result;\par
27474   \} else\par
27475     return -1;\par
27476 \}\par
}
}
{\xe \v selectTestRect\:QCPErrorBars}
{\xe \v QCPErrorBars\:selectTestRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPErrorBars::selectTestRect (const QRectF &  {\i rect}, bool  {\i onlySelectable}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection containing all the data points of this plottable which are contained (or hit by) {\i rect} . This is used mainly in the selection rect interaction for data selection (data selection mechanism).\par
If {\i onlySelectable}  is true, an empty {\b QCPDataSelection} is returned if this plottable is not selectable (i.e. if {\b QCPAbstractPlottable::setSelectable} is {\b QCP::stNone}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i rect}  must be a normalized rect (positive or zero width and height). This is especially important when using the rect of {\b QCPSelectionRect::accepted}, which is not necessarily normalized. Use {\f2 QRect::normalized()}  when passing a rect which might not be normalized. \par
}}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27391 \{\par
27392   QCPDataSelection result;\par
27393   if (!mDataPlottable)\par
27394     return result;\par
27395   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
27396     return result;\par
27397   if (!mKeyAxis || !mValueAxis)\par
27398     return result;\par
27399   \par
27400   QCPErrorBarsDataContainer::const_iterator visibleBegin, visibleEnd;\par
27401   getVisibleDataBounds(visibleBegin, visibleEnd, QCPDataRange(0, dataCount()));\par
27402   \par
27403   QVector<QLineF> backbones, whiskers;\par
27404   for (QCPErrorBarsDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)\par
27405   \{\par
27406     backbones.clear();\par
27407     whiskers.clear();\par
27408     getErrorBarLines(it, backbones, whiskers);\par
27409     for (int i=0; i<backbones.size(); ++i)\par
27410     \{\par
27411       if (rectIntersectsLine(rect, backbones.at(i)))\par
27412       \{\par
27413         result.addDataRange(QCPDataRange(it-mDataContainer->constBegin(), it-mDataContainer->constBegin()+1), false);\par
27414         break;\par
27415       \}\par
27416     \}\par
27417   \}\par
27418   result.simplify();\par
27419   return result;\par
27420 \}\par
}
}
{\xe \v setData\:QCPErrorBars}
{\xe \v QCPErrorBars\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::setData (QSharedPointer< {\b QCPErrorBarsDataContainer} >  {\i data})}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data container with the provided {\i data}  container.\par
Since a QSharedPointer is used, multiple {\b QCPErrorBars} instances may share the same data container safely. Modifying the data in the container will then affect all {\b QCPErrorBars} instances that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } If you do not wish to share containers, but create a copy from an existing container, assign the data containers directly: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }(This uses different notation compared with other plottables, because the {\b QCPErrorBars} uses a {\f2 QVector<QCPErrorBarsData>}  as its data container, instead of a {\b QCPDataContainer}.)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27153 \{\par
27154   mDataContainer = data;\par
27155 \}\par
}
}
{\xe \v setData\:QCPErrorBars}
{\xe \v QCPErrorBars\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::setData (const QVector< double > &  {\i error})}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets symmetrical error values as specified in {\i error} . The errors will be associated one-to-one by the data point index to the associated data plottable ({\b setDataPlottable}).\par
You can directly access and manipulate the error bar data via {\b data}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27167 \{\par
27168   mDataContainer->clear();\par
27169   addData(error);\par
27170 \}\par
}
}
{\xe \v setData\:QCPErrorBars}
{\xe \v QCPErrorBars\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::setData (const QVector< double > &  {\i errorMinus}, const QVector< double > &  {\i errorPlus})}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets asymmetrical errors as specified in {\i errorMinus}  and {\i errorPlus} . The errors will be associated one-to-one by the data point index to the associated data plottable ({\b setDataPlottable}).\par
You can directly access and manipulate the error bar data via {\b data}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27183 \{\par
27184   mDataContainer->clear();\par
27185   addData(errorMinus, errorPlus);\par
27186 \}\par
}
}
{\xe \v setDataPlottable\:QCPErrorBars}
{\xe \v QCPErrorBars\:setDataPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::setDataPlottable ({\b QCPAbstractPlottable} *  {\i plottable})}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the data plottable to which the error bars will be applied. The error values specified e.g. via {\b setData} will be associated one-to-one by the data point index to the data points of {\i plottable} . This means that the error bars will adopt the key/value coordinates of the data point with the same index.\par
The passed {\i plottable}  must be a one-dimensional plottable, i.e. it must implement the {\b QCPPlottableInterface1D}. Further, it must not be a {\b QCPErrorBars} instance itself. If either of these restrictions is violated, a corresponding qDebug output is generated, and the data plottable of this {\b QCPErrorBars} instance is set to zero.\par
For proper display, care must also be taken that the key and value axes of the {\i plottable}  match those configured for this {\b QCPErrorBars} instance. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27203 \{\par
27204   if (plottable && qobject_cast<QCPErrorBars*>(plottable))\par
27205   \{\par
27206     mDataPlottable = 0;\par
27207     qDebug() << Q_FUNC_INFO << "can't set another QCPErrorBars instance as data plottable";\par
27208     return;\par
27209   \}\par
27210   if (plottable && !plottable->interface1D())\par
27211   \{\par
27212     mDataPlottable = 0;\par
27213     qDebug() << Q_FUNC_INFO << "passed plottable doesn't implement 1d interface, can't associate with QCPErrorBars";\par
27214     return;\par
27215   \}\par
27216   \par
27217   mDataPlottable = plottable;\par
27218 \}\par
}
}
{\xe \v setErrorType\:QCPErrorBars}
{\xe \v QCPErrorBars\:setErrorType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::setErrorType ({\b ErrorType}  {\i type})}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets in which orientation the error bars shall appear on the data points. If your data needs both error dimensions, create two {\b QCPErrorBars} with different {\i type} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27225 \{\par
27226   mErrorType = type;\par
27227 \}\par
}
}
{\xe \v setSymbolGap\:QCPErrorBars}
{\xe \v QCPErrorBars\:setSymbolGap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::setSymbolGap (double  {\i pixels})}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the gap diameter around the data points that will be left out when drawing the error bar backbones. This gap prevents that error bars are drawn too close to or even through scatter points. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27244 \{\par
27245   mSymbolGap = pixels;\par
27246 \}\par
}
}
{\xe \v setWhiskerWidth\:QCPErrorBars}
{\xe \v QCPErrorBars\:setWhiskerWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPErrorBars::setWhiskerWidth (double  {\i pixels})}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the width of the whiskers (the short bars at the end of the actual error bar backbones) to {\i pixels} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27234 \{\par
27235   mWhiskerWidth = pixels;\par
27236 \}\par
}
}
{\xe \v sortKeyIsMainKey\:QCPErrorBars}
{\xe \v QCPErrorBars\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPErrorBars::sortKeyIsMainKey () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the sort key ({\b dataSortKey}) is identical to the main key ({\b dataMainKey}).\par
What the sort and main keys are, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implements {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27376 \{\par
27377   if (mDataPlottable)\par
27378   \{\par
27379     return mDataPlottable->interface1D()->sortKeyIsMainKey();\par
27380   \} else\par
27381   \{\par
27382     qDebug() << Q_FUNC_INFO << "no data plottable set";\par
27383     return true;\par
27384   \}\par
27385 \}\par
}
}
{\xe \v symbolGap\:QCPErrorBars}
{\xe \v QCPErrorBars\:symbolGap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBars::symbolGap () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6014 \{ return mSymbolGap; \}\par
}
}
{\xe \v whiskerWidth\:QCPErrorBars}
{\xe \v QCPErrorBars\:whiskerWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBars::whiskerWidth () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6013 \{ return mWhiskerWidth; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLegend\:QCPErrorBars}
{\xe \v QCPErrorBars\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPErrorBars}
{\xe \v QCPErrorBars\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mDataContainer\:QCPErrorBars}
{\xe \v QCPErrorBars\:mDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer<{\b QCPErrorBarsDataContainer}> QCPErrorBars::mDataContainer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataPlottable\:QCPErrorBars}
{\xe \v QCPErrorBars\:mDataPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAbstractPlottable}> QCPErrorBars::mDataPlottable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mErrorType\:QCPErrorBars}
{\xe \v QCPErrorBars\:mErrorType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ErrorType} QCPErrorBars::mErrorType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSymbolGap\:QCPErrorBars}
{\xe \v QCPErrorBars\:mSymbolGap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBars::mSymbolGap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWhiskerWidth\:QCPErrorBars}
{\xe \v QCPErrorBars\:mWhiskerWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBars::mWhiskerWidth{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPErrorBarsData Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPErrorBarsData}
{\xe \v QCPErrorBarsData}
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single error bar for {\b QCPErrorBars}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPErrorBarsData:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_error_bars_data__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPErrorBarsData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPErrorBarsData} (double error)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPErrorBarsData} (double {\b errorMinus}, double {\b errorPlus})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b errorMinus}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b errorPlus}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single error bar for {\b QCPErrorBars}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The stored data is: {
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i errorMinus:}  how much the error bar extends towards negative coordinates from the data point position \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i errorPlus:}  how much the error bar extends towards positive coordinates from the data point position\par
}
The container for storing the error bar information is {\b QCPErrorBarsDataContainer}. It is a typedef for {\f2 QVector<{\b QCPErrorBarsData}>} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b QCPErrorBarsDataContainer} \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPErrorBarsData\:QCPErrorBarsData}
{\xe \v QCPErrorBarsData\:QCPErrorBarsData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPErrorBarsData::QCPErrorBarsData ()}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an error bar with errors set to zero. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27036                                    :\par
27037   errorMinus(0),\par
27038   errorPlus(0)\par
27039 \{\par
27040 \}\par
}
}
{\xe \v QCPErrorBarsData\:QCPErrorBarsData}
{\xe \v QCPErrorBarsData\:QCPErrorBarsData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPErrorBarsData::QCPErrorBarsData (double  {\i error}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an error bar with equal {\i error}  in both negative and positive direction. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27045                                                :\par
27046   errorMinus(error),\par
27047   errorPlus(error)\par
27048 \{\par
27049 \}\par
}
}
{\xe \v QCPErrorBarsData\:QCPErrorBarsData}
{\xe \v QCPErrorBarsData\:QCPErrorBarsData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPErrorBarsData::QCPErrorBarsData (double  {\i errorMinus}, double  {\i errorPlus})}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an error bar with negative and positive errors set to {\i errorMinus}  and {\i errorPlus} , respectively. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27055                                                                       :\par
27056   errorMinus(errorMinus),\par
27057   errorPlus(errorPlus)\par
27058 \{\par
27059 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v errorMinus\:QCPErrorBarsData}
{\xe \v QCPErrorBarsData\:errorMinus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBarsData::errorMinus}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v errorPlus\:QCPErrorBarsData}
{\xe \v QCPErrorBarsData\:errorPlus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPErrorBarsData::errorPlus}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPFinancial Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPFinancial}
{\xe \v QCPFinancial}
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a financial stock chart. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPFinancial:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_financial__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPFinancial:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_financial__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b WidthType} \{ {\b wtAbsolute}, 
{\b wtAxisRectRatio}, 
{\b wtPlotCoords}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ChartStyle} \{ {\b csOhlc}, 
{\b csCandlestick}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPFinancial} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPFinancial} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPFinancialDataContainer} > {\b data} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChartStyle} {\b chartStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b width} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WidthType} {\b widthType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b twoColored} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brushPositive} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brushNegative} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b penPositive} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b penNegative} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (QSharedPointer< {\b QCPFinancialDataContainer} > {\b data})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (const QVector< double > &keys, const QVector< double > &open, const QVector< double > &high, const QVector< double > &low, const QVector< double > &close, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setChartStyle} ({\b ChartStyle} style)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWidth} (double {\b width})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWidthType} ({\b WidthType} {\b widthType})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTwoColored} (bool {\b twoColored})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrushPositive} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrushNegative} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPenPositive} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPenNegative} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (const QVector< double > &keys, const QVector< double > &open, const QVector< double > &high, const QVector< double > &low, const QVector< double > &close, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (double key, double open, double high, double low, double close)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPDataSelection} {\b selectTestRect} (const QRectF &rect, bool onlySelectable) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b QCPFinancialDataContainer} {\b timeSeriesToOhlc} (const QVector< double > &time, const QVector< double > &value, double timeBinSize, double timeBinOffset=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawOhlcPlot} ({\b QCPPainter} *painter, const {\b QCPFinancialDataContainer::const_iterator} &begin, const {\b QCPFinancialDataContainer::const_iterator} &end, bool isSelected)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawCandlestickPlot} ({\b QCPPainter} *painter, const {\b QCPFinancialDataContainer::const_iterator} &begin, const {\b QCPFinancialDataContainer::const_iterator} &end, bool isSelected)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getPixelWidth} (double key, double keyPixel) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b ohlcSelectTest} (const QPointF &pos, const {\b QCPFinancialDataContainer::const_iterator} &begin, const {\b QCPFinancialDataContainer::const_iterator} &end, {\b QCPFinancialDataContainer::const_iterator} &closestDataPoint) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b candlestickSelectTest} (const QPointF &pos, const {\b QCPFinancialDataContainer::const_iterator} &begin, const {\b QCPFinancialDataContainer::const_iterator} &end, {\b QCPFinancialDataContainer::const_iterator} &closestDataPoint) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getVisibleDataBounds} ({\b QCPFinancialDataContainer::const_iterator} &begin, {\b QCPFinancialDataContainer::const_iterator} &end) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRectF {\b selectionHitBox} ({\b QCPFinancialDataContainer::const_iterator} it) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChartStyle} {\b mChartStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WidthType} {\b mWidthType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mTwoColored}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrushPositive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrushNegative}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPenPositive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPenNegative}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a financial stock chart. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
This plottable represents time series data binned to certain intervals, mainly used for stock charts. The two common representations OHLC (Open-High-Low-Close) bars and Candlesticks can be set via {\b setChartStyle}.\par
The data is passed via {\b setData} as a set of open/high/low/close values at certain keys (typically times). This means the data must be already binned appropriately. If data is only available as a series of values (e.g. {\i price}  against {\i time} ), you can use the static convenience function {\b timeSeriesToOhlc} to generate binned OHLC-data which can then be passed to {\b setData}.\par
The width of the OHLC bars/candlesticks can be controlled with {\b setWidth} and {\b setWidthType}. A typical choice is to set the width type to {\b wtPlotCoords} (the default) and the width to (or slightly less than) one time bin interval width.\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Changing the appearance
\par}
{\tc\tcl2 \v Changing the appearance}
Charts can be either single- or two-colored ({\b setTwoColored}). If set to be single-colored, lines are drawn with the plottable's pen ({\b setPen}) and fills with the brush ({\b setBrush}).\par
If set to two-colored, positive changes of the value during an interval ({\i close}  >= {\i open} ) are represented with a different pen and brush than negative changes ({\i close}  < {\i open} ). These can be configured with {\b setPenPositive}, {\b setPenNegative}, {\b setBrushPositive}, and {\b setBrushNegative}. In two-colored mode, the normal plottable pen/brush is ignored. Upon selection however, the normal selected pen/brush (provided by the {\b selectionDecorator}) is used, irrespective of whether the chart is single- or two-colored.\par}
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
Like all data representing objects in {\b QCustomPlot}, the {\b QCPFinancial} is a plottable ({\b QCPAbstractPlottable}). So the plottable-interface of {\b QCustomPlot} applies ({\b QCustomPlot::plottable}, {\b QCustomPlot::removePlottable}, etc.)\par
Usually, you first create an instance:\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }which registers it with the {\b QCustomPlot} instance of the passed axes. Note that this {\b QCustomPlot} instance takes ownership of the plottable, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. The newly created plottable can be modified, e.g.:\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }Here we have used the static helper method {\b timeSeriesToOhlc}, to turn a time-price data series into a 24-hour binned open-high-low-close data series as {\b QCPFinancial} uses. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ChartStyle\:QCPFinancial}
{\xe \v QCPFinancial\:ChartStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPFinancial::ChartStyle}}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the possible representations of OHLC data in the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setChartStyle} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v csOhlc\:QCPFinancial}
{\xe \v QCPFinancial\:csOhlc}
{\qr csOhlc{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Open-High-Low-Close bar representation. \par
}\cell }{\row }
{\xe \v csCandlestick\:QCPFinancial}
{\xe \v QCPFinancial\:csCandlestick}
{\qr csCandlestick{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Candlestick representation. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5878                   \{ csOhlc         \par
 5879                    ,csCandlestick  \par
 5880                   \};\par
}
}
{\xe \v WidthType\:QCPFinancial}
{\xe \v QCPFinancial\:WidthType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPFinancial::WidthType}}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the ways the width of the financial bar can be specified. Thus it defines what the number passed to {\b setWidth} actually means.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWidthType}, {\b setWidth} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v wtAbsolute\:QCPFinancial}
{\xe \v QCPFinancial\:wtAbsolute}
{\qr wtAbsolute{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
width is in absolute pixels \par
}\cell }{\row }
{\xe \v wtAxisRectRatio\:QCPFinancial}
{\xe \v QCPFinancial\:wtAxisRectRatio}
{\qr wtAxisRectRatio{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
width is given by a fraction of the axis rect size \par
}\cell }{\row }
{\xe \v wtPlotCoords\:QCPFinancial}
{\xe \v QCPFinancial\:wtPlotCoords}
{\qr wtPlotCoords{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
width is in key coordinates and thus scales with the key axis range \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5867                  \{ wtAbsolute       \par
 5868                    ,wtAxisRectRatio \par
 5869                    ,wtPlotCoords    \par
 5870                  \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPFinancial\:QCPFinancial}
{\xe \v QCPFinancial\:QCPFinancial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPFinancial::QCPFinancial ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a financial chart which uses {\i keyAxis}  as its key axis ("x") and {\i valueAxis}  as its value axis ("y"). {\i keyAxis}  and {\i valueAxis}  must reside in the same {\b QCustomPlot} instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.\par
The created {\b QCPFinancial} is automatically registered with the {\b QCustomPlot} instance inferred from {\i keyAxis} . This {\b QCustomPlot} instance takes ownership of the {\b QCPFinancial}, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26232                                                                :\par
26233   QCPAbstractPlottable1D<QCPFinancialData>(keyAxis, valueAxis),\par
26234   mChartStyle(csCandlestick),\par
26235   mWidth(0.5),\par
26236   mWidthType(wtPlotCoords),\par
26237   mTwoColored(true),\par
26238   mBrushPositive(QBrush(QColor(50, 160, 0))),\par
26239   mBrushNegative(QBrush(QColor(180, 0, 15))),\par
26240   mPenPositive(QPen(QColor(40, 150, 0))),\par
26241   mPenNegative(QPen(QColor(170, 5, 5)))\par
26242 \{\par
26243   mSelectionDecorator->setBrush(QBrush(QColor(160, 160, 255)));\par
26244 \}\par
}
}
{\xe \v ~QCPFinancial\:QCPFinancial}
{\xe \v QCPFinancial\:~QCPFinancial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPFinancial::~QCPFinancial (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26247 \{\par
26248 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addData\:QCPFinancial}
{\xe \v QCPFinancial\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::addData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i open}, const QVector< double > &  {\i high}, const QVector< double > &  {\i low}, const QVector< double > &  {\i close}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided points in {\i keys} , {\i open} , {\i high} , {\i low}  and {\i close}  to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b timeSeriesToOhlc} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26403 \{\par
26404   if (keys.size() != open.size() || open.size() != high.size() || high.size() != low.size() || low.size() != close.size() || close.size() != keys.size())\par
26405     qDebug() << Q_FUNC_INFO << "keys, open, high, low, close have different sizes:" << keys.size() << open.size() << high.size() << low.size() << close.size();\par
26406   const int n = qMin(keys.size(), qMin(open.size(), qMin(high.size(), qMin(low.size(), close.size()))));\par
26407   QVector<QCPFinancialData> tempData(n);\par
26408   QVector<QCPFinancialData>::iterator it = tempData.begin();\par
26409   const QVector<QCPFinancialData>::iterator itEnd = tempData.end();\par
26410   int i = 0;\par
26411   while (it != itEnd)\par
26412   \{\par
26413     it->key = keys[i];\par
26414     it->open = open[i];\par
26415     it->high = high[i];\par
26416     it->low = low[i];\par
26417     it->close = close[i];\par
26418     ++it;\par
26419     ++i;\par
26420   \}\par
26421   mDataContainer->add(tempData, alreadySorted); // don't modify tempData beyond this to prevent copy on write\par
26422 \}\par
}
}
{\xe \v addData\:QCPFinancial}
{\xe \v QCPFinancial\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::addData (double  {\i key}, double  {\i open}, double  {\i high}, double  {\i low}, double  {\i close})}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided data point as {\i key} , {\i open} , {\i high} , {\i low}  and {\i close}  to the current data.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b timeSeriesToOhlc} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26435 \{\par
26436   mDataContainer->add(QCPFinancialData(key, open, high, low, close));\par
26437 \}\par
}
}
{\xe \v brushNegative\:QCPFinancial}
{\xe \v QCPFinancial\:brushNegative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPFinancial::brushNegative () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5893 \{ return mBrushNegative; \}\par
}
}
{\xe \v brushPositive\:QCPFinancial}
{\xe \v QCPFinancial\:brushPositive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPFinancial::brushPositive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5892 \{ return mBrushPositive; \}\par
}
}
{\xe \v candlestickSelectTest\:QCPFinancial}
{\xe \v QCPFinancial\:candlestickSelectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancial::candlestickSelectTest (const QPointF &  {\i pos}, const {\b QCPFinancialDataContainer::const_iterator} &  {\i begin}, const {\b QCPFinancialDataContainer::const_iterator} &  {\i end}, {\b QCPFinancialDataContainer::const_iterator} &  {\i closestDataPoint}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26896 \{\par
26897   closestDataPoint = mDataContainer->constEnd();\par
26898   QCPAxis *keyAxis = mKeyAxis.data();\par
26899   QCPAxis *valueAxis = mValueAxis.data();\par
26900   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; \}\par
26901 \par
26902   double minDistSqr = std::numeric_limits<double>::max();\par
26903   if (keyAxis->orientation() == Qt::Horizontal)\par
26904   \{\par
26905     for (QCPFinancialDataContainer::const_iterator it=begin; it!=end; ++it)\par
26906     \{\par
26907       double currentDistSqr;\par
26908       // determine whether pos is in open-close-box:\par
26909       QCPRange boxKeyRange(it->key-mWidth*0.5, it->key+mWidth*0.5);\par
26910       QCPRange boxValueRange(it->close, it->open);\par
26911       double posKey, posValue;\par
26912       pixelsToCoords(pos, posKey, posValue);\par
26913       if (boxKeyRange.contains(posKey) && boxValueRange.contains(posValue)) // is in open-close-box\par
26914       \{\par
26915         currentDistSqr = mParentPlot->selectionTolerance()*0.99 * mParentPlot->selectionTolerance()*0.99;\par
26916       \} else\par
26917       \{\par
26918         // calculate distance to high/low lines:\par
26919         double keyPixel = keyAxis->coordToPixel(it->key);\par
26920         double highLineDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(keyPixel, valueAxis->coordToPixel(it->high)), QCPVector2D(keyPixel, valueAxis->coordToPixel(qMax(it->open, it->close))));\par
26921         double lowLineDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(keyPixel, valueAxis->coordToPixel(it->low)), QCPVector2D(keyPixel, valueAxis->coordToPixel(qMin(it->open, it->close))));\par
26922         currentDistSqr = qMin(highLineDistSqr, lowLineDistSqr);\par
26923       \}\par
26924       if (currentDistSqr < minDistSqr)\par
26925       \{\par
26926         minDistSqr = currentDistSqr;\par
26927         closestDataPoint = it;\par
26928       \}\par
26929     \}\par
26930   \} else // keyAxis->orientation() == Qt::Vertical\par
26931   \{\par
26932     for (QCPFinancialDataContainer::const_iterator it=begin; it!=end; ++it)\par
26933     \{\par
26934       double currentDistSqr;\par
26935       // determine whether pos is in open-close-box:\par
26936       QCPRange boxKeyRange(it->key-mWidth*0.5, it->key+mWidth*0.5);\par
26937       QCPRange boxValueRange(it->close, it->open);\par
26938       double posKey, posValue;\par
26939       pixelsToCoords(pos, posKey, posValue);\par
26940       if (boxKeyRange.contains(posKey) && boxValueRange.contains(posValue)) // is in open-close-box\par
26941       \{\par
26942         currentDistSqr = mParentPlot->selectionTolerance()*0.99 * mParentPlot->selectionTolerance()*0.99;\par
26943       \} else\par
26944       \{\par
26945         // calculate distance to high/low lines:\par
26946         double keyPixel = keyAxis->coordToPixel(it->key);\par
26947         double highLineDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(valueAxis->coordToPixel(it->high), keyPixel), QCPVector2D(valueAxis->coordToPixel(qMax(it->open, it->close)), keyPixel));\par
26948         double lowLineDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(valueAxis->coordToPixel(it->low), keyPixel), QCPVector2D(valueAxis->coordToPixel(qMin(it->open, it->close)), keyPixel));\par
26949         currentDistSqr = qMin(highLineDistSqr, lowLineDistSqr);\par
26950       \}\par
26951       if (currentDistSqr < minDistSqr)\par
26952       \{\par
26953         minDistSqr = currentDistSqr;\par
26954         closestDataPoint = it;\par
26955       \}\par
26956     \}\par
26957   \}\par
26958   return qSqrt(minDistSqr);\par
26959 \}\par
}
}
{\xe \v chartStyle\:QCPFinancial}
{\xe \v QCPFinancial\:chartStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ChartStyle} QCPFinancial::chartStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5888 \{ return mChartStyle; \}\par
}
}
{\xe \v data\:QCPFinancial}
{\xe \v QCPFinancial\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPFinancialDataContainer} * QCPFinancial::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the internal data storage of type {\b QCPFinancialDataContainer}. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular {\b setData} or {\b addData} methods, in certain situations. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5887 \{ return mDataContainer; \}\par
}
}
{\xe \v draw\:QCPFinancial}
{\xe \v QCPFinancial\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26573 \{\par
26574   // get visible data range:\par
26575   QCPFinancialDataContainer::const_iterator visibleBegin, visibleEnd;\par
26576   getVisibleDataBounds(visibleBegin, visibleEnd);\par
26577   \par
26578   // loop over and draw segments of unselected/selected data:\par
26579   QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;\par
26580   getDataSegments(selectedSegments, unselectedSegments);\par
26581   allSegments << unselectedSegments << selectedSegments;\par
26582   for (int i=0; i<allSegments.size(); ++i)\par
26583   \{\par
26584     bool isSelectedSegment = i >= unselectedSegments.size();\par
26585     QCPFinancialDataContainer::const_iterator begin = visibleBegin;\par
26586     QCPFinancialDataContainer::const_iterator end = visibleEnd;\par
26587     mDataContainer->limitIteratorsToDataRange(begin, end, allSegments.at(i));\par
26588     if (begin == end)\par
26589       continue;\par
26590     \par
26591     // draw data segment according to configured style:\par
26592     switch (mChartStyle)\par
26593     \{\par
26594       case QCPFinancial::csOhlc:\par
26595         drawOhlcPlot(painter, begin, end, isSelectedSegment); break;\par
26596       case QCPFinancial::csCandlestick:\par
26597         drawCandlestickPlot(painter, begin, end, isSelectedSegment); break;\par
26598     \}\par
26599   \}\par
26600   \par
26601   // draw other selection decoration that isn't just line/scatter pens and brushes:\par
26602   if (mSelectionDecorator)\par
26603     mSelectionDecorator->drawDecoration(painter, selection());\par
26604 \}\par
}
}
{\xe \v drawCandlestickPlot\:QCPFinancial}
{\xe \v QCPFinancial\:drawCandlestickPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::drawCandlestickPlot ({\b QCPPainter} *  {\i painter}, const {\b QCPFinancialDataContainer::const_iterator} &  {\i begin}, const {\b QCPFinancialDataContainer::const_iterator} &  {\i end}, bool  {\i isSelected}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26729 \{\par
26730   QCPAxis *keyAxis = mKeyAxis.data();\par
26731   QCPAxis *valueAxis = mValueAxis.data();\par
26732   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
26733   \par
26734   if (keyAxis->orientation() == Qt::Horizontal)\par
26735   \{\par
26736     for (QCPFinancialDataContainer::const_iterator it = begin; it != end; ++it)\par
26737     \{\par
26738       if (isSelected && mSelectionDecorator)\par
26739       \{\par
26740         mSelectionDecorator->applyPen(painter);\par
26741         mSelectionDecorator->applyBrush(painter);\par
26742       \} else if (mTwoColored)\par
26743       \{\par
26744         painter->setPen(it->close >= it->open ? mPenPositive : mPenNegative);\par
26745         painter->setBrush(it->close >= it->open ? mBrushPositive : mBrushNegative);\par
26746       \} else\par
26747       \{\par
26748         painter->setPen(mPen);\par
26749         painter->setBrush(mBrush);\par
26750       \}\par
26751       double keyPixel = keyAxis->coordToPixel(it->key);\par
26752       double openPixel = valueAxis->coordToPixel(it->open);\par
26753       double closePixel = valueAxis->coordToPixel(it->close);\par
26754       // draw high:\par
26755       painter->drawLine(QPointF(keyPixel, valueAxis->coordToPixel(it->high)), QPointF(keyPixel, valueAxis->coordToPixel(qMax(it->open, it->close))));\par
26756       // draw low:\par
26757       painter->drawLine(QPointF(keyPixel, valueAxis->coordToPixel(it->low)), QPointF(keyPixel, valueAxis->coordToPixel(qMin(it->open, it->close))));\par
26758       // draw open-close box:\par
26759       double pixelWidth = getPixelWidth(it->key, keyPixel);\par
26760       painter->drawRect(QRectF(QPointF(keyPixel-pixelWidth, closePixel), QPointF(keyPixel+pixelWidth, openPixel)));\par
26761     \}\par
26762   \} else // keyAxis->orientation() == Qt::Vertical\par
26763   \{\par
26764     for (QCPFinancialDataContainer::const_iterator it = begin; it != end; ++it)\par
26765     \{\par
26766       if (isSelected && mSelectionDecorator)\par
26767       \{\par
26768         mSelectionDecorator->applyPen(painter);\par
26769         mSelectionDecorator->applyBrush(painter);\par
26770       \} else if (mTwoColored)\par
26771       \{\par
26772         painter->setPen(it->close >= it->open ? mPenPositive : mPenNegative);\par
26773         painter->setBrush(it->close >= it->open ? mBrushPositive : mBrushNegative);\par
26774       \} else\par
26775       \{\par
26776         painter->setPen(mPen);\par
26777         painter->setBrush(mBrush);\par
26778       \}\par
26779       double keyPixel = keyAxis->coordToPixel(it->key);\par
26780       double openPixel = valueAxis->coordToPixel(it->open);\par
26781       double closePixel = valueAxis->coordToPixel(it->close);\par
26782       // draw high:\par
26783       painter->drawLine(QPointF(valueAxis->coordToPixel(it->high), keyPixel), QPointF(valueAxis->coordToPixel(qMax(it->open, it->close)), keyPixel));\par
26784       // draw low:\par
26785       painter->drawLine(QPointF(valueAxis->coordToPixel(it->low), keyPixel), QPointF(valueAxis->coordToPixel(qMin(it->open, it->close)), keyPixel));\par
26786       // draw open-close box:\par
26787       double pixelWidth = getPixelWidth(it->key, keyPixel);\par
26788       painter->drawRect(QRectF(QPointF(closePixel, keyPixel-pixelWidth), QPointF(openPixel, keyPixel+pixelWidth)));\par
26789     \}\par
26790   \}\par
26791 \}\par
}
}
{\xe \v drawLegendIcon\:QCPFinancial}
{\xe \v QCPFinancial\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26608 \{\par
26609   painter->setAntialiasing(false); // legend icon especially of csCandlestick looks better without antialiasing\par
26610   if (mChartStyle == csOhlc)\par
26611   \{\par
26612     if (mTwoColored)\par
26613     \{\par
26614       // draw upper left half icon with positive color:\par
26615       painter->setBrush(mBrushPositive);\par
26616       painter->setPen(mPenPositive);\par
26617       painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.topLeft().toPoint()));\par
26618       painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));\par
26619       painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));\par
26620       painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));\par
26621       // draw bottom right half icon with negative color:\par
26622       painter->setBrush(mBrushNegative);\par
26623       painter->setPen(mPenNegative);\par
26624       painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));\par
26625       painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));\par
26626       painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));\par
26627       painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));\par
26628     \} else\par
26629     \{\par
26630       painter->setBrush(mBrush);\par
26631       painter->setPen(mPen);\par
26632       painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));\par
26633       painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));\par
26634       painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));\par
26635     \}\par
26636   \} else if (mChartStyle == csCandlestick)\par
26637   \{\par
26638     if (mTwoColored)\par
26639     \{\par
26640       // draw upper left half icon with positive color:\par
26641       painter->setBrush(mBrushPositive);\par
26642       painter->setPen(mPenPositive);\par
26643       painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.topLeft().toPoint()));\par
26644       painter->drawLine(QLineF(0, rect.height()*0.5, rect.width()*0.25, rect.height()*0.5).translated(rect.topLeft()));\par
26645       painter->drawLine(QLineF(rect.width()*0.75, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));\par
26646       painter->drawRect(QRectF(rect.width()*0.25, rect.height()*0.25, rect.width()*0.5, rect.height()*0.5).translated(rect.topLeft()));\par
26647       // draw bottom right half icon with negative color:\par
26648       painter->setBrush(mBrushNegative);\par
26649       painter->setPen(mPenNegative);\par
26650       painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));\par
26651       painter->drawLine(QLineF(0, rect.height()*0.5, rect.width()*0.25, rect.height()*0.5).translated(rect.topLeft()));\par
26652       painter->drawLine(QLineF(rect.width()*0.75, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));\par
26653       painter->drawRect(QRectF(rect.width()*0.25, rect.height()*0.25, rect.width()*0.5, rect.height()*0.5).translated(rect.topLeft()));\par
26654     \} else\par
26655     \{\par
26656       painter->setBrush(mBrush);\par
26657       painter->setPen(mPen);\par
26658       painter->drawLine(QLineF(0, rect.height()*0.5, rect.width()*0.25, rect.height()*0.5).translated(rect.topLeft()));\par
26659       painter->drawLine(QLineF(rect.width()*0.75, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));\par
26660       painter->drawRect(QRectF(rect.width()*0.25, rect.height()*0.25, rect.width()*0.5, rect.height()*0.5).translated(rect.topLeft()));\par
26661     \}\par
26662   \}\par
26663 \}\par
}
}
{\xe \v drawOhlcPlot\:QCPFinancial}
{\xe \v QCPFinancial\:drawOhlcPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::drawOhlcPlot ({\b QCPPainter} *  {\i painter}, const {\b QCPFinancialDataContainer::const_iterator} &  {\i begin}, const {\b QCPFinancialDataContainer::const_iterator} &  {\i end}, bool  {\i isSelected}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26672 \{\par
26673   QCPAxis *keyAxis = mKeyAxis.data();\par
26674   QCPAxis *valueAxis = mValueAxis.data();\par
26675   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
26676   \par
26677   if (keyAxis->orientation() == Qt::Horizontal)\par
26678   \{\par
26679     for (QCPFinancialDataContainer::const_iterator it = begin; it != end; ++it)\par
26680     \{\par
26681       if (isSelected && mSelectionDecorator)\par
26682         mSelectionDecorator->applyPen(painter);\par
26683       else if (mTwoColored)\par
26684         painter->setPen(it->close >= it->open ? mPenPositive : mPenNegative);\par
26685       else\par
26686         painter->setPen(mPen);\par
26687       double keyPixel = keyAxis->coordToPixel(it->key);\par
26688       double openPixel = valueAxis->coordToPixel(it->open);\par
26689       double closePixel = valueAxis->coordToPixel(it->close);\par
26690       // draw backbone:\par
26691       painter->drawLine(QPointF(keyPixel, valueAxis->coordToPixel(it->high)), QPointF(keyPixel, valueAxis->coordToPixel(it->low)));\par
26692       // draw open:\par
26693       double pixelWidth = getPixelWidth(it->key, keyPixel); // sign of this makes sure open/close are on correct sides\par
26694       painter->drawLine(QPointF(keyPixel-pixelWidth, openPixel), QPointF(keyPixel, openPixel));\par
26695       // draw close:\par
26696       painter->drawLine(QPointF(keyPixel, closePixel), QPointF(keyPixel+pixelWidth, closePixel));\par
26697     \}\par
26698   \} else\par
26699   \{\par
26700     for (QCPFinancialDataContainer::const_iterator it = begin; it != end; ++it)\par
26701     \{\par
26702       if (isSelected && mSelectionDecorator)\par
26703         mSelectionDecorator->applyPen(painter);\par
26704       else if (mTwoColored)\par
26705         painter->setPen(it->close >= it->open ? mPenPositive : mPenNegative);\par
26706       else\par
26707         painter->setPen(mPen);\par
26708       double keyPixel = keyAxis->coordToPixel(it->key);\par
26709       double openPixel = valueAxis->coordToPixel(it->open);\par
26710       double closePixel = valueAxis->coordToPixel(it->close);\par
26711       // draw backbone:\par
26712       painter->drawLine(QPointF(valueAxis->coordToPixel(it->high), keyPixel), QPointF(valueAxis->coordToPixel(it->low), keyPixel));\par
26713       // draw open:\par
26714       double pixelWidth = getPixelWidth(it->key, keyPixel); // sign of this makes sure open/close are on correct sides\par
26715       painter->drawLine(QPointF(openPixel, keyPixel-pixelWidth), QPointF(openPixel, keyPixel));\par
26716       // draw close:\par
26717       painter->drawLine(QPointF(closePixel, keyPixel), QPointF(closePixel, keyPixel+pixelWidth));\par
26718     \}\par
26719   \}\par
26720 \}\par
}
}
{\xe \v getKeyRange\:QCPFinancial}
{\xe \v QCPFinancial\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPFinancial::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26499 \{\par
26500   QCPRange range = mDataContainer->keyRange(foundRange, inSignDomain);\par
26501   // determine exact range by including width of bars/flags:\par
26502   if (foundRange)\par
26503   \{\par
26504     if (inSignDomain != QCP::sdPositive || range.lower-mWidth*0.5 > 0)\par
26505       range.lower -= mWidth*0.5;\par
26506     if (inSignDomain != QCP::sdNegative || range.upper+mWidth*0.5 < 0)\par
26507       range.upper += mWidth*0.5;\par
26508   \}\par
26509   return range;\par
26510 \}\par
}
}
{\xe \v getPixelWidth\:QCPFinancial}
{\xe \v QCPFinancial\:getPixelWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancial::getPixelWidth (double  {\i key}, double  {\i keyPixel}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26806 \{\par
26807   double result = 0;\par
26808   switch (mWidthType)\par
26809   \{\par
26810     case wtAbsolute:\par
26811     \{\par
26812       if (mKeyAxis)\par
26813         result = mWidth*0.5*mKeyAxis.data()->pixelOrientation();\par
26814       break;\par
26815     \}\par
26816     case wtAxisRectRatio:\par
26817     \{\par
26818       if (mKeyAxis && mKeyAxis.data()->axisRect())\par
26819       \{\par
26820         if (mKeyAxis.data()->orientation() == Qt::Horizontal)\par
26821           result = mKeyAxis.data()->axisRect()->width()*mWidth*0.5*mKeyAxis.data()->pixelOrientation();\par
26822         else\par
26823           result = mKeyAxis.data()->axisRect()->height()*mWidth*0.5*mKeyAxis.data()->pixelOrientation();\par
26824       \} else\par
26825         qDebug() << Q_FUNC_INFO << "No key axis or axis rect defined";\par
26826       break;\par
26827     \}\par
26828     case wtPlotCoords:\par
26829     \{\par
26830       if (mKeyAxis)\par
26831         result = mKeyAxis.data()->coordToPixel(key+mWidth*0.5)-keyPixel;\par
26832       else\par
26833         qDebug() << Q_FUNC_INFO << "No key axis defined";\par
26834       break;\par
26835     \}\par
26836   \}\par
26837   return result;\par
26838 \}\par
}
}
{\xe \v getValueRange\:QCPFinancial}
{\xe \v QCPFinancial\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPFinancial::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26514 \{\par
26515   return mDataContainer->valueRange(foundRange, inSignDomain, inKeyRange);\par
26516 \}\par
}
}
{\xe \v getVisibleDataBounds\:QCPFinancial}
{\xe \v QCPFinancial\:getVisibleDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::getVisibleDataBounds ({\b QCPFinancialDataContainer::const_iterator} &  {\i begin}, {\b QCPFinancialDataContainer::const_iterator} &  {\i end}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26976 \{\par
26977   if (!mKeyAxis)\par
26978   \{\par
26979     qDebug() << Q_FUNC_INFO << "invalid key axis";\par
26980     begin = mDataContainer->constEnd();\par
26981     end = mDataContainer->constEnd();\par
26982     return;\par
26983   \}\par
26984   begin = mDataContainer->findBegin(mKeyAxis.data()->range().lower-mWidth*0.5); // subtract half width of ohlc/candlestick to include partially visible data points\par
26985   end = mDataContainer->findEnd(mKeyAxis.data()->range().upper+mWidth*0.5); // add half width of ohlc/candlestick to include partially visible data points\par
26986 \}\par
}
}
{\xe \v ohlcSelectTest\:QCPFinancial}
{\xe \v QCPFinancial\:ohlcSelectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancial::ohlcSelectTest (const QPointF &  {\i pos}, const {\b QCPFinancialDataContainer::const_iterator} &  {\i begin}, const {\b QCPFinancialDataContainer::const_iterator} &  {\i end}, {\b QCPFinancialDataContainer::const_iterator} &  {\i closestDataPoint}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26849 \{\par
26850   closestDataPoint = mDataContainer->constEnd();\par
26851   QCPAxis *keyAxis = mKeyAxis.data();\par
26852   QCPAxis *valueAxis = mValueAxis.data();\par
26853   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return -1; \}\par
26854 \par
26855   double minDistSqr = std::numeric_limits<double>::max();\par
26856   if (keyAxis->orientation() == Qt::Horizontal)\par
26857   \{\par
26858     for (QCPFinancialDataContainer::const_iterator it=begin; it!=end; ++it)\par
26859     \{\par
26860       double keyPixel = keyAxis->coordToPixel(it->key);\par
26861       // calculate distance to backbone:\par
26862       double currentDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(keyPixel, valueAxis->coordToPixel(it->high)), QCPVector2D(keyPixel, valueAxis->coordToPixel(it->low)));\par
26863       if (currentDistSqr < minDistSqr)\par
26864       \{\par
26865         minDistSqr = currentDistSqr;\par
26866         closestDataPoint = it;\par
26867       \}\par
26868     \}\par
26869   \} else // keyAxis->orientation() == Qt::Vertical\par
26870   \{\par
26871     for (QCPFinancialDataContainer::const_iterator it=begin; it!=end; ++it)\par
26872     \{\par
26873       double keyPixel = keyAxis->coordToPixel(it->key);\par
26874       // calculate distance to backbone:\par
26875       double currentDistSqr = QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(valueAxis->coordToPixel(it->high), keyPixel), QCPVector2D(valueAxis->coordToPixel(it->low), keyPixel));\par
26876       if (currentDistSqr < minDistSqr)\par
26877       \{\par
26878         minDistSqr = currentDistSqr;\par
26879         closestDataPoint = it;\par
26880       \}\par
26881     \}\par
26882   \}\par
26883   return qSqrt(minDistSqr);\par
26884 \}\par
}
}
{\xe \v penNegative\:QCPFinancial}
{\xe \v QCPFinancial\:penNegative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPFinancial::penNegative () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5895 \{ return mPenNegative; \}\par
}
}
{\xe \v penPositive\:QCPFinancial}
{\xe \v QCPFinancial\:penPositive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPFinancial::penPositive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5894 \{ return mPenPositive; \}\par
}
}
{\xe \v selectionHitBox\:QCPFinancial}
{\xe \v QCPFinancial\:selectionHitBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRectF QCPFinancial::selectionHitBox ({\b QCPFinancialDataContainer::const_iterator}  {\i it}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26994 \{\par
26995   QCPAxis *keyAxis = mKeyAxis.data();\par
26996   QCPAxis *valueAxis = mValueAxis.data();\par
26997   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QRectF(); \}\par
26998   \par
26999   double keyPixel = keyAxis->coordToPixel(it->key);\par
27000   double highPixel = valueAxis->coordToPixel(it->high);\par
27001   double lowPixel = valueAxis->coordToPixel(it->low);\par
27002   double keyWidthPixels = keyPixel-keyAxis->coordToPixel(it->key-mWidth*0.5);\par
27003   if (keyAxis->orientation() == Qt::Horizontal)\par
27004     return QRectF(keyPixel-keyWidthPixels, highPixel, keyWidthPixels*2, lowPixel-highPixel).normalized();\par
27005   else\par
27006     return QRectF(highPixel, keyPixel-keyWidthPixels, lowPixel-highPixel, keyWidthPixels*2).normalized();\par
27007 \}\par
}
}
{\xe \v selectTest\:QCPFinancial}
{\xe \v QCPFinancial\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancial::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Reimplemented from {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26464 \{\par
26465   Q_UNUSED(details)\par
26466   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
26467     return -1;\par
26468   if (!mKeyAxis || !mValueAxis)\par
26469     return -1;\par
26470   \par
26471   if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))\par
26472   \{\par
26473     // get visible data range:\par
26474     QCPFinancialDataContainer::const_iterator visibleBegin, visibleEnd;\par
26475     QCPFinancialDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();\par
26476     getVisibleDataBounds(visibleBegin, visibleEnd);\par
26477     // perform select test according to configured style:\par
26478     double result = -1;\par
26479     switch (mChartStyle)\par
26480     \{\par
26481       case QCPFinancial::csOhlc:\par
26482         result = ohlcSelectTest(pos, visibleBegin, visibleEnd, closestDataPoint); break;\par
26483       case QCPFinancial::csCandlestick:\par
26484         result = candlestickSelectTest(pos, visibleBegin, visibleEnd, closestDataPoint); break;\par
26485     \}\par
26486     if (details)\par
26487     \{\par
26488       int pointIndex = closestDataPoint-mDataContainer->constBegin();\par
26489       details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));\par
26490     \}\par
26491     return result;\par
26492   \}\par
26493   \par
26494   return -1;\par
26495 \}\par
}
}
{\xe \v selectTestRect\:QCPFinancial}
{\xe \v QCPFinancial\:selectTestRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPFinancial::selectTestRect (const QRectF &  {\i rect}, bool  {\i onlySelectable}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection containing all the data points of this plottable which are contained (or hit by) {\i rect} . This is used mainly in the selection rect interaction for data selection (data selection mechanism).\par
If {\i onlySelectable}  is true, an empty {\b QCPDataSelection} is returned if this plottable is not selectable (i.e. if {\b QCPAbstractPlottable::setSelectable} is {\b QCP::stNone}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i rect}  must be a normalized rect (positive or zero width and height). This is especially important when using the rect of {\b QCPSelectionRect::accepted}, which is not necessarily normalized. Use {\f2 QRect::normalized()}  when passing a rect which might not be normalized. \par
}}{
Reimplemented from {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26443 \{\par
26444   QCPDataSelection result;\par
26445   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
26446     return result;\par
26447   if (!mKeyAxis || !mValueAxis)\par
26448     return result;\par
26449   \par
26450   QCPFinancialDataContainer::const_iterator visibleBegin, visibleEnd;\par
26451   getVisibleDataBounds(visibleBegin, visibleEnd);\par
26452   \par
26453   for (QCPFinancialDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)\par
26454   \{\par
26455     if (rect.intersects(selectionHitBox(it)))\par
26456       result.addDataRange(QCPDataRange(it-mDataContainer->constBegin(), it-mDataContainer->constBegin()+1), false);\par
26457   \}\par
26458   result.simplify();\par
26459   return result;\par
26460 \}\par
}
}
{\xe \v setBrushNegative\:QCPFinancial}
{\xe \v QCPFinancial\:setBrushNegative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setBrushNegative (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If {\b setTwoColored} is set to true, this function controls the brush that is used to draw fills of data points with a negative trend (i.e. bars/candlesticks with close < open).\par
If {\i twoColored}  is false, the normal plottable's pen and brush are used ({\b setPen}, {\b setBrush}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrushPositive}, {\b setPenNegative}, {\b setPenPositive} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26356 \{\par
26357   mBrushNegative = brush;\par
26358 \}\par
}
}
{\xe \v setBrushPositive\:QCPFinancial}
{\xe \v QCPFinancial\:setBrushPositive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setBrushPositive (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If {\b setTwoColored} is set to true, this function controls the brush that is used to draw fills of data points with a positive trend (i.e. bars/candlesticks with close >= open).\par
If {\i twoColored}  is false, the normal plottable's pen and brush are used ({\b setPen}, {\b setBrush}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrushNegative}, {\b setPenPositive}, {\b setPenNegative} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26342 \{\par
26343   mBrushPositive = brush;\par
26344 \}\par
}
}
{\xe \v setChartStyle\:QCPFinancial}
{\xe \v QCPFinancial\:setChartStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setChartStyle ({\b QCPFinancial::ChartStyle}  {\i style})}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which representation style shall be used to display the OHLC data. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26291 \{\par
26292   mChartStyle = style;\par
26293 \}\par
}
}
{\xe \v setData\:QCPFinancial}
{\xe \v QCPFinancial\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setData (QSharedPointer< {\b QCPFinancialDataContainer} >  {\i data})}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data container with the provided {\i data}  container.\par
Since a QSharedPointer is used, multiple QCPFinancials may share the same data container safely. Modifying the data in the container will then affect all financials that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } If you do not wish to share containers, but create a copy from an existing container, rather use the {\b QCPDataContainer<DataType>::set} method on the financial's data container directly: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData}, {\b timeSeriesToOhlc} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26266 \{\par
26267   mDataContainer = data;\par
26268 \}\par
}
}
{\xe \v setData\:QCPFinancial}
{\xe \v QCPFinancial\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i open}, const QVector< double > &  {\i high}, const QVector< double > &  {\i low}, const QVector< double > &  {\i close}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data with the provided points in {\i keys} , {\i open} , {\i high} , {\i low}  and {\i close} . The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData}, {\b timeSeriesToOhlc} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26282 \{\par
26283   mDataContainer->clear();\par
26284   addData(keys, open, high, low, close, alreadySorted);\par
26285 \}\par
}
}
{\xe \v setPenNegative\:QCPFinancial}
{\xe \v QCPFinancial\:setPenNegative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setPenNegative (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If {\b setTwoColored} is set to true, this function controls the pen that is used to draw outlines of data points with a negative trend (i.e. bars/candlesticks with close < open).\par
If {\i twoColored}  is false, the normal plottable's pen and brush are used ({\b setPen}, {\b setBrush}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPenPositive}, {\b setBrushNegative}, {\b setBrushPositive} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26384 \{\par
26385   mPenNegative = pen;\par
26386 \}\par
}
}
{\xe \v setPenPositive\:QCPFinancial}
{\xe \v QCPFinancial\:setPenPositive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setPenPositive (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If {\b setTwoColored} is set to true, this function controls the pen that is used to draw outlines of data points with a positive trend (i.e. bars/candlesticks with close >= open).\par
If {\i twoColored}  is false, the normal plottable's pen and brush are used ({\b setPen}, {\b setBrush}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPenNegative}, {\b setBrushPositive}, {\b setBrushNegative} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26370 \{\par
26371   mPenPositive = pen;\par
26372 \}\par
}
}
{\xe \v setTwoColored\:QCPFinancial}
{\xe \v QCPFinancial\:setTwoColored}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setTwoColored (bool  {\i twoColored})}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this chart shall contrast positive from negative trends per data point by using two separate colors to draw the respective bars/candlesticks.\par
If {\i twoColored}  is false, the normal plottable's pen and brush are used ({\b setPen}, {\b setBrush}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPenPositive}, {\b setPenNegative}, {\b setBrushPositive}, {\b setBrushNegative} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26328 \{\par
26329   mTwoColored = twoColored;\par
26330 \}\par
}
}
{\xe \v setWidth\:QCPFinancial}
{\xe \v QCPFinancial\:setWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setWidth (double  {\i width})}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the width of the individual bars/candlesticks to {\i width}  in plot key coordinates.\par
A typical choice is to set it to (or slightly less than) one bin interval width. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26301 \{\par
26302   mWidth = width;\par
26303 \}\par
}
}
{\xe \v setWidthType\:QCPFinancial}
{\xe \v QCPFinancial\:setWidthType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPFinancial::setWidthType ({\b QCPFinancial::WidthType}  {\i widthType})}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how the width of the financial bars is defined. See the documentation of {\b WidthType} for an explanation of the possible values for {\i widthType} .\par
The default value is {\b wtPlotCoords}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWidth} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26314 \{\par
26315   mWidthType = widthType;\par
26316 \}\par
}
}
{\xe \v timeSeriesToOhlc\:QCPFinancial}
{\xe \v QCPFinancial\:timeSeriesToOhlc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPFinancialDataContainer} QCPFinancial::timeSeriesToOhlc (const QVector< double > &  {\i time}, const QVector< double > &  {\i value}, double  {\i timeBinSize}, double  {\i timeBinOffset} = {\f2 0}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A convenience function that converts time series data ({\i value}  against {\i time} ) to OHLC binned data points. The return value can then be passed on to {\b QCPFinancialDataContainer::set}(const QCPFinancialDataContainer&).\par
The size of the bins can be controlled with {\i timeBinSize}  in the same units as {\i time}  is given. For example, if the unit of {\i time}  is seconds and single OHLC/Candlesticks should span an hour each, set {\i timeBinSize}  to 3600.\par
{\i timeBinOffset}  allows to control precisely at what {\i time}  coordinate a bin should start. The value passed as {\i timeBinOffset}  doesn't need to be in the range encompassed by the {\i time}  keys. It merely defines the mathematical offset/phase of the bins that will be used to process the data. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26533 \{\par
26534   QCPFinancialDataContainer data;\par
26535   int count = qMin(time.size(), value.size());\par
26536   if (count == 0)\par
26537     return QCPFinancialDataContainer();\par
26538   \par
26539   QCPFinancialData currentBinData(0, value.first(), value.first(), value.first(), value.first());\par
26540   int currentBinIndex = qFloor((time.first()-timeBinOffset)/timeBinSize+0.5);\par
26541   for (int i=0; i<count; ++i)\par
26542   \{\par
26543     int index = qFloor((time.at(i)-timeBinOffset)/timeBinSize+0.5);\par
26544     if (currentBinIndex == index) // data point still in current bin, extend high/low:\par
26545     \{\par
26546       if (value.at(i) < currentBinData.low) currentBinData.low = value.at(i);\par
26547       if (value.at(i) > currentBinData.high) currentBinData.high = value.at(i);\par
26548       if (i == count-1) // last data point is in current bin, finalize bin:\par
26549       \{\par
26550         currentBinData.close = value.at(i);\par
26551         currentBinData.key = timeBinOffset+(index)*timeBinSize;\par
26552         data.add(currentBinData);\par
26553       \}\par
26554     \} else // data point not anymore in current bin, set close of old and open of new bin, and add old to map:\par
26555     \{\par
26556       // finalize current bin:\par
26557       currentBinData.close = value.at(i-1);\par
26558       currentBinData.key = timeBinOffset+(index-1)*timeBinSize;\par
26559       data.add(currentBinData);\par
26560       // start next bin:\par
26561       currentBinIndex = index;\par
26562       currentBinData.open = value.at(i);\par
26563       currentBinData.high = value.at(i);\par
26564       currentBinData.low = value.at(i);\par
26565     \}\par
26566   \}\par
26567   \par
26568   return data;\par
26569 \}\par
}
}
{\xe \v twoColored\:QCPFinancial}
{\xe \v QCPFinancial\:twoColored}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPFinancial::twoColored () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5891 \{ return mTwoColored; \}\par
}
}
{\xe \v width\:QCPFinancial}
{\xe \v QCPFinancial\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancial::width () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5889 \{ return mWidth; \}\par
}
}
{\xe \v widthType\:QCPFinancial}
{\xe \v QCPFinancial\:widthType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WidthType} QCPFinancial::widthType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5890 \{ return mWidthType; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLegend\:QCPFinancial}
{\xe \v QCPFinancial\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPFinancial}
{\xe \v QCPFinancial\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBrushNegative\:QCPFinancial}
{\xe \v QCPFinancial\:mBrushNegative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPFinancial::mBrushNegative{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBrushPositive\:QCPFinancial}
{\xe \v QCPFinancial\:mBrushPositive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPFinancial::mBrushPositive{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mChartStyle\:QCPFinancial}
{\xe \v QCPFinancial\:mChartStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ChartStyle} QCPFinancial::mChartStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPenNegative\:QCPFinancial}
{\xe \v QCPFinancial\:mPenNegative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPFinancial::mPenNegative{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPenPositive\:QCPFinancial}
{\xe \v QCPFinancial\:mPenPositive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPFinancial::mPenPositive{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTwoColored\:QCPFinancial}
{\xe \v QCPFinancial\:mTwoColored}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPFinancial::mTwoColored{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWidth\:QCPFinancial}
{\xe \v QCPFinancial\:mWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancial::mWidth{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWidthType\:QCPFinancial}
{\xe \v QCPFinancial\:mWidthType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WidthType} QCPFinancial::mWidthType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPFinancialData Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPFinancialData}
{\xe \v QCPFinancialData}
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPFinancial}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPFinancialData:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_financial_data__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPFinancialData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPFinancialData} (double {\b key}, double {\b open}, double {\b high}, double {\b low}, double {\b close})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sortKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b valueRange} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b QCPFinancialData} {\b fromSortKey} (double {\b sortKey})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b sortKeyIsMainKey} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b open}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b high}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b low}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b close}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPFinancial}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The stored data is: {
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i key:}  coordinate on the key axis of this data point (this is the {\i mainKey}  and the {\i sortKey} ) \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i open:}  The opening value at the data point (this is the {\i mainValue} ) \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i high:}  The high/maximum value at the data point \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i low:}  The low/minimum value at the data point \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i close:}  The closing value at the data point\par
}
The container for storing multiple data points is {\b QCPFinancialDataContainer}. It is a typedef for {\b QCPDataContainer} with {\b QCPFinancialData} as the DataType template parameter. See the documentation there for an explanation regarding the data type's generic methods.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b QCPFinancialDataContainer} \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPFinancialData\:QCPFinancialData}
{\xe \v QCPFinancialData\:QCPFinancialData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPFinancialData::QCPFinancialData ()}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a data point with key and all values set to zero. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26136                                    :\par
26137   key(0),\par
26138   open(0),\par
26139   high(0),\par
26140   low(0),\par
26141   close(0)\par
26142 \{\par
26143 \}\par
}
}
{\xe \v QCPFinancialData\:QCPFinancialData}
{\xe \v QCPFinancialData\:QCPFinancialData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPFinancialData::QCPFinancialData (double  {\i key}, double  {\i open}, double  {\i high}, double  {\i low}, double  {\i close})}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a data point with the specified {\i key}  and OHLC values. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26148                                                                                                  :\par
26149   key(key),\par
26150   open(open),\par
26151   high(high),\par
26152   low(low),\par
26153   close(close)\par
26154 \{\par
26155 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fromSortKey\:QCPFinancialData}
{\xe \v QCPFinancialData\:fromSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b QCPFinancialData} QCPFinancialData::fromSortKey (double  {\i sortKey}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data point with the specified {\i sortKey} . All other members are set to zero.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5823 \{ return QCPFinancialData(sortKey, 0, 0, 0, 0); \}\par
}
}
{\xe \v mainKey\:QCPFinancialData}
{\xe \v QCPFinancialData\:mainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancialData::mainKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i key}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5826 \{ return key; \}\par
}
}
{\xe \v mainValue\:QCPFinancialData}
{\xe \v QCPFinancialData\:mainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancialData::mainValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i open}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5827 \{ return open; \}\par
}
}
{\xe \v sortKey\:QCPFinancialData}
{\xe \v QCPFinancialData\:sortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancialData::sortKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i key}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5822 \{ return key; \}\par
}
}
{\xe \v sortKeyIsMainKey\:QCPFinancialData}
{\xe \v QCPFinancialData\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static static bool QCPFinancialData::sortKeyIsMainKey (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Since the member {\i key}  is both the data point key coordinate and the data ordering parameter, this method returns true.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5824 \{ return true; \} \par
}
}
{\xe \v valueRange\:QCPFinancialData}
{\xe \v QCPFinancialData\:valueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPFinancialData::valueRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPRange} spanning from the {\i low}  to the {\i high}  value of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5829 \{ return QCPRange(low, high); \} // open and close must lie between low and high, so we don't need to check them\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v close\:QCPFinancialData}
{\xe \v QCPFinancialData\:close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancialData::close}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v high\:QCPFinancialData}
{\xe \v QCPFinancialData\:high}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancialData::high}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v key\:QCPFinancialData}
{\xe \v QCPFinancialData\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancialData::key}}
\par
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v low\:QCPFinancialData}
{\xe \v QCPFinancialData\:low}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancialData::low}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v open\:QCPFinancialData}
{\xe \v QCPFinancialData\:open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPFinancialData::open}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPGraph Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPGraph}
{\xe \v QCPGraph}
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a graph in a plot. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPGraph:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_graph__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPGraph:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_graph__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LineStyle} \{ {\b lsNone}, 
{\b lsLine}, 
{\b lsStepLeft}, 
{\b lsStepRight}, 
{\b lsStepCenter}, 
{\b lsImpulse}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPGraph} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPGraphDataContainer} > {\b data} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LineStyle} {\b lineStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b scatterStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b scatterSkip} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b channelFillGraph} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b adaptiveSampling} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (QSharedPointer< {\b QCPGraphDataContainer} > {\b data})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLineStyle} ({\b LineStyle} ls)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScatterStyle} (const {\b QCPScatterStyle} &style)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScatterSkip} (int skip)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setChannelFillGraph} ({\b QCPGraph} *targetGraph)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAdaptiveSampling} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (double key, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawFill} ({\b QCPPainter} *painter, QVector< QPointF > *lines) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawScatterPlot} ({\b QCPPainter} *painter, const QVector< QPointF > &scatters, const {\b QCPScatterStyle} &style) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLinePlot} ({\b QCPPainter} *painter, const QVector< QPointF > &lines) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawImpulsePlot} ({\b QCPPainter} *painter, const QVector< QPointF > &lines) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getOptimizedLineData} (QVector< {\b QCPGraphData} > *lineData, const {\b QCPGraphDataContainer::const_iterator} &begin, const {\b QCPGraphDataContainer::const_iterator} &end) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getOptimizedScatterData} (QVector< {\b QCPGraphData} > *scatterData, {\b QCPGraphDataContainer::const_iterator} begin, {\b QCPGraphDataContainer::const_iterator} end) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getVisibleDataBounds} ({\b QCPGraphDataContainer::const_iterator} &begin, {\b QCPGraphDataContainer::const_iterator} &end, const {\b QCPDataRange} &rangeRestriction) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getLines} (QVector< QPointF > *lines, const {\b QCPDataRange} &dataRange) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getScatters} (QVector< QPointF > *scatters, const {\b QCPDataRange} &dataRange) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToStepLeftLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToStepRightLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToStepCenterLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToImpulseLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< {\b QCPDataRange} > {\b getNonNanSegments} (const QVector< QPointF > *lineData, Qt::Orientation keyOrientation) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPair< {\b QCPDataRange}, {\b QCPDataRange} > > {\b getOverlappingSegments} (QVector< {\b QCPDataRange} > thisSegments, const QVector< QPointF > *thisData, QVector< {\b QCPDataRange} > otherSegments, const QVector< QPointF > *otherData) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b segmentsIntersect} (double aLower, double aUpper, double bLower, double bUpper, int &bPrecedence) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointF {\b getFillBasePoint} (QPointF matchingDataPoint) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QPolygonF {\b getFillPolygon} (const QVector< QPointF > *lineData, {\b QCPDataRange} segment) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QPolygonF {\b getChannelFillPolygon} (const QVector< QPointF > *lineData, {\b QCPDataRange} thisSegment, const QVector< QPointF > *otherData, {\b QCPDataRange} otherSegment) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIndexBelowX} (const QVector< QPointF > *{\b data}, double x) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIndexAboveX} (const QVector< QPointF > *{\b data}, double x) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIndexBelowY} (const QVector< QPointF > *{\b data}, double y) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIndexAboveY} (const QVector< QPointF > *{\b data}, double y) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b pointDistance} (const QPointF &pixelPoint, {\b QCPGraphDataContainer::const_iterator} &closestData) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LineStyle} {\b mLineStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b mScatterStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mScatterSkip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPGraph} > {\b mChannelFillGraph}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAdaptiveSampling}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a graph in a plot. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
Usually you create new graphs by calling {\b QCustomPlot::addGraph}. The resulting instance can be accessed via {\b QCustomPlot::graph}.\par
To plot data, assign it with the {\b setData} or {\b addData} functions. Alternatively, you can also access and modify the data via the {\b data} method, which returns a pointer to the internal {\b QCPGraphDataContainer}.\par
Graphs are used to display single-valued data. Single-valued means that there should only be one data point per unique key coordinate. In other words, the graph can't have {\i loops} . If you do want to plot non-single-valued curves, rather use the {\b QCPCurve} plottable.\par
Gaps in the graph line can be created by adding data points with NaN as value ({\f2 qQNaN()}  or {\f2 std::numeric_limits<double>::quiet_NaN()} ) in between the two data points that shall be separated.\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Changing the appearance
\par}
{\tc\tcl2 \v Changing the appearance}
The appearance of the graph is mainly determined by the line style, scatter style, brush and pen of the graph ({\b setLineStyle}, {\b setScatterStyle}, {\b setBrush}, {\b setPen}).\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Filling under or between graphs
\par}
{\tc\tcl3 \v Filling under or between graphs}
{\b QCPGraph} knows two types of fills: Normal graph fills towards the zero-value-line parallel to the key axis of the graph, and fills between two graphs, called channel fills. To enable a fill, just set a brush with {\b setBrush} which is neither Qt::NoBrush nor fully transparent.\par
By default, a normal fill towards the zero-value-line will be drawn. To set up a channel fill between this graph and another one, call {\b setChannelFillGraph} with the other graph as parameter.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::addGraph}, {\b QCustomPlot::graph} \par
}\par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v LineStyle\:QCPGraph}
{\xe \v QCPGraph\:LineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPGraph::LineStyle}}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines how the graph's line is represented visually in the plot. The line is drawn with the current pen of the graph ({\b setPen}). \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLineStyle} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v lsNone\:QCPGraph}
{\xe \v QCPGraph\:lsNone}
{\qr lsNone{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data points are not connected with any lines (e.g. data only represented with symbols according to the scatter style, see {\b setScatterStyle}) \par
}\cell }{\row }
{\xe \v lsLine\:QCPGraph}
{\xe \v QCPGraph\:lsLine}
{\qr lsLine{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data points are connected by a straight line \par
}\cell }{\row }
{\xe \v lsStepLeft\:QCPGraph}
{\xe \v QCPGraph\:lsStepLeft}
{\qr lsStepLeft{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
line is drawn as steps where the step height is the value of the left data point \par
}\cell }{\row }
{\xe \v lsStepRight\:QCPGraph}
{\xe \v QCPGraph\:lsStepRight}
{\qr lsStepRight{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
line is drawn as steps where the step height is the value of the right data point \par
}\cell }{\row }
{\xe \v lsStepCenter\:QCPGraph}
{\xe \v QCPGraph\:lsStepCenter}
{\qr lsStepCenter{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
line is drawn as steps where the step is in between two data points \par
}\cell }{\row }
{\xe \v lsImpulse\:QCPGraph}
{\xe \v QCPGraph\:lsImpulse}
{\qr lsImpulse{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
each data point is represented by a line parallel to the value axis, which reaches from the data point to the zero-value-line \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5168                  \{ lsNone        \par
 5169                    ,lsLine       \par
 5171                    ,lsStepLeft   \par
 5172                    ,lsStepRight  \par
 5173                    ,lsStepCenter \par
 5174                    ,lsImpulse    \par
 5175                  \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPGraph\:QCPGraph}
{\xe \v QCPGraph\:QCPGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPGraph::QCPGraph ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a graph which uses {\i keyAxis}  as its key axis ("x") and {\i valueAxis}  as its value axis ("y"). {\i keyAxis}  and {\i valueAxis}  must reside in the same {\b QCustomPlot} instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.\par
The created {\b QCPGraph} is automatically registered with the {\b QCustomPlot} instance inferred from {\i keyAxis} . This {\b QCustomPlot} instance takes ownership of the {\b QCPGraph}, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead.\par
To directly create a graph inside a plot, you can also use the simpler {\b QCustomPlot::addGraph} function. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20060                                                        :\par
20061   QCPAbstractPlottable1D<QCPGraphData>(keyAxis, valueAxis)\par
20062 \{\par
20063   // special handling for QCPGraphs to maintain the simple graph interface:\par
20064   mParentPlot->registerGraph(this);\par
20065 \par
20066   setPen(QPen(Qt::blue, 0));\par
20067   setBrush(Qt::NoBrush);\par
20068   \par
20069   setLineStyle(lsLine);\par
20070   setScatterSkip(0);\par
20071   setChannelFillGraph(0);\par
20072   setAdaptiveSampling(true);\par
20073 \}\par
}
}
{\xe \v ~QCPGraph\:QCPGraph}
{\xe \v QCPGraph\:~QCPGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPGraph::~QCPGraph (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20076 \{\par
20077 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v adaptiveSampling\:QCPGraph}
{\xe \v QCPGraph\:adaptiveSampling}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGraph::adaptiveSampling () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5187 \{ return mAdaptiveSampling; \}\par
}
}
{\xe \v addData\:QCPGraph}
{\xe \v QCPGraph\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::addData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i values}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided points in {\i keys}  and {\i values}  to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20232 \{\par
20233   if (keys.size() != values.size())\par
20234     qDebug() << Q_FUNC_INFO << "keys and values have different sizes:" << keys.size() << values.size();\par
20235   const int n = qMin(keys.size(), values.size());\par
20236   QVector<QCPGraphData> tempData(n);\par
20237   QVector<QCPGraphData>::iterator it = tempData.begin();\par
20238   const QVector<QCPGraphData>::iterator itEnd = tempData.end();\par
20239   int i = 0;\par
20240   while (it != itEnd)\par
20241   \{\par
20242     it->key = keys[i];\par
20243     it->value = values[i];\par
20244     ++it;\par
20245     ++i;\par
20246   \}\par
20247   mDataContainer->add(tempData, alreadySorted); // don't modify tempData beyond this to prevent copy on write\par
20248 \}\par
}
}
{\xe \v addData\:QCPGraph}
{\xe \v QCPGraph\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::addData (double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided data point as {\i key}  and {\i value}  to the current data.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20258 \{\par
20259   mDataContainer->add(QCPGraphData(key, value));\par
20260 \}\par
}
}
{\xe \v channelFillGraph\:QCPGraph}
{\xe \v QCPGraph\:channelFillGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph}* QCPGraph::channelFillGraph () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5186 \{ return mChannelFillGraph.data(); \}\par
}
}
{\xe \v data\:QCPGraph}
{\xe \v QCPGraph\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer< {\b QCPGraphDataContainer} > QCPGraph::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a shared pointer to the internal data storage of type {\b QCPGraphDataContainer}. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular {\b setData} or {\b addData} methods. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5182 \{ return mDataContainer; \}\par
}
}
{\xe \v dataToImpulseLines\:QCPGraph}
{\xe \v QCPGraph\:dataToImpulseLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToImpulseLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20710 \{\par
20711   QVector<QPointF> result;\par
20712   QCPAxis *keyAxis = mKeyAxis.data();\par
20713   QCPAxis *valueAxis = mValueAxis.data();\par
20714   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20715   \par
20716   result.resize(data.size()*2);\par
20717   \par
20718   // transform data points to pixels:\par
20719   if (keyAxis->orientation() == Qt::Vertical)\par
20720   \{\par
20721     for (int i=0; i<data.size(); ++i)\par
20722     \{\par
20723       const double key = keyAxis->coordToPixel(data.at(i).key);\par
20724       result[i*2+0].setX(valueAxis->coordToPixel(0));\par
20725       result[i*2+0].setY(key);\par
20726       result[i*2+1].setX(valueAxis->coordToPixel(data.at(i).value));\par
20727       result[i*2+1].setY(key);\par
20728     \}\par
20729   \} else // key axis is horizontal\par
20730   \{\par
20731     for (int i=0; i<data.size(); ++i)\par
20732     \{\par
20733       const double key = keyAxis->coordToPixel(data.at(i).key);\par
20734       result[i*2+0].setX(key);\par
20735       result[i*2+0].setY(valueAxis->coordToPixel(0));\par
20736       result[i*2+1].setX(key);\par
20737       result[i*2+1].setY(valueAxis->coordToPixel(data.at(i).value));\par
20738     \}\par
20739   \}\par
20740   return result;\par
20741 \}\par
}
}
{\xe \v dataToLines\:QCPGraph}
{\xe \v QCPGraph\:dataToLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20516 \{\par
20517   QVector<QPointF> result;\par
20518   QCPAxis *keyAxis = mKeyAxis.data();\par
20519   QCPAxis *valueAxis = mValueAxis.data();\par
20520   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20521 \par
20522   result.resize(data.size());\par
20523   \par
20524   // transform data points to pixels:\par
20525   if (keyAxis->orientation() == Qt::Vertical)\par
20526   \{\par
20527     for (int i=0; i<data.size(); ++i)\par
20528     \{\par
20529       result[i].setX(valueAxis->coordToPixel(data.at(i).value));\par
20530       result[i].setY(keyAxis->coordToPixel(data.at(i).key));\par
20531     \}\par
20532   \} else // key axis is horizontal\par
20533   \{\par
20534     for (int i=0; i<data.size(); ++i)\par
20535     \{\par
20536       result[i].setX(keyAxis->coordToPixel(data.at(i).key));\par
20537       result[i].setY(valueAxis->coordToPixel(data.at(i).value));\par
20538     \}\par
20539   \}\par
20540   return result;\par
20541 \}\par
}
}
{\xe \v dataToStepCenterLines\:QCPGraph}
{\xe \v QCPGraph\:dataToStepCenterLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToStepCenterLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20650 \{\par
20651   QVector<QPointF> result;\par
20652   QCPAxis *keyAxis = mKeyAxis.data();\par
20653   QCPAxis *valueAxis = mValueAxis.data();\par
20654   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20655   \par
20656   result.resize(data.size()*2);\par
20657   \par
20658   // calculate steps from data and transform to pixel coordinates:\par
20659   if (keyAxis->orientation() == Qt::Vertical)\par
20660   \{\par
20661     double lastKey = keyAxis->coordToPixel(data.first().key);\par
20662     double lastValue = valueAxis->coordToPixel(data.first().value);\par
20663     result[0].setX(lastValue);\par
20664     result[0].setY(lastKey);\par
20665     for (int i=1; i<data.size(); ++i)\par
20666     \{\par
20667       const double key = (keyAxis->coordToPixel(data.at(i).key)+lastKey)*0.5;\par
20668       result[i*2-1].setX(lastValue);\par
20669       result[i*2-1].setY(key);\par
20670       lastValue = valueAxis->coordToPixel(data.at(i).value);\par
20671       lastKey = keyAxis->coordToPixel(data.at(i).key);\par
20672       result[i*2+0].setX(lastValue);\par
20673       result[i*2+0].setY(key);\par
20674     \}\par
20675     result[data.size()*2-1].setX(lastValue);\par
20676     result[data.size()*2-1].setY(lastKey);\par
20677   \} else // key axis is horizontal\par
20678   \{\par
20679     double lastKey = keyAxis->coordToPixel(data.first().key);\par
20680     double lastValue = valueAxis->coordToPixel(data.first().value);\par
20681     result[0].setX(lastKey);\par
20682     result[0].setY(lastValue);\par
20683     for (int i=1; i<data.size(); ++i)\par
20684     \{\par
20685       const double key = (keyAxis->coordToPixel(data.at(i).key)+lastKey)*0.5;\par
20686       result[i*2-1].setX(key);\par
20687       result[i*2-1].setY(lastValue);\par
20688       lastValue = valueAxis->coordToPixel(data.at(i).value);\par
20689       lastKey = keyAxis->coordToPixel(data.at(i).key);\par
20690       result[i*2+0].setX(key);\par
20691       result[i*2+0].setY(lastValue);\par
20692     \}\par
20693     result[data.size()*2-1].setX(lastKey);\par
20694     result[data.size()*2-1].setY(lastValue);\par
20695   \}\par
20696   return result;\par
20697 \}\par
}
}
{\xe \v dataToStepLeftLines\:QCPGraph}
{\xe \v QCPGraph\:dataToStepLeftLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToStepLeftLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20554 \{\par
20555   QVector<QPointF> result;\par
20556   QCPAxis *keyAxis = mKeyAxis.data();\par
20557   QCPAxis *valueAxis = mValueAxis.data();\par
20558   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20559   \par
20560   result.resize(data.size()*2);\par
20561   \par
20562   // calculate steps from data and transform to pixel coordinates:\par
20563   if (keyAxis->orientation() == Qt::Vertical)\par
20564   \{\par
20565     double lastValue = valueAxis->coordToPixel(data.first().value);\par
20566     for (int i=0; i<data.size(); ++i)\par
20567     \{\par
20568       const double key = keyAxis->coordToPixel(data.at(i).key);\par
20569       result[i*2+0].setX(lastValue);\par
20570       result[i*2+0].setY(key);\par
20571       lastValue = valueAxis->coordToPixel(data.at(i).value);\par
20572       result[i*2+1].setX(lastValue);\par
20573       result[i*2+1].setY(key);\par
20574     \}\par
20575   \} else // key axis is horizontal\par
20576   \{\par
20577     double lastValue = valueAxis->coordToPixel(data.first().value);\par
20578     for (int i=0; i<data.size(); ++i)\par
20579     \{\par
20580       const double key = keyAxis->coordToPixel(data.at(i).key);\par
20581       result[i*2+0].setX(key);\par
20582       result[i*2+0].setY(lastValue);\par
20583       lastValue = valueAxis->coordToPixel(data.at(i).value);\par
20584       result[i*2+1].setX(key);\par
20585       result[i*2+1].setY(lastValue);\par
20586     \}\par
20587   \}\par
20588   return result;\par
20589 \}\par
}
}
{\xe \v dataToStepRightLines\:QCPGraph}
{\xe \v QCPGraph\:dataToStepRightLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToStepRightLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20602 \{\par
20603   QVector<QPointF> result;\par
20604   QCPAxis *keyAxis = mKeyAxis.data();\par
20605   QCPAxis *valueAxis = mValueAxis.data();\par
20606   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20607   \par
20608   result.resize(data.size()*2);\par
20609   \par
20610   // calculate steps from data and transform to pixel coordinates:\par
20611   if (keyAxis->orientation() == Qt::Vertical)\par
20612   \{\par
20613     double lastKey = keyAxis->coordToPixel(data.first().key);\par
20614     for (int i=0; i<data.size(); ++i)\par
20615     \{\par
20616       const double value = valueAxis->coordToPixel(data.at(i).value);\par
20617       result[i*2+0].setX(value);\par
20618       result[i*2+0].setY(lastKey);\par
20619       lastKey = keyAxis->coordToPixel(data.at(i).key);\par
20620       result[i*2+1].setX(value);\par
20621       result[i*2+1].setY(lastKey);\par
20622     \}\par
20623   \} else // key axis is horizontal\par
20624   \{\par
20625     double lastKey = keyAxis->coordToPixel(data.first().key);\par
20626     for (int i=0; i<data.size(); ++i)\par
20627     \{\par
20628       const double value = valueAxis->coordToPixel(data.at(i).value);\par
20629       result[i*2+0].setX(lastKey);\par
20630       result[i*2+0].setY(value);\par
20631       lastKey = keyAxis->coordToPixel(data.at(i).key);\par
20632       result[i*2+1].setX(lastKey);\par
20633       result[i*2+1].setY(value);\par
20634     \}\par
20635   \}\par
20636   return result;\par
20637 \}\par
}
}
{\xe \v draw\:QCPGraph}
{\xe \v QCPGraph\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20298 \{\par
20299   if (!mKeyAxis || !mValueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
20300   if (mKeyAxis.data()->range().size() <= 0 || mDataContainer->isEmpty()) return;\par
20301   if (mLineStyle == lsNone && mScatterStyle.isNone()) return;\par
20302   \par
20303   QVector<QPointF> lines, scatters; // line and (if necessary) scatter pixel coordinates will be stored here while iterating over segments\par
20304   \par
20305   // loop over and draw segments of unselected/selected data:\par
20306   QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;\par
20307   getDataSegments(selectedSegments, unselectedSegments);\par
20308   allSegments << unselectedSegments << selectedSegments;\par
20309   for (int i=0; i<allSegments.size(); ++i)\par
20310   \{\par
20311     bool isSelectedSegment = i >= unselectedSegments.size();\par
20312     // get line pixel points appropriate to line style:\par
20313     QCPDataRange lineDataRange = isSelectedSegment ? allSegments.at(i) : allSegments.at(i).adjusted(-1, 1); // unselected segments extend lines to bordering selected data point (safe to exceed total data bounds in first/last segment, getLines takes care)\par
20314     getLines(&lines, lineDataRange);\par
20315     \par
20316     // check data validity if flag set:\par
20317 #ifdef QCUSTOMPLOT_CHECK_DATA\par
20318     QCPGraphDataContainer::const_iterator it;\par
20319     for (it = mDataContainer->constBegin(); it != mDataContainer->constEnd(); ++it)\par
20320     \{\par
20321       if (QCP::isInvalidData(it->key, it->value))\par
20322         qDebug() << Q_FUNC_INFO << "Data point at" << it->key << "invalid." << "Plottable name:" << name();\par
20323     \}\par
20324 #endif\par
20325     \par
20326     // draw fill of graph:\par
20327     if (isSelectedSegment && mSelectionDecorator)\par
20328       mSelectionDecorator->applyBrush(painter);\par
20329     else\par
20330       painter->setBrush(mBrush);\par
20331     painter->setPen(Qt::NoPen);\par
20332     drawFill(painter, &lines);\par
20333     \par
20334     // draw line:\par
20335     if (mLineStyle != lsNone)\par
20336     \{\par
20337       if (isSelectedSegment && mSelectionDecorator)\par
20338         mSelectionDecorator->applyPen(painter);\par
20339       else\par
20340         painter->setPen(mPen);\par
20341       painter->setBrush(Qt::NoBrush);\par
20342       if (mLineStyle == lsImpulse)\par
20343         drawImpulsePlot(painter, lines);\par
20344       else\par
20345         drawLinePlot(painter, lines); // also step plots can be drawn as a line plot\par
20346     \}\par
20347     \par
20348     // draw scatters:\par
20349     QCPScatterStyle finalScatterStyle = mScatterStyle;\par
20350     if (isSelectedSegment && mSelectionDecorator)\par
20351       finalScatterStyle = mSelectionDecorator->getFinalScatterStyle(mScatterStyle);\par
20352     if (!finalScatterStyle.isNone())\par
20353     \{\par
20354       getScatters(&scatters, allSegments.at(i));\par
20355       drawScatterPlot(painter, scatters, finalScatterStyle);\par
20356     \}\par
20357   \}\par
20358   \par
20359   // draw other selection decoration that isn't just line/scatter pens and brushes:\par
20360   if (mSelectionDecorator)\par
20361     mSelectionDecorator->drawDecoration(painter, selection());\par
20362 \}\par
}
}
{\xe \v drawFill\:QCPGraph}
{\xe \v QCPGraph\:drawFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawFill ({\b QCPPainter} *  {\i painter}, QVector< QPointF > *  {\i lines}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20761 \{\par
20762   if (mLineStyle == lsImpulse) return; // fill doesn't make sense for impulse plot\par
20763   if (painter->brush().style() == Qt::NoBrush || painter->brush().color().alpha() == 0) return;\par
20764   \par
20765   applyFillAntialiasingHint(painter);\par
20766   QVector<QCPDataRange> segments = getNonNanSegments(lines, keyAxis()->orientation());\par
20767   if (!mChannelFillGraph)\par
20768   \{\par
20769     // draw base fill under graph, fill goes all the way to the zero-value-line:\par
20770     for (int i=0; i<segments.size(); ++i)\par
20771       painter->drawPolygon(getFillPolygon(lines, segments.at(i)));\par
20772   \} else\par
20773   \{\par
20774     // draw fill between this graph and mChannelFillGraph:\par
20775     QVector<QPointF> otherLines;\par
20776     mChannelFillGraph->getLines(&otherLines, QCPDataRange(0, mChannelFillGraph->dataCount()));\par
20777     if (!otherLines.isEmpty())\par
20778     \{\par
20779       QVector<QCPDataRange> otherSegments = getNonNanSegments(&otherLines, mChannelFillGraph->keyAxis()->orientation());\par
20780       QVector<QPair<QCPDataRange, QCPDataRange> > segmentPairs = getOverlappingSegments(segments, lines, otherSegments, &otherLines);\par
20781       for (int i=0; i<segmentPairs.size(); ++i)\par
20782         painter->drawPolygon(getChannelFillPolygon(lines, segmentPairs.at(i).first, &otherLines, segmentPairs.at(i).second));\par
20783     \}\par
20784   \}\par
20785 \}\par
}
}
{\xe \v drawImpulsePlot\:QCPGraph}
{\xe \v QCPGraph\:drawImpulsePlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawImpulsePlot ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i lines}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20826 \{\par
20827   if (painter->pen().style() != Qt::NoPen && painter->pen().color().alpha() != 0)\par
20828   \{\par
20829     applyDefaultAntialiasingHint(painter);\par
20830     QPen oldPen = painter->pen();\par
20831     QPen newPen = painter->pen();\par
20832     newPen.setCapStyle(Qt::FlatCap); // so impulse line doesn't reach beyond zero-line\par
20833     painter->setPen(newPen);\par
20834     painter->drawLines(lines);\par
20835     painter->setPen(oldPen);\par
20836   \}\par
20837 \}\par
}
}
{\xe \v drawLegendIcon\:QCPGraph}
{\xe \v QCPGraph\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20366 \{\par
20367   // draw fill:\par
20368   if (mBrush.style() != Qt::NoBrush)\par
20369   \{\par
20370     applyFillAntialiasingHint(painter);\par
20371     painter->fillRect(QRectF(rect.left(), rect.top()+rect.height()/2.0, rect.width(), rect.height()/3.0), mBrush);\par
20372   \}\par
20373   // draw line vertically centered:\par
20374   if (mLineStyle != lsNone)\par
20375   \{\par
20376     applyDefaultAntialiasingHint(painter);\par
20377     painter->setPen(mPen);\par
20378     painter->drawLine(QLineF(rect.left(), rect.top()+rect.height()/2.0, rect.right()+5, rect.top()+rect.height()/2.0)); // +5 on x2 else last segment is missing from dashed/dotted pens\par
20379   \}\par
20380   // draw scatter symbol:\par
20381   if (!mScatterStyle.isNone())\par
20382   \{\par
20383     applyScattersAntialiasingHint(painter);\par
20384     // scale scatter pixmap if it's too large to fit in legend icon rect:\par
20385     if (mScatterStyle.shape() == QCPScatterStyle::ssPixmap && (mScatterStyle.pixmap().size().width() > rect.width() || mScatterStyle.pixmap().size().height() > rect.height()))\par
20386     \{\par
20387       QCPScatterStyle scaledStyle(mScatterStyle);\par
20388       scaledStyle.setPixmap(scaledStyle.pixmap().scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::SmoothTransformation));\par
20389       scaledStyle.applyTo(painter, mPen);\par
20390       scaledStyle.drawShape(painter, QRectF(rect).center());\par
20391     \} else\par
20392     \{\par
20393       mScatterStyle.applyTo(painter, mPen);\par
20394       mScatterStyle.drawShape(painter, QRectF(rect).center());\par
20395     \}\par
20396   \}\par
20397 \}\par
}
}
{\xe \v drawLinePlot\:QCPGraph}
{\xe \v QCPGraph\:drawLinePlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawLinePlot ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i lines}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20809 \{\par
20810   if (painter->pen().style() != Qt::NoPen && painter->pen().color().alpha() != 0)\par
20811   \{\par
20812     applyDefaultAntialiasingHint(painter);\par
20813     drawPolyline(painter, lines);\par
20814   \}\par
20815 \}\par
}
}
{\xe \v drawScatterPlot\:QCPGraph}
{\xe \v QCPGraph\:drawScatterPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawScatterPlot ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i scatters}, const {\b QCPScatterStyle} &  {\i style}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20795 \{\par
20796   applyScattersAntialiasingHint(painter);\par
20797   style.applyTo(painter, mPen);\par
20798   for (int i=0; i<scatters.size(); ++i)\par
20799     style.drawShape(painter, scatters.at(i).x(), scatters.at(i).y());\par
20800 \}\par
}
}
{\xe \v findIndexAboveX\:QCPGraph}
{\xe \v QCPGraph\:findIndexAboveX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::findIndexAboveX (const QVector< QPointF > *  {\i data}, double  {\i x}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21506 \{\par
21507   for (int i=data->size()-1; i>=0; --i)\par
21508   \{\par
21509     if (data->at(i).x() < x)\par
21510     \{\par
21511       if (i<data->size()-1)\par
21512         return i+1;\par
21513       else\par
21514         return data->size()-1;\par
21515     \}\par
21516   \}\par
21517   return -1;\par
21518 \}\par
}
}
{\xe \v findIndexAboveY\:QCPGraph}
{\xe \v QCPGraph\:findIndexAboveY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::findIndexAboveY (const QVector< QPointF > *  {\i data}, double  {\i y}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21552 \{\par
21553   for (int i=data->size()-1; i>=0; --i)\par
21554   \{\par
21555     if (data->at(i).y() < y)\par
21556     \{\par
21557       if (i<data->size()-1)\par
21558         return i+1;\par
21559       else\par
21560         return data->size()-1;\par
21561     \}\par
21562   \}\par
21563   return -1;\par
21564 \}\par
}
}
{\xe \v findIndexBelowX\:QCPGraph}
{\xe \v QCPGraph\:findIndexBelowX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::findIndexBelowX (const QVector< QPointF > *  {\i data}, double  {\i x}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21529 \{\par
21530   for (int i=0; i<data->size(); ++i)\par
21531   \{\par
21532     if (data->at(i).x() > x)\par
21533     \{\par
21534       if (i>0)\par
21535         return i-1;\par
21536       else\par
21537         return 0;\par
21538     \}\par
21539   \}\par
21540   return -1;\par
21541 \}\par
}
}
{\xe \v findIndexBelowY\:QCPGraph}
{\xe \v QCPGraph\:findIndexBelowY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::findIndexBelowY (const QVector< QPointF > *  {\i data}, double  {\i y}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21634 \{\par
21635   for (int i=0; i<data->size(); ++i)\par
21636   \{\par
21637     if (data->at(i).y() > y)\par
21638     \{\par
21639       if (i>0)\par
21640         return i-1;\par
21641       else\par
21642         return 0;\par
21643     \}\par
21644   \}\par
21645   return -1;\par
21646 \}\par
}
}
{\xe \v getChannelFillPolygon\:QCPGraph}
{\xe \v QCPGraph\:getChannelFillPolygon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QPolygonF QCPGraph::getChannelFillPolygon (const QVector< QPointF > *  {\i lineData}, {\b QCPDataRange}  {\i thisSegment}, const QVector< QPointF > *  {\i otherData}, {\b QCPDataRange}  {\i otherSegment}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21399 \{\par
21400   if (!mChannelFillGraph)\par
21401     return QPolygonF();\par
21402   \par
21403   QCPAxis *keyAxis = mKeyAxis.data();\par
21404   QCPAxis *valueAxis = mValueAxis.data();\par
21405   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPolygonF(); \}\par
21406   if (!mChannelFillGraph.data()->mKeyAxis) \{ qDebug() << Q_FUNC_INFO << "channel fill target key axis invalid"; return QPolygonF(); \}\par
21407   \par
21408   if (mChannelFillGraph.data()->mKeyAxis.data()->orientation() != keyAxis->orientation())\par
21409     return QPolygonF(); // don't have same axis orientation, can't fill that (Note: if keyAxis fits, valueAxis will fit too, because it's always orthogonal to keyAxis)\par
21410   \par
21411   if (thisData->isEmpty()) return QPolygonF();\par
21412   QVector<QPointF> thisSegmentData(thisSegment.size());\par
21413   QVector<QPointF> otherSegmentData(otherSegment.size());\par
21414   std::copy(thisData->constBegin()+thisSegment.begin(), thisData->constBegin()+thisSegment.end(), thisSegmentData.begin());\par
21415   std::copy(otherData->constBegin()+otherSegment.begin(), otherData->constBegin()+otherSegment.end(), otherSegmentData.begin());\par
21416   // pointers to be able to swap them, depending which data range needs cropping:\par
21417   QVector<QPointF> *staticData = &thisSegmentData;\par
21418   QVector<QPointF> *croppedData = &otherSegmentData;\par
21419   \par
21420   // crop both vectors to ranges in which the keys overlap (which coord is key, depends on axisType):\par
21421   if (keyAxis->orientation() == Qt::Horizontal)\par
21422   \{\par
21423     // x is key\par
21424     // crop lower bound:\par
21425     if (staticData->first().x() < croppedData->first().x()) // other one must be cropped\par
21426       qSwap(staticData, croppedData);\par
21427     const int lowBound = findIndexBelowX(croppedData, staticData->first().x());\par
21428     if (lowBound == -1) return QPolygonF(); // key ranges have no overlap\par
21429     croppedData->remove(0, lowBound);\par
21430     // set lowest point of cropped data to fit exactly key position of first static data point via linear interpolation:\par
21431     if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation\par
21432     double slope;\par
21433     if (!qFuzzyCompare(croppedData->at(1).x(), croppedData->at(0).x()))\par
21434       slope = (croppedData->at(1).y()-croppedData->at(0).y())/(croppedData->at(1).x()-croppedData->at(0).x());\par
21435     else\par
21436       slope = 0;\par
21437     (*croppedData)[0].setY(croppedData->at(0).y()+slope*(staticData->first().x()-croppedData->at(0).x()));\par
21438     (*croppedData)[0].setX(staticData->first().x());\par
21439     \par
21440     // crop upper bound:\par
21441     if (staticData->last().x() > croppedData->last().x()) // other one must be cropped\par
21442       qSwap(staticData, croppedData);\par
21443     int highBound = findIndexAboveX(croppedData, staticData->last().x());\par
21444     if (highBound == -1) return QPolygonF(); // key ranges have no overlap\par
21445     croppedData->remove(highBound+1, croppedData->size()-(highBound+1));\par
21446     // set highest point of cropped data to fit exactly key position of last static data point via linear interpolation:\par
21447     if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation\par
21448     const int li = croppedData->size()-1; // last index\par
21449     if (!qFuzzyCompare(croppedData->at(li).x(), croppedData->at(li-1).x()))\par
21450       slope = (croppedData->at(li).y()-croppedData->at(li-1).y())/(croppedData->at(li).x()-croppedData->at(li-1).x());\par
21451     else\par
21452       slope = 0;\par
21453     (*croppedData)[li].setY(croppedData->at(li-1).y()+slope*(staticData->last().x()-croppedData->at(li-1).x()));\par
21454     (*croppedData)[li].setX(staticData->last().x());\par
21455   \} else // mKeyAxis->orientation() == Qt::Vertical\par
21456   \{\par
21457     // y is key\par
21458     // crop lower bound:\par
21459     if (staticData->first().y() < croppedData->first().y()) // other one must be cropped\par
21460       qSwap(staticData, croppedData);\par
21461     int lowBound = findIndexBelowY(croppedData, staticData->first().y());\par
21462     if (lowBound == -1) return QPolygonF(); // key ranges have no overlap\par
21463     croppedData->remove(0, lowBound);\par
21464     // set lowest point of cropped data to fit exactly key position of first static data point via linear interpolation:\par
21465     if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation\par
21466     double slope;\par
21467     if (!qFuzzyCompare(croppedData->at(1).y(), croppedData->at(0).y())) // avoid division by zero in step plots\par
21468       slope = (croppedData->at(1).x()-croppedData->at(0).x())/(croppedData->at(1).y()-croppedData->at(0).y());\par
21469     else\par
21470       slope = 0;\par
21471     (*croppedData)[0].setX(croppedData->at(0).x()+slope*(staticData->first().y()-croppedData->at(0).y()));\par
21472     (*croppedData)[0].setY(staticData->first().y());\par
21473     \par
21474     // crop upper bound:\par
21475     if (staticData->last().y() > croppedData->last().y()) // other one must be cropped\par
21476       qSwap(staticData, croppedData);\par
21477     int highBound = findIndexAboveY(croppedData, staticData->last().y());\par
21478     if (highBound == -1) return QPolygonF(); // key ranges have no overlap\par
21479     croppedData->remove(highBound+1, croppedData->size()-(highBound+1));\par
21480     // set highest point of cropped data to fit exactly key position of last static data point via linear interpolation:\par
21481     if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation\par
21482     int li = croppedData->size()-1; // last index\par
21483     if (!qFuzzyCompare(croppedData->at(li).y(), croppedData->at(li-1).y())) // avoid division by zero in step plots\par
21484       slope = (croppedData->at(li).x()-croppedData->at(li-1).x())/(croppedData->at(li).y()-croppedData->at(li-1).y());\par
21485     else\par
21486       slope = 0;\par
21487     (*croppedData)[li].setX(croppedData->at(li-1).x()+slope*(staticData->last().y()-croppedData->at(li-1).y()));\par
21488     (*croppedData)[li].setY(staticData->last().y());\par
21489   \}\par
21490   \par
21491   // return joined:\par
21492   for (int i=otherSegmentData.size()-1; i>=0; --i) // insert reversed, otherwise the polygon will be twisted\par
21493     thisSegmentData << otherSegmentData.at(i);\par
21494   return QPolygonF(thisSegmentData);\par
21495 \}\par
}
}
{\xe \v getFillBasePoint\:QCPGraph}
{\xe \v QCPGraph\:getFillBasePoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPGraph::getFillBasePoint (QPointF  {\i matchingDataPoint}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21309 \{\par
21310   QCPAxis *keyAxis = mKeyAxis.data();\par
21311   QCPAxis *valueAxis = mValueAxis.data();\par
21312   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); \}\par
21313   \par
21314   QPointF result;\par
21315   if (valueAxis->scaleType() == QCPAxis::stLinear)\par
21316   \{\par
21317     if (keyAxis->orientation() == Qt::Horizontal)\par
21318     \{\par
21319       result.setX(matchingDataPoint.x());\par
21320       result.setY(valueAxis->coordToPixel(0));\par
21321     \} else // keyAxis->orientation() == Qt::Vertical\par
21322     \{\par
21323       result.setX(valueAxis->coordToPixel(0));\par
21324       result.setY(matchingDataPoint.y());\par
21325     \}\par
21326   \} else // valueAxis->mScaleType == QCPAxis::stLogarithmic\par
21327   \{\par
21328     // In logarithmic scaling we can't just draw to value 0 so we just fill all the way\par
21329     // to the axis which is in the direction towards 0\par
21330     if (keyAxis->orientation() == Qt::Vertical)\par
21331     \{\par
21332       if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||\par
21333           (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) // if range is negative, zero is on opposite side of key axis\par
21334         result.setX(keyAxis->axisRect()->right());\par
21335       else\par
21336         result.setX(keyAxis->axisRect()->left());\par
21337       result.setY(matchingDataPoint.y());\par
21338     \} else if (keyAxis->axisType() == QCPAxis::atTop || keyAxis->axisType() == QCPAxis::atBottom)\par
21339     \{\par
21340       result.setX(matchingDataPoint.x());\par
21341       if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||\par
21342           (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) // if range is negative, zero is on opposite side of key axis\par
21343         result.setY(keyAxis->axisRect()->top());\par
21344       else\par
21345         result.setY(keyAxis->axisRect()->bottom());\par
21346     \}\par
21347   \}\par
21348   return result;\par
21349 \}\par
}
}
{\xe \v getFillPolygon\:QCPGraph}
{\xe \v QCPGraph\:getFillPolygon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QPolygonF QCPGraph::getFillPolygon (const QVector< QPointF > *  {\i lineData}, {\b QCPDataRange}  {\i segment}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21368 \{\par
21369   if (segment.size() < 2)\par
21370     return QPolygonF();\par
21371   QPolygonF result(segment.size()+2);\par
21372   \par
21373   result[0] = getFillBasePoint(lineData->at(segment.begin()));\par
21374   std::copy(lineData->constBegin()+segment.begin(), lineData->constBegin()+segment.end(), result.begin()+1);\par
21375   result[result.size()-1] = getFillBasePoint(lineData->at(segment.end()-1));\par
21376   \par
21377   return result;\par
21378 \}\par
}
}
{\xe \v getKeyRange\:QCPGraph}
{\xe \v QCPGraph\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPGraph::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20286 \{\par
20287   return mDataContainer->keyRange(foundRange, inSignDomain);\par
20288 \}\par
}
}
{\xe \v getLines\:QCPGraph}
{\xe \v QCPGraph\:getLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getLines (QVector< QPointF > *  {\i lines}, const {\b QCPDataRange} &  {\i dataRange}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20420 \{\par
20421   if (!lines) return;\par
20422   QCPGraphDataContainer::const_iterator begin, end;\par
20423   getVisibleDataBounds(begin, end, dataRange);\par
20424   if (begin == end)\par
20425   \{\par
20426     lines->clear();\par
20427     return;\par
20428   \}\par
20429   \par
20430   QVector<QCPGraphData> lineData;\par
20431   if (mLineStyle != lsNone)\par
20432     getOptimizedLineData(&lineData, begin, end);\par
20433   \par
20434   if (mKeyAxis->rangeReversed() != (mKeyAxis->orientation() == Qt::Vertical)) // make sure key pixels are sorted ascending in lineData (significantly simplifies following processing)\par
20435     std::reverse(lineData.begin(), lineData.end());\par
20436 \par
20437   switch (mLineStyle)\par
20438   \{\par
20439     case lsNone: lines->clear(); break;\par
20440     case lsLine: *lines = dataToLines(lineData); break;\par
20441     case lsStepLeft: *lines = dataToStepLeftLines(lineData); break;\par
20442     case lsStepRight: *lines = dataToStepRightLines(lineData); break;\par
20443     case lsStepCenter: *lines = dataToStepCenterLines(lineData); break;\par
20444     case lsImpulse: *lines = dataToImpulseLines(lineData); break;\par
20445   \}\par
20446 \}\par
}
}
{\xe \v getNonNanSegments\:QCPGraph}
{\xe \v QCPGraph\:getNonNanSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< {\b QCPDataRange} > QCPGraph::getNonNanSegments (const QVector< QPointF > *  {\i lineData}, Qt::Orientation  {\i keyOrientation}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21155 \{\par
21156   QVector<QCPDataRange> result;\par
21157   const int n = lineData->size();\par
21158   \par
21159   QCPDataRange currentSegment(-1, -1);\par
21160   int i = 0;\par
21161   \par
21162   if (keyOrientation == Qt::Horizontal)\par
21163   \{\par
21164     while (i < n)\par
21165     \{\par
21166       while (i < n && qIsNaN(lineData->at(i).y())) // seek next non-NaN data point\par
21167         ++i;\par
21168       if (i == n)\par
21169         break;\par
21170       currentSegment.setBegin(i++);\par
21171       while (i < n && !qIsNaN(lineData->at(i).y())) // seek next NaN data point or end of data\par
21172         ++i;\par
21173       currentSegment.setEnd(i++);\par
21174       result.append(currentSegment);\par
21175     \}\par
21176   \} else // keyOrientation == Qt::Vertical\par
21177   \{\par
21178     while (i < n)\par
21179     \{\par
21180       while (i < n && qIsNaN(lineData->at(i).x())) // seek next non-NaN data point\par
21181         ++i;\par
21182       if (i == n)\par
21183         break;\par
21184       currentSegment.setBegin(i++);\par
21185       while (i < n && !qIsNaN(lineData->at(i).x())) // seek next NaN data point or end of data\par
21186         ++i;\par
21187       currentSegment.setEnd(i++);\par
21188       result.append(currentSegment);\par
21189     \}\par
21190   \}\par
21191   return result;\par
21192 \}\par
}
}
{\xe \v getOptimizedLineData\:QCPGraph}
{\xe \v QCPGraph\:getOptimizedLineData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getOptimizedLineData (QVector< {\b QCPGraphData} > *  {\i lineData}, const {\b QCPGraphDataContainer::const_iterator} &  {\i begin}, const {\b QCPGraphDataContainer::const_iterator} &  {\i end}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20852 \{\par
20853   if (!lineData) return;\par
20854   QCPAxis *keyAxis = mKeyAxis.data();\par
20855   QCPAxis *valueAxis = mValueAxis.data();\par
20856   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
20857   if (begin == end) return;\par
20858   \par
20859   int dataCount = end-begin;\par
20860   int maxCount = std::numeric_limits<int>::max();\par
20861   if (mAdaptiveSampling)\par
20862   \{\par
20863     double keyPixelSpan = qAbs(keyAxis->coordToPixel(begin->key)-keyAxis->coordToPixel((end-1)->key));\par
20864     if (2*keyPixelSpan+2 < (double)std::numeric_limits<int>::max())\par
20865       maxCount = 2*keyPixelSpan+2;\par
20866   \}\par
20867   \par
20868   if (mAdaptiveSampling && dataCount >= maxCount) // use adaptive sampling only if there are at least two points per pixel on average\par
20869   \{\par
20870     QCPGraphDataContainer::const_iterator it = begin;\par
20871     double minValue = it->value;\par
20872     double maxValue = it->value;\par
20873     QCPGraphDataContainer::const_iterator currentIntervalFirstPoint = it;\par
20874     int reversedFactor = keyAxis->pixelOrientation(); // is used to calculate keyEpsilon pixel into the correct direction\par
20875     int reversedRound = reversedFactor==-1 ? 1 : 0; // is used to switch between floor (normal) and ceil (reversed) rounding of currentIntervalStartKey\par
20876     double currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(begin->key)+reversedRound));\par
20877     double lastIntervalEndKey = currentIntervalStartKey;\par
20878     double keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor)); // interval of one pixel on screen when mapped to plot key coordinates\par
20879     bool keyEpsilonVariable = keyAxis->scaleType() == QCPAxis::stLogarithmic; // indicates whether keyEpsilon needs to be updated after every interval (for log axes)\par
20880     int intervalDataCount = 1;\par
20881     ++it; // advance iterator to second data point because adaptive sampling works in 1 point retrospect\par
20882     while (it != end)\par
20883     \{\par
20884       if (it->key < currentIntervalStartKey+keyEpsilon) // data point is still within same pixel, so skip it and expand value span of this cluster if necessary\par
20885       \{\par
20886         if (it->value < minValue)\par
20887           minValue = it->value;\par
20888         else if (it->value > maxValue)\par
20889           maxValue = it->value;\par
20890         ++intervalDataCount;\par
20891       \} else // new pixel interval started\par
20892       \{\par
20893         if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them to a cluster\par
20894         \{\par
20895           if (lastIntervalEndKey < currentIntervalStartKey-keyEpsilon) // last point is further away, so first point of this cluster must be at a real data point\par
20896             lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.2, currentIntervalFirstPoint->value));\par
20897           lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.25, minValue));\par
20898           lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.75, maxValue));\par
20899           if (it->key > currentIntervalStartKey+keyEpsilon*2) // new pixel started further away from previous cluster, so make sure the last point of the cluster is at a real data point\par
20900             lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.8, (it-1)->value));\par
20901         \} else\par
20902           lineData->append(QCPGraphData(currentIntervalFirstPoint->key, currentIntervalFirstPoint->value));\par
20903         lastIntervalEndKey = (it-1)->key;\par
20904         minValue = it->value;\par
20905         maxValue = it->value;\par
20906         currentIntervalFirstPoint = it;\par
20907         currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(it->key)+reversedRound));\par
20908         if (keyEpsilonVariable)\par
20909           keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor));\par
20910         intervalDataCount = 1;\par
20911       \}\par
20912       ++it;\par
20913     \}\par
20914     // handle last interval:\par
20915     if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them to a cluster\par
20916     \{\par
20917       if (lastIntervalEndKey < currentIntervalStartKey-keyEpsilon) // last point wasn't a cluster, so first point of this cluster must be at a real data point\par
20918         lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.2, currentIntervalFirstPoint->value));\par
20919       lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.25, minValue));\par
20920       lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.75, maxValue));\par
20921     \} else\par
20922       lineData->append(QCPGraphData(currentIntervalFirstPoint->key, currentIntervalFirstPoint->value));\par
20923     \par
20924   \} else // don't use adaptive sampling algorithm, transfer points one-to-one from the data container into the output\par
20925   \{\par
20926     lineData->resize(dataCount);\par
20927     std::copy(begin, end, lineData->begin());\par
20928   \}\par
20929 \}\par
}
}
{\xe \v getOptimizedScatterData\:QCPGraph}
{\xe \v QCPGraph\:getOptimizedScatterData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getOptimizedScatterData (QVector< {\b QCPGraphData} > *  {\i scatterData}, {\b QCPGraphDataContainer::const_iterator}  {\i begin}, {\b QCPGraphDataContainer::const_iterator}  {\i end}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20944 \{\par
20945   if (!scatterData) return;\par
20946   QCPAxis *keyAxis = mKeyAxis.data();\par
20947   QCPAxis *valueAxis = mValueAxis.data();\par
20948   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
20949   \par
20950   const int scatterModulo = mScatterSkip+1;\par
20951   const bool doScatterSkip = mScatterSkip > 0;\par
20952   int beginIndex = begin-mDataContainer->constBegin();\par
20953   int endIndex = end-mDataContainer->constBegin();\par
20954   while (doScatterSkip && begin != end && beginIndex % scatterModulo != 0) // advance begin iterator to first non-skipped scatter\par
20955   \{\par
20956     ++beginIndex;\par
20957     ++begin;\par
20958   \}\par
20959   if (begin == end) return;\par
20960   int dataCount = end-begin;\par
20961   int maxCount = std::numeric_limits<int>::max();\par
20962   if (mAdaptiveSampling)\par
20963   \{\par
20964     int keyPixelSpan = qAbs(keyAxis->coordToPixel(begin->key)-keyAxis->coordToPixel((end-1)->key));\par
20965     maxCount = 2*keyPixelSpan+2;\par
20966   \}\par
20967   \par
20968   if (mAdaptiveSampling && dataCount >= maxCount) // use adaptive sampling only if there are at least two points per pixel on average\par
20969   \{\par
20970     double valueMaxRange = valueAxis->range().upper;\par
20971     double valueMinRange = valueAxis->range().lower;\par
20972     QCPGraphDataContainer::const_iterator it = begin;\par
20973     int itIndex = beginIndex;\par
20974     double minValue = it->value;\par
20975     double maxValue = it->value;\par
20976     QCPGraphDataContainer::const_iterator minValueIt = it;\par
20977     QCPGraphDataContainer::const_iterator maxValueIt = it;\par
20978     QCPGraphDataContainer::const_iterator currentIntervalStart = it;\par
20979     int reversedFactor = keyAxis->pixelOrientation(); // is used to calculate keyEpsilon pixel into the correct direction\par
20980     int reversedRound = reversedFactor==-1 ? 1 : 0; // is used to switch between floor (normal) and ceil (reversed) rounding of currentIntervalStartKey\par
20981     double currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(begin->key)+reversedRound));\par
20982     double keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor)); // interval of one pixel on screen when mapped to plot key coordinates\par
20983     bool keyEpsilonVariable = keyAxis->scaleType() == QCPAxis::stLogarithmic; // indicates whether keyEpsilon needs to be updated after every interval (for log axes)\par
20984     int intervalDataCount = 1;\par
20985     // advance iterator to second (non-skipped) data point because adaptive sampling works in 1 point retrospect:\par
20986     if (!doScatterSkip)\par
20987       ++it;\par
20988     else\par
20989     \{\par
20990       itIndex += scatterModulo;\par
20991       if (itIndex < endIndex) // make sure we didn't jump over end\par
20992         it += scatterModulo;\par
20993       else\par
20994       \{\par
20995         it = end;\par
20996         itIndex = endIndex;\par
20997       \}\par
20998     \}\par
20999     // main loop over data points:\par
21000     while (it != end)\par
21001     \{\par
21002       if (it->key < currentIntervalStartKey+keyEpsilon) // data point is still within same pixel, so skip it and expand value span of this pixel if necessary\par
21003       \{\par
21004         if (it->value < minValue && it->value > valueMinRange && it->value < valueMaxRange)\par
21005         \{\par
21006           minValue = it->value;\par
21007           minValueIt = it;\par
21008         \} else if (it->value > maxValue && it->value > valueMinRange && it->value < valueMaxRange)\par
21009         \{\par
21010           maxValue = it->value;\par
21011           maxValueIt = it;\par
21012         \}\par
21013         ++intervalDataCount;\par
21014       \} else // new pixel started\par
21015       \{\par
21016         if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them\par
21017         \{\par
21018           // determine value pixel span and add as many points in interval to maintain certain vertical data density (this is specific to scatter plot):\par
21019           double valuePixelSpan = qAbs(valueAxis->coordToPixel(minValue)-valueAxis->coordToPixel(maxValue));\par
21020           int dataModulo = qMax(1, qRound(intervalDataCount/(valuePixelSpan/4.0))); // approximately every 4 value pixels one data point on average\par
21021           QCPGraphDataContainer::const_iterator intervalIt = currentIntervalStart;\par
21022           int c = 0;\par
21023           while (intervalIt != it)\par
21024           \{\par
21025             if ((c % dataModulo == 0 || intervalIt == minValueIt || intervalIt == maxValueIt) && intervalIt->value > valueMinRange && intervalIt->value < valueMaxRange)\par
21026               scatterData->append(*intervalIt);\par
21027             ++c;\par
21028             if (!doScatterSkip)\par
21029               ++intervalIt;\par
21030             else\par
21031               intervalIt += scatterModulo; // since we know indices of "currentIntervalStart", "intervalIt" and "it" are multiples of scatterModulo, we can't accidentally jump over "it" here\par
21032           \}\par
21033         \} else if (currentIntervalStart->value > valueMinRange && currentIntervalStart->value < valueMaxRange)\par
21034           scatterData->append(*currentIntervalStart);\par
21035         minValue = it->value;\par
21036         maxValue = it->value;\par
21037         currentIntervalStart = it;\par
21038         currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(it->key)+reversedRound));\par
21039         if (keyEpsilonVariable)\par
21040           keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor));\par
21041         intervalDataCount = 1;\par
21042       \}\par
21043       // advance to next data point:\par
21044       if (!doScatterSkip)\par
21045         ++it;\par
21046       else\par
21047       \{\par
21048         itIndex += scatterModulo;\par
21049         if (itIndex < endIndex) // make sure we didn't jump over end\par
21050           it += scatterModulo;\par
21051         else\par
21052         \{\par
21053           it = end;\par
21054           itIndex = endIndex;\par
21055         \}\par
21056       \}\par
21057     \}\par
21058     // handle last interval:\par
21059     if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them\par
21060     \{\par
21061       // determine value pixel span and add as many points in interval to maintain certain vertical data density (this is specific to scatter plot):\par
21062       double valuePixelSpan = qAbs(valueAxis->coordToPixel(minValue)-valueAxis->coordToPixel(maxValue));\par
21063       int dataModulo = qMax(1, qRound(intervalDataCount/(valuePixelSpan/4.0))); // approximately every 4 value pixels one data point on average\par
21064       QCPGraphDataContainer::const_iterator intervalIt = currentIntervalStart;\par
21065       int intervalItIndex = intervalIt-mDataContainer->constBegin();\par
21066       int c = 0;\par
21067       while (intervalIt != it)\par
21068       \{\par
21069         if ((c % dataModulo == 0 || intervalIt == minValueIt || intervalIt == maxValueIt) && intervalIt->value > valueMinRange && intervalIt->value < valueMaxRange)\par
21070           scatterData->append(*intervalIt);\par
21071         ++c;\par
21072         if (!doScatterSkip)\par
21073           ++intervalIt;\par
21074         else // here we can't guarantee that adding scatterModulo doesn't exceed "it" (because "it" is equal to "end" here, and "end" isn't scatterModulo-aligned), so check via index comparison:\par
21075         \{\par
21076           intervalItIndex += scatterModulo;\par
21077           if (intervalItIndex < itIndex)\par
21078             intervalIt += scatterModulo;\par
21079           else\par
21080           \{\par
21081             intervalIt = it;\par
21082             intervalItIndex = itIndex;\par
21083           \}\par
21084         \}\par
21085       \}\par
21086     \} else if (currentIntervalStart->value > valueMinRange && currentIntervalStart->value < valueMaxRange)\par
21087       scatterData->append(*currentIntervalStart);\par
21088     \par
21089   \} else // don't use adaptive sampling algorithm, transfer points one-to-one from the data container into the output\par
21090   \{\par
21091     QCPGraphDataContainer::const_iterator it = begin;\par
21092     int itIndex = beginIndex;\par
21093     scatterData->reserve(dataCount);\par
21094     while (it != end)\par
21095     \{\par
21096       scatterData->append(*it);\par
21097       // advance to next data point:\par
21098       if (!doScatterSkip)\par
21099         ++it;\par
21100       else\par
21101       \{\par
21102         itIndex += scatterModulo;\par
21103         if (itIndex < endIndex)\par
21104           it += scatterModulo;\par
21105         else\par
21106         \{\par
21107           it = end;\par
21108           itIndex = endIndex;\par
21109         \}\par
21110       \}\par
21111     \}\par
21112   \}\par
21113 \}\par
}
}
{\xe \v getOverlappingSegments\:QCPGraph}
{\xe \v QCPGraph\:getOverlappingSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPair< {\b QCPDataRange}, {\b QCPDataRange} > > QCPGraph::getOverlappingSegments (QVector< {\b QCPDataRange} >  {\i thisSegments}, const QVector< QPointF > *  {\i thisData}, QVector< {\b QCPDataRange} >  {\i otherSegments}, const QVector< QPointF > *  {\i otherData}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21213 \{\par
21214   QVector<QPair<QCPDataRange, QCPDataRange> > result;\par
21215   if (thisData->isEmpty() || otherData->isEmpty() || thisSegments.isEmpty() || otherSegments.isEmpty())\par
21216     return result;\par
21217   \par
21218   int thisIndex = 0;\par
21219   int otherIndex = 0;\par
21220   const bool verticalKey = mKeyAxis->orientation() == Qt::Vertical;\par
21221   while (thisIndex < thisSegments.size() && otherIndex < otherSegments.size())\par
21222   \{\par
21223     if (thisSegments.at(thisIndex).size() < 2) // segments with fewer than two points won't have a fill anyhow\par
21224     \{\par
21225       ++thisIndex;\par
21226       continue;\par
21227     \}\par
21228     if (otherSegments.at(otherIndex).size() < 2) // segments with fewer than two points won't have a fill anyhow\par
21229     \{\par
21230       ++otherIndex;\par
21231       continue;\par
21232     \}\par
21233     double thisLower, thisUpper, otherLower, otherUpper;\par
21234     if (!verticalKey)\par
21235     \{\par
21236       thisLower = thisData->at(thisSegments.at(thisIndex).begin()).x();\par
21237       thisUpper = thisData->at(thisSegments.at(thisIndex).end()-1).x();\par
21238       otherLower = otherData->at(otherSegments.at(otherIndex).begin()).x();\par
21239       otherUpper = otherData->at(otherSegments.at(otherIndex).end()-1).x();\par
21240     \} else\par
21241     \{\par
21242       thisLower = thisData->at(thisSegments.at(thisIndex).begin()).y();\par
21243       thisUpper = thisData->at(thisSegments.at(thisIndex).end()-1).y();\par
21244       otherLower = otherData->at(otherSegments.at(otherIndex).begin()).y();\par
21245       otherUpper = otherData->at(otherSegments.at(otherIndex).end()-1).y();\par
21246     \}\par
21247     \par
21248     int bPrecedence;\par
21249     if (segmentsIntersect(thisLower, thisUpper, otherLower, otherUpper, bPrecedence))\par
21250       result.append(QPair<QCPDataRange, QCPDataRange>(thisSegments.at(thisIndex), otherSegments.at(otherIndex)));\par
21251     \par
21252     if (bPrecedence <= 0) // otherSegment doesn't reach as far as thisSegment, so continue with next otherSegment, keeping current thisSegment\par
21253       ++otherIndex;\par
21254     else // otherSegment reaches further than thisSegment, so continue with next thisSegment, keeping current otherSegment\par
21255       ++thisIndex;\par
21256   \}\par
21257   \par
21258   return result;\par
21259 \}\par
}
}
{\xe \v getScatters\:QCPGraph}
{\xe \v QCPGraph\:getScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getScatters (QVector< QPointF > *  {\i scatters}, const {\b QCPDataRange} &  {\i dataRange}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20461 \{\par
20462   if (!scatters) return;\par
20463   QCPAxis *keyAxis = mKeyAxis.data();\par
20464   QCPAxis *valueAxis = mValueAxis.data();\par
20465   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; scatters->clear(); return; \}\par
20466   \par
20467   QCPGraphDataContainer::const_iterator begin, end;\par
20468   getVisibleDataBounds(begin, end, dataRange);\par
20469   if (begin == end)\par
20470   \{\par
20471     scatters->clear();\par
20472     return;\par
20473   \}\par
20474   \par
20475   QVector<QCPGraphData> data;\par
20476   getOptimizedScatterData(&data, begin, end);\par
20477   \par
20478   if (mKeyAxis->rangeReversed() != (mKeyAxis->orientation() == Qt::Vertical)) // make sure key pixels are sorted ascending in data (significantly simplifies following processing)\par
20479     std::reverse(data.begin(), data.end());\par
20480   \par
20481   scatters->resize(data.size());\par
20482   if (keyAxis->orientation() == Qt::Vertical)\par
20483   \{\par
20484     for (int i=0; i<data.size(); ++i)\par
20485     \{\par
20486       if (!qIsNaN(data.at(i).value))\par
20487       \{\par
20488         (*scatters)[i].setX(valueAxis->coordToPixel(data.at(i).value));\par
20489         (*scatters)[i].setY(keyAxis->coordToPixel(data.at(i).key));\par
20490       \}\par
20491     \}\par
20492   \} else\par
20493   \{\par
20494     for (int i=0; i<data.size(); ++i)\par
20495     \{\par
20496       if (!qIsNaN(data.at(i).value))\par
20497       \{\par
20498         (*scatters)[i].setX(keyAxis->coordToPixel(data.at(i).key));\par
20499         (*scatters)[i].setY(valueAxis->coordToPixel(data.at(i).value));\par
20500       \}\par
20501     \}\par
20502   \}\par
20503 \}\par
}
}
{\xe \v getValueRange\:QCPGraph}
{\xe \v QCPGraph\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPGraph::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20292 \{\par
20293   return mDataContainer->valueRange(foundRange, inSignDomain, inKeyRange);\par
20294 \}\par
}
}
{\xe \v getVisibleDataBounds\:QCPGraph}
{\xe \v QCPGraph\:getVisibleDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getVisibleDataBounds ({\b QCPGraphDataContainer::const_iterator} &  {\i begin}, {\b QCPGraphDataContainer::const_iterator} &  {\i end}, const {\b QCPDataRange} &  {\i rangeRestriction}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method outputs the currently visible data range via {\i begin}  and {\i end} . The returned range will also never exceed {\i rangeRestriction} .\par
This method takes into account that the drawing of data lines at the axis rect border always requires the points just outside the visible axis range. So {\i begin}  and {\i end}  may actually indicate a range that contains one additional data point to the left and right of the visible axis range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21125 \{\par
21126   if (rangeRestriction.isEmpty())\par
21127   \{\par
21128     end = mDataContainer->constEnd();\par
21129     begin = end;\par
21130   \} else\par
21131   \{\par
21132     QCPAxis *keyAxis = mKeyAxis.data();\par
21133     QCPAxis *valueAxis = mValueAxis.data();\par
21134     if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
21135     // get visible data range:\par
21136     begin = mDataContainer->findBegin(keyAxis->range().lower);\par
21137     end = mDataContainer->findEnd(keyAxis->range().upper);\par
21138     // limit lower/upperEnd to rangeRestriction:\par
21139     mDataContainer->limitIteratorsToDataRange(begin, end, rangeRestriction); // this also ensures rangeRestriction outside data bounds doesn't break anything\par
21140   \}\par
21141 \}\par
}
}
{\xe \v lineStyle\:QCPGraph}
{\xe \v QCPGraph\:lineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LineStyle} QCPGraph::lineStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5183 \{ return mLineStyle; \}\par
}
}
{\xe \v pointDistance\:QCPGraph}
{\xe \v QCPGraph\:pointDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPGraph::pointDistance (const QPointF &  {\i pixelPoint}, {\b QCPGraphDataContainer::const_iterator} &  {\i closestData}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21578 \{\par
21579   closestData = mDataContainer->constEnd();\par
21580   if (mDataContainer->isEmpty())\par
21581     return -1.0;\par
21582   if (mLineStyle == lsNone && mScatterStyle.isNone())\par
21583     return -1.0;\par
21584   \par
21585   // calculate minimum distances to graph data points and find closestData iterator:\par
21586   double minDistSqr = std::numeric_limits<double>::max();\par
21587   // determine which key range comes into question, taking selection tolerance around pos into account:\par
21588   double posKeyMin, posKeyMax, dummy;\par
21589   pixelsToCoords(pixelPoint-QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMin, dummy);\par
21590   pixelsToCoords(pixelPoint+QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMax, dummy);\par
21591   if (posKeyMin > posKeyMax)\par
21592     qSwap(posKeyMin, posKeyMax);\par
21593   // iterate over found data points and then choose the one with the shortest distance to pos:\par
21594   QCPGraphDataContainer::const_iterator begin = mDataContainer->findBegin(posKeyMin, true);\par
21595   QCPGraphDataContainer::const_iterator end = mDataContainer->findEnd(posKeyMax, true);\par
21596   for (QCPGraphDataContainer::const_iterator it=begin; it!=end; ++it)\par
21597   \{\par
21598     const double currentDistSqr = QCPVector2D(coordsToPixels(it->key, it->value)-pixelPoint).lengthSquared();\par
21599     if (currentDistSqr < minDistSqr)\par
21600     \{\par
21601       minDistSqr = currentDistSqr;\par
21602       closestData = it;\par
21603     \}\par
21604   \}\par
21605     \par
21606   // calculate distance to graph line if there is one (if so, will probably be smaller than distance to closest data point):\par
21607   if (mLineStyle != lsNone)\par
21608   \{\par
21609     // line displayed, calculate distance to line segments:\par
21610     QVector<QPointF> lineData;\par
21611     getLines(&lineData, QCPDataRange(0, dataCount()));\par
21612     QCPVector2D p(pixelPoint);\par
21613     const int step = mLineStyle==lsImpulse ? 2 : 1; // impulse plot differs from other line styles in that the lineData points are only pairwise connected\par
21614     for (int i=0; i<lineData.size()-1; i+=step)\par
21615     \{\par
21616       const double currentDistSqr = p.distanceSquaredToLine(lineData.at(i), lineData.at(i+1));\par
21617       if (currentDistSqr < minDistSqr)\par
21618         minDistSqr = currentDistSqr;\par
21619     \}\par
21620   \}\par
21621   \par
21622   return qSqrt(minDistSqr);\par
21623 \}\par
}
}
{\xe \v scatterSkip\:QCPGraph}
{\xe \v QCPGraph\:scatterSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::scatterSkip () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5185 \{ return mScatterSkip; \}\par
}
}
{\xe \v scatterStyle\:QCPGraph}
{\xe \v QCPGraph\:scatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPGraph::scatterStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5184 \{ return mScatterStyle; \}\par
}
}
{\xe \v segmentsIntersect\:QCPGraph}
{\xe \v QCPGraph\:segmentsIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGraph::segmentsIntersect (double  {\i aLower}, double  {\i aUpper}, double  {\i bLower}, double  {\i bUpper}, int &  {\i bPrecedence}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21276 \{\par
21277   bPrecedence = 0;\par
21278   if (aLower > bUpper)\par
21279   \{\par
21280     bPrecedence = -1;\par
21281     return false;\par
21282   \} else if (bLower > aUpper)\par
21283   \{\par
21284     bPrecedence = 1;\par
21285     return false;\par
21286   \} else\par
21287   \{\par
21288     if (aUpper > bUpper)\par
21289       bPrecedence = -1;\par
21290     else if (aUpper < bUpper)\par
21291       bPrecedence = 1;\par
21292     \par
21293     return true;\par
21294   \}\par
21295 \}\par
}
}
{\xe \v selectTest\:QCPGraph}
{\xe \v QCPGraph\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPGraph::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Reimplemented from {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20264 \{\par
20265   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
20266     return -1;\par
20267   if (!mKeyAxis || !mValueAxis)\par
20268     return -1;\par
20269   \par
20270   if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))\par
20271   \{\par
20272     QCPGraphDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();\par
20273     double result = pointDistance(pos, closestDataPoint);\par
20274     if (details)\par
20275     \{\par
20276       int pointIndex = closestDataPoint-mDataContainer->constBegin();\par
20277       details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));\par
20278     \}\par
20279     return result;\par
20280   \} else\par
20281     return -1;\par
20282 \}\par
}
}
{\xe \v setAdaptiveSampling\:QCPGraph}
{\xe \v QCPGraph\:setAdaptiveSampling}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setAdaptiveSampling (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether adaptive sampling shall be used when plotting this graph. {\b QCustomPlot}'s adaptive sampling technique can drastically improve the replot performance for graphs with a larger number of points (e.g. above 10,000), without notably changing the appearance of the graph.\par
By default, adaptive sampling is enabled. Even if enabled, {\b QCustomPlot} decides whether adaptive sampling shall actually be used on a per-graph basis. So leaving adaptive sampling enabled has no disadvantage in almost all cases.\par
 As can be seen, line plots experience no visual degradation from adaptive sampling. Outliers are reproduced reliably, as well as the overall shape of the data set. The replot time reduces dramatically though. This allows {\b QCustomPlot} to display large amounts of data in realtime.\par
 Care must be taken when using high-density scatter plots in combination with adaptive sampling. The adaptive sampling algorithm treats scatter plots more carefully than line plots which still gives a significant reduction of replot times, but not quite as much as for line plots. This is because scatter plots inherently need more data points to be preserved in order to still resemble the original, non-adaptive-sampling plot. As shown above, the results still aren't quite identical, as banding occurs for the outer data points. This is in fact intentional, such that the boundaries of the data cloud stay visible to the viewer. How strong the banding appears, depends on the point density, i.e. the number of points in the plot.\par
For some situations with scatter plots it might thus be desirable to manually turn adaptive sampling off. For example, when saving the plot to disk. This can be achieved by setting {\i enabled}  to false before issuing a command like {\b QCustomPlot::savePng}, and setting {\i enabled}  back to true afterwards. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20215 \{\par
20216   mAdaptiveSampling = enabled;\par
20217 \}\par
}
}
{\xe \v setChannelFillGraph\:QCPGraph}
{\xe \v QCPGraph\:setChannelFillGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setChannelFillGraph ({\b QCPGraph} *  {\i targetGraph})}}
\par
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the target graph for filling the area between this graph and {\i targetGraph}  with the current brush ({\b setBrush}).\par
When {\i targetGraph}  is set to 0, a normal graph fill to the zero-value-line will be shown. To disable any filling, set the brush to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20164 \{\par
20165   // prevent setting channel target to this graph itself:\par
20166   if (targetGraph == this)\par
20167   \{\par
20168     qDebug() << Q_FUNC_INFO << "targetGraph is this graph itself";\par
20169     mChannelFillGraph = 0;\par
20170     return;\par
20171   \}\par
20172   // prevent setting channel target to a graph not in the plot:\par
20173   if (targetGraph && targetGraph->mParentPlot != mParentPlot)\par
20174   \{\par
20175     qDebug() << Q_FUNC_INFO << "targetGraph not in same plot";\par
20176     mChannelFillGraph = 0;\par
20177     return;\par
20178   \}\par
20179   \par
20180   mChannelFillGraph = targetGraph;\par
20181 \}\par
}
}
{\xe \v setData\:QCPGraph}
{\xe \v QCPGraph\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setData (QSharedPointer< {\b QCPGraphDataContainer} >  {\i data})}}
\par
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data container with the provided {\i data}  container.\par
Since a QSharedPointer is used, multiple QCPGraphs may share the same data container safely. Modifying the data in the container will then affect all graphs that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } If you do not wish to share containers, but create a copy from an existing container, rather use the {\b QCPDataContainer<DataType>::set} method on the graph's data container directly: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20095 \{\par
20096   mDataContainer = data;\par
20097 \}\par
}
}
{\xe \v setData\:QCPGraph}
{\xe \v QCPGraph\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i values}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data with the provided points in {\i keys}  and {\i values} . The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20111 \{\par
20112   mDataContainer->clear();\par
20113   addData(keys, values, alreadySorted);\par
20114 \}\par
}
}
{\xe \v setLineStyle\:QCPGraph}
{\xe \v QCPGraph\:setLineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setLineStyle ({\b LineStyle}  {\i ls})}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how the single data points are connected in the plot. For scatter-only plots, set {\i ls}  to {\b lsNone} and {\b setScatterStyle} to the desired scatter style.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setScatterStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20123 \{\par
20124   mLineStyle = ls;\par
20125 \}\par
}
}
{\xe \v setScatterSkip\:QCPGraph}
{\xe \v QCPGraph\:setScatterSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setScatterSkip (int  {\i skip})}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If scatters are displayed (scatter style not {\b QCPScatterStyle::ssNone}), {\i skip}  number of scatter points are skipped/not drawn after every drawn scatter point.\par
This can be used to make the data appear sparser while for example still having a smooth line, and to improve performance for very high density plots.\par
If {\i skip}  is set to 0 (default), all scatter points are drawn.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setScatterStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20150 \{\par
20151   mScatterSkip = qMax(0, skip);\par
20152 \}\par
}
}
{\xe \v setScatterStyle\:QCPGraph}
{\xe \v QCPGraph\:setScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setScatterStyle (const {\b QCPScatterStyle} &  {\i style})}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the visual appearance of single data points in the plot. If set to {\b QCPScatterStyle::ssNone}, no scatter points are drawn (e.g. for line-only-plots with appropriate line style).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPScatterStyle}, {\b setLineStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20134 \{\par
20135   mScatterStyle = style;\par
20136 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLegend\:QCPGraph}
{\xe \v QCPGraph\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPGraph}
{\xe \v QCPGraph\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAdaptiveSampling\:QCPGraph}
{\xe \v QCPGraph\:mAdaptiveSampling}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGraph::mAdaptiveSampling{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mChannelFillGraph\:QCPGraph}
{\xe \v QCPGraph\:mChannelFillGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPGraph}> QCPGraph::mChannelFillGraph{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLineStyle\:QCPGraph}
{\xe \v QCPGraph\:mLineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LineStyle} QCPGraph::mLineStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScatterSkip\:QCPGraph}
{\xe \v QCPGraph\:mScatterSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::mScatterSkip{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScatterStyle\:QCPGraph}
{\xe \v QCPGraph\:mScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPGraph::mScatterStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPGraphData Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPGraphData}
{\xe \v QCPGraphData}
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPGraph}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPGraphData:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_graph_data__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraphData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraphData} (double {\b key}, double {\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sortKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b valueRange} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b QCPGraphData} {\b fromSortKey} (double {\b sortKey})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b sortKeyIsMainKey} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPGraph}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The stored data is: {
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i key:}  coordinate on the key axis of this data point (this is the {\i mainKey}  and the {\i sortKey} ) \par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i value:}  coordinate on the value axis of this data point (this is the {\i mainValue} )\par
}
The container for storing multiple data points is {\b QCPGraphDataContainer}. It is a typedef for {\b QCPDataContainer} with {\b QCPGraphData} as the DataType template parameter. See the documentation there for an explanation regarding the data type's generic methods.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b QCPGraphDataContainer} \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPGraphData\:QCPGraphData}
{\xe \v QCPGraphData\:QCPGraphData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPGraphData::QCPGraphData ()}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a data point with key and value set to zero. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19979                            :\par
19980   key(0),\par
19981   value(0)\par
19982 \{\par
19983 \}\par
}
}
{\xe \v QCPGraphData\:QCPGraphData}
{\xe \v QCPGraphData\:QCPGraphData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPGraphData::QCPGraphData (double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a data point with the specified {\i key}  and {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19988                                                    :\par
19989   key(key),\par
19990   value(value)\par
19991 \{\par
19992 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fromSortKey\:QCPGraphData}
{\xe \v QCPGraphData\:fromSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b QCPGraphData} QCPGraphData::fromSortKey (double  {\i sortKey}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data point with the specified {\i sortKey} . All other members are set to zero.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5128 \{ return QCPGraphData(sortKey, 0); \}\par
}
}
{\xe \v mainKey\:QCPGraphData}
{\xe \v QCPGraphData\:mainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPGraphData::mainKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i key}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5131 \{ return key; \}\par
}
}
{\xe \v mainValue\:QCPGraphData}
{\xe \v QCPGraphData\:mainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPGraphData::mainValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i value}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5132 \{ return value; \}\par
}
}
{\xe \v sortKey\:QCPGraphData}
{\xe \v QCPGraphData\:sortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPGraphData::sortKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i key}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5127 \{ return key; \}\par
}
}
{\xe \v sortKeyIsMainKey\:QCPGraphData}
{\xe \v QCPGraphData\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static static bool QCPGraphData::sortKeyIsMainKey (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Since the member {\i key}  is both the data point key coordinate and the data ordering parameter, this method returns true.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5129 \{ return true; \}\par
}
}
{\xe \v valueRange\:QCPGraphData}
{\xe \v QCPGraphData\:valueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPGraphData::valueRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPRange} with both lower and upper boundary set to {\i value}  of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5134 \{ return QCPRange(value, value); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v key\:QCPGraphData}
{\xe \v QCPGraphData\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPGraphData::key}}
\par
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:QCPGraphData}
{\xe \v QCPGraphData\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPGraphData::value}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPGrid Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPGrid}
{\xe \v QCPGrid}
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Responsible for drawing the grid of a {\b QCPAxis}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPGrid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_grid__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPGrid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_grid__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGrid} ({\b QCPAxis} *parentAxis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b subGridVisible} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiasedSubGrid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiasedZeroLine} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b subGridPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b zeroLinePen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubGridVisible} (bool {\b visible})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedSubGrid} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedZeroLine} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubGridPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZeroLinePen} (const QPen &{\b pen})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawGridLines} ({\b QCPPainter} *painter) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawSubGridLines} ({\b QCPPainter} *painter) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mSubGridVisible}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiasedSubGrid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiasedZeroLine}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSubGridPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mZeroLinePen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b mParentAxis}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxis}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Responsible for drawing the grid of a {\b QCPAxis}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is tightly bound to {\b QCPAxis}. Every axis owns a grid instance and uses it to draw the grid lines, sub grid lines and zero-line. You can interact with the grid of an axis via {\b QCPAxis::grid}. Normally, you don't need to create an instance of {\b QCPGrid} yourself.\par
The axis and grid drawing was split into two classes to allow them to be placed on different layers (both {\b QCPAxis} and {\b QCPGrid} inherit from {\b QCPLayerable}). Thus it is possible to have the grid in the background and the axes in the foreground, and any plottables/items in between. This described situation is the default setup, see the {\b QCPLayer} documentation. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPGrid\:QCPGrid}
{\xe \v QCPGrid\:QCPGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPGrid::QCPGrid ({\b QCPAxis} *  {\i parentAxis}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPGrid} instance and sets default values.\par
You shouldn't instantiate grids on their own, since every {\b QCPAxis} brings its own {\b QCPGrid}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7161                                     :\par
 7162   QCPLayerable(parentAxis->parentPlot(), QString(), parentAxis),\par
 7163   mParentAxis(parentAxis)\par
 7164 \{\par
 7165   // warning: this is called in QCPAxis constructor, so parentAxis members should not be accessed/called\par
 7166   setParent(parentAxis);\par
 7167   setPen(QPen(QColor(200,200,200), 0, Qt::DotLine));\par
 7168   setSubGridPen(QPen(QColor(220,220,220), 0, Qt::DotLine));\par
 7169   setZeroLinePen(QPen(QColor(200,200,200), 0, Qt::SolidLine));\par
 7170   setSubGridVisible(false);\par
 7171   setAntialiased(false);\par
 7172   setAntialiasedSubGrid(false);\par
 7173   setAntialiasedZeroLine(false);\par
 7174 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v antialiasedSubGrid\:QCPGrid}
{\xe \v QCPGrid\:antialiasedSubGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGrid::antialiasedSubGrid () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1876 \{ return mAntialiasedSubGrid; \}\par
}
}
{\xe \v antialiasedZeroLine\:QCPGrid}
{\xe \v QCPGrid\:antialiasedZeroLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGrid::antialiasedZeroLine () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1877 \{ return mAntialiasedZeroLine; \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPGrid}
{\xe \v QCPGrid\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7243 \{\par
 7244   applyAntialiasingHint(painter, mAntialiased, QCP::aeGrid);\par
 7245 \}\par
}
}
{\xe \v draw\:QCPGrid}
{\xe \v QCPGrid\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7253 \{\par
 7254   if (!mParentAxis) \{ qDebug() << Q_FUNC_INFO << "invalid parent axis"; return; \}\par
 7255   \par
 7256   if (mParentAxis->subTicks() && mSubGridVisible)\par
 7257     drawSubGridLines(painter);\par
 7258   drawGridLines(painter);\par
 7259 \}\par
}
}
{\xe \v drawGridLines\:QCPGrid}
{\xe \v QCPGrid\:drawGridLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::drawGridLines ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7268 \{\par
 7269   if (!mParentAxis) \{ qDebug() << Q_FUNC_INFO << "invalid parent axis"; return; \}\par
 7270   \par
 7271   const int tickCount = mParentAxis->mTickVector.size();\par
 7272   double t; // helper variable, result of coordinate-to-pixel transforms\par
 7273   if (mParentAxis->orientation() == Qt::Horizontal)\par
 7274   \{\par
 7275     // draw zeroline:\par
 7276     int zeroLineIndex = -1;\par
 7277     if (mZeroLinePen.style() != Qt::NoPen && mParentAxis->mRange.lower < 0 && mParentAxis->mRange.upper > 0)\par
 7278     \{\par
 7279       applyAntialiasingHint(painter, mAntialiasedZeroLine, QCP::aeZeroLine);\par
 7280       painter->setPen(mZeroLinePen);\par
 7281       double epsilon = mParentAxis->range().size()*1E-6; // for comparing double to zero\par
 7282       for (int i=0; i<tickCount; ++i)\par
 7283       \{\par
 7284         if (qAbs(mParentAxis->mTickVector.at(i)) < epsilon)\par
 7285         \{\par
 7286           zeroLineIndex = i;\par
 7287           t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // x\par
 7288           painter->drawLine(QLineF(t, mParentAxis->mAxisRect->bottom(), t, mParentAxis->mAxisRect->top()));\par
 7289           break;\par
 7290         \}\par
 7291       \}\par
 7292     \}\par
 7293     // draw grid lines:\par
 7294     applyDefaultAntialiasingHint(painter);\par
 7295     painter->setPen(mPen);\par
 7296     for (int i=0; i<tickCount; ++i)\par
 7297     \{\par
 7298       if (i == zeroLineIndex) continue; // don't draw a gridline on top of the zeroline\par
 7299       t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // x\par
 7300       painter->drawLine(QLineF(t, mParentAxis->mAxisRect->bottom(), t, mParentAxis->mAxisRect->top()));\par
 7301     \}\par
 7302   \} else\par
 7303   \{\par
 7304     // draw zeroline:\par
 7305     int zeroLineIndex = -1;\par
 7306     if (mZeroLinePen.style() != Qt::NoPen && mParentAxis->mRange.lower < 0 && mParentAxis->mRange.upper > 0)\par
 7307     \{\par
 7308       applyAntialiasingHint(painter, mAntialiasedZeroLine, QCP::aeZeroLine);\par
 7309       painter->setPen(mZeroLinePen);\par
 7310       double epsilon = mParentAxis->mRange.size()*1E-6; // for comparing double to zero\par
 7311       for (int i=0; i<tickCount; ++i)\par
 7312       \{\par
 7313         if (qAbs(mParentAxis->mTickVector.at(i)) < epsilon)\par
 7314         \{\par
 7315           zeroLineIndex = i;\par
 7316           t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // y\par
 7317           painter->drawLine(QLineF(mParentAxis->mAxisRect->left(), t, mParentAxis->mAxisRect->right(), t));\par
 7318           break;\par
 7319         \}\par
 7320       \}\par
 7321     \}\par
 7322     // draw grid lines:\par
 7323     applyDefaultAntialiasingHint(painter);\par
 7324     painter->setPen(mPen);\par
 7325     for (int i=0; i<tickCount; ++i)\par
 7326     \{\par
 7327       if (i == zeroLineIndex) continue; // don't draw a gridline on top of the zeroline\par
 7328       t = mParentAxis->coordToPixel(mParentAxis->mTickVector.at(i)); // y\par
 7329       painter->drawLine(QLineF(mParentAxis->mAxisRect->left(), t, mParentAxis->mAxisRect->right(), t));\par
 7330     \}\par
 7331   \}\par
 7332 \}\par
}
}
{\xe \v drawSubGridLines\:QCPGrid}
{\xe \v QCPGrid\:drawSubGridLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::drawSubGridLines ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7341 \{\par
 7342   if (!mParentAxis) \{ qDebug() << Q_FUNC_INFO << "invalid parent axis"; return; \}\par
 7343   \par
 7344   applyAntialiasingHint(painter, mAntialiasedSubGrid, QCP::aeSubGrid);\par
 7345   double t; // helper variable, result of coordinate-to-pixel transforms\par
 7346   painter->setPen(mSubGridPen);\par
 7347   if (mParentAxis->orientation() == Qt::Horizontal)\par
 7348   \{\par
 7349     for (int i=0; i<mParentAxis->mSubTickVector.size(); ++i)\par
 7350     \{\par
 7351       t = mParentAxis->coordToPixel(mParentAxis->mSubTickVector.at(i)); // x\par
 7352       painter->drawLine(QLineF(t, mParentAxis->mAxisRect->bottom(), t, mParentAxis->mAxisRect->top()));\par
 7353     \}\par
 7354   \} else\par
 7355   \{\par
 7356     for (int i=0; i<mParentAxis->mSubTickVector.size(); ++i)\par
 7357     \{\par
 7358       t = mParentAxis->coordToPixel(mParentAxis->mSubTickVector.at(i)); // y\par
 7359       painter->drawLine(QLineF(mParentAxis->mAxisRect->left(), t, mParentAxis->mAxisRect->right(), t));\par
 7360     \}\par
 7361   \}\par
 7362 \}\par
}
}
{\xe \v pen\:QCPGrid}
{\xe \v QCPGrid\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPGrid::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1878 \{ return mPen; \}\par
}
}
{\xe \v setAntialiasedSubGrid\:QCPGrid}
{\xe \v QCPGrid\:setAntialiasedSubGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::setAntialiasedSubGrid (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether sub grid lines are drawn antialiased. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7190 \{\par
 7191   mAntialiasedSubGrid = enabled;\par
 7192 \}\par
}
}
{\xe \v setAntialiasedZeroLine\:QCPGrid}
{\xe \v QCPGrid\:setAntialiasedZeroLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::setAntialiasedZeroLine (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether zero lines are drawn antialiased. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7198 \{\par
 7199   mAntialiasedZeroLine = enabled;\par
 7200 \}\par
}
}
{\xe \v setPen\:QCPGrid}
{\xe \v QCPGrid\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen with which (major) grid lines are drawn. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7206 \{\par
 7207   mPen = pen;\par
 7208 \}\par
}
}
{\xe \v setSubGridPen\:QCPGrid}
{\xe \v QCPGrid\:setSubGridPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::setSubGridPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen with which sub grid lines are drawn. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7214 \{\par
 7215   mSubGridPen = pen;\par
 7216 \}\par
}
}
{\xe \v setSubGridVisible\:QCPGrid}
{\xe \v QCPGrid\:setSubGridVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::setSubGridVisible (bool  {\i visible})}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether grid lines at sub tick marks are drawn.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubGridPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7182 \{\par
 7183   mSubGridVisible = visible;\par
 7184 \}\par
}
}
{\xe \v setZeroLinePen\:QCPGrid}
{\xe \v QCPGrid\:setZeroLinePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGrid::setZeroLinePen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen with which zero lines are drawn.\par
Zero lines are lines at value coordinate 0 which may be drawn with a different pen than other grid lines. To disable zero lines and just draw normal grid lines at zero, set {\i pen}  to Qt::NoPen. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7225 \{\par
 7226   mZeroLinePen = pen;\par
 7227 \}\par
}
}
{\xe \v subGridPen\:QCPGrid}
{\xe \v QCPGrid\:subGridPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPGrid::subGridPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1879 \{ return mSubGridPen; \}\par
}
}
{\xe \v subGridVisible\:QCPGrid}
{\xe \v QCPGrid\:subGridVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGrid::subGridVisible () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1875 \{ return mSubGridVisible; \}\par
}
}
{\xe \v zeroLinePen\:QCPGrid}
{\xe \v QCPGrid\:zeroLinePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPGrid::zeroLinePen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1880 \{ return mZeroLinePen; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPAxis\:QCPGrid}
{\xe \v QCPGrid\:QCPAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAxis}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAntialiasedSubGrid\:QCPGrid}
{\xe \v QCPGrid\:mAntialiasedSubGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGrid::mAntialiasedSubGrid{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAntialiasedZeroLine\:QCPGrid}
{\xe \v QCPGrid\:mAntialiasedZeroLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGrid::mAntialiasedZeroLine{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentAxis\:QCPGrid}
{\xe \v QCPGrid\:mParentAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis}* QCPGrid::mParentAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPGrid}
{\xe \v QCPGrid\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPGrid::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSubGridPen\:QCPGrid}
{\xe \v QCPGrid\:mSubGridPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPGrid::mSubGridPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSubGridVisible\:QCPGrid}
{\xe \v QCPGrid\:mSubGridVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGrid::mSubGridVisible{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mZeroLinePen\:QCPGrid}
{\xe \v QCPGrid\:mZeroLinePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPGrid::mZeroLinePen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemAnchor Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemAnchor}
{\xe \v QCPItemAnchor}
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An anchor of an item to which positions can be attached to. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemAnchor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_anchor__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemAnchor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_anchor__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} ({\b QCustomPlot} *parentPlot, {\b QCPAbstractItem} *parentItem, const QString &{\b name}, int anchorId=-1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemAnchor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b name} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b pixelPosition} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPItemPosition} * {\b toQCPItemPosition} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addChildX} ({\b QCPItemPosition} *pos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeChildX} ({\b QCPItemPosition} *pos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addChildY} ({\b QCPItemPosition} *pos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeChildY} ({\b QCPItemPosition} *pos)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractItem} * {\b mParentItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mAnchorId}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSet< {\b QCPItemPosition} * > {\b mChildrenX}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSet< {\b QCPItemPosition} * > {\b mChildrenY}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemPosition}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An anchor of an item to which positions can be attached to. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An item ({\b QCPAbstractItem}) may have one or more anchors. Unlike {\b QCPItemPosition}, an anchor doesn't control anything on its item, but provides a way to tie other items via their positions to the anchor.\par
For example, a {\b QCPItemRect} is defined by its positions {\i topLeft}  and {\i bottomRight} . Additionally it has various anchors like {\i top} , {\i topRight}  or {\i bottomLeft}  etc. So you can attach the {\i start}  (which is a {\b QCPItemPosition}) of a {\b QCPItemLine} to one of the anchors by calling {\b QCPItemPosition::setParentAnchor} on {\i start} , passing the wanted anchor of the {\b QCPItemRect}. This way the start of the line will now always follow the respective anchor location on the rect item.\par
Note that {\b QCPItemPosition} derives from {\b QCPItemAnchor}, so every position can also serve as an anchor to other positions.\par
To learn how to provide anchors in your own item subclasses, see the subclassing section of the {\b QCPAbstractItem} documentation. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemAnchor\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:QCPItemAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemAnchor::QCPItemAnchor ({\b QCustomPlot} *  {\i parentPlot}, {\b QCPAbstractItem} *  {\i parentItem}, const QString &  {\i name}, int  {\i anchorId} = {\f2 -1})}}
\par
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPItemAnchor}. You shouldn't create {\b QCPItemAnchor} instances directly, even if you want to make a new item subclass. Use {\b QCPAbstractItem::createAnchor} instead, as explained in the subclassing section of the {\b QCPAbstractItem} documentation. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11315                                                                                                                     :\par
11316   mName(name),\par
11317   mParentPlot(parentPlot),\par
11318   mParentItem(parentItem),\par
11319   mAnchorId(anchorId)\par
11320 \{\par
11321 \}\par
}
}
{\xe \v ~QCPItemAnchor\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:~QCPItemAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemAnchor::~QCPItemAnchor (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11324 \{\par
11325   // unregister as parent at children:\par
11326   foreach (QCPItemPosition *child, mChildrenX.toList())\par
11327   \{\par
11328     if (child->parentAnchorX() == this)\par
11329       child->setParentAnchorX(0); // this acts back on this anchor and child removes itself from mChildrenX\par
11330   \}\par
11331   foreach (QCPItemPosition *child, mChildrenY.toList())\par
11332   \{\par
11333     if (child->parentAnchorY() == this)\par
11334       child->setParentAnchorY(0); // this acts back on this anchor and child removes itself from mChildrenY\par
11335   \}\par
11336 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addChildX\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:addChildX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemAnchor::addChildX ({\b QCPItemPosition} *  {\i pos}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11372 \{\par
11373   if (!mChildrenX.contains(pos))\par
11374     mChildrenX.insert(pos);\par
11375   else\par
11376     qDebug() << Q_FUNC_INFO << "provided pos is child already" << reinterpret_cast<quintptr>(pos);\par
11377 \}\par
}
}
{\xe \v addChildY\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:addChildY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemAnchor::addChildY ({\b QCPItemPosition} *  {\i pos}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11400 \{\par
11401   if (!mChildrenY.contains(pos))\par
11402     mChildrenY.insert(pos);\par
11403   else\par
11404     qDebug() << Q_FUNC_INFO << "provided pos is child already" << reinterpret_cast<quintptr>(pos);\par
11405 \}\par
}
}
{\xe \v name\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPItemAnchor::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3405 \{ return mName; \}\par
}
}
{\xe \v pixelPosition\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:pixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPItemAnchor::pixelPosition () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the final absolute pixel position of the {\b QCPItemAnchor} on the {\b QCustomPlot} surface.\par
The pixel information is internally retrieved via {\b QCPAbstractItem::anchorPixelPosition} of the parent item, {\b QCPItemAnchor} is just an intermediary. \par
}{
Reimplemented in {\b QCPItemPosition} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11345 \{\par
11346   if (mParentItem)\par
11347   \{\par
11348     if (mAnchorId > -1)\par
11349     \{\par
11350       return mParentItem->anchorPixelPosition(mAnchorId);\par
11351     \} else\par
11352     \{\par
11353       qDebug() << Q_FUNC_INFO << "no valid anchor id set:" << mAnchorId;\par
11354       return QPointF();\par
11355     \}\par
11356   \} else\par
11357   \{\par
11358     qDebug() << Q_FUNC_INFO << "no parent item set";\par
11359     return QPointF();\par
11360   \}\par
11361 \}\par
}
}
{\xe \v removeChildX\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:removeChildX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemAnchor::removeChildX ({\b QCPItemPosition} *  {\i pos}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11386 \{\par
11387   if (!mChildrenX.remove(pos))\par
11388     qDebug() << Q_FUNC_INFO << "provided pos isn't child" << reinterpret_cast<quintptr>(pos);\par
11389 \}\par
}
}
{\xe \v removeChildY\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:removeChildY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemAnchor::removeChildY ({\b QCPItemPosition} *  {\i pos}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11414 \{\par
11415   if (!mChildrenY.remove(pos))\par
11416     qDebug() << Q_FUNC_INFO << "provided pos isn't child" << reinterpret_cast<quintptr>(pos);\par
11417 \}\par
}
}
{\xe \v toQCPItemPosition\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:toQCPItemPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition} * QCPItemAnchor::toQCPItemPosition (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns 0 if this instance is merely a {\b QCPItemAnchor}, and a valid pointer of type QCPItemPosition* if it actually is a {\b QCPItemPosition} (which is a subclass of {\b QCPItemAnchor}).\par
This safe downcast functionality could also be achieved with a dynamic_cast. However, {\b QCustomPlot} avoids dynamic_cast to work with projects that don't have RTTI support enabled (e.g. -fno-rtti flag with gcc compiler). \par
}{
Reimplemented in {\b QCPItemPosition} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3419 \{ return 0; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPItemPosition\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:QCPItemPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPItemPosition}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAnchorId\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:mAnchorId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPItemAnchor::mAnchorId{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mChildrenX\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:mChildrenX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSet<{\b QCPItemPosition}*> QCPItemAnchor::mChildrenX{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mChildrenY\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:mChildrenY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSet<{\b QCPItemPosition}*> QCPItemAnchor::mChildrenY{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mName\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:mName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPItemAnchor::mName{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentItem\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:mParentItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractItem}* QCPItemAnchor::mParentItem{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPItemAnchor}
{\xe \v QCPItemAnchor\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPItemAnchor::mParentPlot{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemBracket Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemBracket}
{\xe \v QCPItemBracket}
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bracket for referencing/highlighting certain parts in the plot. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemBracket:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_bracket__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemBracket:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_bracket__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b BracketStyle} \{ {\b bsSquare}, 
{\b bsRound}, 
{\b bsCurly}, 
{\b bsCalligraphic}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemBracket} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemBracket} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b length} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BracketStyle} {\b style} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLength} (double {\b length})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setStyle} ({\b BracketStyle} {\b style})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b left}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b right}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b center}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AnchorIndex} \{ {\b aiCenter}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b anchorPixelPosition} (int anchorId) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mainPen} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mLength}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BracketStyle} {\b mStyle}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bracket for referencing/highlighting certain parts in the plot. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 It has two positions, {\i left}  and {\i right} , which define the span of the bracket. If {\i left}  is actually farther to the left than {\i right} , the bracket is opened to the bottom, as shown in the example image.\par
The bracket supports multiple styles via {\b setStyle}. The length, i.e. how far the bracket stretches away from the embraced span, can be controlled with {\b setLength}.\par
 {\qc Demonstrating the effect of different values for {\b setLength}, for styles {\b bsCalligraphic} and {\b bsSquare}. Anchors and positions are displayed for reference.} \par
It provides an anchor {\i center} , to allow connection of other items, e.g. an arrow ({\b QCPItemLine} or {\b QCPItemCurve}) or a text label ({\b QCPItemText}), to the bracket. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v AnchorIndex\:QCPItemBracket}
{\xe \v QCPItemBracket\:AnchorIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPItemBracket::AnchorIndex}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v aiCenter\:QCPItemBracket}
{\xe \v QCPItemBracket\:aiCenter}
{\qr aiCenter{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6644 \{aiCenter\};\par
}
}
{\xe \v BracketStyle\:QCPItemBracket}
{\xe \v QCPItemBracket\:BracketStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPItemBracket::BracketStyle}}}
\par
{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the various visual shapes of the bracket item. The appearance can be further modified by {\b setLength} and {\b setPen}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setStyle} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v bsSquare\:QCPItemBracket}
{\xe \v QCPItemBracket\:bsSquare}
{\qr bsSquare{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A brace with angled edges. \par
}\cell }{\row }
{\xe \v bsRound\:QCPItemBracket}
{\xe \v QCPItemBracket\:bsRound}
{\qr bsRound{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A brace with round edges. \par
}\cell }{\row }
{\xe \v bsCurly\:QCPItemBracket}
{\xe \v QCPItemBracket\:bsCurly}
{\qr bsCurly{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A curly brace. \par
}\cell }{\row }
{\xe \v bsCalligraphic\:QCPItemBracket}
{\xe \v QCPItemBracket\:bsCalligraphic}
{\qr bsCalligraphic{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A curly brace with varying stroke width giving a calligraphic impression. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6613                     \{ bsSquare  \par
 6614                       ,bsRound  \par
 6615                       ,bsCurly  \par
 6616                       ,bsCalligraphic \par
 6617   \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemBracket\:QCPItemBracket}
{\xe \v QCPItemBracket\:QCPItemBracket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemBracket::QCPItemBracket ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a bracket item and sets default values.\par
The created item is automatically registered with {\i parentPlot} . This {\b QCustomPlot} instance takes ownership of the item, so do not delete it manually but use {\b QCustomPlot::removeItem()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29915                                                       :\par
29916   QCPAbstractItem(parentPlot),\par
29917   left(createPosition(QLatin1String("left"))),\par
29918   right(createPosition(QLatin1String("right"))),\par
29919   center(createAnchor(QLatin1String("center"), aiCenter)),\par
29920   mLength(8),\par
29921   mStyle(bsCalligraphic)\par
29922 \{\par
29923   left->setCoords(0, 0);\par
29924   right->setCoords(1, 1);\par
29925   \par
29926   setPen(QPen(Qt::black));\par
29927   setSelectedPen(QPen(Qt::blue, 2));\par
29928 \}\par
}
}
{\xe \v ~QCPItemBracket\:QCPItemBracket}
{\xe \v QCPItemBracket\:~QCPItemBracket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemBracket::~QCPItemBracket (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29931 \{\par
29932 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v anchorPixelPosition\:QCPItemBracket}
{\xe \v QCPItemBracket\:anchorPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPItemBracket::anchorPixelPosition (int  {\i anchorId}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 30091 \{\par
30092   QCPVector2D leftVec(left->pixelPosition());\par
30093   QCPVector2D rightVec(right->pixelPosition());\par
30094   if (leftVec.toPoint() == rightVec.toPoint())\par
30095     return leftVec.toPointF();\par
30096   \par
30097   QCPVector2D widthVec = (rightVec-leftVec)*0.5;\par
30098   QCPVector2D lengthVec = widthVec.perpendicular().normalized()*mLength;\par
30099   QCPVector2D centerVec = (rightVec+leftVec)*0.5-lengthVec;\par
30100   \par
30101   switch (anchorId)\par
30102   \{\par
30103     case aiCenter:\par
30104       return centerVec.toPointF();\par
30105   \}\par
30106   qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;\par
30107   return QPointF();\par
30108 \}\par
}
}
{\xe \v draw\:QCPItemBracket}
{\xe \v QCPItemBracket\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemBracket::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 30023 \{\par
30024   QCPVector2D leftVec(left->pixelPosition());\par
30025   QCPVector2D rightVec(right->pixelPosition());\par
30026   if (leftVec.toPoint() == rightVec.toPoint())\par
30027     return;\par
30028   \par
30029   QCPVector2D widthVec = (rightVec-leftVec)*0.5;\par
30030   QCPVector2D lengthVec = widthVec.perpendicular().normalized()*mLength;\par
30031   QCPVector2D centerVec = (rightVec+leftVec)*0.5-lengthVec;\par
30032 \par
30033   QPolygon boundingPoly;\par
30034   boundingPoly << leftVec.toPoint() << rightVec.toPoint()\par
30035                << (rightVec-lengthVec).toPoint() << (leftVec-lengthVec).toPoint();\par
30036   QRect clip = clipRect().adjusted(-mainPen().widthF(), -mainPen().widthF(), mainPen().widthF(), mainPen().widthF());\par
30037   if (clip.intersects(boundingPoly.boundingRect()))\par
30038   \{\par
30039     painter->setPen(mainPen());\par
30040     switch (mStyle)\par
30041     \{\par
30042       case bsSquare:\par
30043       \{\par
30044         painter->drawLine((centerVec+widthVec).toPointF(), (centerVec-widthVec).toPointF());\par
30045         painter->drawLine((centerVec+widthVec).toPointF(), (centerVec+widthVec+lengthVec).toPointF());\par
30046         painter->drawLine((centerVec-widthVec).toPointF(), (centerVec-widthVec+lengthVec).toPointF());\par
30047         break;\par
30048       \}\par
30049       case bsRound:\par
30050       \{\par
30051         painter->setBrush(Qt::NoBrush);\par
30052         QPainterPath path;\par
30053         path.moveTo((centerVec+widthVec+lengthVec).toPointF());\par
30054         path.cubicTo((centerVec+widthVec).toPointF(), (centerVec+widthVec).toPointF(), centerVec.toPointF());\par
30055         path.cubicTo((centerVec-widthVec).toPointF(), (centerVec-widthVec).toPointF(), (centerVec-widthVec+lengthVec).toPointF());\par
30056         painter->drawPath(path);\par
30057         break;\par
30058       \}\par
30059       case bsCurly:\par
30060       \{\par
30061         painter->setBrush(Qt::NoBrush);\par
30062         QPainterPath path;\par
30063         path.moveTo((centerVec+widthVec+lengthVec).toPointF());\par
30064         path.cubicTo((centerVec+widthVec-lengthVec*0.8).toPointF(), (centerVec+0.4*widthVec+lengthVec).toPointF(), centerVec.toPointF());\par
30065         path.cubicTo((centerVec-0.4*widthVec+lengthVec).toPointF(), (centerVec-widthVec-lengthVec*0.8).toPointF(), (centerVec-widthVec+lengthVec).toPointF());\par
30066         painter->drawPath(path);\par
30067         break;\par
30068       \}\par
30069       case bsCalligraphic:\par
30070       \{\par
30071         painter->setPen(Qt::NoPen);\par
30072         painter->setBrush(QBrush(mainPen().color()));\par
30073         QPainterPath path;\par
30074         path.moveTo((centerVec+widthVec+lengthVec).toPointF());\par
30075         \par
30076         path.cubicTo((centerVec+widthVec-lengthVec*0.8).toPointF(), (centerVec+0.4*widthVec+0.8*lengthVec).toPointF(), centerVec.toPointF());\par
30077         path.cubicTo((centerVec-0.4*widthVec+0.8*lengthVec).toPointF(), (centerVec-widthVec-lengthVec*0.8).toPointF(), (centerVec-widthVec+lengthVec).toPointF());\par
30078         \par
30079         path.cubicTo((centerVec-widthVec-lengthVec*0.5).toPointF(), (centerVec-0.2*widthVec+1.2*lengthVec).toPointF(), (centerVec+lengthVec*0.2).toPointF());\par
30080         path.cubicTo((centerVec+0.2*widthVec+1.2*lengthVec).toPointF(), (centerVec+widthVec-lengthVec*0.5).toPointF(), (centerVec+widthVec+lengthVec).toPointF());\par
30081         \par
30082         painter->drawPath(path);\par
30083         break;\par
30084       \}\par
30085     \}\par
30086   \}\par
30087 \}\par
}
}
{\xe \v length\:QCPItemBracket}
{\xe \v QCPItemBracket\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemBracket::length () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6626 \{ return mLength; \}\par
}
}
{\xe \v mainPen\:QCPItemBracket}
{\xe \v QCPItemBracket\:mainPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemBracket::mainPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 30116 \{\par
30117     return mSelected ? mSelectedPen : mPen;\par
30118 \}\par
}
}
{\xe \v pen\:QCPItemBracket}
{\xe \v QCPItemBracket\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemBracket::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6624 \{ return mPen; \}\par
}
}
{\xe \v selectedPen\:QCPItemBracket}
{\xe \v QCPItemBracket\:selectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemBracket::selectedPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6625 \{ return mSelectedPen; \}\par
}
}
{\xe \v selectTest\:QCPItemBracket}
{\xe \v QCPItemBracket\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemBracket::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29983 \{\par
29984   Q_UNUSED(details)\par
29985   if (onlySelectable && !mSelectable)\par
29986     return -1;\par
29987   \par
29988   QCPVector2D p(pos);\par
29989   QCPVector2D leftVec(left->pixelPosition());\par
29990   QCPVector2D rightVec(right->pixelPosition());\par
29991   if (leftVec.toPoint() == rightVec.toPoint())\par
29992     return -1;\par
29993   \par
29994   QCPVector2D widthVec = (rightVec-leftVec)*0.5;\par
29995   QCPVector2D lengthVec = widthVec.perpendicular().normalized()*mLength;\par
29996   QCPVector2D centerVec = (rightVec+leftVec)*0.5-lengthVec;\par
29997   \par
29998   switch (mStyle)\par
29999   \{\par
30000     case QCPItemBracket::bsSquare:\par
30001     case QCPItemBracket::bsRound:\par
30002     \{\par
30003       double a = p.distanceSquaredToLine(centerVec-widthVec, centerVec+widthVec);\par
30004       double b = p.distanceSquaredToLine(centerVec-widthVec+lengthVec, centerVec-widthVec);\par
30005       double c = p.distanceSquaredToLine(centerVec+widthVec+lengthVec, centerVec+widthVec);\par
30006       return qSqrt(qMin(qMin(a, b), c));\par
30007     \}\par
30008     case QCPItemBracket::bsCurly:\par
30009     case QCPItemBracket::bsCalligraphic:\par
30010     \{\par
30011       double a = p.distanceSquaredToLine(centerVec-widthVec*0.75+lengthVec*0.15, centerVec+lengthVec*0.3);\par
30012       double b = p.distanceSquaredToLine(centerVec-widthVec+lengthVec*0.7, centerVec-widthVec*0.75+lengthVec*0.15);\par
30013       double c = p.distanceSquaredToLine(centerVec+widthVec*0.75+lengthVec*0.15, centerVec+lengthVec*0.3);\par
30014       double d = p.distanceSquaredToLine(centerVec+widthVec+lengthVec*0.7, centerVec+widthVec*0.75+lengthVec*0.15);\par
30015       return qSqrt(qMin(qMin(a, b), qMin(c, d)));\par
30016     \}\par
30017   \}\par
30018   return -1;\par
30019 \}\par
}
}
{\xe \v setLength\:QCPItemBracket}
{\xe \v QCPItemBracket\:setLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemBracket::setLength (double  {\i length})}}
\par
{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i length}  in pixels how far the bracket extends in the direction towards the embraced span of the bracket (i.e. perpendicular to the {\i left} -{\i right} -direction)\par
 {\qc Demonstrating the effect of different values for {\b setLength}, for styles {\b bsCalligraphic} and {\b bsSquare}. Anchors and positions are displayed for reference.}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29967 \{\par
29968   mLength = length;\par
29969 \}\par
}
}
{\xe \v setPen\:QCPItemBracket}
{\xe \v QCPItemBracket\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemBracket::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the bracket.\par
Note that when the style is {\b bsCalligraphic}, only the color will be taken from the pen, the stroke and width are ignored. To change the apparent stroke width of a calligraphic bracket, use {\b setLength}, which has a similar effect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29944 \{\par
29945   mPen = pen;\par
29946 \}\par
}
}
{\xe \v setSelectedPen\:QCPItemBracket}
{\xe \v QCPItemBracket\:setSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemBracket::setSelectedPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the bracket when selected\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29954 \{\par
29955   mSelectedPen = pen;\par
29956 \}\par
}
}
{\xe \v setStyle\:QCPItemBracket}
{\xe \v QCPItemBracket\:setStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemBracket::setStyle ({\b QCPItemBracket::BracketStyle}  {\i style})}}
\par
{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the style of the bracket, i.e. the shape/visual appearance.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29977 \{\par
29978   mStyle = style;\par
29979 \}\par
}
}
{\xe \v style\:QCPItemBracket}
{\xe \v QCPItemBracket\:style}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BracketStyle} QCPItemBracket::style () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6627 \{ return mStyle; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v center\:QCPItemBracket}
{\xe \v QCPItemBracket\:center}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemBracket::center}}
\par
{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v left\:QCPItemBracket}
{\xe \v QCPItemBracket\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemBracket::left}}
\par
{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLength\:QCPItemBracket}
{\xe \v QCPItemBracket\:mLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemBracket::mLength{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPItemBracket}
{\xe \v QCPItemBracket\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemBracket::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedPen\:QCPItemBracket}
{\xe \v QCPItemBracket\:mSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemBracket::mSelectedPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mStyle\:QCPItemBracket}
{\xe \v QCPItemBracket\:mStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BracketStyle} QCPItemBracket::mStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v right\:QCPItemBracket}
{\xe \v QCPItemBracket\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemBracket::right}}
\par
{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemCurve Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemCurve}
{\xe \v QCPItemCurve}
{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A curved line from one point to another. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemCurve:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_curve__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemCurve:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_curve__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemCurve} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemCurve} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b head} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b tail} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHead} (const {\b QCPLineEnding} &{\b head})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTail} (const {\b QCPLineEnding} &{\b tail})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b start}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b startDir}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b endDir}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b end}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mainPen} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b mHead}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b mTail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A curved line from one point to another. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 It has four positions, {\i start}  and {\i end} , which define the end points of the line, and two control points which define the direction the line exits from the start and the direction from which it approaches the end: {\i startDir}  and {\i endDir} .\par
With {\b setHead} and {\b setTail} you may set different line ending styles, e.g. to create an arrow.\par
Often it is desirable for the control points to stay at fixed relative positions to the start/end point. This can be achieved by setting the parent anchor e.g. of {\i startDir}  simply to {\i start} , and then specify the desired pixel offset with {\b QCPItemPosition::setCoords} on {\i startDir} . \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemCurve\:QCPItemCurve}
{\xe \v QCPItemCurve\:QCPItemCurve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemCurve::QCPItemCurve ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a curve item and sets default values.\par
The created item is automatically registered with {\i parentPlot} . This {\b QCustomPlot} instance takes ownership of the item, so do not delete it manually but use {\b QCustomPlot::removeItem()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28414                                                   :\par
28415   QCPAbstractItem(parentPlot),\par
28416   start(createPosition(QLatin1String("start"))),\par
28417   startDir(createPosition(QLatin1String("startDir"))),\par
28418   endDir(createPosition(QLatin1String("endDir"))),\par
28419   end(createPosition(QLatin1String("end")))\par
28420 \{\par
28421   start->setCoords(0, 0);\par
28422   startDir->setCoords(0.5, 0);\par
28423   endDir->setCoords(0, 0.5);\par
28424   end->setCoords(1, 1);\par
28425   \par
28426   setPen(QPen(Qt::black));\par
28427   setSelectedPen(QPen(Qt::blue,2));\par
28428 \}\par
}
}
{\xe \v ~QCPItemCurve\:QCPItemCurve}
{\xe \v QCPItemCurve\:~QCPItemCurve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemCurve::~QCPItemCurve (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28431 \{\par
28432 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v draw\:QCPItemCurve}
{\xe \v QCPItemCurve\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemCurve::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28509 \{\par
28510   QCPVector2D startVec(start->pixelPosition());\par
28511   QCPVector2D startDirVec(startDir->pixelPosition());\par
28512   QCPVector2D endDirVec(endDir->pixelPosition());\par
28513   QCPVector2D endVec(end->pixelPosition());\par
28514   if ((endVec-startVec).length() > 1e10) // too large curves cause crash\par
28515     return;\par
28516 \par
28517   QPainterPath cubicPath(startVec.toPointF());\par
28518   cubicPath.cubicTo(startDirVec.toPointF(), endDirVec.toPointF(), endVec.toPointF());\par
28519 \par
28520   // paint visible segment, if existent:\par
28521   QRect clip = clipRect().adjusted(-mainPen().widthF(), -mainPen().widthF(), mainPen().widthF(), mainPen().widthF());\par
28522   QRect cubicRect = cubicPath.controlPointRect().toRect();\par
28523   if (cubicRect.isEmpty()) // may happen when start and end exactly on same x or y position\par
28524     cubicRect.adjust(0, 0, 1, 1);\par
28525   if (clip.intersects(cubicRect))\par
28526   \{\par
28527     painter->setPen(mainPen());\par
28528     painter->drawPath(cubicPath);\par
28529     painter->setBrush(Qt::SolidPattern);\par
28530     if (mTail.style() != QCPLineEnding::esNone)\par
28531       mTail.draw(painter, startVec, M_PI-cubicPath.angleAtPercent(0)/180.0*M_PI);\par
28532     if (mHead.style() != QCPLineEnding::esNone)\par
28533       mHead.draw(painter, endVec, -cubicPath.angleAtPercent(1)/180.0*M_PI);\par
28534   \}\par
28535 \}\par
}
}
{\xe \v head\:QCPItemCurve}
{\xe \v QCPItemCurve\:head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPItemCurve::head () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6189 \{ return mHead; \}\par
}
}
{\xe \v mainPen\:QCPItemCurve}
{\xe \v QCPItemCurve\:mainPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemCurve::mainPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28543 \{\par
28544   return mSelected ? mSelectedPen : mPen;\par
28545 \}\par
}
}
{\xe \v pen\:QCPItemCurve}
{\xe \v QCPItemCurve\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemCurve::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6187 \{ return mPen; \}\par
}
}
{\xe \v selectedPen\:QCPItemCurve}
{\xe \v QCPItemCurve\:selectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemCurve::selectedPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6188 \{ return mSelectedPen; \}\par
}
}
{\xe \v selectTest\:QCPItemCurve}
{\xe \v QCPItemCurve\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemCurve::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28482 \{\par
28483   Q_UNUSED(details)\par
28484   if (onlySelectable && !mSelectable)\par
28485     return -1;\par
28486   \par
28487   QPointF startVec(start->pixelPosition());\par
28488   QPointF startDirVec(startDir->pixelPosition());\par
28489   QPointF endDirVec(endDir->pixelPosition());\par
28490   QPointF endVec(end->pixelPosition());\par
28491 \par
28492   QPainterPath cubicPath(startVec);\par
28493   cubicPath.cubicTo(startDirVec, endDirVec, endVec);\par
28494   \par
28495   QPolygonF polygon = cubicPath.toSubpathPolygons().first();\par
28496   QCPVector2D p(pos);\par
28497   double minDistSqr = std::numeric_limits<double>::max();\par
28498   for (int i=1; i<polygon.size(); ++i)\par
28499   \{\par
28500     double distSqr = p.distanceSquaredToLine(polygon.at(i-1), polygon.at(i));\par
28501     if (distSqr < minDistSqr)\par
28502       minDistSqr = distSqr;\par
28503   \}\par
28504   return qSqrt(minDistSqr);\par
28505 \}\par
}
}
{\xe \v setHead\:QCPItemCurve}
{\xe \v QCPItemCurve\:setHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemCurve::setHead (const {\b QCPLineEnding} &  {\i head})}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the line ending style of the head. The head corresponds to the {\i end}  position.\par
Note that due to the overloaded {\b QCPLineEnding} constructor, you may directly specify a {\b QCPLineEnding::EndingStyle} here, e.g.{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid setHead(QCPLineEnding::esSpikeArrow) \par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTail} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28463 \{\par
28464   mHead = head;\par
28465 \}\par
}
}
{\xe \v setPen\:QCPItemCurve}
{\xe \v QCPItemCurve\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemCurve::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28440 \{\par
28441   mPen = pen;\par
28442 \}\par
}
}
{\xe \v setSelectedPen\:QCPItemCurve}
{\xe \v QCPItemCurve\:setSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemCurve::setSelectedPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line when selected\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28450 \{\par
28451   mSelectedPen = pen;\par
28452 \}\par
}
}
{\xe \v setTail\:QCPItemCurve}
{\xe \v QCPItemCurve\:setTail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemCurve::setTail (const {\b QCPLineEnding} &  {\i tail})}}
\par
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the line ending style of the tail. The tail corresponds to the {\i start}  position.\par
Note that due to the overloaded {\b QCPLineEnding} constructor, you may directly specify a {\b QCPLineEnding::EndingStyle} here, e.g.{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid setTail(QCPLineEnding::esSpikeArrow) \par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setHead} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28476 \{\par
28477   mTail = tail;\par
28478 \}\par
}
}
{\xe \v tail\:QCPItemCurve}
{\xe \v QCPItemCurve\:tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPItemCurve::tail () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6190 \{ return mTail; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v end\:QCPItemCurve}
{\xe \v QCPItemCurve\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemCurve::end}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v endDir\:QCPItemCurve}
{\xe \v QCPItemCurve\:endDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemCurve::endDir}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mHead\:QCPItemCurve}
{\xe \v QCPItemCurve\:mHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPItemCurve::mHead{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPItemCurve}
{\xe \v QCPItemCurve\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemCurve::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedPen\:QCPItemCurve}
{\xe \v QCPItemCurve\:mSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemCurve::mSelectedPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTail\:QCPItemCurve}
{\xe \v QCPItemCurve\:mTail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPItemCurve::mTail{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v start\:QCPItemCurve}
{\xe \v QCPItemCurve\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemCurve::start}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v startDir\:QCPItemCurve}
{\xe \v QCPItemCurve\:startDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemCurve::startDir}}
\par
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemEllipse Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemEllipse}
{\xe \v QCPItemEllipse}
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An ellipse. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemEllipse:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_ellipse__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemEllipse:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_ellipse__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemEllipse} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemEllipse} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b selectedBrush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b topLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b bottomRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b topLeftRim}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b top}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b topRightRim}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b right}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottomRightRim}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottom}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottomLeftRim}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b left}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b center}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AnchorIndex} \{ {\b aiTopLeftRim}, 
{\b aiTop}, 
{\b aiTopRightRim}, 
{\b aiRight}, 
{\b aiBottomRightRim}, 
{\b aiBottom}, 
{\b aiBottomLeftRim}, 
{\b aiLeft}, 
{\b aiCenter}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b anchorPixelPosition} (int anchorId) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mainPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mainBrush} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mSelectedBrush}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An ellipse. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 It has two positions, {\i topLeft}  and {\i bottomRight} , which define the rect the ellipse will be drawn in. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v AnchorIndex\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:AnchorIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPItemEllipse::AnchorIndex}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v aiTopLeftRim\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:aiTopLeftRim}
{\qr aiTopLeftRim{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
\cell }{\cell }{\row }
{\xe \v aiTop\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:aiTop}
{\qr aiTop{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
\cell }{\cell }{\row }
{\xe \v aiTopRightRim\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:aiTopRightRim}
{\qr aiTopRightRim{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
\cell }{\cell }{\row }
{\xe \v aiRight\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:aiRight}
{\qr aiRight{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
\cell }{\cell }{\row }
{\xe \v aiBottomRightRim\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:aiBottomRightRim}
{\qr aiBottomRightRim{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
\cell }{\cell }{\row }
{\xe \v aiBottom\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:aiBottom}
{\qr aiBottom{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
\cell }{\cell }{\row }
{\xe \v aiBottomLeftRim\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:aiBottomLeftRim}
{\qr aiBottomLeftRim{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
\cell }{\cell }{\row }
{\xe \v aiLeft\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:aiLeft}
{\qr aiLeft{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
\cell }{\cell }{\row }
{\xe \v aiCenter\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:aiCenter}
{\qr aiCenter{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6421 \{aiTopLeftRim, aiTop, aiTopRightRim, aiRight, aiBottomRightRim, aiBottom, aiBottomLeftRim, aiLeft, aiCenter\};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemEllipse\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:QCPItemEllipse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemEllipse::QCPItemEllipse ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an ellipse item and sets default values.\par
The created item is automatically registered with {\i parentPlot} . This {\b QCustomPlot} instance takes ownership of the item, so do not delete it manually but use {\b QCustomPlot::removeItem()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29075                                                       :\par
29076   QCPAbstractItem(parentPlot),\par
29077   topLeft(createPosition(QLatin1String("topLeft"))),\par
29078   bottomRight(createPosition(QLatin1String("bottomRight"))),\par
29079   topLeftRim(createAnchor(QLatin1String("topLeftRim"), aiTopLeftRim)),\par
29080   top(createAnchor(QLatin1String("top"), aiTop)),\par
29081   topRightRim(createAnchor(QLatin1String("topRightRim"), aiTopRightRim)),\par
29082   right(createAnchor(QLatin1String("right"), aiRight)),\par
29083   bottomRightRim(createAnchor(QLatin1String("bottomRightRim"), aiBottomRightRim)),\par
29084   bottom(createAnchor(QLatin1String("bottom"), aiBottom)),\par
29085   bottomLeftRim(createAnchor(QLatin1String("bottomLeftRim"), aiBottomLeftRim)),\par
29086   left(createAnchor(QLatin1String("left"), aiLeft)),\par
29087   center(createAnchor(QLatin1String("center"), aiCenter))\par
29088 \{\par
29089   topLeft->setCoords(0, 1);\par
29090   bottomRight->setCoords(1, 0);\par
29091   \par
29092   setPen(QPen(Qt::black));\par
29093   setSelectedPen(QPen(Qt::blue, 2));\par
29094   setBrush(Qt::NoBrush);\par
29095   setSelectedBrush(Qt::NoBrush);\par
29096 \}\par
}
}
{\xe \v ~QCPItemEllipse\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:~QCPItemEllipse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemEllipse::~QCPItemEllipse (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29099 \{\par
29100 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v anchorPixelPosition\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:anchorPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPItemEllipse::anchorPixelPosition (int  {\i anchorId}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29201 \{\par
29202   QRectF rect = QRectF(topLeft->pixelPosition(), bottomRight->pixelPosition());\par
29203   switch (anchorId)\par
29204   \{\par
29205     case aiTopLeftRim:     return rect.center()+(rect.topLeft()-rect.center())*1/qSqrt(2);\par
29206     case aiTop:            return (rect.topLeft()+rect.topRight())*0.5;\par
29207     case aiTopRightRim:    return rect.center()+(rect.topRight()-rect.center())*1/qSqrt(2);\par
29208     case aiRight:          return (rect.topRight()+rect.bottomRight())*0.5;\par
29209     case aiBottomRightRim: return rect.center()+(rect.bottomRight()-rect.center())*1/qSqrt(2);\par
29210     case aiBottom:         return (rect.bottomLeft()+rect.bottomRight())*0.5;\par
29211     case aiBottomLeftRim:  return rect.center()+(rect.bottomLeft()-rect.center())*1/qSqrt(2);\par
29212     case aiLeft:           return (rect.topLeft()+rect.bottomLeft())*0.5;\par
29213     case aiCenter:         return (rect.topLeft()+rect.bottomRight())*0.5;\par
29214   \}\par
29215   \par
29216   qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;\par
29217   return QPointF();\par
29218 \}\par
}
}
{\xe \v brush\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemEllipse::brush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6396 \{ return mBrush; \}\par
}
}
{\xe \v draw\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemEllipse::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29173 \{\par
29174   QPointF p1 = topLeft->pixelPosition();\par
29175   QPointF p2 = bottomRight->pixelPosition();\par
29176   if (p1.toPoint() == p2.toPoint())\par
29177     return;\par
29178   QRectF ellipseRect = QRectF(p1, p2).normalized();\par
29179   QRect clip = clipRect().adjusted(-mainPen().widthF(), -mainPen().widthF(), mainPen().widthF(), mainPen().widthF());\par
29180   if (ellipseRect.intersects(clip)) // only draw if bounding rect of ellipse is visible in cliprect\par
29181   \{\par
29182     painter->setPen(mainPen());\par
29183     painter->setBrush(mainBrush());\par
29184 #ifdef __EXCEPTIONS\par
29185     try // drawEllipse sometimes throws exceptions if ellipse is too big\par
29186     \{\par
29187 #endif\par
29188       painter->drawEllipse(ellipseRect);\par
29189 #ifdef __EXCEPTIONS\par
29190     \} catch (...)\par
29191     \{\par
29192       qDebug() << Q_FUNC_INFO << "Item too large for memory, setting invisible";\par
29193       setVisible(false);\par
29194     \}\par
29195 #endif\par
29196   \}\par
29197 \}\par
}
}
{\xe \v mainBrush\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:mainBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemEllipse::mainBrush () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29236 \{\par
29237   return mSelected ? mSelectedBrush : mBrush;\par
29238 \}\par
}
}
{\xe \v mainPen\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:mainPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemEllipse::mainPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29226 \{\par
29227   return mSelected ? mSelectedPen : mPen;\par
29228 \}\par
}
}
{\xe \v pen\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemEllipse::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6394 \{ return mPen; \}\par
}
}
{\xe \v selectedBrush\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:selectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemEllipse::selectedBrush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6397 \{ return mSelectedBrush; \}\par
}
}
{\xe \v selectedPen\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:selectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemEllipse::selectedPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6395 \{ return mSelectedPen; \}\par
}
}
{\xe \v selectTest\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemEllipse::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29146 \{\par
29147   Q_UNUSED(details)\par
29148   if (onlySelectable && !mSelectable)\par
29149     return -1;\par
29150   \par
29151   QPointF p1 = topLeft->pixelPosition();\par
29152   QPointF p2 = bottomRight->pixelPosition();\par
29153   QPointF center((p1+p2)/2.0);\par
29154   double a = qAbs(p1.x()-p2.x())/2.0;\par
29155   double b = qAbs(p1.y()-p2.y())/2.0;\par
29156   double x = pos.x()-center.x();\par
29157   double y = pos.y()-center.y();\par
29158   \par
29159   // distance to border:\par
29160   double c = 1.0/qSqrt(x*x/(a*a)+y*y/(b*b));\par
29161   double result = qAbs(c-1)*qSqrt(x*x+y*y);\par
29162   // filled ellipse, allow click inside to count as hit:\par
29163   if (result > mParentPlot->selectionTolerance()*0.99 && mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0)\par
29164   \{\par
29165     if (x*x/(a*a) + y*y/(b*b) <= 1)\par
29166       result = mParentPlot->selectionTolerance()*0.99;\par
29167   \}\par
29168   return result;\par
29169 \}\par
}
}
{\xe \v setBrush\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemEllipse::setBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used to fill the ellipse. To disable filling, set {\i brush}  to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedBrush}, {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29129 \{\par
29130   mBrush = brush;\par
29131 \}\par
}
}
{\xe \v setPen\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemEllipse::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line of the ellipse\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedPen}, {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29108 \{\par
29109   mPen = pen;\par
29110 \}\par
}
}
{\xe \v setSelectedBrush\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:setSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemEllipse::setSelectedBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used to fill the ellipse when selected. To disable filling, set {\i brush}  to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29140 \{\par
29141   mSelectedBrush = brush;\par
29142 \}\par
}
}
{\xe \v setSelectedPen\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:setSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemEllipse::setSelectedPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line of the ellipse when selected\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29118 \{\par
29119   mSelectedPen = pen;\par
29120 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v bottom\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:bottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemEllipse::bottom}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bottomLeftRim\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:bottomLeftRim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemEllipse::bottomLeftRim}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bottomRight\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:bottomRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemEllipse::bottomRight}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bottomRightRim\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:bottomRightRim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemEllipse::bottomRightRim}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v center\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:center}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemEllipse::center}}
\par
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v left\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemEllipse::left}}
\par
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBrush\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemEllipse::mBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemEllipse::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedBrush\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:mSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemEllipse::mSelectedBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedPen\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:mSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemEllipse::mSelectedPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v right\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemEllipse::right}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v top\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:top}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemEllipse::top}}
\par
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v topLeft\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:topLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemEllipse::topLeft}}
\par
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v topLeftRim\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:topLeftRim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemEllipse::topLeftRim}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v topRightRim\:QCPItemEllipse}
{\xe \v QCPItemEllipse\:topRightRim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemEllipse::topRightRim}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemLine Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemLine}
{\xe \v QCPItemLine}
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A line from one point to another. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemLine:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_line__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemLine:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_line__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemLine} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemLine} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b head} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b tail} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHead} (const {\b QCPLineEnding} &{\b head})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTail} (const {\b QCPLineEnding} &{\b tail})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b start}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b end}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineF {\b getRectClippedLine} (const {\b QCPVector2D} &{\b start}, const {\b QCPVector2D} &{\b end}, const QRect &rect) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mainPen} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b mHead}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b mTail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A line from one point to another. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 It has two positions, {\i start}  and {\i end} , which define the end points of the line.\par
With {\b setHead} and {\b setTail} you may set different line ending styles, e.g. to create an arrow. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemLine\:QCPItemLine}
{\xe \v QCPItemLine\:QCPItemLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemLine::QCPItemLine ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a line item and sets default values.\par
The created item is automatically registered with {\i parentPlot} . This {\b QCustomPlot} instance takes ownership of the item, so do not delete it manually but use {\b QCustomPlot::removeItem()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28176                                                 :\par
28177   QCPAbstractItem(parentPlot),\par
28178   start(createPosition(QLatin1String("start"))),\par
28179   end(createPosition(QLatin1String("end")))\par
28180 \{\par
28181   start->setCoords(0, 0);\par
28182   end->setCoords(1, 1);\par
28183   \par
28184   setPen(QPen(Qt::black));\par
28185   setSelectedPen(QPen(Qt::blue,2));\par
28186 \}\par
}
}
{\xe \v ~QCPItemLine\:QCPItemLine}
{\xe \v QCPItemLine\:~QCPItemLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemLine::~QCPItemLine (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28189 \{\par
28190 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v draw\:QCPItemLine}
{\xe \v QCPItemLine\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemLine::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28250 \{\par
28251   QCPVector2D startVec(start->pixelPosition());\par
28252   QCPVector2D endVec(end->pixelPosition());\par
28253   if (qFuzzyIsNull((startVec-endVec).lengthSquared()))\par
28254     return;\par
28255   // get visible segment of straight line inside clipRect:\par
28256   double clipPad = qMax(mHead.boundingDistance(), mTail.boundingDistance());\par
28257   clipPad = qMax(clipPad, (double)mainPen().widthF());\par
28258   QLineF line = getRectClippedLine(startVec, endVec, clipRect().adjusted(-clipPad, -clipPad, clipPad, clipPad));\par
28259   // paint visible segment, if existent:\par
28260   if (!line.isNull())\par
28261   \{\par
28262     painter->setPen(mainPen());\par
28263     painter->drawLine(line);\par
28264     painter->setBrush(Qt::SolidPattern);\par
28265     if (mTail.style() != QCPLineEnding::esNone)\par
28266       mTail.draw(painter, startVec, startVec-endVec);\par
28267     if (mHead.style() != QCPLineEnding::esNone)\par
28268       mHead.draw(painter, endVec, endVec-startVec);\par
28269   \}\par
28270 \}\par
}
}
{\xe \v getRectClippedLine\:QCPItemLine}
{\xe \v QCPItemLine\:getRectClippedLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineF QCPItemLine::getRectClippedLine (const {\b QCPVector2D} &  {\i start}, const {\b QCPVector2D} &  {\i end}, const QRect &  {\i rect}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28280 \{\par
28281   bool containsStart = rect.contains(start.x(), start.y());\par
28282   bool containsEnd = rect.contains(end.x(), end.y());\par
28283   if (containsStart && containsEnd)\par
28284     return QLineF(start.toPointF(), end.toPointF());\par
28285   \par
28286   QCPVector2D base = start;\par
28287   QCPVector2D vec = end-start;\par
28288   double bx, by;\par
28289   double gamma, mu;\par
28290   QLineF result;\par
28291   QList<QCPVector2D> pointVectors;\par
28292 \par
28293   if (!qFuzzyIsNull(vec.y())) // line is not horizontal\par
28294   \{\par
28295     // check top of rect:\par
28296     bx = rect.left();\par
28297     by = rect.top();\par
28298     mu = (by-base.y())/vec.y();\par
28299     if (mu >= 0 && mu <= 1)\par
28300     \{\par
28301       gamma = base.x()-bx + mu*vec.x();\par
28302       if (gamma >= 0 && gamma <= rect.width())\par
28303         pointVectors.append(QCPVector2D(bx+gamma, by));\par
28304     \}\par
28305     // check bottom of rect:\par
28306     bx = rect.left();\par
28307     by = rect.bottom();\par
28308     mu = (by-base.y())/vec.y();\par
28309     if (mu >= 0 && mu <= 1)\par
28310     \{\par
28311       gamma = base.x()-bx + mu*vec.x();\par
28312       if (gamma >= 0 && gamma <= rect.width())\par
28313         pointVectors.append(QCPVector2D(bx+gamma, by));\par
28314     \}\par
28315   \}\par
28316   if (!qFuzzyIsNull(vec.x())) // line is not vertical\par
28317   \{\par
28318     // check left of rect:\par
28319     bx = rect.left();\par
28320     by = rect.top();\par
28321     mu = (bx-base.x())/vec.x();\par
28322     if (mu >= 0 && mu <= 1)\par
28323     \{\par
28324       gamma = base.y()-by + mu*vec.y();\par
28325       if (gamma >= 0 && gamma <= rect.height())\par
28326         pointVectors.append(QCPVector2D(bx, by+gamma));\par
28327     \}\par
28328     // check right of rect:\par
28329     bx = rect.right();\par
28330     by = rect.top();\par
28331     mu = (bx-base.x())/vec.x();\par
28332     if (mu >= 0 && mu <= 1)\par
28333     \{\par
28334       gamma = base.y()-by + mu*vec.y();\par
28335       if (gamma >= 0 && gamma <= rect.height())\par
28336         pointVectors.append(QCPVector2D(bx, by+gamma));\par
28337     \}\par
28338   \}\par
28339   \par
28340   if (containsStart)\par
28341     pointVectors.append(start);\par
28342   if (containsEnd)\par
28343     pointVectors.append(end);\par
28344   \par
28345   // evaluate points:\par
28346   if (pointVectors.size() == 2)\par
28347   \{\par
28348     result.setPoints(pointVectors.at(0).toPointF(), pointVectors.at(1).toPointF());\par
28349   \} else if (pointVectors.size() > 2)\par
28350   \{\par
28351     // line probably goes through corner of rect, and we got two points there. single out the point pair with greatest distance:\par
28352     double distSqrMax = 0;\par
28353     QCPVector2D pv1, pv2;\par
28354     for (int i=0; i<pointVectors.size()-1; ++i)\par
28355     \{\par
28356       for (int k=i+1; k<pointVectors.size(); ++k)\par
28357       \{\par
28358         double distSqr = (pointVectors.at(i)-pointVectors.at(k)).lengthSquared();\par
28359         if (distSqr > distSqrMax)\par
28360         \{\par
28361           pv1 = pointVectors.at(i);\par
28362           pv2 = pointVectors.at(k);\par
28363           distSqrMax = distSqr;\par
28364         \}\par
28365       \}\par
28366     \}\par
28367     result.setPoints(pv1.toPointF(), pv2.toPointF());\par
28368   \}\par
28369   return result;\par
28370 \}\par
}
}
{\xe \v head\:QCPItemLine}
{\xe \v QCPItemLine\:head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPItemLine::head () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6139 \{ return mHead; \}\par
}
}
{\xe \v mainPen\:QCPItemLine}
{\xe \v QCPItemLine\:mainPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemLine::mainPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28378 \{\par
28379   return mSelected ? mSelectedPen : mPen;\par
28380 \}\par
}
}
{\xe \v pen\:QCPItemLine}
{\xe \v QCPItemLine\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemLine::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6137 \{ return mPen; \}\par
}
}
{\xe \v selectedPen\:QCPItemLine}
{\xe \v QCPItemLine\:selectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemLine::selectedPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6138 \{ return mSelectedPen; \}\par
}
}
{\xe \v selectTest\:QCPItemLine}
{\xe \v QCPItemLine\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemLine::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28240 \{\par
28241   Q_UNUSED(details)\par
28242   if (onlySelectable && !mSelectable)\par
28243     return -1;\par
28244   \par
28245   return qSqrt(QCPVector2D(pos).distanceSquaredToLine(start->pixelPosition(), end->pixelPosition()));\par
28246 \}\par
}
}
{\xe \v setHead\:QCPItemLine}
{\xe \v QCPItemLine\:setHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemLine::setHead (const {\b QCPLineEnding} &  {\i head})}}
\par
{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the line ending style of the head. The head corresponds to the {\i end}  position.\par
Note that due to the overloaded {\b QCPLineEnding} constructor, you may directly specify a {\b QCPLineEnding::EndingStyle} here, e.g.{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid setHead(QCPLineEnding::esSpikeArrow) \par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTail} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28221 \{\par
28222   mHead = head;\par
28223 \}\par
}
}
{\xe \v setPen\:QCPItemLine}
{\xe \v QCPItemLine\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemLine::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28198 \{\par
28199   mPen = pen;\par
28200 \}\par
}
}
{\xe \v setSelectedPen\:QCPItemLine}
{\xe \v QCPItemLine\:setSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemLine::setSelectedPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line when selected\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28208 \{\par
28209   mSelectedPen = pen;\par
28210 \}\par
}
}
{\xe \v setTail\:QCPItemLine}
{\xe \v QCPItemLine\:setTail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemLine::setTail (const {\b QCPLineEnding} &  {\i tail})}}
\par
{\bkmkstart AAAAAAACHQ}
{\bkmkend AAAAAAACHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the line ending style of the tail. The tail corresponds to the {\i start}  position.\par
Note that due to the overloaded {\b QCPLineEnding} constructor, you may directly specify a {\b QCPLineEnding::EndingStyle} here, e.g.{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid setTail(QCPLineEnding::esSpikeArrow) \par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setHead} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28234 \{\par
28235   mTail = tail;\par
28236 \}\par
}
}
{\xe \v tail\:QCPItemLine}
{\xe \v QCPItemLine\:tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPItemLine::tail () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHR}
{\bkmkend AAAAAAACHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6140 \{ return mTail; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v end\:QCPItemLine}
{\xe \v QCPItemLine\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemLine::end}}
\par
{\bkmkstart AAAAAAACHS}
{\bkmkend AAAAAAACHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mHead\:QCPItemLine}
{\xe \v QCPItemLine\:mHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPItemLine::mHead{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHT}
{\bkmkend AAAAAAACHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPItemLine}
{\xe \v QCPItemLine\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemLine::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHU}
{\bkmkend AAAAAAACHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedPen\:QCPItemLine}
{\xe \v QCPItemLine\:mSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemLine::mSelectedPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHV}
{\bkmkend AAAAAAACHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTail\:QCPItemLine}
{\xe \v QCPItemLine\:mTail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPItemLine::mTail{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHW}
{\bkmkend AAAAAAACHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v start\:QCPItemLine}
{\xe \v QCPItemLine\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemLine::start}}
\par
{\bkmkstart AAAAAAACHX}
{\bkmkend AAAAAAACHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemPixmap Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemPixmap}
{\xe \v QCPItemPixmap}
{\bkmkstart AAAAAAACHY}
{\bkmkend AAAAAAACHY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An arbitrary pixmap. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemPixmap:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_pixmap__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemPixmap:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_pixmap__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPixmap} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemPixmap} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b pixmap} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b scaled} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b aspectRatioMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::TransformationMode {\b transformationMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPixmap} (const QPixmap &{\b pixmap})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScaled} (bool {\b scaled}, Qt::AspectRatioMode {\b aspectRatioMode}=Qt::KeepAspectRatio, Qt::TransformationMode {\b transformationMode}=Qt::SmoothTransformation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b topLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b bottomRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b top}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b topRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b right}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottom}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottomLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b left}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AnchorIndex} \{ {\b aiTop}, 
{\b aiTopRight}, 
{\b aiRight}, 
{\b aiBottom}, 
{\b aiBottomLeft}, 
{\b aiLeft}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b anchorPixelPosition} (int anchorId) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateScaledPixmap} (QRect finalRect=QRect(), bool flipHorz=false, bool flipVert=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b getFinalRect} (bool *flippedHorz=0, bool *flippedVert=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mainPen} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mScaledPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mScaled}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mScaledPixmapInvalidated}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b mAspectRatioMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::TransformationMode {\b mTransformationMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedPen}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An arbitrary pixmap. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 It has two positions, {\i topLeft}  and {\i bottomRight} , which define the rectangle the pixmap will be drawn in. Depending on the scale setting ({\b setScaled}), the pixmap will be either scaled to fit the rectangle or be drawn aligned to the topLeft position.\par
If scaling is enabled and {\i topLeft}  is further to the bottom/right than {\i bottomRight}  (as shown on the right side of the example image), the pixmap will be flipped in the respective orientations. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v AnchorIndex\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:AnchorIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPItemPixmap::AnchorIndex}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHZ}
{\bkmkend AAAAAAACHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v aiTop\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:aiTop}
{\qr aiTop{\bkmkstart AAAAAAACIA}
{\bkmkend AAAAAAACIA}
\cell }{\cell }{\row }
{\xe \v aiTopRight\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:aiTopRight}
{\qr aiTopRight{\bkmkstart AAAAAAACIB}
{\bkmkend AAAAAAACIB}
\cell }{\cell }{\row }
{\xe \v aiRight\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:aiRight}
{\qr aiRight{\bkmkstart AAAAAAACIC}
{\bkmkend AAAAAAACIC}
\cell }{\cell }{\row }
{\xe \v aiBottom\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:aiBottom}
{\qr aiBottom{\bkmkstart AAAAAAACID}
{\bkmkend AAAAAAACID}
\cell }{\cell }{\row }
{\xe \v aiBottomLeft\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:aiBottomLeft}
{\qr aiBottomLeft{\bkmkstart AAAAAAACIE}
{\bkmkend AAAAAAACIE}
\cell }{\cell }{\row }
{\xe \v aiLeft\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:aiLeft}
{\qr aiLeft{\bkmkstart AAAAAAACIF}
{\bkmkend AAAAAAACIF}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6484 \{aiTop, aiTopRight, aiRight, aiBottom, aiBottomLeft, aiLeft\};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemPixmap\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:QCPItemPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemPixmap::QCPItemPixmap ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACIG}
{\bkmkend AAAAAAACIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a rectangle item and sets default values.\par
The created item is automatically registered with {\i parentPlot} . This {\b QCustomPlot} instance takes ownership of the item, so do not delete it manually but use {\b QCustomPlot::removeItem()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29269                                                     :\par
29270   QCPAbstractItem(parentPlot),\par
29271   topLeft(createPosition(QLatin1String("topLeft"))),\par
29272   bottomRight(createPosition(QLatin1String("bottomRight"))),\par
29273   top(createAnchor(QLatin1String("top"), aiTop)),\par
29274   topRight(createAnchor(QLatin1String("topRight"), aiTopRight)),\par
29275   right(createAnchor(QLatin1String("right"), aiRight)),\par
29276   bottom(createAnchor(QLatin1String("bottom"), aiBottom)),\par
29277   bottomLeft(createAnchor(QLatin1String("bottomLeft"), aiBottomLeft)),\par
29278   left(createAnchor(QLatin1String("left"), aiLeft)),\par
29279   mScaled(false),\par
29280   mScaledPixmapInvalidated(true),\par
29281   mAspectRatioMode(Qt::KeepAspectRatio),\par
29282   mTransformationMode(Qt::SmoothTransformation)\par
29283 \{\par
29284   topLeft->setCoords(0, 1);\par
29285   bottomRight->setCoords(1, 0);\par
29286   \par
29287   setPen(Qt::NoPen);\par
29288   setSelectedPen(QPen(Qt::blue));\par
29289 \}\par
}
}
{\xe \v ~QCPItemPixmap\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:~QCPItemPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemPixmap::~QCPItemPixmap (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACIH}
{\bkmkend AAAAAAACIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29292 \{\par
29293 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v anchorPixelPosition\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:anchorPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPItemPixmap::anchorPixelPosition (int  {\i anchorId}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29372 \{\par
29373   bool flipHorz;\par
29374   bool flipVert;\par
29375   QRect rect = getFinalRect(&flipHorz, &flipVert);\par
29376   // we actually want denormal rects (negative width/height) here, so restore\par
29377   // the flipped state:\par
29378   if (flipHorz)\par
29379     rect.adjust(rect.width(), 0, -rect.width(), 0);\par
29380   if (flipVert)\par
29381     rect.adjust(0, rect.height(), 0, -rect.height());\par
29382   \par
29383   switch (anchorId)\par
29384   \{\par
29385     case aiTop:         return (rect.topLeft()+rect.topRight())*0.5;\par
29386     case aiTopRight:    return rect.topRight();\par
29387     case aiRight:       return (rect.topRight()+rect.bottomRight())*0.5;\par
29388     case aiBottom:      return (rect.bottomLeft()+rect.bottomRight())*0.5;\par
29389     case aiBottomLeft:  return rect.bottomLeft();\par
29390     case aiLeft:        return (rect.topLeft()+rect.bottomLeft())*0.5;;\par
29391   \}\par
29392   \par
29393   qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;\par
29394   return QPointF();\par
29395 \}\par
}
}
{\xe \v aspectRatioMode\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:aspectRatioMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCPItemPixmap::aspectRatioMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACII}
{\bkmkend AAAAAAACII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6460 \{ return mAspectRatioMode; \}\par
}
}
{\xe \v draw\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPixmap::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29350 \{\par
29351   bool flipHorz = false;\par
29352   bool flipVert = false;\par
29353   QRect rect = getFinalRect(&flipHorz, &flipVert);\par
29354   double clipPad = mainPen().style() == Qt::NoPen ? 0 : mainPen().widthF();\par
29355   QRect boundingRect = rect.adjusted(-clipPad, -clipPad, clipPad, clipPad);\par
29356   if (boundingRect.intersects(clipRect()))\par
29357   \{\par
29358     updateScaledPixmap(rect, flipHorz, flipVert);\par
29359     painter->drawPixmap(rect.topLeft(), mScaled ? mScaledPixmap : mPixmap);\par
29360     QPen pen = mainPen();\par
29361     if (pen.style() != Qt::NoPen)\par
29362     \{\par
29363       painter->setPen(pen);\par
29364       painter->setBrush(Qt::NoBrush);\par
29365       painter->drawRect(rect);\par
29366     \}\par
29367   \}\par
29368 \}\par
}
}
{\xe \v getFinalRect\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:getFinalRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPItemPixmap::getFinalRect (bool *  {\i flippedHorz} = {\f2 0}, bool *  {\i flippedVert} = {\f2 0}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACIJ}
{\bkmkend AAAAAAACIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29453 \{\par
29454   QRect result;\par
29455   bool flipHorz = false;\par
29456   bool flipVert = false;\par
29457   QPoint p1 = topLeft->pixelPosition().toPoint();\par
29458   QPoint p2 = bottomRight->pixelPosition().toPoint();\par
29459   if (p1 == p2)\par
29460     return QRect(p1, QSize(0, 0));\par
29461   if (mScaled)\par
29462   \{\par
29463     QSize newSize = QSize(p2.x()-p1.x(), p2.y()-p1.y());\par
29464     QPoint topLeft = p1;\par
29465     if (newSize.width() < 0)\par
29466     \{\par
29467       flipHorz = true;\par
29468       newSize.rwidth() *= -1;\par
29469       topLeft.setX(p2.x());\par
29470     \}\par
29471     if (newSize.height() < 0)\par
29472     \{\par
29473       flipVert = true;\par
29474       newSize.rheight() *= -1;\par
29475       topLeft.setY(p2.y());\par
29476     \}\par
29477     QSize scaledSize = mPixmap.size();\par
29478 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
29479     scaledSize /= mPixmap.devicePixelRatio();\par
29480     scaledSize.scale(newSize*mPixmap.devicePixelRatio(), mAspectRatioMode);\par
29481 #else\par
29482     scaledSize.scale(newSize, mAspectRatioMode);\par
29483 #endif\par
29484     result = QRect(topLeft, scaledSize);\par
29485   \} else\par
29486   \{\par
29487 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
29488     result = QRect(p1, mPixmap.size()/mPixmap.devicePixelRatio());\par
29489 #else\par
29490     result = QRect(p1, mPixmap.size());\par
29491 #endif\par
29492   \}\par
29493   if (flippedHorz)\par
29494     *flippedHorz = flipHorz;\par
29495   if (flippedVert)\par
29496     *flippedVert = flipVert;\par
29497   return result;\par
29498 \}\par
}
}
{\xe \v mainPen\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:mainPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemPixmap::mainPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACIK}
{\bkmkend AAAAAAACIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29506 \{\par
29507   return mSelected ? mSelectedPen : mPen;\par
29508 \}\par
}
}
{\xe \v pen\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemPixmap::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIL}
{\bkmkend AAAAAAACIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6462 \{ return mPen; \}\par
}
}
{\xe \v pixmap\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:pixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPItemPixmap::pixmap () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIM}
{\bkmkend AAAAAAACIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6458 \{ return mPixmap; \}\par
}
}
{\xe \v scaled\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:scaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPItemPixmap::scaled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIN}
{\bkmkend AAAAAAACIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6459 \{ return mScaled; \}\par
}
}
{\xe \v selectedPen\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:selectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemPixmap::selectedPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIO}
{\bkmkend AAAAAAACIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6463 \{ return mSelectedPen; \}\par
}
}
{\xe \v selectTest\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemPixmap::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29340 \{\par
29341   Q_UNUSED(details)\par
29342   if (onlySelectable && !mSelectable)\par
29343     return -1;\par
29344   \par
29345   return rectDistance(getFinalRect(), pos, true);\par
29346 \}\par
}
}
{\xe \v setPen\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPixmap::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACIP}
{\bkmkend AAAAAAACIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw a border around the pixmap.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedPen}, setBrush \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29324 \{\par
29325   mPen = pen;\par
29326 \}\par
}
}
{\xe \v setPixmap\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:setPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPixmap::setPixmap (const QPixmap &  {\i pixmap})}}
\par
{\bkmkstart AAAAAAACIQ}
{\bkmkend AAAAAAACIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pixmap that will be displayed. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29299 \{\par
29300   mPixmap = pixmap;\par
29301   mScaledPixmapInvalidated = true;\par
29302   if (mPixmap.isNull())\par
29303     qDebug() << Q_FUNC_INFO << "pixmap is null";\par
29304 \}\par
}
}
{\xe \v setScaled\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:setScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPixmap::setScaled (bool  {\i scaled}, Qt::AspectRatioMode  {\i aspectRatioMode} = {\f2 Qt::KeepAspectRatio}, Qt::TransformationMode  {\i transformationMode} = {\f2 Qt::SmoothTransformation})}}
\par
{\bkmkstart AAAAAAACIR}
{\bkmkend AAAAAAACIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the pixmap will be scaled to fit the rectangle defined by the {\i topLeft}  and {\i bottomRight}  positions. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29311 \{\par
29312   mScaled = scaled;\par
29313   mAspectRatioMode = aspectRatioMode;\par
29314   mTransformationMode = transformationMode;\par
29315   mScaledPixmapInvalidated = true;\par
29316 \}\par
}
}
{\xe \v setSelectedPen\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:setSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPixmap::setSelectedPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACIS}
{\bkmkend AAAAAAACIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw a border around the pixmap when selected\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29334 \{\par
29335   mSelectedPen = pen;\par
29336 \}\par
}
}
{\xe \v transformationMode\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:transformationMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::TransformationMode QCPItemPixmap::transformationMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACIT}
{\bkmkend AAAAAAACIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6461 \{ return mTransformationMode; \}\par
}
}
{\xe \v updateScaledPixmap\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:updateScaledPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPixmap::updateScaledPixmap (QRect  {\i finalRect} = {\f2 QRect()}, bool  {\i flipHorz} = {\f2 false}, bool  {\i flipVert} = {\f2 false}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACIU}
{\bkmkend AAAAAAACIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29411 \{\par
29412   if (mPixmap.isNull())\par
29413     return;\par
29414   \par
29415   if (mScaled)\par
29416   \{\par
29417 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
29418     double devicePixelRatio = mPixmap.devicePixelRatio();\par
29419 #else\par
29420     double devicePixelRatio = 1.0;\par
29421 #endif\par
29422     if (finalRect.isNull())\par
29423       finalRect = getFinalRect(&flipHorz, &flipVert);\par
29424     if (mScaledPixmapInvalidated || finalRect.size() != mScaledPixmap.size()/devicePixelRatio)\par
29425     \{\par
29426       mScaledPixmap = mPixmap.scaled(finalRect.size()*devicePixelRatio, mAspectRatioMode, mTransformationMode);\par
29427       if (flipHorz || flipVert)\par
29428         mScaledPixmap = QPixmap::fromImage(mScaledPixmap.toImage().mirrored(flipHorz, flipVert));\par
29429 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
29430       mScaledPixmap.setDevicePixelRatio(devicePixelRatio);\par
29431 #endif\par
29432     \}\par
29433   \} else if (!mScaledPixmap.isNull())\par
29434     mScaledPixmap = QPixmap();\par
29435   mScaledPixmapInvalidated = false;\par
29436 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v bottom\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:bottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemPixmap::bottom}}
\par
{\bkmkstart AAAAAAACIV}
{\bkmkend AAAAAAACIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bottomLeft\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:bottomLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemPixmap::bottomLeft}}
\par
{\bkmkstart AAAAAAACIW}
{\bkmkend AAAAAAACIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bottomRight\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:bottomRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemPixmap::bottomRight}}
\par
{\bkmkstart AAAAAAACIX}
{\bkmkend AAAAAAACIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v left\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemPixmap::left}}
\par
{\bkmkstart AAAAAAACIY}
{\bkmkend AAAAAAACIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAspectRatioMode\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:mAspectRatioMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCPItemPixmap::mAspectRatioMode{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACIZ}
{\bkmkend AAAAAAACIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemPixmap::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJA}
{\bkmkend AAAAAAACJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPixmap\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:mPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPItemPixmap::mPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJB}
{\bkmkend AAAAAAACJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScaled\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:mScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPItemPixmap::mScaled{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJC}
{\bkmkend AAAAAAACJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScaledPixmap\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:mScaledPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPItemPixmap::mScaledPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJD}
{\bkmkend AAAAAAACJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScaledPixmapInvalidated\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:mScaledPixmapInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPItemPixmap::mScaledPixmapInvalidated{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJE}
{\bkmkend AAAAAAACJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedPen\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:mSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemPixmap::mSelectedPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJF}
{\bkmkend AAAAAAACJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTransformationMode\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:mTransformationMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::TransformationMode QCPItemPixmap::mTransformationMode{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACJG}
{\bkmkend AAAAAAACJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v right\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemPixmap::right}}
\par
{\bkmkstart AAAAAAACJH}
{\bkmkend AAAAAAACJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v top\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:top}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemPixmap::top}}
\par
{\bkmkstart AAAAAAACJI}
{\bkmkend AAAAAAACJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v topLeft\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:topLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemPixmap::topLeft}}
\par
{\bkmkstart AAAAAAACJJ}
{\bkmkend AAAAAAACJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v topRight\:QCPItemPixmap}
{\xe \v QCPItemPixmap\:topRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemPixmap::topRight}}
\par
{\bkmkstart AAAAAAACJK}
{\bkmkend AAAAAAACJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemPosition Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemPosition}
{\xe \v QCPItemPosition}
{\bkmkstart AAAAAAACJL}
{\bkmkend AAAAAAACJL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages the position of an item. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemPosition:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_position__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemPosition:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_position__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PositionType} \{ {\b ptAbsolute}, 
{\b ptViewportRatio}, 
{\b ptAxisRectRatio}, 
{\b ptPlotCoords}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} ({\b QCustomPlot} *parentPlot, {\b QCPAbstractItem} *parentItem, const QString &{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemPosition} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PositionType} {\b type} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PositionType} {\b typeX} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PositionType} {\b typeY} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} * {\b parentAnchor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} * {\b parentAnchorX} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} * {\b parentAnchorY} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b key} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b value} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointF {\b coords} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b keyAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b valueAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b axisRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b pixelPosition} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setType} ({\b PositionType} {\b type})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTypeX} ({\b PositionType} {\b type})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTypeY} ({\b PositionType} {\b type})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setParentAnchor} ({\b QCPItemAnchor} *{\b parentAnchor}, bool keepPixelPosition=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setParentAnchorX} ({\b QCPItemAnchor} *{\b parentAnchor}, bool keepPixelPosition=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setParentAnchorY} ({\b QCPItemAnchor} *{\b parentAnchor}, bool keepPixelPosition=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCoords} (double {\b key}, double {\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCoords} (const QPointF &{\b coords})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAxes} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAxisRect} ({\b QCPAxisRect} *{\b axisRect})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPixelPosition} (const QPointF &{\b pixelPosition})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPItemPosition} * {\b toQCPItemPosition} () {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PositionType} {\b mPositionTypeX}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PositionType} {\b mPositionTypeY}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxis} > {\b mKeyAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxis} > {\b mValueAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxisRect} > {\b mAxisRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mKey}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mValue}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} * {\b mParentAnchorX}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} * {\b mParentAnchorY}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages the position of an item. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Every item has at least one public {\b QCPItemPosition} member pointer which provides ways to position the item on the {\b QCustomPlot} surface. Some items have multiple positions, for example {\b QCPItemRect} has two: {\i topLeft}  and {\i bottomRight} .\par
{\b QCPItemPosition} has a type ({\b PositionType}) that can be set with {\b setType}. This type defines how coordinates passed to {\b setCoords} are to be interpreted, e.g. as absolute pixel coordinates, as plot coordinates of certain axes, etc. For more advanced plots it is also possible to assign different types per X/Y coordinate of the position (see {\b setTypeX}, {\b setTypeY}). This way an item could be positioned at a fixed pixel distance from the top in the Y direction, while following a plot coordinate in the X direction.\par
A {\b QCPItemPosition} may have a parent {\b QCPItemAnchor}, see {\b setParentAnchor}. This way you can tie multiple items together. If the {\b QCPItemPosition} has a parent, its coordinates ({\b setCoords}) are considered to be absolute pixels in the reference frame of the parent anchor, where (0, 0) means directly ontop of the parent anchor. For example, You could attach the {\i start}  position of a {\b QCPItemLine} to the {\i bottom}  anchor of a {\b QCPItemText} to make the starting point of the line always be centered under the text label, no matter where the text is moved to. For more advanced plots, it is possible to assign different parent anchors per X/Y coordinate of the position, see {\b setParentAnchorX}, {\b setParentAnchorY}. This way an item could follow another item in the X direction but stay at a fixed position in the Y direction. Or even follow item A in X, and item B in Y.\par
Note that every {\b QCPItemPosition} inherits from {\b QCPItemAnchor} and thus can itself be used as parent anchor for other positions.\par
To set the apparent pixel position on the {\b QCustomPlot} surface directly, use {\b setPixelPosition}. This works no matter what type this {\b QCPItemPosition} is or what parent-child situation it is in, as {\b setPixelPosition} transforms the coordinates appropriately, to make the position appear at the specified pixel values. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v PositionType\:QCPItemPosition}
{\xe \v QCPItemPosition\:PositionType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPItemPosition::PositionType}}}
\par
{\bkmkstart AAAAAAACJM}
{\bkmkend AAAAAAACJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the ways an item position can be specified. Thus it defines what the numbers passed to {\b setCoords} actually mean.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setType} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ptAbsolute\:QCPItemPosition}
{\xe \v QCPItemPosition\:ptAbsolute}
{\qr ptAbsolute{\bkmkstart AAAAAAACJN}
{\bkmkend AAAAAAACJN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static positioning in pixels, starting from the top left corner of the viewport/widget. \par
}\cell }{\row }
{\xe \v ptViewportRatio\:QCPItemPosition}
{\xe \v QCPItemPosition\:ptViewportRatio}
{\qr ptViewportRatio{\bkmkstart AAAAAAACJO}
{\bkmkend AAAAAAACJO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static positioning given by a fraction of the viewport size. For example, if you call setCoords(0, 0), the position will be at the top left corner of the viewport/widget. setCoords(1, 1) will be at the bottom right corner, setCoords(0.5, 0) will be horizontally centered and vertically at the top of the viewport/widget, etc. \par
}\cell }{\row }
{\xe \v ptAxisRectRatio\:QCPItemPosition}
{\xe \v QCPItemPosition\:ptAxisRectRatio}
{\qr ptAxisRectRatio{\bkmkstart AAAAAAACJP}
{\bkmkend AAAAAAACJP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static positioning given by a fraction of the axis rect size (see {\b setAxisRect}). For example, if you call setCoords(0, 0), the position will be at the top left corner of the axis rect. setCoords(1, 1) will be at the bottom right corner, setCoords(0.5, 0) will be horizontally centered and vertically at the top of the axis rect, etc. You can also go beyond the axis rect by providing negative coordinates or coordinates larger than 1. \par
}\cell }{\row }
{\xe \v ptPlotCoords\:QCPItemPosition}
{\xe \v QCPItemPosition\:ptPlotCoords}
{\qr ptPlotCoords{\bkmkstart AAAAAAACJQ}
{\bkmkend AAAAAAACJQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dynamic positioning at a plot coordinate defined by two axes (see {\b setAxes}). \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3445                     \{ ptAbsolute        \par
 3446                       ,ptViewportRatio  \par
 3447                       ,ptAxisRectRatio  \par
 3450                       ,ptPlotCoords     \par
 3453                     \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemPosition\:QCPItemPosition}
{\xe \v QCPItemPosition\:QCPItemPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemPosition::QCPItemPosition ({\b QCustomPlot} *  {\i parentPlot}, {\b QCPAbstractItem} *  {\i parentItem}, const QString &  {\i name})}}
\par
{\bkmkstart AAAAAAACJR}
{\bkmkend AAAAAAACJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPItemPosition}. You shouldn't create {\b QCPItemPosition} instances directly, even if you want to make a new item subclass. Use {\b QCPAbstractItem::createPosition} instead, as explained in the subclassing section of the {\b QCPAbstractItem} documentation. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11488                                                                                                           :\par
11489   QCPItemAnchor(parentPlot, parentItem, name),\par
11490   mPositionTypeX(ptAbsolute),\par
11491   mPositionTypeY(ptAbsolute),\par
11492   mKey(0),\par
11493   mValue(0),\par
11494   mParentAnchorX(0),\par
11495   mParentAnchorY(0)\par
11496 \{\par
11497 \}\par
}
}
{\xe \v ~QCPItemPosition\:QCPItemPosition}
{\xe \v QCPItemPosition\:~QCPItemPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemPosition::~QCPItemPosition (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACJS}
{\bkmkend AAAAAAACJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11500 \{\par
11501   // unregister as parent at children:\par
11502   // Note: this is done in ~QCPItemAnchor again, but it's important QCPItemPosition does it itself, because only then\par
11503   //       the setParentAnchor(0) call the correct QCPItemPosition::pixelPosition function instead of QCPItemAnchor::pixelPosition\par
11504   foreach (QCPItemPosition *child, mChildrenX.toList())\par
11505   \{\par
11506     if (child->parentAnchorX() == this)\par
11507       child->setParentAnchorX(0); // this acts back on this anchor and child removes itself from mChildrenX\par
11508   \}\par
11509   foreach (QCPItemPosition *child, mChildrenY.toList())\par
11510   \{\par
11511     if (child->parentAnchorY() == this)\par
11512       child->setParentAnchorY(0); // this acts back on this anchor and child removes itself from mChildrenY\par
11513   \}\par
11514   // unregister as child in parent:\par
11515   if (mParentAnchorX)\par
11516     mParentAnchorX->removeChildX(this);\par
11517   if (mParentAnchorY)\par
11518     mParentAnchorY->removeChildY(this);\par
11519 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v axisRect\:QCPItemPosition}
{\xe \v QCPItemPosition\:axisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect} * QCPItemPosition::axisRect () const}}
\par
{\bkmkstart AAAAAAACJT}
{\bkmkend AAAAAAACJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11523 \{\par
11524   return mAxisRect.data();\par
11525 \}\par
}
}
{\xe \v coords\:QCPItemPosition}
{\xe \v QCPItemPosition\:coords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPItemPosition::coords () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJU}
{\bkmkend AAAAAAACJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3468 \{ return QPointF(mKey, mValue); \}\par
}
}
{\xe \v key\:QCPItemPosition}
{\xe \v QCPItemPosition\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemPosition::key () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJV}
{\bkmkend AAAAAAACJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3466 \{ return mKey; \}\par
}
}
{\xe \v keyAxis\:QCPItemPosition}
{\xe \v QCPItemPosition\:keyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis}* QCPItemPosition::keyAxis () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJW}
{\bkmkend AAAAAAACJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3469 \{ return mKeyAxis.data(); \}\par
}
}
{\xe \v parentAnchor\:QCPItemPosition}
{\xe \v QCPItemPosition\:parentAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor} * QCPItemPosition::parentAnchor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJX}
{\bkmkend AAAAAAACJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current parent anchor.\par
If different parent anchors were set for X and Y ({\b setParentAnchorX}, {\b setParentAnchorY}), this method returns the parent anchor of the Y coordinate. In that case rather use {\i {\b parentAnchorX()}}  and {\i {\b parentAnchorY()}} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setParentAnchor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3463 \{ return parentAnchorX(); \}\par
}
}
{\xe \v parentAnchorX\:QCPItemPosition}
{\xe \v QCPItemPosition\:parentAnchorX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* QCPItemPosition::parentAnchorX () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJY}
{\bkmkend AAAAAAACJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3464 \{ return mParentAnchorX; \}\par
}
}
{\xe \v parentAnchorY\:QCPItemPosition}
{\xe \v QCPItemPosition\:parentAnchorY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* QCPItemPosition::parentAnchorY () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJZ}
{\bkmkend AAAAAAACJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3465 \{ return mParentAnchorY; \}\par
}
}
{\xe \v pixelPosition\:QCPItemPosition}
{\xe \v QCPItemPosition\:pixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPItemPosition::pixelPosition () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the final absolute pixel position of the {\b QCPItemPosition} on the {\b QCustomPlot} surface. It includes all effects of type ({\b setType}) and possible parent anchors ({\b setParentAnchor}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPixelPosition} \par
}}{
Reimplemented from {\b QCPItemAnchor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11813 \{\par
11814   QPointF result;\par
11815   \par
11816   // determine X:\par
11817   switch (mPositionTypeX)\par
11818   \{\par
11819     case ptAbsolute:\par
11820     \{\par
11821       result.rx() = mKey;\par
11822       if (mParentAnchorX)\par
11823         result.rx() += mParentAnchorX->pixelPosition().x();\par
11824       break;\par
11825     \}\par
11826     case ptViewportRatio:\par
11827     \{\par
11828       result.rx() = mKey*mParentPlot->viewport().width();\par
11829       if (mParentAnchorX)\par
11830         result.rx() += mParentAnchorX->pixelPosition().x();\par
11831       else\par
11832         result.rx() += mParentPlot->viewport().left();\par
11833       break;\par
11834     \}\par
11835     case ptAxisRectRatio:\par
11836     \{\par
11837       if (mAxisRect)\par
11838       \{\par
11839         result.rx() = mKey*mAxisRect.data()->width();\par
11840         if (mParentAnchorX)\par
11841           result.rx() += mParentAnchorX->pixelPosition().x();\par
11842         else\par
11843           result.rx() += mAxisRect.data()->left();\par
11844       \} else\par
11845         qDebug() << Q_FUNC_INFO << "Item position type x is ptAxisRectRatio, but no axis rect was defined";\par
11846       break;\par
11847     \}\par
11848     case ptPlotCoords:\par
11849     \{\par
11850       if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Horizontal)\par
11851         result.rx() = mKeyAxis.data()->coordToPixel(mKey);\par
11852       else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Horizontal)\par
11853         result.rx() = mValueAxis.data()->coordToPixel(mValue);\par
11854       else\par
11855         qDebug() << Q_FUNC_INFO << "Item position type x is ptPlotCoords, but no axes were defined";\par
11856       break;\par
11857     \}\par
11858   \}\par
11859   \par
11860   // determine Y:\par
11861   switch (mPositionTypeY)\par
11862   \{\par
11863     case ptAbsolute:\par
11864     \{\par
11865       result.ry() = mValue;\par
11866       if (mParentAnchorY)\par
11867         result.ry() += mParentAnchorY->pixelPosition().y();\par
11868       break;\par
11869     \}\par
11870     case ptViewportRatio:\par
11871     \{\par
11872       result.ry() = mValue*mParentPlot->viewport().height();\par
11873       if (mParentAnchorY)\par
11874         result.ry() += mParentAnchorY->pixelPosition().y();\par
11875       else\par
11876         result.ry() += mParentPlot->viewport().top();\par
11877       break;\par
11878     \}\par
11879     case ptAxisRectRatio:\par
11880     \{\par
11881       if (mAxisRect)\par
11882       \{\par
11883         result.ry() = mValue*mAxisRect.data()->height();\par
11884         if (mParentAnchorY)\par
11885           result.ry() += mParentAnchorY->pixelPosition().y();\par
11886         else\par
11887           result.ry() += mAxisRect.data()->top();\par
11888       \} else\par
11889         qDebug() << Q_FUNC_INFO << "Item position type y is ptAxisRectRatio, but no axis rect was defined";\par
11890       break;\par
11891     \}\par
11892     case ptPlotCoords:\par
11893     \{\par
11894       if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Vertical)\par
11895         result.ry() = mKeyAxis.data()->coordToPixel(mKey);\par
11896       else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Vertical)\par
11897         result.ry() = mValueAxis.data()->coordToPixel(mValue);\par
11898       else\par
11899         qDebug() << Q_FUNC_INFO << "Item position type y is ptPlotCoords, but no axes were defined";\par
11900       break;\par
11901     \}\par
11902   \}\par
11903   \par
11904   return result;\par
11905 \}\par
}
}
{\xe \v setAxes\:QCPItemPosition}
{\xe \v QCPItemPosition\:setAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPosition::setAxes ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis})}}
\par
{\bkmkstart AAAAAAACKA}
{\bkmkend AAAAAAACKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When {\b setType} is {\b ptPlotCoords}, this function may be used to specify the axes the coordinates set with {\b setCoords} relate to. By default they are set to the initial xAxis and yAxis of the {\b QCustomPlot}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11913 \{\par
11914   mKeyAxis = keyAxis;\par
11915   mValueAxis = valueAxis;\par
11916 \}\par
}
}
{\xe \v setAxisRect\:QCPItemPosition}
{\xe \v QCPItemPosition\:setAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPosition::setAxisRect ({\b QCPAxisRect} *  {\i axisRect})}}
\par
{\bkmkstart AAAAAAACKB}
{\bkmkend AAAAAAACKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When {\b setType} is {\b ptAxisRectRatio}, this function may be used to specify the axis rect the coordinates set with {\b setCoords} relate to. By default this is set to the main axis rect of the {\b QCustomPlot}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11924 \{\par
11925   mAxisRect = axisRect;\par
11926 \}\par
}
}
{\xe \v setCoords\:QCPItemPosition}
{\xe \v QCPItemPosition\:setCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPosition::setCoords (double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAACKC}
{\bkmkend AAAAAAACKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the coordinates of this {\b QCPItemPosition}. What the coordinates mean, is defined by the type ({\b setType}, {\b setTypeX}, {\b setTypeY}).\par
For example, if the type is {\b ptAbsolute}, {\i key}  and {\i value}  mean the x and y pixel position on the {\b QCustomPlot} surface. In that case the origin (0, 0) is in the top left corner of the {\b QCustomPlot} viewport. If the type is {\b ptPlotCoords}, {\i key}  and {\i value}  mean a point in the plot coordinate system defined by the axes set by {\b setAxes}. By default those are the {\b QCustomPlot}'s xAxis and yAxis. See the documentation of {\b setType} for other available coordinate types and their meaning.\par
If different types were configured for X and Y ({\b setTypeX}, {\b setTypeY}), {\i key}  and {\i value}  must also be provided in the different coordinate systems. Here, the X type refers to {\i key} , and the Y type refers to {\i value} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPixelPosition} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11791 \{\par
11792   mKey = key;\par
11793   mValue = value;\par
11794 \}\par
}
}
{\xe \v setCoords\:QCPItemPosition}
{\xe \v QCPItemPosition\:setCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPosition::setCoords (const QPointF &  {\i pos})}}
\par
{\bkmkstart AAAAAAACKD}
{\bkmkend AAAAAAACKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the coordinates as a QPointF {\i pos}  where pos.x has the meaning of {\i key}  and pos.y the meaning of {\i value}  of the {\b setCoords(double key, double value)} method. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11802 \{\par
11803   setCoords(pos.x(), pos.y());\par
11804 \}\par
}
}
{\xe \v setParentAnchor\:QCPItemPosition}
{\xe \v QCPItemPosition\:setParentAnchor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPItemPosition::setParentAnchor ({\b QCPItemAnchor} *  {\i parentAnchor}, bool  {\i keepPixelPosition} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACKE}
{\bkmkend AAAAAAACKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the parent of this {\b QCPItemPosition} to {\i parentAnchor} . This means the position will now follow any position changes of the anchor. The local coordinate system of positions with a parent anchor always is absolute pixels, with (0, 0) being exactly on top of the parent anchor. (Hence the type shouldn't be set to {\b ptPlotCoords} for positions with parent anchors.)\par
if {\i keepPixelPosition}  is true, the current pixel position of the {\b QCPItemPosition} is preserved during reparenting. If it's set to false, the coordinates are set to (0, 0), i.e. the position will be exactly on top of the parent anchor.\par
To remove this {\b QCPItemPosition} from any parent anchor, set {\i parentAnchor}  to 0.\par
If the {\b QCPItemPosition} previously had no parent and the type is {\b ptPlotCoords}, the type is set to {\b ptAbsolute}, to keep the position in a valid state.\par
This method sets the parent anchor for both X and Y directions. It is also possible to set different parents for X and Y, see {\b setParentAnchorX}, {\b setParentAnchorY}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11637 \{\par
11638   bool successX = setParentAnchorX(parentAnchor, keepPixelPosition);\par
11639   bool successY = setParentAnchorY(parentAnchor, keepPixelPosition);\par
11640   return successX && successY;\par
11641 \}\par
}
}
{\xe \v setParentAnchorX\:QCPItemPosition}
{\xe \v QCPItemPosition\:setParentAnchorX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPItemPosition::setParentAnchorX ({\b QCPItemAnchor} *  {\i parentAnchor}, bool  {\i keepPixelPosition} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACKF}
{\bkmkend AAAAAAACKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method sets the parent anchor of the X coordinate to {\i parentAnchor} .\par
For a detailed description of what a parent anchor is, see the documentation of {\b setParentAnchor}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setParentAnchor}, {\b setParentAnchorY} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11651 \{\par
11652   // make sure self is not assigned as parent:\par
11653   if (parentAnchor == this)\par
11654   \{\par
11655     qDebug() << Q_FUNC_INFO << "can't set self as parent anchor" << reinterpret_cast<quintptr>(parentAnchor);\par
11656     return false;\par
11657   \}\par
11658   // make sure no recursive parent-child-relationships are created:\par
11659   QCPItemAnchor *currentParent = parentAnchor;\par
11660   while (currentParent)\par
11661   \{\par
11662     if (QCPItemPosition *currentParentPos = currentParent->toQCPItemPosition())\par
11663     \{\par
11664       // is a QCPItemPosition, might have further parent, so keep iterating\par
11665       if (currentParentPos == this)\par
11666       \{\par
11667         qDebug() << Q_FUNC_INFO << "can't create recursive parent-child-relationship" << reinterpret_cast<quintptr>(parentAnchor);\par
11668         return false;\par
11669       \}\par
11670       currentParent = currentParentPos->parentAnchorX();\par
11671     \} else\par
11672     \{\par
11673       // is a QCPItemAnchor, can't have further parent. Now make sure the parent items aren't the\par
11674       // same, to prevent a position being child of an anchor which itself depends on the position,\par
11675       // because they're both on the same item:\par
11676       if (currentParent->mParentItem == mParentItem)\par
11677       \{\par
11678         qDebug() << Q_FUNC_INFO << "can't set parent to be an anchor which itself depends on this position" << reinterpret_cast<quintptr>(parentAnchor);\par
11679         return false;\par
11680       \}\par
11681       break;\par
11682     \}\par
11683   \}\par
11684   \par
11685   // if previously no parent set and PosType is still ptPlotCoords, set to ptAbsolute:\par
11686   if (!mParentAnchorX && mPositionTypeX == ptPlotCoords)\par
11687     setTypeX(ptAbsolute);\par
11688   \par
11689   // save pixel position:\par
11690   QPointF pixelP;\par
11691   if (keepPixelPosition)\par
11692     pixelP = pixelPosition();\par
11693   // unregister at current parent anchor:\par
11694   if (mParentAnchorX)\par
11695     mParentAnchorX->removeChildX(this);\par
11696   // register at new parent anchor:\par
11697   if (parentAnchor)\par
11698     parentAnchor->addChildX(this);\par
11699   mParentAnchorX = parentAnchor;\par
11700   // restore pixel position under new parent:\par
11701   if (keepPixelPosition)\par
11702     setPixelPosition(pixelP);\par
11703   else\par
11704     setCoords(0, coords().y());\par
11705   return true;\par
11706 \}\par
}
}
{\xe \v setParentAnchorY\:QCPItemPosition}
{\xe \v QCPItemPosition\:setParentAnchorY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPItemPosition::setParentAnchorY ({\b QCPItemAnchor} *  {\i parentAnchor}, bool  {\i keepPixelPosition} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACKG}
{\bkmkend AAAAAAACKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method sets the parent anchor of the Y coordinate to {\i parentAnchor} .\par
For a detailed description of what a parent anchor is, see the documentation of {\b setParentAnchor}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setParentAnchor}, {\b setParentAnchorX} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11716 \{\par
11717   // make sure self is not assigned as parent:\par
11718   if (parentAnchor == this)\par
11719   \{\par
11720     qDebug() << Q_FUNC_INFO << "can't set self as parent anchor" << reinterpret_cast<quintptr>(parentAnchor);\par
11721     return false;\par
11722   \}\par
11723   // make sure no recursive parent-child-relationships are created:\par
11724   QCPItemAnchor *currentParent = parentAnchor;\par
11725   while (currentParent)\par
11726   \{\par
11727     if (QCPItemPosition *currentParentPos = currentParent->toQCPItemPosition())\par
11728     \{\par
11729       // is a QCPItemPosition, might have further parent, so keep iterating\par
11730       if (currentParentPos == this)\par
11731       \{\par
11732         qDebug() << Q_FUNC_INFO << "can't create recursive parent-child-relationship" << reinterpret_cast<quintptr>(parentAnchor);\par
11733         return false;\par
11734       \}\par
11735       currentParent = currentParentPos->parentAnchorY();\par
11736     \} else\par
11737     \{\par
11738       // is a QCPItemAnchor, can't have further parent. Now make sure the parent items aren't the\par
11739       // same, to prevent a position being child of an anchor which itself depends on the position,\par
11740       // because they're both on the same item:\par
11741       if (currentParent->mParentItem == mParentItem)\par
11742       \{\par
11743         qDebug() << Q_FUNC_INFO << "can't set parent to be an anchor which itself depends on this position" << reinterpret_cast<quintptr>(parentAnchor);\par
11744         return false;\par
11745       \}\par
11746       break;\par
11747     \}\par
11748   \}\par
11749   \par
11750   // if previously no parent set and PosType is still ptPlotCoords, set to ptAbsolute:\par
11751   if (!mParentAnchorY && mPositionTypeY == ptPlotCoords)\par
11752     setTypeY(ptAbsolute);\par
11753   \par
11754   // save pixel position:\par
11755   QPointF pixelP;\par
11756   if (keepPixelPosition)\par
11757     pixelP = pixelPosition();\par
11758   // unregister at current parent anchor:\par
11759   if (mParentAnchorY)\par
11760     mParentAnchorY->removeChildY(this);\par
11761   // register at new parent anchor:\par
11762   if (parentAnchor)\par
11763     parentAnchor->addChildY(this);\par
11764   mParentAnchorY = parentAnchor;\par
11765   // restore pixel position under new parent:\par
11766   if (keepPixelPosition)\par
11767     setPixelPosition(pixelP);\par
11768   else\par
11769     setCoords(coords().x(), 0);\par
11770   return true;\par
11771 \}\par
}
}
{\xe \v setPixelPosition\:QCPItemPosition}
{\xe \v QCPItemPosition\:setPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPosition::setPixelPosition (const QPointF &  {\i pixelPosition})}}
\par
{\bkmkstart AAAAAAACKH}
{\bkmkend AAAAAAACKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the apparent pixel position. This works no matter what type ({\b setType}) this {\b QCPItemPosition} is or what parent-child situation it is in, as coordinates are transformed appropriately, to make the position finally appear at the specified pixel values.\par
Only if the type is {\b ptAbsolute} and no parent anchor is set, this function's effect is identical to that of {\b setCoords}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b pixelPosition}, {\b setCoords} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11939 \{\par
11940   double x = pixelPosition.x();\par
11941   double y = pixelPosition.y();\par
11942   \par
11943   switch (mPositionTypeX)\par
11944   \{\par
11945     case ptAbsolute:\par
11946     \{\par
11947       if (mParentAnchorX)\par
11948         x -= mParentAnchorX->pixelPosition().x();\par
11949       break;\par
11950     \}\par
11951     case ptViewportRatio:\par
11952     \{\par
11953       if (mParentAnchorX)\par
11954         x -= mParentAnchorX->pixelPosition().x();\par
11955       else\par
11956         x -= mParentPlot->viewport().left();\par
11957       x /= (double)mParentPlot->viewport().width();\par
11958       break;\par
11959     \}\par
11960     case ptAxisRectRatio:\par
11961     \{\par
11962       if (mAxisRect)\par
11963       \{\par
11964         if (mParentAnchorX)\par
11965           x -= mParentAnchorX->pixelPosition().x();\par
11966         else\par
11967           x -= mAxisRect.data()->left();\par
11968         x /= (double)mAxisRect.data()->width();\par
11969       \} else\par
11970         qDebug() << Q_FUNC_INFO << "Item position type x is ptAxisRectRatio, but no axis rect was defined";\par
11971       break;\par
11972     \}\par
11973     case ptPlotCoords:\par
11974     \{\par
11975       if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Horizontal)\par
11976         x = mKeyAxis.data()->pixelToCoord(x);\par
11977       else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Horizontal)\par
11978         y = mValueAxis.data()->pixelToCoord(x);\par
11979       else\par
11980         qDebug() << Q_FUNC_INFO << "Item position type x is ptPlotCoords, but no axes were defined";\par
11981       break;\par
11982     \}\par
11983   \}\par
11984   \par
11985   switch (mPositionTypeY)\par
11986   \{\par
11987     case ptAbsolute:\par
11988     \{\par
11989       if (mParentAnchorY)\par
11990         y -= mParentAnchorY->pixelPosition().y();\par
11991       break;\par
11992     \}\par
11993     case ptViewportRatio:\par
11994     \{\par
11995       if (mParentAnchorY)\par
11996         y -= mParentAnchorY->pixelPosition().y();\par
11997       else\par
11998         y -= mParentPlot->viewport().top();\par
11999       y /= (double)mParentPlot->viewport().height();\par
12000       break;\par
12001     \}\par
12002     case ptAxisRectRatio:\par
12003     \{\par
12004       if (mAxisRect)\par
12005       \{\par
12006         if (mParentAnchorY)\par
12007           y -= mParentAnchorY->pixelPosition().y();\par
12008         else\par
12009           y -= mAxisRect.data()->top();\par
12010         y /= (double)mAxisRect.data()->height();\par
12011       \} else\par
12012         qDebug() << Q_FUNC_INFO << "Item position type y is ptAxisRectRatio, but no axis rect was defined";\par
12013       break;\par
12014     \}\par
12015     case ptPlotCoords:\par
12016     \{\par
12017       if (mKeyAxis && mKeyAxis.data()->orientation() == Qt::Vertical)\par
12018         x = mKeyAxis.data()->pixelToCoord(y);\par
12019       else if (mValueAxis && mValueAxis.data()->orientation() == Qt::Vertical)\par
12020         y = mValueAxis.data()->pixelToCoord(y);\par
12021       else\par
12022         qDebug() << Q_FUNC_INFO << "Item position type y is ptPlotCoords, but no axes were defined";\par
12023       break;\par
12024     \}\par
12025   \}\par
12026   \par
12027   setCoords(x, y);\par
12028 \}\par
}
}
{\xe \v setType\:QCPItemPosition}
{\xe \v QCPItemPosition\:setType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPosition::setType ({\b QCPItemPosition::PositionType}  {\i type})}}
\par
{\bkmkstart AAAAAAACKI}
{\bkmkend AAAAAAACKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the type of the position. The type defines how the coordinates passed to {\b setCoords} should be handled and how the {\b QCPItemPosition} should behave in the plot.\par
The possible values for {\i type}  can be separated in two main categories:\par
{
\par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The position is regarded as a point in plot coordinates. This corresponds to {\b ptPlotCoords} and requires two axes that define the plot coordinate system. They can be specified with {\b setAxes}. By default, the {\b QCustomPlot}'s x- and yAxis are used.\par
}
{
\par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The position is fixed on the {\b QCustomPlot} surface, i.e. independent of axis ranges. This corresponds to all other types, i.e. {\b ptAbsolute}, {\b ptViewportRatio} and {\b ptAxisRectRatio}. They differ only in the way the absolute position is described, see the documentation of {\b PositionType} for details. For {\b ptAxisRectRatio}, note that you can specify the axis rect with {\b setAxisRect}. By default this is set to the main axis rect.\par
}
Note that the position type {\b ptPlotCoords} is only available (and sensible) when the position has no parent anchor ({\b setParentAnchor}).\par
If the type is changed, the apparent pixel position on the plot is preserved. This means the coordinates as retrieved with {\b coords()} and set with {\b setCoords} may change in the process.\par
This method sets the type for both X and Y directions. It is also possible to set different types for X and Y, see {\b setTypeX}, {\b setTypeY}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11553 \{\par
11554   setTypeX(type);\par
11555   setTypeY(type);\par
11556 \}\par
}
}
{\xe \v setTypeX\:QCPItemPosition}
{\xe \v QCPItemPosition\:setTypeX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPosition::setTypeX ({\b QCPItemPosition::PositionType}  {\i type})}}
\par
{\bkmkstart AAAAAAACKJ}
{\bkmkend AAAAAAACKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method sets the position type of the X coordinate to {\i type} .\par
For a detailed description of what a position type is, see the documentation of {\b setType}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setType}, {\b setTypeY} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11566 \{\par
11567   if (mPositionTypeX != type)\par
11568   \{\par
11569     // if switching from or to coordinate type that isn't valid (e.g. because axes or axis rect\par
11570     // were deleted), don't try to recover the pixelPosition() because it would output a qDebug warning.\par
11571     bool retainPixelPosition = true;\par
11572     if ((mPositionTypeX == ptPlotCoords || type == ptPlotCoords) && (!mKeyAxis || !mValueAxis))\par
11573       retainPixelPosition = false;\par
11574     if ((mPositionTypeX == ptAxisRectRatio || type == ptAxisRectRatio) && (!mAxisRect))\par
11575       retainPixelPosition = false;\par
11576     \par
11577     QPointF pixel;\par
11578     if (retainPixelPosition)\par
11579       pixel = pixelPosition();\par
11580     \par
11581     mPositionTypeX = type;\par
11582     \par
11583     if (retainPixelPosition)\par
11584       setPixelPosition(pixel);\par
11585   \}\par
11586 \}\par
}
}
{\xe \v setTypeY\:QCPItemPosition}
{\xe \v QCPItemPosition\:setTypeY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemPosition::setTypeY ({\b QCPItemPosition::PositionType}  {\i type})}}
\par
{\bkmkstart AAAAAAACKK}
{\bkmkend AAAAAAACKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method sets the position type of the Y coordinate to {\i type} .\par
For a detailed description of what a position type is, see the documentation of {\b setType}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setType}, {\b setTypeX} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11596 \{\par
11597   if (mPositionTypeY != type)\par
11598   \{\par
11599     // if switching from or to coordinate type that isn't valid (e.g. because axes or axis rect\par
11600     // were deleted), don't try to recover the pixelPosition() because it would output a qDebug warning.\par
11601     bool retainPixelPosition = true;\par
11602     if ((mPositionTypeY == ptPlotCoords || type == ptPlotCoords) && (!mKeyAxis || !mValueAxis))\par
11603       retainPixelPosition = false;\par
11604     if ((mPositionTypeY == ptAxisRectRatio || type == ptAxisRectRatio) && (!mAxisRect))\par
11605       retainPixelPosition = false;\par
11606     \par
11607     QPointF pixel;\par
11608     if (retainPixelPosition)\par
11609       pixel = pixelPosition();\par
11610     \par
11611     mPositionTypeY = type;\par
11612     \par
11613     if (retainPixelPosition)\par
11614       setPixelPosition(pixel);\par
11615   \}\par
11616 \}\par
}
}
{\xe \v toQCPItemPosition\:QCPItemPosition}
{\xe \v QCPItemPosition\:toQCPItemPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b QCPItemPosition}* QCPItemPosition::toQCPItemPosition (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns 0 if this instance is merely a {\b QCPItemAnchor}, and a valid pointer of type QCPItemPosition* if it actually is a {\b QCPItemPosition} (which is a subclass of {\b QCPItemAnchor}).\par
This safe downcast functionality could also be achieved with a dynamic_cast. However, {\b QCustomPlot} avoids dynamic_cast to work with projects that don't have RTTI support enabled (e.g. -fno-rtti flag with gcc compiler). \par
}{
Reimplemented from {\b QCPItemAnchor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3496 \{ return this; \}\par
}
}
{\xe \v type\:QCPItemPosition}
{\xe \v QCPItemPosition\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition::PositionType} * QCPItemPosition::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKL}
{\bkmkend AAAAAAACKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current position type.\par
If different types were set for X and Y ({\b setTypeX}, {\b setTypeY}), this method returns the type of the X coordinate. In that case rather use {\i {\b typeX()}}  and {\i {\b typeY()}} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setType} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3460 \{ return typeX(); \}\par
}
}
{\xe \v typeX\:QCPItemPosition}
{\xe \v QCPItemPosition\:typeX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PositionType} QCPItemPosition::typeX () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKM}
{\bkmkend AAAAAAACKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3461 \{ return mPositionTypeX; \}\par
}
}
{\xe \v typeY\:QCPItemPosition}
{\xe \v QCPItemPosition\:typeY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PositionType} QCPItemPosition::typeY () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKN}
{\bkmkend AAAAAAACKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3462 \{ return mPositionTypeY; \}\par
}
}
{\xe \v value\:QCPItemPosition}
{\xe \v QCPItemPosition\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemPosition::value () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKO}
{\bkmkend AAAAAAACKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3467 \{ return mValue; \}\par
}
}
{\xe \v valueAxis\:QCPItemPosition}
{\xe \v QCPItemPosition\:valueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis}* QCPItemPosition::valueAxis () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKP}
{\bkmkend AAAAAAACKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3470 \{ return mValueAxis.data(); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAxisRect\:QCPItemPosition}
{\xe \v QCPItemPosition\:mAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxisRect}> QCPItemPosition::mAxisRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACKQ}
{\bkmkend AAAAAAACKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mKey\:QCPItemPosition}
{\xe \v QCPItemPosition\:mKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemPosition::mKey{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACKR}
{\bkmkend AAAAAAACKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mKeyAxis\:QCPItemPosition}
{\xe \v QCPItemPosition\:mKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxis}> QCPItemPosition::mKeyAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACKS}
{\bkmkend AAAAAAACKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentAnchorX\:QCPItemPosition}
{\xe \v QCPItemPosition\:mParentAnchorX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* QCPItemPosition::mParentAnchorX{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACKT}
{\bkmkend AAAAAAACKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentAnchorY\:QCPItemPosition}
{\xe \v QCPItemPosition\:mParentAnchorY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor} * QCPItemPosition::mParentAnchorY{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACKU}
{\bkmkend AAAAAAACKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPositionTypeX\:QCPItemPosition}
{\xe \v QCPItemPosition\:mPositionTypeX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PositionType} QCPItemPosition::mPositionTypeX{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACKV}
{\bkmkend AAAAAAACKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPositionTypeY\:QCPItemPosition}
{\xe \v QCPItemPosition\:mPositionTypeY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PositionType} QCPItemPosition::mPositionTypeY{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACKW}
{\bkmkend AAAAAAACKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mValue\:QCPItemPosition}
{\xe \v QCPItemPosition\:mValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemPosition::mValue{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACKX}
{\bkmkend AAAAAAACKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mValueAxis\:QCPItemPosition}
{\xe \v QCPItemPosition\:mValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxis}> QCPItemPosition::mValueAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACKY}
{\bkmkend AAAAAAACKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemRect Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemRect}
{\xe \v QCPItemRect}
{\bkmkstart AAAAAAACKZ}
{\bkmkend AAAAAAACKZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A rectangle. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemRect:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_rect__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemRect:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_rect__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemRect} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemRect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b selectedBrush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b topLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b bottomRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b top}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b topRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b right}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottom}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottomLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b left}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AnchorIndex} \{ {\b aiTop}, 
{\b aiTopRight}, 
{\b aiRight}, 
{\b aiBottom}, 
{\b aiBottomLeft}, 
{\b aiLeft}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b anchorPixelPosition} (int anchorId) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mainPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mainBrush} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mSelectedBrush}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A rectangle. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 It has two positions, {\i topLeft}  and {\i bottomRight} , which define the rectangle. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v AnchorIndex\:QCPItemRect}
{\xe \v QCPItemRect\:AnchorIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPItemRect::AnchorIndex}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLA}
{\bkmkend AAAAAAACLA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v aiTop\:QCPItemRect}
{\xe \v QCPItemRect\:aiTop}
{\qr aiTop{\bkmkstart AAAAAAACLB}
{\bkmkend AAAAAAACLB}
\cell }{\cell }{\row }
{\xe \v aiTopRight\:QCPItemRect}
{\xe \v QCPItemRect\:aiTopRight}
{\qr aiTopRight{\bkmkstart AAAAAAACLC}
{\bkmkend AAAAAAACLC}
\cell }{\cell }{\row }
{\xe \v aiRight\:QCPItemRect}
{\xe \v QCPItemRect\:aiRight}
{\qr aiRight{\bkmkstart AAAAAAACLD}
{\bkmkend AAAAAAACLD}
\cell }{\cell }{\row }
{\xe \v aiBottom\:QCPItemRect}
{\xe \v QCPItemRect\:aiBottom}
{\qr aiBottom{\bkmkstart AAAAAAACLE}
{\bkmkend AAAAAAACLE}
\cell }{\cell }{\row }
{\xe \v aiBottomLeft\:QCPItemRect}
{\xe \v QCPItemRect\:aiBottomLeft}
{\qr aiBottomLeft{\bkmkstart AAAAAAACLF}
{\bkmkend AAAAAAACLF}
\cell }{\cell }{\row }
{\xe \v aiLeft\:QCPItemRect}
{\xe \v QCPItemRect\:aiLeft}
{\qr aiLeft{\bkmkstart AAAAAAACLG}
{\bkmkend AAAAAAACLG}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6262 \{aiTop, aiTopRight, aiRight, aiBottom, aiBottomLeft, aiLeft\};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemRect\:QCPItemRect}
{\xe \v QCPItemRect\:QCPItemRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemRect::QCPItemRect ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACLH}
{\bkmkend AAAAAAACLH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a rectangle item and sets default values.\par
The created item is automatically registered with {\i parentPlot} . This {\b QCustomPlot} instance takes ownership of the item, so do not delete it manually but use {\b QCustomPlot::removeItem()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28570                                                 :\par
28571   QCPAbstractItem(parentPlot),\par
28572   topLeft(createPosition(QLatin1String("topLeft"))),\par
28573   bottomRight(createPosition(QLatin1String("bottomRight"))),\par
28574   top(createAnchor(QLatin1String("top"), aiTop)),\par
28575   topRight(createAnchor(QLatin1String("topRight"), aiTopRight)),\par
28576   right(createAnchor(QLatin1String("right"), aiRight)),\par
28577   bottom(createAnchor(QLatin1String("bottom"), aiBottom)),\par
28578   bottomLeft(createAnchor(QLatin1String("bottomLeft"), aiBottomLeft)),\par
28579   left(createAnchor(QLatin1String("left"), aiLeft))\par
28580 \{\par
28581   topLeft->setCoords(0, 1);\par
28582   bottomRight->setCoords(1, 0);\par
28583   \par
28584   setPen(QPen(Qt::black));\par
28585   setSelectedPen(QPen(Qt::blue,2));\par
28586   setBrush(Qt::NoBrush);\par
28587   setSelectedBrush(Qt::NoBrush);\par
28588 \}\par
}
}
{\xe \v ~QCPItemRect\:QCPItemRect}
{\xe \v QCPItemRect\:~QCPItemRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemRect::~QCPItemRect (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLI}
{\bkmkend AAAAAAACLI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28591 \{\par
28592 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v anchorPixelPosition\:QCPItemRect}
{\xe \v QCPItemRect\:anchorPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPItemRect::anchorPixelPosition (int  {\i anchorId}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28668 \{\par
28669   QRectF rect = QRectF(topLeft->pixelPosition(), bottomRight->pixelPosition());\par
28670   switch (anchorId)\par
28671   \{\par
28672     case aiTop:         return (rect.topLeft()+rect.topRight())*0.5;\par
28673     case aiTopRight:    return rect.topRight();\par
28674     case aiRight:       return (rect.topRight()+rect.bottomRight())*0.5;\par
28675     case aiBottom:      return (rect.bottomLeft()+rect.bottomRight())*0.5;\par
28676     case aiBottomLeft:  return rect.bottomLeft();\par
28677     case aiLeft:        return (rect.topLeft()+rect.bottomLeft())*0.5;\par
28678   \}\par
28679   \par
28680   qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;\par
28681   return QPointF();\par
28682 \}\par
}
}
{\xe \v brush\:QCPItemRect}
{\xe \v QCPItemRect\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemRect::brush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLJ}
{\bkmkend AAAAAAACLJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6240 \{ return mBrush; \}\par
}
}
{\xe \v draw\:QCPItemRect}
{\xe \v QCPItemRect\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemRect::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28650 \{\par
28651   QPointF p1 = topLeft->pixelPosition();\par
28652   QPointF p2 = bottomRight->pixelPosition();\par
28653   if (p1.toPoint() == p2.toPoint())\par
28654     return;\par
28655   QRectF rect = QRectF(p1, p2).normalized();\par
28656   double clipPad = mainPen().widthF();\par
28657   QRectF boundingRect = rect.adjusted(-clipPad, -clipPad, clipPad, clipPad);\par
28658   if (boundingRect.intersects(clipRect())) // only draw if bounding rect of rect item is visible in cliprect\par
28659   \{\par
28660     painter->setPen(mainPen());\par
28661     painter->setBrush(mainBrush());\par
28662     painter->drawRect(rect);\par
28663   \}\par
28664 \}\par
}
}
{\xe \v mainBrush\:QCPItemRect}
{\xe \v QCPItemRect\:mainBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemRect::mainBrush () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLK}
{\bkmkend AAAAAAACLK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28700 \{\par
28701   return mSelected ? mSelectedBrush : mBrush;\par
28702 \}\par
}
}
{\xe \v mainPen\:QCPItemRect}
{\xe \v QCPItemRect\:mainPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemRect::mainPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLL}
{\bkmkend AAAAAAACLL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28690 \{\par
28691   return mSelected ? mSelectedPen : mPen;\par
28692 \}\par
}
}
{\xe \v pen\:QCPItemRect}
{\xe \v QCPItemRect\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemRect::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLM}
{\bkmkend AAAAAAACLM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6238 \{ return mPen; \}\par
}
}
{\xe \v selectedBrush\:QCPItemRect}
{\xe \v QCPItemRect\:selectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemRect::selectedBrush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLN}
{\bkmkend AAAAAAACLN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6241 \{ return mSelectedBrush; \}\par
}
}
{\xe \v selectedPen\:QCPItemRect}
{\xe \v QCPItemRect\:selectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemRect::selectedPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLO}
{\bkmkend AAAAAAACLO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6239 \{ return mSelectedPen; \}\par
}
}
{\xe \v selectTest\:QCPItemRect}
{\xe \v QCPItemRect\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemRect::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28638 \{\par
28639   Q_UNUSED(details)\par
28640   if (onlySelectable && !mSelectable)\par
28641     return -1;\par
28642   \par
28643   QRectF rect = QRectF(topLeft->pixelPosition(), bottomRight->pixelPosition()).normalized();\par
28644   bool filledRect = mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0;\par
28645   return rectDistance(rect, pos, filledRect);\par
28646 \}\par
}
}
{\xe \v setBrush\:QCPItemRect}
{\xe \v QCPItemRect\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemRect::setBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAACLP}
{\bkmkend AAAAAAACLP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used to fill the rectangle. To disable filling, set {\i brush}  to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedBrush}, {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28621 \{\par
28622   mBrush = brush;\par
28623 \}\par
}
}
{\xe \v setPen\:QCPItemRect}
{\xe \v QCPItemRect\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemRect::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACLQ}
{\bkmkend AAAAAAACLQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line of the rectangle\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedPen}, {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28600 \{\par
28601   mPen = pen;\par
28602 \}\par
}
}
{\xe \v setSelectedBrush\:QCPItemRect}
{\xe \v QCPItemRect\:setSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemRect::setSelectedBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAACLR}
{\bkmkend AAAAAAACLR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used to fill the rectangle when selected. To disable filling, set {\i brush}  to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28632 \{\par
28633   mSelectedBrush = brush;\par
28634 \}\par
}
}
{\xe \v setSelectedPen\:QCPItemRect}
{\xe \v QCPItemRect\:setSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemRect::setSelectedPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACLS}
{\bkmkend AAAAAAACLS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line of the rectangle when selected\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28610 \{\par
28611   mSelectedPen = pen;\par
28612 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v bottom\:QCPItemRect}
{\xe \v QCPItemRect\:bottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemRect::bottom}}
\par
{\bkmkstart AAAAAAACLT}
{\bkmkend AAAAAAACLT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bottomLeft\:QCPItemRect}
{\xe \v QCPItemRect\:bottomLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemRect::bottomLeft}}
\par
{\bkmkstart AAAAAAACLU}
{\bkmkend AAAAAAACLU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bottomRight\:QCPItemRect}
{\xe \v QCPItemRect\:bottomRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemRect::bottomRight}}
\par
{\bkmkstart AAAAAAACLV}
{\bkmkend AAAAAAACLV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v left\:QCPItemRect}
{\xe \v QCPItemRect\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemRect::left}}
\par
{\bkmkstart AAAAAAACLW}
{\bkmkend AAAAAAACLW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBrush\:QCPItemRect}
{\xe \v QCPItemRect\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemRect::mBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLX}
{\bkmkend AAAAAAACLX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPItemRect}
{\xe \v QCPItemRect\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemRect::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLY}
{\bkmkend AAAAAAACLY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedBrush\:QCPItemRect}
{\xe \v QCPItemRect\:mSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemRect::mSelectedBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACLZ}
{\bkmkend AAAAAAACLZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedPen\:QCPItemRect}
{\xe \v QCPItemRect\:mSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemRect::mSelectedPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMA}
{\bkmkend AAAAAAACMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v right\:QCPItemRect}
{\xe \v QCPItemRect\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemRect::right}}
\par
{\bkmkstart AAAAAAACMB}
{\bkmkend AAAAAAACMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v top\:QCPItemRect}
{\xe \v QCPItemRect\:top}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemRect::top}}
\par
{\bkmkstart AAAAAAACMC}
{\bkmkend AAAAAAACMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v topLeft\:QCPItemRect}
{\xe \v QCPItemRect\:topLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemRect::topLeft}}
\par
{\bkmkstart AAAAAAACMD}
{\bkmkend AAAAAAACMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v topRight\:QCPItemRect}
{\xe \v QCPItemRect\:topRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemRect::topRight}}
\par
{\bkmkstart AAAAAAACME}
{\bkmkend AAAAAAACME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemStraightLine Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemStraightLine}
{\xe \v QCPItemStraightLine}
{\bkmkstart AAAAAAACMF}
{\bkmkend AAAAAAACMF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A straight line that spans infinitely in both directions. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemStraightLine:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_straight_line__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemStraightLine:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_straight_line__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemStraightLine} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemStraightLine} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b point1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b point2}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineF {\b getRectClippedStraightLine} (const {\b QCPVector2D} &{\b point1}, const {\b QCPVector2D} &vec, const QRect &rect) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mainPen} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedPen}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A straight line that spans infinitely in both directions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 It has two positions, {\i point1}  and {\i point2} , which define the straight line. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemStraightLine\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:QCPItemStraightLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemStraightLine::QCPItemStraightLine ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACMG}
{\bkmkend AAAAAAACMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a straight line item and sets default values.\par
The created item is automatically registered with {\i parentPlot} . This {\b QCustomPlot} instance takes ownership of the item, so do not delete it manually but use {\b QCustomPlot::removeItem()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27993                                                                 :\par
27994   QCPAbstractItem(parentPlot),\par
27995   point1(createPosition(QLatin1String("point1"))),\par
27996   point2(createPosition(QLatin1String("point2")))\par
27997 \{\par
27998   point1->setCoords(0, 0);\par
27999   point2->setCoords(1, 1);\par
28000   \par
28001   setPen(QPen(Qt::black));\par
28002   setSelectedPen(QPen(Qt::blue,2));\par
28003 \}\par
}
}
{\xe \v ~QCPItemStraightLine\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:~QCPItemStraightLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemStraightLine::~QCPItemStraightLine (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMH}
{\bkmkend AAAAAAACMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28006 \{\par
28007 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v draw\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemStraightLine::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28041 \{\par
28042   QCPVector2D start(point1->pixelPosition());\par
28043   QCPVector2D end(point2->pixelPosition());\par
28044   // get visible segment of straight line inside clipRect:\par
28045   double clipPad = mainPen().widthF();\par
28046   QLineF line = getRectClippedStraightLine(start, end-start, clipRect().adjusted(-clipPad, -clipPad, clipPad, clipPad));\par
28047   // paint visible segment, if existent:\par
28048   if (!line.isNull())\par
28049   \{\par
28050     painter->setPen(mainPen());\par
28051     painter->drawLine(line);\par
28052   \}\par
28053 \}\par
}
}
{\xe \v getRectClippedStraightLine\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:getRectClippedStraightLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineF QCPItemStraightLine::getRectClippedStraightLine (const {\b QCPVector2D} &  {\i point1}, const {\b QCPVector2D} &  {\i vec}, const QRect &  {\i rect}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMI}
{\bkmkend AAAAAAACMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28063 \{\par
28064   double bx, by;\par
28065   double gamma;\par
28066   QLineF result;\par
28067   if (vec.x() == 0 && vec.y() == 0)\par
28068     return result;\par
28069   if (qFuzzyIsNull(vec.x())) // line is vertical\par
28070   \{\par
28071     // check top of rect:\par
28072     bx = rect.left();\par
28073     by = rect.top();\par
28074     gamma = base.x()-bx + (by-base.y())*vec.x()/vec.y();\par
28075     if (gamma >= 0 && gamma <= rect.width())\par
28076       result.setLine(bx+gamma, rect.top(), bx+gamma, rect.bottom()); // no need to check bottom because we know line is vertical\par
28077   \} else if (qFuzzyIsNull(vec.y())) // line is horizontal\par
28078   \{\par
28079     // check left of rect:\par
28080     bx = rect.left();\par
28081     by = rect.top();\par
28082     gamma = base.y()-by + (bx-base.x())*vec.y()/vec.x();\par
28083     if (gamma >= 0 && gamma <= rect.height())\par
28084       result.setLine(rect.left(), by+gamma, rect.right(), by+gamma); // no need to check right because we know line is horizontal\par
28085   \} else // line is skewed\par
28086   \{\par
28087     QList<QCPVector2D> pointVectors;\par
28088     // check top of rect:\par
28089     bx = rect.left();\par
28090     by = rect.top();\par
28091     gamma = base.x()-bx + (by-base.y())*vec.x()/vec.y();\par
28092     if (gamma >= 0 && gamma <= rect.width())\par
28093       pointVectors.append(QCPVector2D(bx+gamma, by));\par
28094     // check bottom of rect:\par
28095     bx = rect.left();\par
28096     by = rect.bottom();\par
28097     gamma = base.x()-bx + (by-base.y())*vec.x()/vec.y();\par
28098     if (gamma >= 0 && gamma <= rect.width())\par
28099       pointVectors.append(QCPVector2D(bx+gamma, by));\par
28100     // check left of rect:\par
28101     bx = rect.left();\par
28102     by = rect.top();\par
28103     gamma = base.y()-by + (bx-base.x())*vec.y()/vec.x();\par
28104     if (gamma >= 0 && gamma <= rect.height())\par
28105       pointVectors.append(QCPVector2D(bx, by+gamma));\par
28106     // check right of rect:\par
28107     bx = rect.right();\par
28108     by = rect.top();\par
28109     gamma = base.y()-by + (bx-base.x())*vec.y()/vec.x();\par
28110     if (gamma >= 0 && gamma <= rect.height())\par
28111       pointVectors.append(QCPVector2D(bx, by+gamma));\par
28112     \par
28113     // evaluate points:\par
28114     if (pointVectors.size() == 2)\par
28115     \{\par
28116       result.setPoints(pointVectors.at(0).toPointF(), pointVectors.at(1).toPointF());\par
28117     \} else if (pointVectors.size() > 2)\par
28118     \{\par
28119       // line probably goes through corner of rect, and we got two points there. single out the point pair with greatest distance:\par
28120       double distSqrMax = 0;\par
28121       QCPVector2D pv1, pv2;\par
28122       for (int i=0; i<pointVectors.size()-1; ++i)\par
28123       \{\par
28124         for (int k=i+1; k<pointVectors.size(); ++k)\par
28125         \{\par
28126           double distSqr = (pointVectors.at(i)-pointVectors.at(k)).lengthSquared();\par
28127           if (distSqr > distSqrMax)\par
28128           \{\par
28129             pv1 = pointVectors.at(i);\par
28130             pv2 = pointVectors.at(k);\par
28131             distSqrMax = distSqr;\par
28132           \}\par
28133         \}\par
28134       \}\par
28135       result.setPoints(pv1.toPointF(), pv2.toPointF());\par
28136     \}\par
28137   \}\par
28138   return result;\par
28139 \}\par
}
}
{\xe \v mainPen\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:mainPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemStraightLine::mainPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMJ}
{\bkmkend AAAAAAACMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28147 \{\par
28148   return mSelected ? mSelectedPen : mPen;\par
28149 \}\par
}
}
{\xe \v pen\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemStraightLine::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMK}
{\bkmkend AAAAAAACMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6092 \{ return mPen; \}\par
}
}
{\xe \v selectedPen\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:selectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemStraightLine::selectedPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACML}
{\bkmkend AAAAAAACML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6093 \{ return mSelectedPen; \}\par
}
}
{\xe \v selectTest\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemStraightLine::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28031 \{\par
28032   Q_UNUSED(details)\par
28033   if (onlySelectable && !mSelectable)\par
28034     return -1;\par
28035   \par
28036   return QCPVector2D(pos).distanceToStraightLine(point1->pixelPosition(), point2->pixelPosition()-point1->pixelPosition());\par
28037 \}\par
}
}
{\xe \v setPen\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemStraightLine::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACMM}
{\bkmkend AAAAAAACMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28015 \{\par
28016   mPen = pen;\par
28017 \}\par
}
}
{\xe \v setSelectedPen\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:setSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemStraightLine::setSelectedPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACMN}
{\bkmkend AAAAAAACMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line when selected\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28025 \{\par
28026   mSelectedPen = pen;\par
28027 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mPen\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemStraightLine::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMO}
{\bkmkend AAAAAAACMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedPen\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:mSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemStraightLine::mSelectedPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMP}
{\bkmkend AAAAAAACMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v point1\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:point1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemStraightLine::point1}}
\par
{\bkmkstart AAAAAAACMQ}
{\bkmkend AAAAAAACMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v point2\:QCPItemStraightLine}
{\xe \v QCPItemStraightLine\:point2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemStraightLine::point2}}
\par
{\bkmkstart AAAAAAACMR}
{\bkmkend AAAAAAACMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemText Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemText}
{\xe \v QCPItemText}
{\bkmkstart AAAAAAACMS}
{\bkmkend AAAAAAACMS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A text label. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemText:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_text__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemText:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_text__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemText} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemText} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b color} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b selectedColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b selectedBrush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b font} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b selectedFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b text} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Alignment {\b positionAlignment} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Alignment {\b textAlignment} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b rotation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b padding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColor} (const QColor &{\b color})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedColor} (const QColor &{\b color})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFont} (const QFont &{\b font})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedFont} (const QFont &{\b font})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setText} (const QString &{\b text})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPositionAlignment} (Qt::Alignment alignment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTextAlignment} (Qt::Alignment alignment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRotation} (double degrees)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPadding} (const QMargins &{\b padding})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b topLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b top}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b topRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b right}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottomRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottom}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b bottomLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemAnchor} *const {\b left}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AnchorIndex} \{ {\b aiTopLeft}, 
{\b aiTop}, 
{\b aiTopRight}, 
{\b aiRight}, 
{\b aiBottomRight}, 
{\b aiBottom}, 
{\b aiBottomLeft}, 
{\b aiLeft}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b anchorPixelPosition} (int anchorId) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointF {\b getTextDrawPoint} (const QPointF &pos, const QRectF &rect, Qt::Alignment {\b positionAlignment}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mainFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mainColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mainPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mainBrush} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mSelectedColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mSelectedBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mSelectedFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mText}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Alignment {\b mPositionAlignment}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Alignment {\b mTextAlignment}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mRotation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b mPadding}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A text label. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 Its position is defined by the member {\i position}  and the setting of {\b setPositionAlignment}. The latter controls which part of the text rect shall be aligned with {\i position} .\par
The text alignment itself (i.e. left, center, right) can be controlled with {\b setTextAlignment}.\par
The text may be rotated around the {\i position}  point with {\b setRotation}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v AnchorIndex\:QCPItemText}
{\xe \v QCPItemText\:AnchorIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPItemText::AnchorIndex}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACMT}
{\bkmkend AAAAAAACMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v aiTopLeft\:QCPItemText}
{\xe \v QCPItemText\:aiTopLeft}
{\qr aiTopLeft{\bkmkstart AAAAAAACMU}
{\bkmkend AAAAAAACMU}
\cell }{\cell }{\row }
{\xe \v aiTop\:QCPItemText}
{\xe \v QCPItemText\:aiTop}
{\qr aiTop{\bkmkstart AAAAAAACMV}
{\bkmkend AAAAAAACMV}
\cell }{\cell }{\row }
{\xe \v aiTopRight\:QCPItemText}
{\xe \v QCPItemText\:aiTopRight}
{\qr aiTopRight{\bkmkstart AAAAAAACMW}
{\bkmkend AAAAAAACMW}
\cell }{\cell }{\row }
{\xe \v aiRight\:QCPItemText}
{\xe \v QCPItemText\:aiRight}
{\qr aiRight{\bkmkstart AAAAAAACMX}
{\bkmkend AAAAAAACMX}
\cell }{\cell }{\row }
{\xe \v aiBottomRight\:QCPItemText}
{\xe \v QCPItemText\:aiBottomRight}
{\qr aiBottomRight{\bkmkstart AAAAAAACMY}
{\bkmkend AAAAAAACMY}
\cell }{\cell }{\row }
{\xe \v aiBottom\:QCPItemText}
{\xe \v QCPItemText\:aiBottom}
{\qr aiBottom{\bkmkstart AAAAAAACMZ}
{\bkmkend AAAAAAACMZ}
\cell }{\cell }{\row }
{\xe \v aiBottomLeft\:QCPItemText}
{\xe \v QCPItemText\:aiBottomLeft}
{\qr aiBottomLeft{\bkmkstart AAAAAAACNA}
{\bkmkend AAAAAAACNA}
\cell }{\cell }{\row }
{\xe \v aiLeft\:QCPItemText}
{\xe \v QCPItemText\:aiLeft}
{\qr aiLeft{\bkmkstart AAAAAAACNB}
{\bkmkend AAAAAAACNB}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6349 \{aiTopLeft, aiTop, aiTopRight, aiRight, aiBottomRight, aiBottom, aiBottomLeft, aiLeft\};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemText\:QCPItemText}
{\xe \v QCPItemText\:QCPItemText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemText::QCPItemText ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACNC}
{\bkmkend AAAAAAACNC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a text item and sets default values.\par
The created item is automatically registered with {\i parentPlot} . This {\b QCustomPlot} instance takes ownership of the item, so do not delete it manually but use {\b QCustomPlot::removeItem()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28733                                                 :\par
28734   QCPAbstractItem(parentPlot),\par
28735   position(createPosition(QLatin1String("position"))),\par
28736   topLeft(createAnchor(QLatin1String("topLeft"), aiTopLeft)),\par
28737   top(createAnchor(QLatin1String("top"), aiTop)),\par
28738   topRight(createAnchor(QLatin1String("topRight"), aiTopRight)),\par
28739   right(createAnchor(QLatin1String("right"), aiRight)),\par
28740   bottomRight(createAnchor(QLatin1String("bottomRight"), aiBottomRight)),\par
28741   bottom(createAnchor(QLatin1String("bottom"), aiBottom)),\par
28742   bottomLeft(createAnchor(QLatin1String("bottomLeft"), aiBottomLeft)),\par
28743   left(createAnchor(QLatin1String("left"), aiLeft)),\par
28744   mText(QLatin1String("text")),\par
28745   mPositionAlignment(Qt::AlignCenter),\par
28746   mTextAlignment(Qt::AlignTop|Qt::AlignHCenter),\par
28747   mRotation(0)\par
28748 \{\par
28749   position->setCoords(0, 0);\par
28750   \par
28751   setPen(Qt::NoPen);\par
28752   setSelectedPen(Qt::NoPen);\par
28753   setBrush(Qt::NoBrush);\par
28754   setSelectedBrush(Qt::NoBrush);\par
28755   setColor(Qt::black);\par
28756   setSelectedColor(Qt::blue);\par
28757 \}\par
}
}
{\xe \v ~QCPItemText\:QCPItemText}
{\xe \v QCPItemText\:~QCPItemText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemText::~QCPItemText (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACND}
{\bkmkend AAAAAAACND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28760 \{\par
28761 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v anchorPixelPosition\:QCPItemText}
{\xe \v QCPItemText\:anchorPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPItemText::anchorPixelPosition (int  {\i anchorId}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28955 \{\par
28956   // get actual rect points (pretty much copied from draw function):\par
28957   QPointF pos(position->pixelPosition());\par
28958   QTransform transform;\par
28959   transform.translate(pos.x(), pos.y());\par
28960   if (!qFuzzyIsNull(mRotation))\par
28961     transform.rotate(mRotation);\par
28962   QFontMetrics fontMetrics(mainFont());\par
28963   QRect textRect = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip|mTextAlignment, mText);\par
28964   QRectF textBoxRect = textRect.adjusted(-mPadding.left(), -mPadding.top(), mPadding.right(), mPadding.bottom());\par
28965   QPointF textPos = getTextDrawPoint(QPointF(0, 0), textBoxRect, mPositionAlignment); // 0, 0 because the transform does the translation\par
28966   textBoxRect.moveTopLeft(textPos.toPoint());\par
28967   QPolygonF rectPoly = transform.map(QPolygonF(textBoxRect));\par
28968   \par
28969   switch (anchorId)\par
28970   \{\par
28971     case aiTopLeft:     return rectPoly.at(0);\par
28972     case aiTop:         return (rectPoly.at(0)+rectPoly.at(1))*0.5;\par
28973     case aiTopRight:    return rectPoly.at(1);\par
28974     case aiRight:       return (rectPoly.at(1)+rectPoly.at(2))*0.5;\par
28975     case aiBottomRight: return rectPoly.at(2);\par
28976     case aiBottom:      return (rectPoly.at(2)+rectPoly.at(3))*0.5;\par
28977     case aiBottomLeft:  return rectPoly.at(3);\par
28978     case aiLeft:        return (rectPoly.at(3)+rectPoly.at(0))*0.5;\par
28979   \}\par
28980   \par
28981   qDebug() << Q_FUNC_INFO << "invalid anchorId" << anchorId;\par
28982   return QPointF();\par
28983 \}\par
}
}
{\xe \v brush\:QCPItemText}
{\xe \v QCPItemText\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemText::brush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNE}
{\bkmkend AAAAAAACNE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6310 \{ return mBrush; \}\par
}
}
{\xe \v color\:QCPItemText}
{\xe \v QCPItemText\:color}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPItemText::color () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNF}
{\bkmkend AAAAAAACNF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6306 \{ return mColor; \}\par
}
}
{\xe \v draw\:QCPItemText}
{\xe \v QCPItemText\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28923 \{\par
28924   QPointF pos(position->pixelPosition());\par
28925   QTransform transform = painter->transform();\par
28926   transform.translate(pos.x(), pos.y());\par
28927   if (!qFuzzyIsNull(mRotation))\par
28928     transform.rotate(mRotation);\par
28929   painter->setFont(mainFont());\par
28930   QRect textRect = painter->fontMetrics().boundingRect(0, 0, 0, 0, Qt::TextDontClip|mTextAlignment, mText);\par
28931   QRect textBoxRect = textRect.adjusted(-mPadding.left(), -mPadding.top(), mPadding.right(), mPadding.bottom());\par
28932   QPointF textPos = getTextDrawPoint(QPointF(0, 0), textBoxRect, mPositionAlignment); // 0, 0 because the transform does the translation\par
28933   textRect.moveTopLeft(textPos.toPoint()+QPoint(mPadding.left(), mPadding.top()));\par
28934   textBoxRect.moveTopLeft(textPos.toPoint());\par
28935   double clipPad = mainPen().widthF();\par
28936   QRect boundingRect = textBoxRect.adjusted(-clipPad, -clipPad, clipPad, clipPad);\par
28937   if (transform.mapRect(boundingRect).intersects(painter->transform().mapRect(clipRect())))\par
28938   \{\par
28939     painter->setTransform(transform);\par
28940     if ((mainBrush().style() != Qt::NoBrush && mainBrush().color().alpha() != 0) ||\par
28941         (mainPen().style() != Qt::NoPen && mainPen().color().alpha() != 0))\par
28942     \{\par
28943       painter->setPen(mainPen());\par
28944       painter->setBrush(mainBrush());\par
28945       painter->drawRect(textBoxRect);\par
28946     \}\par
28947     painter->setBrush(Qt::NoBrush);\par
28948     painter->setPen(QPen(mainColor()));\par
28949     painter->drawText(textRect, Qt::TextDontClip|mTextAlignment, mText);\par
28950   \}\par
28951 \}\par
}
}
{\xe \v font\:QCPItemText}
{\xe \v QCPItemText\:font}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPItemText::font () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNG}
{\bkmkend AAAAAAACNG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6312 \{ return mFont; \}\par
}
}
{\xe \v getTextDrawPoint\:QCPItemText}
{\xe \v QCPItemText\:getTextDrawPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPItemText::getTextDrawPoint (const QPointF &  {\i pos}, const QRectF &  {\i rect}, Qt::Alignment  {\i positionAlignment}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNH}
{\bkmkend AAAAAAACNH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28996 \{\par
28997   if (positionAlignment == 0 || positionAlignment == (Qt::AlignLeft|Qt::AlignTop))\par
28998     return pos;\par
28999   \par
29000   QPointF result = pos; // start at top left\par
29001   if (positionAlignment.testFlag(Qt::AlignHCenter))\par
29002     result.rx() -= rect.width()/2.0;\par
29003   else if (positionAlignment.testFlag(Qt::AlignRight))\par
29004     result.rx() -= rect.width();\par
29005   if (positionAlignment.testFlag(Qt::AlignVCenter))\par
29006     result.ry() -= rect.height()/2.0;\par
29007   else if (positionAlignment.testFlag(Qt::AlignBottom))\par
29008     result.ry() -= rect.height();\par
29009   return result;\par
29010 \}\par
}
}
{\xe \v mainBrush\:QCPItemText}
{\xe \v QCPItemText\:mainBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemText::mainBrush () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNI}
{\bkmkend AAAAAAACNI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29048 \{\par
29049   return mSelected ? mSelectedBrush : mBrush;\par
29050 \}\par
}
}
{\xe \v mainColor\:QCPItemText}
{\xe \v QCPItemText\:mainColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPItemText::mainColor () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNJ}
{\bkmkend AAAAAAACNJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29028 \{\par
29029   return mSelected ? mSelectedColor : mColor;\par
29030 \}\par
}
}
{\xe \v mainFont\:QCPItemText}
{\xe \v QCPItemText\:mainFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPItemText::mainFont () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNK}
{\bkmkend AAAAAAACNK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29018 \{\par
29019   return mSelected ? mSelectedFont : mFont;\par
29020 \}\par
}
}
{\xe \v mainPen\:QCPItemText}
{\xe \v QCPItemText\:mainPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemText::mainPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNL}
{\bkmkend AAAAAAACNL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29038 \{\par
29039   return mSelected ? mSelectedPen : mPen;\par
29040 \}\par
}
}
{\xe \v padding\:QCPItemText}
{\xe \v QCPItemText\:padding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPItemText::padding () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNM}
{\bkmkend AAAAAAACNM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6318 \{ return mPadding; \}\par
}
}
{\xe \v pen\:QCPItemText}
{\xe \v QCPItemText\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemText::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNN}
{\bkmkend AAAAAAACNN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6308 \{ return mPen; \}\par
}
}
{\xe \v positionAlignment\:QCPItemText}
{\xe \v QCPItemText\:positionAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Alignment QCPItemText::positionAlignment () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNO}
{\bkmkend AAAAAAACNO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6315 \{ return mPositionAlignment; \}\par
}
}
{\xe \v rotation\:QCPItemText}
{\xe \v QCPItemText\:rotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemText::rotation () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNP}
{\bkmkend AAAAAAACNP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6317 \{ return mRotation; \}\par
}
}
{\xe \v selectedBrush\:QCPItemText}
{\xe \v QCPItemText\:selectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemText::selectedBrush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNQ}
{\bkmkend AAAAAAACNQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6311 \{ return mSelectedBrush; \}\par
}
}
{\xe \v selectedColor\:QCPItemText}
{\xe \v QCPItemText\:selectedColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPItemText::selectedColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNR}
{\bkmkend AAAAAAACNR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6307 \{ return mSelectedColor; \}\par
}
}
{\xe \v selectedFont\:QCPItemText}
{\xe \v QCPItemText\:selectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPItemText::selectedFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNS}
{\bkmkend AAAAAAACNS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6313 \{ return mSelectedFont; \}\par
}
}
{\xe \v selectedPen\:QCPItemText}
{\xe \v QCPItemText\:selectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemText::selectedPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNT}
{\bkmkend AAAAAAACNT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6309 \{ return mSelectedPen; \}\par
}
}
{\xe \v selectTest\:QCPItemText}
{\xe \v QCPItemText\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemText::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28899 \{\par
28900   Q_UNUSED(details)\par
28901   if (onlySelectable && !mSelectable)\par
28902     return -1;\par
28903   \par
28904   // The rect may be rotated, so we transform the actual clicked pos to the rotated\par
28905   // coordinate system, so we can use the normal rectDistance function for non-rotated rects:\par
28906   QPointF positionPixels(position->pixelPosition());\par
28907   QTransform inputTransform;\par
28908   inputTransform.translate(positionPixels.x(), positionPixels.y());\par
28909   inputTransform.rotate(-mRotation);\par
28910   inputTransform.translate(-positionPixels.x(), -positionPixels.y());\par
28911   QPointF rotatedPos = inputTransform.map(pos);\par
28912   QFontMetrics fontMetrics(mFont);\par
28913   QRect textRect = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip|mTextAlignment, mText);\par
28914   QRect textBoxRect = textRect.adjusted(-mPadding.left(), -mPadding.top(), mPadding.right(), mPadding.bottom());\par
28915   QPointF textPos = getTextDrawPoint(positionPixels, textBoxRect, mPositionAlignment);\par
28916   textBoxRect.moveTopLeft(textPos.toPoint());\par
28917 \par
28918   return rectDistance(textBoxRect, rotatedPos, true);\par
28919 \}\par
}
}
{\xe \v setBrush\:QCPItemText}
{\xe \v QCPItemText\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAACNU}
{\bkmkend AAAAAAACNU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used do fill the background of the text. To disable the background, set {\i brush}  to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedBrush}, {\b setPen}, {\b setPadding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28808 \{\par
28809   mBrush = brush;\par
28810 \}\par
}
}
{\xe \v setColor\:QCPItemText}
{\xe \v QCPItemText\:setColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAACNV}
{\bkmkend AAAAAAACNV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color of the text. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28767 \{\par
28768   mColor = color;\par
28769 \}\par
}
}
{\xe \v setFont\:QCPItemText}
{\xe \v QCPItemText\:setFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAACNW}
{\bkmkend AAAAAAACNW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font of the text.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedFont}, {\b setColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28829 \{\par
28830   mFont = font;\par
28831 \}\par
}
}
{\xe \v setPadding\:QCPItemText}
{\xe \v QCPItemText\:setPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setPadding (const QMargins &  {\i padding})}}
\par
{\bkmkstart AAAAAAACNX}
{\bkmkend AAAAAAACNX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the distance between the border of the text rectangle and the text. The appearance (and visibility) of the text rectangle can be controlled with {\b setPen} and {\b setBrush}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28893 \{\par
28894   mPadding = padding;\par
28895 \}\par
}
}
{\xe \v setPen\:QCPItemText}
{\xe \v QCPItemText\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACNY}
{\bkmkend AAAAAAACNY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used do draw a rectangular border around the text. To disable the border, set {\i pen}  to Qt::NoPen.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedPen}, {\b setBrush}, {\b setPadding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28786 \{\par
28787   mPen = pen;\par
28788 \}\par
}
}
{\xe \v setPositionAlignment\:QCPItemText}
{\xe \v QCPItemText\:setPositionAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setPositionAlignment (Qt::Alignment  {\i alignment})}}
\par
{\bkmkstart AAAAAAACNZ}
{\bkmkend AAAAAAACNZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which point of the text rect shall be aligned with {\i position} .\par
Examples: {
\par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If {\i alignment}  is {\f2 Qt::AlignHCenter | Qt::AlignTop} , the text will be positioned such that the top of the text rect will be horizontally centered on {\i position} . \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
If {\i alignment}  is {\f2 Qt::AlignLeft | Qt::AlignBottom} , {\i position}  will indicate the bottom left corner of the text rect.\par
}
If you want to control the alignment of (multi-lined) text within the text rect, use {\b setTextAlignment}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28867 \{\par
28868   mPositionAlignment = alignment;\par
28869 \}\par
}
}
{\xe \v setRotation\:QCPItemText}
{\xe \v QCPItemText\:setRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setRotation (double  {\i degrees})}}
\par
{\bkmkstart AAAAAAACOA}
{\bkmkend AAAAAAACOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the angle in degrees by which the text (and the text rectangle, if visible) will be rotated around {\i position} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28884 \{\par
28885   mRotation = degrees;\par
28886 \}\par
}
}
{\xe \v setSelectedBrush\:QCPItemText}
{\xe \v QCPItemText\:setSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setSelectedBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAACOB}
{\bkmkend AAAAAAACOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used do fill the background of the text, when the item is selected. To disable the background, set {\i brush}  to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28819 \{\par
28820   mSelectedBrush = brush;\par
28821 \}\par
}
}
{\xe \v setSelectedColor\:QCPItemText}
{\xe \v QCPItemText\:setSelectedColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setSelectedColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAACOC}
{\bkmkend AAAAAAACOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color of the text that will be used when the item is selected. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28775 \{\par
28776   mSelectedColor = color;\par
28777 \}\par
}
}
{\xe \v setSelectedFont\:QCPItemText}
{\xe \v QCPItemText\:setSelectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setSelectedFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAACOD}
{\bkmkend AAAAAAACOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font of the text that will be used when the item is selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28839 \{\par
28840   mSelectedFont = font;\par
28841 \}\par
}
}
{\xe \v setSelectedPen\:QCPItemText}
{\xe \v QCPItemText\:setSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setSelectedPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACOE}
{\bkmkend AAAAAAACOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used do draw a rectangular border around the text, when the item is selected. To disable the border, set {\i pen}  to Qt::NoPen.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28797 \{\par
28798   mSelectedPen = pen;\par
28799 \}\par
}
}
{\xe \v setText\:QCPItemText}
{\xe \v QCPItemText\:setText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setText (const QString &  {\i text})}}
\par
{\bkmkstart AAAAAAACOF}
{\bkmkend AAAAAAACOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the text that will be displayed. Multi-line texts are supported by inserting a line break character, e.g. '\par
'.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFont}, {\b setColor}, {\b setTextAlignment} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28850 \{\par
28851   mText = text;\par
28852 \}\par
}
}
{\xe \v setTextAlignment\:QCPItemText}
{\xe \v QCPItemText\:setTextAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemText::setTextAlignment (Qt::Alignment  {\i alignment})}}
\par
{\bkmkstart AAAAAAACOG}
{\bkmkend AAAAAAACOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls how (multi-lined) text is aligned inside the text rect (typically Qt::AlignLeft, Qt::AlignCenter or Qt::AlignRight). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28875 \{\par
28876   mTextAlignment = alignment;\par
28877 \}\par
}
}
{\xe \v text\:QCPItemText}
{\xe \v QCPItemText\:text}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPItemText::text () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOH}
{\bkmkend AAAAAAACOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6314 \{ return mText; \}\par
}
}
{\xe \v textAlignment\:QCPItemText}
{\xe \v QCPItemText\:textAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Alignment QCPItemText::textAlignment () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACOI}
{\bkmkend AAAAAAACOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6316 \{ return mTextAlignment; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v bottom\:QCPItemText}
{\xe \v QCPItemText\:bottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemText::bottom}}
\par
{\bkmkstart AAAAAAACOJ}
{\bkmkend AAAAAAACOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bottomLeft\:QCPItemText}
{\xe \v QCPItemText\:bottomLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemText::bottomLeft}}
\par
{\bkmkstart AAAAAAACOK}
{\bkmkend AAAAAAACOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bottomRight\:QCPItemText}
{\xe \v QCPItemText\:bottomRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemText::bottomRight}}
\par
{\bkmkstart AAAAAAACOL}
{\bkmkend AAAAAAACOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v left\:QCPItemText}
{\xe \v QCPItemText\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemText::left}}
\par
{\bkmkstart AAAAAAACOM}
{\bkmkend AAAAAAACOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBrush\:QCPItemText}
{\xe \v QCPItemText\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemText::mBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACON}
{\bkmkend AAAAAAACON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mColor\:QCPItemText}
{\xe \v QCPItemText\:mColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPItemText::mColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOO}
{\bkmkend AAAAAAACOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mFont\:QCPItemText}
{\xe \v QCPItemText\:mFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPItemText::mFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOP}
{\bkmkend AAAAAAACOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPadding\:QCPItemText}
{\xe \v QCPItemText\:mPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPItemText::mPadding{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOQ}
{\bkmkend AAAAAAACOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPItemText}
{\xe \v QCPItemText\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemText::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOR}
{\bkmkend AAAAAAACOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPositionAlignment\:QCPItemText}
{\xe \v QCPItemText\:mPositionAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Alignment QCPItemText::mPositionAlignment{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOS}
{\bkmkend AAAAAAACOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRotation\:QCPItemText}
{\xe \v QCPItemText\:mRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemText::mRotation{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOT}
{\bkmkend AAAAAAACOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedBrush\:QCPItemText}
{\xe \v QCPItemText\:mSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemText::mSelectedBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOU}
{\bkmkend AAAAAAACOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedColor\:QCPItemText}
{\xe \v QCPItemText\:mSelectedColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPItemText::mSelectedColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOV}
{\bkmkend AAAAAAACOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedFont\:QCPItemText}
{\xe \v QCPItemText\:mSelectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPItemText::mSelectedFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOW}
{\bkmkend AAAAAAACOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedPen\:QCPItemText}
{\xe \v QCPItemText\:mSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemText::mSelectedPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOX}
{\bkmkend AAAAAAACOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mText\:QCPItemText}
{\xe \v QCPItemText\:mText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPItemText::mText{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOY}
{\bkmkend AAAAAAACOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTextAlignment\:QCPItemText}
{\xe \v QCPItemText\:mTextAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Alignment QCPItemText::mTextAlignment{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACOZ}
{\bkmkend AAAAAAACOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v position\:QCPItemText}
{\xe \v QCPItemText\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemText::position}}
\par
{\bkmkstart AAAAAAACPA}
{\bkmkend AAAAAAACPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v right\:QCPItemText}
{\xe \v QCPItemText\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemText::right}}
\par
{\bkmkstart AAAAAAACPB}
{\bkmkend AAAAAAACPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v top\:QCPItemText}
{\xe \v QCPItemText\:top}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemText::top}}
\par
{\bkmkstart AAAAAAACPC}
{\bkmkend AAAAAAACPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v topLeft\:QCPItemText}
{\xe \v QCPItemText\:topLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemText::topLeft}}
\par
{\bkmkstart AAAAAAACPD}
{\bkmkend AAAAAAACPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v topRight\:QCPItemText}
{\xe \v QCPItemText\:topRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemAnchor}* const QCPItemText::topRight}}
\par
{\bkmkstart AAAAAAACPE}
{\bkmkend AAAAAAACPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPItemTracer Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPItemTracer}
{\xe \v QCPItemTracer}
{\bkmkstart AAAAAAACPF}
{\bkmkend AAAAAAACPF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Item that sticks to {\b QCPGraph} data points. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPItemTracer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_tracer__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPItemTracer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_item_tracer__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b TracerStyle} \{ {\b tsNone}, 
{\b tsPlus}, 
{\b tsCrosshair}, 
{\b tsCircle}, 
{\b tsSquare}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemTracer} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPItemTracer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b selectedBrush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TracerStyle} {\b style} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b graph} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b graphKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b interpolating} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSize} (double {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setStyle} ({\b TracerStyle} {\b style})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGraph} ({\b QCPGraph} *{\b graph})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setGraphKey} (double key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInterpolating} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updatePosition} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPItemPosition} *const {\b position}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mainPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mainBrush} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mSelectedBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TracerStyle} {\b mStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b mGraph}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mGraphKey}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mInterpolating}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Item that sticks to {\b QCPGraph} data points. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 The tracer can be connected with a {\b QCPGraph} via {\b setGraph}. Then it will automatically adopt the coordinate axes of the graph and update its {\i position}  to be on the graph's data. This means the key stays controllable via {\b setGraphKey}, but the value will follow the graph data. If a {\b QCPGraph} is connected, note that setting the coordinates of the tracer item directly via {\i position}  will have no effect because they will be overriden in the next redraw (this is when the coordinate update happens).\par
If the specified key in {\b setGraphKey} is outside the key bounds of the graph, the tracer will stay at the corresponding end of the graph.\par
With {\b setInterpolating} you may specify whether the tracer may only stay exactly on data points or whether it interpolates data points linearly, if given a key that lies between two data points of the graph.\par
The tracer has different visual styles, see {\b setStyle}. It is also possible to make the tracer have no own visual appearance (set the style to {\b tsNone}), and just connect other item positions to the tracer {\i position}  (used as an anchor) via {\b QCPItemPosition::setParentAnchor}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The tracer position is only automatically updated upon redraws. So when the data of the graph changes and immediately afterwards (without a redraw) the position coordinates of the tracer are retrieved, they will not reflect the updated data of the graph. In this case {\b updatePosition} must be called manually, prior to reading the tracer coordinates. \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v TracerStyle\:QCPItemTracer}
{\xe \v QCPItemTracer\:TracerStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPItemTracer::TracerStyle}}}
\par
{\bkmkstart AAAAAAACPG}
{\bkmkend AAAAAAACPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The different visual appearances a tracer item can have. Some styles size may be controlled with {\b setSize}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setStyle} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v tsNone\:QCPItemTracer}
{\xe \v QCPItemTracer\:tsNone}
{\qr tsNone{\bkmkstart AAAAAAACPH}
{\bkmkend AAAAAAACPH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The tracer is not visible. \par
}\cell }{\row }
{\xe \v tsPlus\:QCPItemTracer}
{\xe \v QCPItemTracer\:tsPlus}
{\qr tsPlus{\bkmkstart AAAAAAACPI}
{\bkmkend AAAAAAACPI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plus shaped crosshair with limited size. \par
}\cell }{\row }
{\xe \v tsCrosshair\:QCPItemTracer}
{\xe \v QCPItemTracer\:tsCrosshair}
{\qr tsCrosshair{\bkmkstart AAAAAAACPJ}
{\bkmkend AAAAAAACPJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plus shaped crosshair which spans the complete axis rect. \par
}\cell }{\row }
{\xe \v tsCircle\:QCPItemTracer}
{\xe \v QCPItemTracer\:tsCircle}
{\qr tsCircle{\bkmkstart AAAAAAACPK}
{\bkmkend AAAAAAACPK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A circle. \par
}\cell }{\row }
{\xe \v tsSquare\:QCPItemTracer}
{\xe \v QCPItemTracer\:tsSquare}
{\qr tsSquare{\bkmkstart AAAAAAACPL}
{\bkmkend AAAAAAACPL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A square. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6531                    \{ tsNone        \par
 6532                      ,tsPlus       \par
 6533                      ,tsCrosshair  \par
 6534                      ,tsCircle     \par
 6535                      ,tsSquare     \par
 6536                    \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPItemTracer\:QCPItemTracer}
{\xe \v QCPItemTracer\:QCPItemTracer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemTracer::QCPItemTracer ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACPM}
{\bkmkend AAAAAAACPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a tracer item and sets default values.\par
The created item is automatically registered with {\i parentPlot} . This {\b QCustomPlot} instance takes ownership of the item, so do not delete it manually but use {\b QCustomPlot::removeItem()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29555                                                     :\par
29556   QCPAbstractItem(parentPlot),\par
29557   position(createPosition(QLatin1String("position"))),\par
29558   mSize(6),\par
29559   mStyle(tsCrosshair),\par
29560   mGraph(0),\par
29561   mGraphKey(0),\par
29562   mInterpolating(false)\par
29563 \{\par
29564   position->setCoords(0, 0);\par
29565 \par
29566   setBrush(Qt::NoBrush);\par
29567   setSelectedBrush(Qt::NoBrush);\par
29568   setPen(QPen(Qt::black));\par
29569   setSelectedPen(QPen(Qt::blue, 2));\par
29570 \}\par
}
}
{\xe \v ~QCPItemTracer\:QCPItemTracer}
{\xe \v QCPItemTracer\:~QCPItemTracer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPItemTracer::~QCPItemTracer (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACPN}
{\bkmkend AAAAAAACPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29573 \{\par
29574 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v brush\:QCPItemTracer}
{\xe \v QCPItemTracer\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemTracer::brush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPO}
{\bkmkend AAAAAAACPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6545 \{ return mBrush; \}\par
}
}
{\xe \v draw\:QCPItemTracer}
{\xe \v QCPItemTracer\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29753 \{\par
29754   updatePosition();\par
29755   if (mStyle == tsNone)\par
29756     return;\par
29757 \par
29758   painter->setPen(mainPen());\par
29759   painter->setBrush(mainBrush());\par
29760   QPointF center(position->pixelPosition());\par
29761   double w = mSize/2.0;\par
29762   QRect clip = clipRect();\par
29763   switch (mStyle)\par
29764   \{\par
29765     case tsNone: return;\par
29766     case tsPlus:\par
29767     \{\par
29768       if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))\par
29769       \{\par
29770         painter->drawLine(QLineF(center+QPointF(-w, 0), center+QPointF(w, 0)));\par
29771         painter->drawLine(QLineF(center+QPointF(0, -w), center+QPointF(0, w)));\par
29772       \}\par
29773       break;\par
29774     \}\par
29775     case tsCrosshair:\par
29776     \{\par
29777       if (center.y() > clip.top() && center.y() < clip.bottom())\par
29778         painter->drawLine(QLineF(clip.left(), center.y(), clip.right(), center.y()));\par
29779       if (center.x() > clip.left() && center.x() < clip.right())\par
29780         painter->drawLine(QLineF(center.x(), clip.top(), center.x(), clip.bottom()));\par
29781       break;\par
29782     \}\par
29783     case tsCircle:\par
29784     \{\par
29785       if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))\par
29786         painter->drawEllipse(center, w, w);\par
29787       break;\par
29788     \}\par
29789     case tsSquare:\par
29790     \{\par
29791       if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))\par
29792         painter->drawRect(QRectF(center-QPointF(w, w), center+QPointF(w, w)));\par
29793       break;\par
29794     \}\par
29795   \}\par
29796 \}\par
}
}
{\xe \v graph\:QCPItemTracer}
{\xe \v QCPItemTracer\:graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph}* QCPItemTracer::graph () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPP}
{\bkmkend AAAAAAACPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6549 \{ return mGraph; \}\par
}
}
{\xe \v graphKey\:QCPItemTracer}
{\xe \v QCPItemTracer\:graphKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemTracer::graphKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPQ}
{\bkmkend AAAAAAACPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6550 \{ return mGraphKey; \}\par
}
}
{\xe \v interpolating\:QCPItemTracer}
{\xe \v QCPItemTracer\:interpolating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPItemTracer::interpolating () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPR}
{\bkmkend AAAAAAACPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6551 \{ return mInterpolating; \}\par
}
}
{\xe \v mainBrush\:QCPItemTracer}
{\xe \v QCPItemTracer\:mainBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemTracer::mainBrush () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACPS}
{\bkmkend AAAAAAACPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29876 \{\par
29877   return mSelected ? mSelectedBrush : mBrush;\par
29878 \}\par
}
}
{\xe \v mainPen\:QCPItemTracer}
{\xe \v QCPItemTracer\:mainPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemTracer::mainPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACPT}
{\bkmkend AAAAAAACPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29866 \{\par
29867   return mSelected ? mSelectedPen : mPen;\par
29868 \}\par
}
}
{\xe \v pen\:QCPItemTracer}
{\xe \v QCPItemTracer\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemTracer::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPU}
{\bkmkend AAAAAAACPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6543 \{ return mPen; \}\par
}
}
{\xe \v selectedBrush\:QCPItemTracer}
{\xe \v QCPItemTracer\:selectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemTracer::selectedBrush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPV}
{\bkmkend AAAAAAACPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6546 \{ return mSelectedBrush; \}\par
}
}
{\xe \v selectedPen\:QCPItemTracer}
{\xe \v QCPItemTracer\:selectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemTracer::selectedPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACPW}
{\bkmkend AAAAAAACPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6544 \{ return mSelectedPen; \}\par
}
}
{\xe \v selectTest\:QCPItemTracer}
{\xe \v QCPItemTracer\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemTracer::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Implements {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29696 \{\par
29697   Q_UNUSED(details)\par
29698   if (onlySelectable && !mSelectable)\par
29699     return -1;\par
29700 \par
29701   QPointF center(position->pixelPosition());\par
29702   double w = mSize/2.0;\par
29703   QRect clip = clipRect();\par
29704   switch (mStyle)\par
29705   \{\par
29706     case tsNone: return -1;\par
29707     case tsPlus:\par
29708     \{\par
29709       if (clipRect().intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))\par
29710         return qSqrt(qMin(QCPVector2D(pos).distanceSquaredToLine(center+QPointF(-w, 0), center+QPointF(w, 0)),\par
29711                           QCPVector2D(pos).distanceSquaredToLine(center+QPointF(0, -w), center+QPointF(0, w))));\par
29712       break;\par
29713     \}\par
29714     case tsCrosshair:\par
29715     \{\par
29716       return qSqrt(qMin(QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(clip.left(), center.y()), QCPVector2D(clip.right(), center.y())),\par
29717                         QCPVector2D(pos).distanceSquaredToLine(QCPVector2D(center.x(), clip.top()), QCPVector2D(center.x(), clip.bottom()))));\par
29718     \}\par
29719     case tsCircle:\par
29720     \{\par
29721       if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))\par
29722       \{\par
29723         // distance to border:\par
29724         double centerDist = QCPVector2D(center-pos).length();\par
29725         double circleLine = w;\par
29726         double result = qAbs(centerDist-circleLine);\par
29727         // filled ellipse, allow click inside to count as hit:\par
29728         if (result > mParentPlot->selectionTolerance()*0.99 && mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0)\par
29729         \{\par
29730           if (centerDist <= circleLine)\par
29731             result = mParentPlot->selectionTolerance()*0.99;\par
29732         \}\par
29733         return result;\par
29734       \}\par
29735       break;\par
29736     \}\par
29737     case tsSquare:\par
29738     \{\par
29739       if (clip.intersects(QRectF(center-QPointF(w, w), center+QPointF(w, w)).toRect()))\par
29740       \{\par
29741         QRectF rect = QRectF(center-QPointF(w, w), center+QPointF(w, w));\par
29742         bool filledRect = mBrush.style() != Qt::NoBrush && mBrush.color().alpha() != 0;\par
29743         return rectDistance(rect, pos, filledRect);\par
29744       \}\par
29745       break;\par
29746     \}\par
29747   \}\par
29748   return -1;\par
29749 \}\par
}
}
{\xe \v setBrush\:QCPItemTracer}
{\xe \v QCPItemTracer\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::setBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAACPX}
{\bkmkend AAAAAAACPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used to draw any fills of the tracer\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedBrush}, {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29602 \{\par
29603   mBrush = brush;\par
29604 \}\par
}
}
{\xe \v setGraph\:QCPItemTracer}
{\xe \v QCPItemTracer\:setGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::setGraph ({\b QCPGraph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAACPY}
{\bkmkend AAAAAAACPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\b QCPGraph} this tracer sticks to. The tracer {\i position}  will be set to type {\b QCPItemPosition::ptPlotCoords} and the axes will be set to the axes of {\i graph} .\par
To free the tracer from any graph, set {\i graph}  to 0. The tracer {\i position}  can then be placed freely like any other item position. This is the state the tracer will assume when its graph gets deleted while still attached to it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setGraphKey} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29647 \{\par
29648   if (graph)\par
29649   \{\par
29650     if (graph->parentPlot() == mParentPlot)\par
29651     \{\par
29652       position->setType(QCPItemPosition::ptPlotCoords);\par
29653       position->setAxes(graph->keyAxis(), graph->valueAxis());\par
29654       mGraph = graph;\par
29655       updatePosition();\par
29656     \} else\par
29657       qDebug() << Q_FUNC_INFO << "graph isn't in same QCustomPlot instance as this item";\par
29658   \} else\par
29659   \{\par
29660     mGraph = 0;\par
29661   \}\par
29662 \}\par
}
}
{\xe \v setGraphKey\:QCPItemTracer}
{\xe \v QCPItemTracer\:setGraphKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::setGraphKey (double  {\i key})}}
\par
{\bkmkstart AAAAAAACPZ}
{\bkmkend AAAAAAACPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the key of the graph's data point the tracer will be positioned at. This is the only free coordinate of a tracer when attached to a graph.\par
Depending on {\b setInterpolating}, the tracer will be either positioned on the data point closest to {\i key} , or will stay exactly at {\i key}  and interpolate the value linearly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setGraph}, {\b setInterpolating} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29674 \{\par
29675   mGraphKey = key;\par
29676 \}\par
}
}
{\xe \v setInterpolating\:QCPItemTracer}
{\xe \v QCPItemTracer\:setInterpolating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::setInterpolating (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAACQA}
{\bkmkend AAAAAAACQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the value of the graph's data points shall be interpolated, when positioning the tracer.\par
If {\i enabled}  is set to false and a key is given with {\b setGraphKey}, the tracer is placed on the data point of the graph which is closest to the key, but which is not necessarily exactly there. If {\i enabled}  is true, the tracer will be positioned exactly at the specified key, and the appropriate value will be interpolated from the graph's data points linearly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setGraph}, {\b setGraphKey} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29690 \{\par
29691   mInterpolating = enabled;\par
29692 \}\par
}
}
{\xe \v setPen\:QCPItemTracer}
{\xe \v QCPItemTracer\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACQB}
{\bkmkend AAAAAAACQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line of the tracer\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedPen}, {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29582 \{\par
29583   mPen = pen;\par
29584 \}\par
}
}
{\xe \v setSelectedBrush\:QCPItemTracer}
{\xe \v QCPItemTracer\:setSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::setSelectedBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAACQC}
{\bkmkend AAAAAAACQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used to draw any fills of the tracer, when selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29612 \{\par
29613   mSelectedBrush = brush;\par
29614 \}\par
}
}
{\xe \v setSelectedPen\:QCPItemTracer}
{\xe \v QCPItemTracer\:setSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::setSelectedPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAACQD}
{\bkmkend AAAAAAACQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the line of the tracer when selected\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen}, {\b setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29592 \{\par
29593   mSelectedPen = pen;\par
29594 \}\par
}
}
{\xe \v setSize\:QCPItemTracer}
{\xe \v QCPItemTracer\:setSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::setSize (double  {\i size})}}
\par
{\bkmkstart AAAAAAACQE}
{\bkmkend AAAAAAACQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the size of the tracer in pixels, if the style supports setting a size (e.g. {\b tsSquare} does, {\b tsCrosshair} does not). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29621 \{\par
29622   mSize = size;\par
29623 \}\par
}
}
{\xe \v setStyle\:QCPItemTracer}
{\xe \v QCPItemTracer\:setStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::setStyle ({\b QCPItemTracer::TracerStyle}  {\i style})}}
\par
{\bkmkstart AAAAAAACQF}
{\bkmkend AAAAAAACQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the style/visual appearance of the tracer.\par
If you only want to use the tracer {\i position}  as an anchor for other items, set {\i style}  to {\b tsNone}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29632 \{\par
29633   mStyle = style;\par
29634 \}\par
}
}
{\xe \v size\:QCPItemTracer}
{\xe \v QCPItemTracer\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemTracer::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQG}
{\bkmkend AAAAAAACQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6547 \{ return mSize; \}\par
}
}
{\xe \v style\:QCPItemTracer}
{\xe \v QCPItemTracer\:style}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TracerStyle} QCPItemTracer::style () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACQH}
{\bkmkend AAAAAAACQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6548 \{ return mStyle; \}\par
}
}
{\xe \v updatePosition\:QCPItemTracer}
{\xe \v QCPItemTracer\:updatePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPItemTracer::updatePosition ()}}
\par
{\bkmkstart AAAAAAACQI}
{\bkmkend AAAAAAACQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the tracer is connected with a graph ({\b setGraph}), this function updates the tracer's {\i position}  to reside on the graph data, depending on the configured key ({\b setGraphKey}).\par
It is called automatically on every redraw and normally doesn't need to be called manually. One exception is when you want to read the tracer coordinates via {\i position}  and are not sure that the graph's data (or the tracer key with {\b setGraphKey}) hasn't changed since the last redraw. In that situation, call this function before accessing {\i position} , to make sure you don't get out-of-date coordinates.\par
If there is no graph set on this tracer, this function does nothing. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29811 \{\par
29812   if (mGraph)\par
29813   \{\par
29814     if (mParentPlot->hasPlottable(mGraph))\par
29815     \{\par
29816       if (mGraph->data()->size() > 1)\par
29817       \{\par
29818         QCPGraphDataContainer::const_iterator first = mGraph->data()->constBegin();\par
29819         QCPGraphDataContainer::const_iterator last = mGraph->data()->constEnd()-1;\par
29820         if (mGraphKey <= first->key)\par
29821           position->setCoords(first->key, first->value);\par
29822         else if (mGraphKey >= last->key)\par
29823           position->setCoords(last->key, last->value);\par
29824         else\par
29825         \{\par
29826           QCPGraphDataContainer::const_iterator it = mGraph->data()->findBegin(mGraphKey);\par
29827           if (it != mGraph->data()->constEnd()) // mGraphKey is not exactly on last iterator, but somewhere between iterators\par
29828           \{\par
29829             QCPGraphDataContainer::const_iterator prevIt = it;\par
29830             ++it; // won't advance to constEnd because we handled that case (mGraphKey >= last->key) before\par
29831             if (mInterpolating)\par
29832             \{\par
29833               // interpolate between iterators around mGraphKey:\par
29834               double slope = 0;\par
29835               if (!qFuzzyCompare((double)it->key, (double)prevIt->key))\par
29836                 slope = (it->value-prevIt->value)/(it->key-prevIt->key);\par
29837               position->setCoords(mGraphKey, (mGraphKey-prevIt->key)*slope+prevIt->value);\par
29838             \} else\par
29839             \{\par
29840               // find iterator with key closest to mGraphKey:\par
29841               if (mGraphKey < (prevIt->key+it->key)*0.5)\par
29842                 position->setCoords(prevIt->key, prevIt->value);\par
29843               else\par
29844                 position->setCoords(it->key, it->value);\par
29845             \}\par
29846           \} else // mGraphKey is exactly on last iterator (should actually be caught when comparing first/last keys, but this is a failsafe for fp uncertainty)\par
29847             position->setCoords(it->key, it->value);\par
29848         \}\par
29849       \} else if (mGraph->data()->size() == 1)\par
29850       \{\par
29851         QCPGraphDataContainer::const_iterator it = mGraph->data()->constBegin();\par
29852         position->setCoords(it->key, it->value);\par
29853       \} else\par
29854         qDebug() << Q_FUNC_INFO << "graph has no data";\par
29855     \} else\par
29856       qDebug() << Q_FUNC_INFO << "graph not contained in QCustomPlot instance (anymore)";\par
29857   \}\par
29858 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBrush\:QCPItemTracer}
{\xe \v QCPItemTracer\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemTracer::mBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQJ}
{\bkmkend AAAAAAACQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mGraph\:QCPItemTracer}
{\xe \v QCPItemTracer\:mGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph}* QCPItemTracer::mGraph{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQK}
{\bkmkend AAAAAAACQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mGraphKey\:QCPItemTracer}
{\xe \v QCPItemTracer\:mGraphKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemTracer::mGraphKey{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQL}
{\bkmkend AAAAAAACQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInterpolating\:QCPItemTracer}
{\xe \v QCPItemTracer\:mInterpolating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPItemTracer::mInterpolating{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQM}
{\bkmkend AAAAAAACQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPItemTracer}
{\xe \v QCPItemTracer\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemTracer::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQN}
{\bkmkend AAAAAAACQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedBrush\:QCPItemTracer}
{\xe \v QCPItemTracer\:mSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPItemTracer::mSelectedBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQO}
{\bkmkend AAAAAAACQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedPen\:QCPItemTracer}
{\xe \v QCPItemTracer\:mSelectedPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPItemTracer::mSelectedPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQP}
{\bkmkend AAAAAAACQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSize\:QCPItemTracer}
{\xe \v QCPItemTracer\:mSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPItemTracer::mSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQQ}
{\bkmkend AAAAAAACQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mStyle\:QCPItemTracer}
{\xe \v QCPItemTracer\:mStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TracerStyle} QCPItemTracer::mStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACQR}
{\bkmkend AAAAAAACQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v position\:QCPItemTracer}
{\xe \v QCPItemTracer\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPItemPosition}* const QCPItemTracer::position}}
\par
{\bkmkstart AAAAAAACQS}
{\bkmkend AAAAAAACQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPLayer Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPLayer}
{\xe \v QCPLayer}
{\bkmkstart AAAAAAACQT}
{\bkmkend AAAAAAACQT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layer that may contain objects, to control the rendering order. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPLayer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layer__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPLayer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layer__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LayerMode} \{ {\b lmLogical}, 
{\b lmBuffered}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} ({\b QCustomPlot} *{\b parentPlot}, const QString &layerName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPLayer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b parentPlot} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b name} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b index} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLayerable} * > {\b children} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b visible} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LayerMode} {\b mode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVisible} (bool {\b visible})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMode} ({\b LayerMode} {\b mode})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b replot} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b draw} ({\b QCPPainter} *painter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawToPaintBuffer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addChild} ({\b QCPLayerable} *layerable, bool prepend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeChild} ({\b QCPLayerable} *layerable)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mIndex}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLayerable} * > {\b mChildren}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mVisible}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LayerMode} {\b mMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QWeakPointer< {\b QCPAbstractPaintBuffer} > {\b mPaintBuffer}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayerable}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layer that may contain objects, to control the rendering order. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Layering system of {\b QCustomPlot} is the mechanism to control the rendering order of the elements inside the plot.\par
It is based on the two classes {\b QCPLayer} and {\b QCPLayerable}. {\b QCustomPlot} holds an ordered list of one or more instances of {\b QCPLayer} (see {\b QCustomPlot::addLayer}, {\b QCustomPlot::layer}, {\b QCustomPlot::moveLayer}, etc.). When replotting, {\b QCustomPlot} goes through the list of layers bottom to top and successively draws the layerables of the layers into the paint buffer(s).\par
A {\b QCPLayer} contains an ordered list of {\b QCPLayerable} instances. {\b QCPLayerable} is an abstract base class from which almost all visible objects derive, like axes, grids, graphs, items, etc.\par
{\bkmkstart AAAAAAACQU}
{\bkmkend AAAAAAACQU}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Default layers
\par}
{\tc\tcl2 \v Default layers}
Initially, {\b QCustomPlot} has six layers: "background", "grid", "main", "axes", "legend" and "overlay" (in that order). On top is the "overlay" layer, which only contains the {\b QCustomPlot}'s selection rect ({\b QCustomPlot::selectionRect}). The next two layers "axes" and "legend" contain the default axes and legend, so they will be drawn above plottables. In the middle, there is the "main" layer. It is initially empty and set as the current layer (see {\b QCustomPlot::setCurrentLayer}). This means, all new plottables, items etc. are created on this layer by default. Then comes the "grid" layer which contains the {\b QCPGrid} instances (which belong tightly to {\b QCPAxis}, see {\b QCPAxis::grid}). The Axis rect background shall be drawn behind everything else, thus the default {\b QCPAxisRect} instance is placed on the "background" layer. Of course, the layer affiliation of the individual objects can be changed as required ({\b QCPLayerable::setLayer}).\par}
{\bkmkstart AAAAAAACQV}
{\bkmkend AAAAAAACQV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Controlling the rendering order via layers
\par}
{\tc\tcl2 \v Controlling the rendering order via layers}
Controlling the ordering of layerables in the plot is easy: Create a new layer in the position you want the layerable to be in, e.g. above "main", with {\b QCustomPlot::addLayer}. Then set the current layer with {\b QCustomPlot::setCurrentLayer} to that new layer and finally create the objects normally. They will be placed on the new layer automatically, due to the current layer setting. Alternatively you could have also ignored the current layer setting and just moved the objects with {\b QCPLayerable::setLayer} to the desired layer after creating them.\par
It is also possible to move whole layers. For example, If you want the grid to be shown in front of all plottables/items on the "main" layer, just move it above "main" with {\b QCustomPlot::moveLayer}.\par
The rendering order within one layer is simply by order of creation or insertion. The item created last (or added last to the layer), is drawn on top of all other objects on that layer.\par
When a layer is deleted, the objects on it are not deleted with it, but fall on the layer below the deleted layer, see {\b QCustomPlot::removeLayer}.\par}
{\bkmkstart AAAAAAACQW}
{\bkmkend AAAAAAACQW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Replotting only a specific layer
\par}
{\tc\tcl2 \v Replotting only a specific layer}
If the layer mode ({\b setMode}) is set to {\b lmBuffered}, you can replot only this specific layer by calling {\b replot}. In certain situations this can provide better replot performance, compared with a full replot of all layers. Upon creation of a new layer, the layer mode is initialized to {\b lmLogical}. The only layer that is set to {\b lmBuffered} in a new {\b QCustomPlot} instance is the "overlay" layer, containing the selection rect. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v LayerMode\:QCPLayer}
{\xe \v QCPLayer\:LayerMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPLayer::LayerMode}}}
\par
{\bkmkstart AAAAAAACQX}
{\bkmkend AAAAAAACQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the different rendering modes of a layer. Depending on the mode, certain layers can be replotted individually, without the need to replot (possibly complex) layerables on other layers.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setMode} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v lmLogical\:QCPLayer}
{\xe \v QCPLayer\:lmLogical}
{\qr lmLogical{\bkmkstart AAAAAAACQY}
{\bkmkend AAAAAAACQY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layer is used only for rendering order, and shares paint buffer with all other adjacent logical layers. \par
}\cell }{\row }
{\xe \v lmBuffered\:QCPLayer}
{\xe \v QCPLayer\:lmBuffered}
{\qr lmBuffered{\bkmkstart AAAAAAACQZ}
{\bkmkend AAAAAAACQZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layer has its own paint buffer and may be replotted individually (see {\b replot}). \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   643                  \{ lmLogical   \par
  644                    ,lmBuffered \par
  645                  \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPLayer\:QCPLayer}
{\xe \v QCPLayer\:QCPLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayer::QCPLayer ({\b QCustomPlot} *  {\i parentPlot}, const QString &  {\i layerName})}}
\par
{\bkmkstart AAAAAAACRA}
{\bkmkend AAAAAAACRA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPLayer} instance.\par
Normally you shouldn't directly instantiate layers, use {\b QCustomPlot::addLayer} instead.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid It is not checked that {\i layerName}  is actually a unique layer name in {\i parentPlot} . This check is only performed by {\b QCustomPlot::addLayer}. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1042                                                                     :\par
 1043   QObject(parentPlot),\par
 1044   mParentPlot(parentPlot),\par
 1045   mName(layerName),\par
 1046   mIndex(-1), // will be set to a proper value by the QCustomPlot layer creation function\par
 1047   mVisible(true),\par
 1048   mMode(lmLogical)\par
 1049 \{\par
 1050   // Note: no need to make sure layerName is unique, because layer\par
 1051   // management is done with QCustomPlot functions.\par
 1052 \}\par
}
}
{\xe \v ~QCPLayer\:QCPLayer}
{\xe \v QCPLayer\:~QCPLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayer::~QCPLayer (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACRB}
{\bkmkend AAAAAAACRB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1055 \{\par
 1056   // If child layerables are still on this layer, detach them, so they don't try to reach back to this\par
 1057   // then invalid layer once they get deleted/moved themselves. This only happens when layers are deleted\par
 1058   // directly, like in the QCustomPlot destructor. (The regular layer removal procedure for the user is to\par
 1059   // call QCustomPlot::removeLayer, which moves all layerables off this layer before deleting it.)\par
 1060   \par
 1061   while (!mChildren.isEmpty())\par
 1062     mChildren.last()->setLayer(0); // removes itself from mChildren via removeChild()\par
 1063   \par
 1064   if (mParentPlot->currentLayer() == this)\par
 1065     qDebug() << Q_FUNC_INFO << "The parent plot's mCurrentLayer will be a dangling pointer. Should have been set to a valid layer or 0 beforehand.";\par
 1066 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addChild\:QCPLayer}
{\xe \v QCPLayer\:addChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayer::addChild ({\b QCPLayerable} *  {\i layerable}, bool  {\i prepend}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRC}
{\bkmkend AAAAAAACRC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1199 \{\par
 1200   if (!mChildren.contains(layerable))\par
 1201   \{\par
 1202     if (prepend)\par
 1203       mChildren.prepend(layerable);\par
 1204     else\par
 1205       mChildren.append(layerable);\par
 1206     if (!mPaintBuffer.isNull())\par
 1207       mPaintBuffer.data()->setInvalidated();\par
 1208   \} else\par
 1209     qDebug() << Q_FUNC_INFO << "layerable is already child of this layer" << reinterpret_cast<quintptr>(layerable);\par
 1210 \}\par
}
}
{\xe \v children\:QCPLayer}
{\xe \v QCPLayer\:children}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLayerable} * > QCPLayer::children () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRD}
{\bkmkend AAAAAAACRD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all layerables on this layer. The order corresponds to the rendering order: layerables with higher indices are drawn above layerables with lower indices. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   655 \{ return mChildren; \}\par
}
}
{\xe \v draw\:QCPLayer}
{\xe \v QCPLayer\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayer::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRE}
{\bkmkend AAAAAAACRE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1119 \{\par
 1120   foreach (QCPLayerable *child, mChildren)\par
 1121   \{\par
 1122     if (child->realVisibility())\par
 1123     \{\par
 1124       painter->save();\par
 1125       painter->setClipRect(child->clipRect().translated(0, -1));\par
 1126       child->applyDefaultAntialiasingHint(painter);\par
 1127       child->draw(painter);\par
 1128       painter->restore();\par
 1129     \}\par
 1130   \}\par
 1131 \}\par
}
}
{\xe \v drawToPaintBuffer\:QCPLayer}
{\xe \v QCPLayer\:drawToPaintBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayer::drawToPaintBuffer (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRF}
{\bkmkend AAAAAAACRF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1142 \{\par
 1143   if (!mPaintBuffer.isNull())\par
 1144   \{\par
 1145     if (QCPPainter *painter = mPaintBuffer.data()->startPainting())\par
 1146     \{\par
 1147       if (painter->isActive())\par
 1148         draw(painter);\par
 1149       else\par
 1150         qDebug() << Q_FUNC_INFO << "paint buffer returned inactive painter";\par
 1151       delete painter;\par
 1152       mPaintBuffer.data()->donePainting();\par
 1153     \} else\par
 1154       qDebug() << Q_FUNC_INFO << "paint buffer returned zero painter";\par
 1155   \} else\par
 1156     qDebug() << Q_FUNC_INFO << "no valid paint buffer associated with this layer";\par
 1157 \}\par
}
}
{\xe \v index\:QCPLayer}
{\xe \v QCPLayer\:index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayer::index () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRG}
{\bkmkend AAAAAAACRG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index this layer has in the {\b QCustomPlot}. The index is the integer number by which this layer can be accessed via {\b QCustomPlot::layer}.\par
Layers with higher indices will be drawn above layers with lower indices. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   654 \{ return mIndex; \}\par
}
}
{\xe \v mode\:QCPLayer}
{\xe \v QCPLayer\:mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LayerMode} QCPLayer::mode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRH}
{\bkmkend AAAAAAACRH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   657 \{ return mMode; \}\par
}
}
{\xe \v name\:QCPLayer}
{\xe \v QCPLayer\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPLayer::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRI}
{\bkmkend AAAAAAACRI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   653 \{ return mName; \}\par
}
}
{\xe \v parentPlot\:QCPLayer}
{\xe \v QCPLayer\:parentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayer::parentPlot () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRJ}
{\bkmkend AAAAAAACRJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   652 \{ return mParentPlot; \}\par
}
}
{\xe \v removeChild\:QCPLayer}
{\xe \v QCPLayer\:removeChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayer::removeChild ({\b QCPLayerable} *  {\i layerable}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRK}
{\bkmkend AAAAAAACRK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1222 \{\par
 1223   if (mChildren.removeOne(layerable))\par
 1224   \{\par
 1225     if (!mPaintBuffer.isNull())\par
 1226       mPaintBuffer.data()->setInvalidated();\par
 1227   \} else\par
 1228     qDebug() << Q_FUNC_INFO << "layerable is not child of this layer" << reinterpret_cast<quintptr>(layerable);\par
 1229 \}\par
}
}
{\xe \v replot\:QCPLayer}
{\xe \v QCPLayer\:replot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayer::replot ()}}
\par
{\bkmkstart AAAAAAACRL}
{\bkmkend AAAAAAACRL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the layer mode ({\b setMode}) is set to {\b lmBuffered}, this method allows replotting only the layerables on this specific layer, without the need to replot all other layers (as a call to {\b QCustomPlot::replot} would do).\par
If the layer mode is {\b lmLogical} however, this method simply calls {\b QCustomPlot::replot} on the parent {\b QCustomPlot} instance.\par
{\b QCustomPlot} also makes sure to replot all layers instead of only this one, if the layer ordering has changed since the last full replot and the other paint buffers were thus invalidated.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b draw} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1173 \{\par
 1174   if (mMode == lmBuffered && !mParentPlot->hasInvalidatedPaintBuffers())\par
 1175   \{\par
 1176     if (!mPaintBuffer.isNull())\par
 1177     \{\par
 1178       mPaintBuffer.data()->clear(Qt::transparent);\par
 1179       drawToPaintBuffer();\par
 1180       mPaintBuffer.data()->setInvalidated(false);\par
 1181       mParentPlot->update();\par
 1182     \} else\par
 1183       qDebug() << Q_FUNC_INFO << "no valid paint buffer associated with this layer";\par
 1184   \} else if (mMode == lmLogical)\par
 1185     mParentPlot->replot();\par
 1186 \}\par
}
}
{\xe \v setMode\:QCPLayer}
{\xe \v QCPLayer\:setMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayer::setMode ({\b QCPLayer::LayerMode}  {\i mode})}}
\par
{\bkmkstart AAAAAAACRM}
{\bkmkend AAAAAAACRM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the rendering mode of this layer.\par
If {\i mode}  is set to {\b lmBuffered} for a layer, it will be given a dedicated paint buffer by the parent {\b QCustomPlot} instance. This means it may be replotted individually by calling {\b QCPLayer::replot}, without needing to replot all other layers.\par
Layers which are set to {\b lmLogical} (the default) are used only to define the rendering order and can't be replotted individually.\par
Note that each layer which is set to {\b lmBuffered} requires additional paint buffers for the layers below, above and for the layer itself. This increases the memory consumption and (slightly) decreases the repainting speed because multiple paint buffers need to be joined. So you should carefully choose which layers benefit from having their own paint buffer. A typical example would be a layer which contains certain layerables (e.g. items) that need to be changed and thus replotted regularly, while all other layerables on other layers stay static. By default, only the topmost layer called "overlay" is in mode {\b lmBuffered}, and contains the selection rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b replot} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1103 \{\par
 1104   if (mMode != mode)\par
 1105   \{\par
 1106     mMode = mode;\par
 1107     if (!mPaintBuffer.isNull())\par
 1108       mPaintBuffer.data()->setInvalidated();\par
 1109   \}\par
 1110 \}\par
}
}
{\xe \v setVisible\:QCPLayer}
{\xe \v QCPLayer\:setVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayer::setVisible (bool  {\i visible})}}
\par
{\bkmkstart AAAAAAACRN}
{\bkmkend AAAAAAACRN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this layer is visible or not. If {\i visible}  is set to false, all layerables on this layer will be invisible.\par
This function doesn't change the visibility property of the layerables ({\b QCPLayerable::setVisible}), but the {\b QCPLayerable::realVisibility} of each layerable takes the visibility of the parent layer into account. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1077 \{\par
 1078   mVisible = visible;\par
 1079 \}\par
}
}
{\xe \v visible\:QCPLayer}
{\xe \v QCPLayer\:visible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayer::visible () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACRO}
{\bkmkend AAAAAAACRO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   656 \{ return mVisible; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLayerable\:QCPLayer}
{\xe \v QCPLayer\:QCPLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLayerable}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACRP}
{\bkmkend AAAAAAACRP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPLayer}
{\xe \v QCPLayer\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACRQ}
{\bkmkend AAAAAAACRQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mChildren\:QCPLayer}
{\xe \v QCPLayer\:mChildren}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPLayerable}*> QCPLayer::mChildren{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRR}
{\bkmkend AAAAAAACRR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mIndex\:QCPLayer}
{\xe \v QCPLayer\:mIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayer::mIndex{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRS}
{\bkmkend AAAAAAACRS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMode\:QCPLayer}
{\xe \v QCPLayer\:mMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LayerMode} QCPLayer::mMode{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRT}
{\bkmkend AAAAAAACRT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mName\:QCPLayer}
{\xe \v QCPLayer\:mName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPLayer::mName{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRU}
{\bkmkend AAAAAAACRU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPaintBuffer\:QCPLayer}
{\xe \v QCPLayer\:mPaintBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QWeakPointer<{\b QCPAbstractPaintBuffer}> QCPLayer::mPaintBuffer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRV}
{\bkmkend AAAAAAACRV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPLayer}
{\xe \v QCPLayer\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayer::mParentPlot{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRW}
{\bkmkend AAAAAAACRW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mVisible\:QCPLayer}
{\xe \v QCPLayer\:mVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayer::mVisible{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACRX}
{\bkmkend AAAAAAACRX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPLayerable Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPLayerable}
{\xe \v QCPLayerable}
{\bkmkstart AAAAAAACRY}
{\bkmkend AAAAAAACRY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all drawable objects. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPLayerable:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layerable__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPLayerable:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layerable__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b layerChanged} ({\b QCPLayer} *newLayer)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayerable} ({\b QCustomPlot} *plot, QString targetLayer=QString(), {\b QCPLayerable} *{\b parentLayerable}=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPLayerable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b visible} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b parentPlot} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayerable} * {\b parentLayerable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b layer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiased} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVisible} (bool on)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT bool {\b setLayer} ({\b QCPLayer} *{\b layer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setLayer} (const QString &layerName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiased} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b realVisibility} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parentPlotInitialized} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QRect {\b clipRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseDoubleClickEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initializeParentPlot} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setParentLayerable} ({\b QCPLayerable} *{\b parentLayerable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveToLayer} ({\b QCPLayer} *{\b layer}, bool prepend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyAntialiasingHint} ({\b QCPPainter} *painter, bool localAntialiased, {\b QCP::AntialiasedElement} overrideElement) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mVisible}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPLayerable} > {\b mParentLayerable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b mLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiased}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisRect}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all drawable objects. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the abstract base class most visible objects derive from, e.g. plottables, axes, grid etc.\par
Every layerable is on a layer ({\b QCPLayer}) which allows controlling the rendering order by stacking the layers accordingly.\par
For details about the layering mechanism, see the {\b QCPLayer} documentation. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPLayerable\:QCPLayerable}
{\xe \v QCPLayerable\:QCPLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayerable::QCPLayerable ({\b QCustomPlot} *  {\i plot}, QString  {\i targetLayer} = {\f2 QString()}, {\b QCPLayerable} *  {\i parentLayerable} = {\f2 0})}}
\par
{\bkmkstart AAAAAAACRZ}
{\bkmkend AAAAAAACRZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPLayerable} instance.\par
Since {\b QCPLayerable} is an abstract base class, it can't be instantiated directly. Use one of the derived classes.\par
If {\i plot}  is provided, it automatically places itself on the layer named {\i targetLayer} . If {\i targetLayer}  is an empty string, it places itself on the current layer of the plot (see {\b QCustomPlot::setCurrentLayer}).\par
It is possible to provide 0 as {\i plot} . In that case, you should assign a parent plot at a later time with {\b initializeParentPlot}.\par
The layerable's parent layerable is set to {\i parentLayerable} , if provided. Direct layerable parents are mainly used to control visibility in a hierarchy of layerables. This means a layerable is only drawn, if all its ancestor layerables are also visible. Note that {\i parentLayerable}  does not become the QObject-parent (for memory management) of this layerable, {\i plot}  does. It is not uncommon to set the QObject-parent to something else in the constructors of {\b QCPLayerable} subclasses, to guarantee a working destruction hierarchy. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1339                                                                                                 :\par
 1340   QObject(plot),\par
 1341   mVisible(true),\par
 1342   mParentPlot(plot),\par
 1343   mParentLayerable(parentLayerable),\par
 1344   mLayer(0),\par
 1345   mAntialiased(true)\par
 1346 \{\par
 1347   if (mParentPlot)\par
 1348   \{\par
 1349     if (targetLayer.isEmpty())\par
 1350       setLayer(mParentPlot->currentLayer());\par
 1351     else if (!setLayer(targetLayer))\par
 1352       qDebug() << Q_FUNC_INFO << "setting QCPlayerable initial layer to" << targetLayer << "failed.";\par
 1353   \}\par
 1354 \}\par
}
}
{\xe \v ~QCPLayerable\:QCPLayerable}
{\xe \v QCPLayerable\:~QCPLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayerable::~QCPLayerable (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSA}
{\bkmkend AAAAAAACSA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1357 \{\par
 1358   if (mLayer)\par
 1359   \{\par
 1360     mLayer->removeChild(this);\par
 1361     mLayer = 0;\par
 1362   \}\par
 1363 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v antialiased\:QCPLayerable}
{\xe \v QCPLayerable\:antialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::antialiased () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSB}
{\bkmkend AAAAAAACSB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   711 \{ return mAntialiased; \}\par
}
}
{\xe \v applyAntialiasingHint\:QCPLayerable}
{\xe \v QCPLayerable\:applyAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::applyAntialiasingHint ({\b QCPPainter} *  {\i painter}, bool  {\i localAntialiased}, {\b QCP::AntialiasedElement}  {\i overrideElement}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACSC}
{\bkmkend AAAAAAACSC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1567 \{\par
 1568   if (mParentPlot && mParentPlot->notAntialiasedElements().testFlag(overrideElement))\par
 1569     painter->setAntialiasing(false);\par
 1570   else if (mParentPlot && mParentPlot->antialiasedElements().testFlag(overrideElement))\par
 1571     painter->setAntialiasing(true);\par
 1572   else\par
 1573     painter->setAntialiasing(localAntialiased);\par
 1574 \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPLayerable}
{\xe \v QCPLayerable\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABNQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPSelectionRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v clipRect\:QCPLayerable}
{\xe \v QCPLayerable\:clipRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayerable::clipRect () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1623 \{\par
 1624   if (mParentPlot)\par
 1625     return mParentPlot->viewport();\par
 1626   else\par
 1627     return QRect();\par
 1628 \}\par
}
}
{\xe \v deselectEvent\:QCPLayerable}
{\xe \v QCPLayerable\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1679 \{\par
 1680   Q_UNUSED(selectionStateChanged)\par
 1681 \}\par
}
}
{\xe \v draw\:QCPLayerable}
{\xe \v QCPLayerable\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b QCPItemBracket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemTracer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemPixmap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemEllipse} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemLine} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemStraightLine} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorScaleAxisRectPrivate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPPlottableLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFO \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPSelectionRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initializeParentPlot\:QCPLayerable}
{\xe \v QCPLayerable\:initializeParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::initializeParentPlot ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACSL}
{\bkmkend AAAAAAACSL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1497 \{\par
 1498   if (mParentPlot)\par
 1499   \{\par
 1500     qDebug() << Q_FUNC_INFO << "called with mParentPlot already initialized";\par
 1501     return;\par
 1502   \}\par
 1503   \par
 1504   if (!parentPlot)\par
 1505     qDebug() << Q_FUNC_INFO << "called with parentPlot zero";\par
 1506   \par
 1507   mParentPlot = parentPlot;\par
 1508   parentPlotInitialized(mParentPlot);\par
 1509 \}\par
}
}
{\xe \v layer\:QCPLayerable}
{\xe \v QCPLayerable\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::layer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSM}
{\bkmkend AAAAAAACSM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   710 \{ return mLayer; \}\par
}
}
{\xe \v layerChanged\:QCPLayerable}
{\xe \v QCPLayerable\:layerChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::layerChanged ({\b QCPLayer} *  {\i newLayer}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAACSN}
{\bkmkend AAAAAAACSN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLayer} \par
}}}
{\xe \v mouseDoubleClickEvent\:QCPLayerable}
{\xe \v QCPLayerable\:mouseDoubleClickEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseDoubleClickEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSO}
{\bkmkend AAAAAAACSO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The {\b mouseDoubleClickEvent} is called instead of the second {\b mousePressEvent}. So in the case of a double-click, the event succession is {\i pressEvent \'96 releaseEvent \'96 doubleClickEvent \'96 releaseEvent} .\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
Similarly to {\b mousePressEvent}, once a layerable has accepted the {\b mouseDoubleClickEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} and {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b wheelEvent} \par
}}{
Reimplemented in {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1777 \{\par
 1778   Q_UNUSED(details)\par
 1779   event->ignore();\par
 1780 \}\par
}
}
{\xe \v mouseMoveEvent\:QCPLayerable}
{\xe \v QCPLayerable\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseMoveEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented in {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1727 \{\par
 1728   Q_UNUSED(startPos)\par
 1729   event->ignore();\par
 1730 \}\par
}
}
{\xe \v mousePressEvent\:QCPLayerable}
{\xe \v QCPLayerable\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mousePressEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
{\b QCustomPlot} uses an event propagation system that works the same as Qt's system. If your layerable doesn't reimplement the {\b mousePressEvent} or explicitly calls {\f2 event->ignore()}  in its reimplementation, the event will be propagated to the next layerable in the stacking order.\par
Once a layerable has accepted the {\b mousePressEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} or {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented in {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXV \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1709 \{\par
 1710   Q_UNUSED(details)\par
 1711   event->ignore();\par
 1712 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPLayerable}
{\xe \v QCPLayerable\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseReleaseEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplemented in {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXW \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1745 \{\par
 1746   Q_UNUSED(startPos)\par
 1747   event->ignore();\par
 1748 \}\par
}
}
{\xe \v moveToLayer\:QCPLayerable}
{\xe \v QCPLayerable\:moveToLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::moveToLayer ({\b QCPLayer} *  {\i layer}, bool  {\i prepend}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACSS}
{\bkmkend AAAAAAACSS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1536 \{\par
 1537   if (layer && !mParentPlot)\par
 1538   \{\par
 1539     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1540     return false;\par
 1541   \}\par
 1542   if (layer && layer->parentPlot() != mParentPlot)\par
 1543   \{\par
 1544     qDebug() << Q_FUNC_INFO << "layer" << layer->name() << "is not in same QCustomPlot as this layerable";\par
 1545     return false;\par
 1546   \}\par
 1547   \par
 1548   QCPLayer *oldLayer = mLayer;\par
 1549   if (mLayer)\par
 1550     mLayer->removeChild(this);\par
 1551   mLayer = layer;\par
 1552   if (mLayer)\par
 1553     mLayer->addChild(this, prepend);\par
 1554   if (mLayer != oldLayer)\par
 1555     emit layerChanged(mLayer);\par
 1556   return true;\par
 1557 \}\par
}
}
{\xe \v parentLayerable\:QCPLayerable}
{\xe \v QCPLayerable\:parentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayerable} * QCPLayerable::parentLayerable () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACST}
{\bkmkend AAAAAAACST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method {\b realVisibility}. This way, layerables only get drawn if their parent layerables are visible, too.\par
Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn't always have a parent layerable, so this function may return 0.\par
A parent layerable is set implicitly when placed inside layout elements and doesn't need to be set manually by the user. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   709 \{ return mParentLayerable.data(); \}\par
}
}
{\xe \v parentPlot\:QCPLayerable}
{\xe \v QCPLayerable\:parentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::parentPlot () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACSU}
{\bkmkend AAAAAAACSU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   708 \{ return mParentPlot; \}\par
}
}
{\xe \v parentPlotInitialized\:QCPLayerable}
{\xe \v QCPLayerable\:parentPlotInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::parentPlotInitialized ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSV}
{\bkmkend AAAAAAACSV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSW \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1593 \{\par
 1594    Q_UNUSED(parentPlot)\par
 1595 \}\par
}
}
{\xe \v realVisibility\:QCPLayerable}
{\xe \v QCPLayerable\:realVisibility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::realVisibility () const}}
\par
{\bkmkstart AAAAAAACSY}
{\bkmkend AAAAAAACSY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable's layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.\par
If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of {\b QCPLayoutElement}), this function returns true only if this layerable has its visibility set to true and the parent layerable's {\b realVisibility} returns true. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1433 \{\par
 1434   return mVisible && (!mLayer || mLayer->visible()) && (!mParentLayerable || mParentLayerable.data()->realVisibility());\par
 1435 \}\par
}
}
{\xe \v selectEvent\:QCPLayerable}
{\xe \v QCPLayerable\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJY \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1659 \{\par
 1660   Q_UNUSED(event)\par
 1661   Q_UNUSED(additive)\par
 1662   Q_UNUSED(details)\par
 1663   Q_UNUSED(selectionStateChanged)\par
 1664 \}\par
}
}
{\xe \v selectionCategory\:QCPLayerable}
{\xe \v QCPLayerable\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPLayerable::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1609 \{\par
 1610   return QCP::iSelectOther;\par
 1611 \}\par
}
}
{\xe \v selectTest\:QCPLayerable}
{\xe \v QCPLayerable\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLayerable::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Reimplemented in {\b QCPItemBracket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemTracer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemPixmap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemEllipse} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAES \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemLine} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAET \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPItemStraightLine} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLayoutInset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTE \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1472 \{\par
 1473   Q_UNUSED(pos)\par
 1474   Q_UNUSED(onlySelectable)\par
 1475   Q_UNUSED(details)\par
 1476   return -1.0;\par
 1477 \}\par
}
}
{\xe \v setAntialiased\:QCPLayerable}
{\xe \v QCPLayerable\:setAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setAntialiased (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAACTF}
{\bkmkend AAAAAAACTF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this object will be drawn antialiased or not.\par
Note that antialiasing settings may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1418 \{\par
 1419   mAntialiased = enabled;\par
 1420 \}\par
}
}
{\xe \v setLayer\:QCPLayerable}
{\xe \v QCPLayerable\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer ({\b QCPLayer} *  {\i layer})}}
\par
{\bkmkstart AAAAAAACTG}
{\bkmkend AAAAAAACTG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i layer}  of this layerable object. The object will be placed on top of the other objects already on {\i layer} .\par
If {\i layer}  is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).\par
Returns true if the layer of this layerable was successfully changed to {\i layer} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1385 \{\par
 1386   return moveToLayer(layer, false);\par
 1387 \}\par
}
}
{\xe \v setLayer\:QCPLayerable}
{\xe \v QCPLayerable\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer (const QString &  {\i layerName})}}
\par
{\bkmkstart AAAAAAACTH}
{\bkmkend AAAAAAACTH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Sets the layer of this layerable object by name\par
Returns true on success, i.e. if {\i layerName}  is a valid layer name. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1395 \{\par
 1396   if (!mParentPlot)\par
 1397   \{\par
 1398     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1399     return false;\par
 1400   \}\par
 1401   if (QCPLayer *layer = mParentPlot->layer(layerName))\par
 1402   \{\par
 1403     return setLayer(layer);\par
 1404   \} else\par
 1405   \{\par
 1406     qDebug() << Q_FUNC_INFO << "there is no layer with name" << layerName;\par
 1407     return false;\par
 1408   \}\par
 1409 \}\par
}
}
{\xe \v setParentLayerable\:QCPLayerable}
{\xe \v QCPLayerable\:setParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setParentLayerable ({\b QCPLayerable} *  {\i parentLayerable}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACTI}
{\bkmkend AAAAAAACTI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1523 \{\par
 1524   mParentLayerable = parentLayerable;\par
 1525 \}\par
}
}
{\xe \v setVisible\:QCPLayerable}
{\xe \v QCPLayerable\:setVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setVisible (bool  {\i on})}}
\par
{\bkmkstart AAAAAAACTJ}
{\bkmkend AAAAAAACTJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the {\b QCustomPlot} surface, and user interaction with it (e.g. click and selection) is not possible. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1371 \{\par
 1372   mVisible = on;\par
 1373 \}\par
}
}
{\xe \v visible\:QCPLayerable}
{\xe \v QCPLayerable\:visible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::visible () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTK}
{\bkmkend AAAAAAACTK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   707 \{ return mVisible; \}\par
}
}
{\xe \v wheelEvent\:QCPLayerable}
{\xe \v QCPLayerable\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} .\par
The {\f2 event->delta()}  indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making {\f2 event->delta()}  larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent} \par
}}{
Reimplemented in {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZE \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1800 \{\par
 1801   event->ignore();\par
 1802 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPAxisRect\:QCPLayerable}
{\xe \v QCPLayerable\:QCPAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAxisRect}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACTL}
{\bkmkend AAAAAAACTL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPLayer\:QCPLayerable}
{\xe \v QCPLayerable\:QCPLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLayer}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACTM}
{\bkmkend AAAAAAACTM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPLayerable}
{\xe \v QCPLayerable\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACTN}
{\bkmkend AAAAAAACTN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAntialiased\:QCPLayerable}
{\xe \v QCPLayerable\:mAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mAntialiased{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACTO}
{\bkmkend AAAAAAACTO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLayer\:QCPLayerable}
{\xe \v QCPLayerable\:mLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::mLayer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACTP}
{\bkmkend AAAAAAACTP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentLayerable\:QCPLayerable}
{\xe \v QCPLayerable\:mParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPLayerable}> QCPLayerable::mParentLayerable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACTQ}
{\bkmkend AAAAAAACTQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPLayerable}
{\xe \v QCPLayerable\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::mParentPlot{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACTR}
{\bkmkend AAAAAAACTR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mVisible\:QCPLayerable}
{\xe \v QCPLayerable\:mVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mVisible{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACTS}
{\bkmkend AAAAAAACTS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPLayout Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPLayout}
{\xe \v QCPLayout}
{\bkmkstart AAAAAAACTT}
{\bkmkend AAAAAAACTT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for layouts. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPLayout:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layout__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPLayout:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layout__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayout} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b update} ({\b UpdatePhase} phase) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QList< {\b QCPLayoutElement} * > {\b elements} (bool recursive) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b elementCount} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPLayoutElement} * {\b elementAt} (int index) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPLayoutElement} * {\b takeAt} (int index)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b take} ({\b QCPLayoutElement} *element)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b simplify} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeAt} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b remove} ({\b QCPLayoutElement} *element)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateLayout} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sizeConstraintsChanged} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b adoptElement} ({\b QCPLayoutElement} *el)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b releaseElement} ({\b QCPLayoutElement} *el)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< int > {\b getSectionSizes} (QVector< int > maxSizes, QVector< int > minSizes, QVector< double > stretchFactors, int totalSize) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static QSize {\b getFinalMinimumOuterSize} (const {\b QCPLayoutElement} *el)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static QSize {\b getFinalMaximumOuterSize} (const {\b QCPLayoutElement} *el)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayoutElement}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for layouts. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an abstract base class for layout elements whose main purpose is to define the position and size of other child layout elements. In most cases, layouts don't draw anything themselves (but there are exceptions to this, e.g. {\b QCPLegend}).\par
{\b QCPLayout} derives from {\b QCPLayoutElement}, and thus can itself be nested in other layouts.\par
{\b QCPLayout} introduces a common interface for accessing and manipulating the child elements. Those functions are most notably {\b elementCount}, {\b elementAt}, {\b takeAt}, {\b take}, {\b simplify}, {\b removeAt}, {\b remove} and {\b clear}. Individual subclasses may add more functions to this interface which are more specialized to the form of the layout. For example, {\b QCPLayoutGrid} adds functions that take row and column indices to access cells of the layout grid more conveniently.\par
Since this is an abstract base class, you can't instantiate it directly. Rather use one of its subclasses like {\b QCPLayoutGrid} or {\b QCPLayoutInset}.\par
For a general introduction to the layout system, see the dedicated documentation page The Layout System. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPLayout\:QCPLayout}
{\xe \v QCPLayout\:QCPLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayout::QCPLayout (){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACTU}
{\bkmkend AAAAAAACTU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\b QCPLayout} and sets default values. Note that since {\b QCPLayout} is an abstract base class, it can't be instantiated directly. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3635 \{\par
 3636 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v adoptElement\:QCPLayout}
{\xe \v QCPLayout\:adoptElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayout::adoptElement ({\b QCPLayoutElement} *  {\i el}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACTV}
{\bkmkend AAAAAAACTV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3800 \{\par
 3801   if (el)\par
 3802   \{\par
 3803     el->mParentLayout = this;\par
 3804     el->setParentLayerable(this);\par
 3805     el->setParent(this);\par
 3806     if (!el->parentPlot())\par
 3807       el->initializeParentPlot(mParentPlot);\par
 3808     el->layoutChanged();\par
 3809   \} else\par
 3810     qDebug() << Q_FUNC_INFO << "Null element passed";\par
 3811 \}\par
}
}
{\xe \v clear\:QCPLayout}
{\xe \v QCPLayout\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayout::clear ()}}
\par
{\bkmkstart AAAAAAACTW}
{\bkmkend AAAAAAACTW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes and deletes all layout elements in this layout. Finally calls {\b simplify} to make sure all empty cells are collapsed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b remove}, {\b removeAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3745 \{\par
 3746   for (int i=elementCount()-1; i>=0; --i)\par
 3747   \{\par
 3748     if (elementAt(i))\par
 3749       removeAt(i);\par
 3750   \}\par
 3751   simplify();\par
 3752 \}\par
}
}
{\xe \v elementAt\:QCPLayout}
{\xe \v QCPLayout\:elementAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutElement} * QCPLayout::elementAt (int  {\i index}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACTX}
{\bkmkend AAAAAAACTX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the element in the cell with the given {\i index} . If {\i index}  is invalid, returns 0.\par
Note that even if {\i index}  is valid, the respective cell may be empty in some layouts (e.g. {\b QCPLayoutGrid}), so this function may return 0 in those cases. You may use this function to check whether a cell is empty or not.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b elements}, {\b elementCount}, {\b takeAt} \par
}}{
Implemented in {\b QCPLayoutInset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTY \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v elementCount\:QCPLayout}
{\xe \v QCPLayout\:elementCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayout::elementCount () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACUA}
{\bkmkend AAAAAAACUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of elements/cells in the layout.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b elements}, {\b elementAt} \par
}}{
Implemented in {\b QCPLayoutInset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v elements\:QCPLayout}
{\xe \v QCPLayout\:elements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLayoutElement} * > QCPLayout::elements (bool  {\i recursive}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUD}
{\bkmkend AAAAAAACUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all child elements in this layout element. If {\i recursive}  is true, all sub-child elements are included in the list, too.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid There may be entries with value 0 in the returned list. (For example, {\b QCPLayoutGrid} may have empty cells which yield 0 at the respective index.) \par
}}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3666 \{\par
 3667   const int c = elementCount();\par
 3668   QList<QCPLayoutElement*> result;\par
 3669 #if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)\par
 3670   result.reserve(c);\par
 3671 #endif\par
 3672   for (int i=0; i<c; ++i)\par
 3673     result.append(elementAt(i));\par
 3674   if (recursive)\par
 3675   \{\par
 3676     for (int i=0; i<c; ++i)\par
 3677     \{\par
 3678       if (result.at(i))\par
 3679         result << result.at(i)->elements(recursive);\par
 3680     \}\par
 3681   \}\par
 3682   return result;\par
 3683 \}\par
}
}
{\xe \v getFinalMaximumOuterSize\:QCPLayout}
{\xe \v QCPLayout\:getFinalMaximumOuterSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayout::getFinalMaximumOuterSize (const {\b QCPLayoutElement} *  {\i el}){\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACUF}
{\bkmkend AAAAAAACUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4015 \{\par
 4016   QSize maxOuterHint = el->maximumOuterSizeHint();\par
 4017   QSize maxOuter = el->maximumSize(); // depending on sizeConstraitRect this might be with respect to inner rect, so possibly add margins in next four lines (preserving unset maximum of QWIDGETSIZE_MAX)\par
 4018   if (maxOuter.width() < QWIDGETSIZE_MAX && el->sizeConstraintRect() == QCPLayoutElement::scrInnerRect)\par
 4019     maxOuter.rwidth() += el->margins().left() + el->margins().right();\par
 4020   if (maxOuter.height() < QWIDGETSIZE_MAX && el->sizeConstraintRect() == QCPLayoutElement::scrInnerRect)\par
 4021     maxOuter.rheight() += el->margins().top() + el->margins().bottom();\par
 4022   \par
 4023   return QSize(maxOuter.width() < QWIDGETSIZE_MAX ? maxOuter.width() : maxOuterHint.width(),\par
 4024                maxOuter.height() < QWIDGETSIZE_MAX ? maxOuter.height() : maxOuterHint.height());\par
 4025 \}\par
}
}
{\xe \v getFinalMinimumOuterSize\:QCPLayout}
{\xe \v QCPLayout\:getFinalMinimumOuterSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayout::getFinalMinimumOuterSize (const {\b QCPLayoutElement} *  {\i el}){\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACUG}
{\bkmkend AAAAAAACUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3990 \{\par
 3991   QSize minOuterHint = el->minimumOuterSizeHint();\par
 3992   QSize minOuter = el->minimumSize(); // depending on sizeConstraitRect this might be with respect to inner rect, so possibly add margins in next four lines (preserving unset minimum of 0)\par
 3993   if (minOuter.width() > 0 && el->sizeConstraintRect() == QCPLayoutElement::scrInnerRect)\par
 3994     minOuter.rwidth() += el->margins().left() + el->margins().right();\par
 3995   if (minOuter.height() > 0 && el->sizeConstraintRect() == QCPLayoutElement::scrInnerRect)\par
 3996     minOuter.rheight() += el->margins().top() + el->margins().bottom();\par
 3997   \par
 3998   return QSize(minOuter.width() > 0 ? minOuter.width() : minOuterHint.width(),\par
 3999                minOuter.height() > 0 ? minOuter.height() : minOuterHint.height());;\par
 4000 \}\par
}
}
{\xe \v getSectionSizes\:QCPLayout}
{\xe \v QCPLayout\:getSectionSizes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< int > QCPLayout::getSectionSizes (QVector< int >  {\i maxSizes}, QVector< int >  {\i minSizes}, QVector< double >  {\i stretchFactors}, int  {\i totalSize}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACUH}
{\bkmkend AAAAAAACUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3865 \{\par
 3866   if (maxSizes.size() != minSizes.size() || minSizes.size() != stretchFactors.size())\par
 3867   \{\par
 3868     qDebug() << Q_FUNC_INFO << "Passed vector sizes aren't equal:" << maxSizes << minSizes << stretchFactors;\par
 3869     return QVector<int>();\par
 3870   \}\par
 3871   if (stretchFactors.isEmpty())\par
 3872     return QVector<int>();\par
 3873   int sectionCount = stretchFactors.size();\par
 3874   QVector<double> sectionSizes(sectionCount);\par
 3875   // if provided total size is forced smaller than total minimum size, ignore minimum sizes (squeeze sections):\par
 3876   int minSizeSum = 0;\par
 3877   for (int i=0; i<sectionCount; ++i)\par
 3878     minSizeSum += minSizes.at(i);\par
 3879   if (totalSize < minSizeSum)\par
 3880   \{\par
 3881     // new stretch factors are minimum sizes and minimum sizes are set to zero:\par
 3882     for (int i=0; i<sectionCount; ++i)\par
 3883     \{\par
 3884       stretchFactors[i] = minSizes.at(i);\par
 3885       minSizes[i] = 0;\par
 3886     \}\par
 3887   \}\par
 3888   \par
 3889   QList<int> minimumLockedSections;\par
 3890   QList<int> unfinishedSections;\par
 3891   for (int i=0; i<sectionCount; ++i)\par
 3892     unfinishedSections.append(i);\par
 3893   double freeSize = totalSize;\par
 3894   \par
 3895   int outerIterations = 0;\par
 3896   while (!unfinishedSections.isEmpty() && outerIterations < sectionCount*2) // the iteration check ist just a failsafe in case something really strange happens\par
 3897   \{\par
 3898     ++outerIterations;\par
 3899     int innerIterations = 0;\par
 3900     while (!unfinishedSections.isEmpty() && innerIterations < sectionCount*2) // the iteration check ist just a failsafe in case something really strange happens\par
 3901     \{\par
 3902       ++innerIterations;\par
 3903       // find section that hits its maximum next:\par
 3904       int nextId = -1;\par
 3905       double nextMax = 1e12;\par
 3906       for (int i=0; i<unfinishedSections.size(); ++i)\par
 3907       \{\par
 3908         int secId = unfinishedSections.at(i);\par
 3909         double hitsMaxAt = (maxSizes.at(secId)-sectionSizes.at(secId))/stretchFactors.at(secId);\par
 3910         if (hitsMaxAt < nextMax)\par
 3911         \{\par
 3912           nextMax = hitsMaxAt;\par
 3913           nextId = secId;\par
 3914         \}\par
 3915       \}\par
 3916       // check if that maximum is actually within the bounds of the total size (i.e. can we stretch all remaining sections so far that the found section\par
 3917       // actually hits its maximum, without exceeding the total size when we add up all sections)\par
 3918       double stretchFactorSum = 0;\par
 3919       for (int i=0; i<unfinishedSections.size(); ++i)\par
 3920         stretchFactorSum += stretchFactors.at(unfinishedSections.at(i));\par
 3921       double nextMaxLimit = freeSize/stretchFactorSum;\par
 3922       if (nextMax < nextMaxLimit) // next maximum is actually hit, move forward to that point and fix the size of that section\par
 3923       \{\par
 3924         for (int i=0; i<unfinishedSections.size(); ++i)\par
 3925         \{\par
 3926           sectionSizes[unfinishedSections.at(i)] += nextMax*stretchFactors.at(unfinishedSections.at(i)); // increment all sections\par
 3927           freeSize -= nextMax*stretchFactors.at(unfinishedSections.at(i));\par
 3928         \}\par
 3929         unfinishedSections.removeOne(nextId); // exclude the section that is now at maximum from further changes\par
 3930       \} else // next maximum isn't hit, just distribute rest of free space on remaining sections\par
 3931       \{\par
 3932         for (int i=0; i<unfinishedSections.size(); ++i)\par
 3933           sectionSizes[unfinishedSections.at(i)] += nextMaxLimit*stretchFactors.at(unfinishedSections.at(i)); // increment all sections\par
 3934         unfinishedSections.clear();\par
 3935       \}\par
 3936     \}\par
 3937     if (innerIterations == sectionCount*2)\par
 3938       qDebug() << Q_FUNC_INFO << "Exceeded maximum expected inner iteration count, layouting aborted. Input was:" << maxSizes << minSizes << stretchFactors << totalSize;\par
 3939     \par
 3940     // now check whether the resulting section sizes violate minimum restrictions:\par
 3941     bool foundMinimumViolation = false;\par
 3942     for (int i=0; i<sectionSizes.size(); ++i)\par
 3943     \{\par
 3944       if (minimumLockedSections.contains(i))\par
 3945         continue;\par
 3946       if (sectionSizes.at(i) < minSizes.at(i)) // section violates minimum\par
 3947       \{\par
 3948         sectionSizes[i] = minSizes.at(i); // set it to minimum\par
 3949         foundMinimumViolation = true; // make sure we repeat the whole optimization process\par
 3950         minimumLockedSections.append(i);\par
 3951       \}\par
 3952     \}\par
 3953     if (foundMinimumViolation)\par
 3954     \{\par
 3955       freeSize = totalSize;\par
 3956       for (int i=0; i<sectionCount; ++i)\par
 3957       \{\par
 3958         if (!minimumLockedSections.contains(i)) // only put sections that haven't hit their minimum back into the pool\par
 3959           unfinishedSections.append(i);\par
 3960         else\par
 3961           freeSize -= sectionSizes.at(i); // remove size of minimum locked sections from available space in next round\par
 3962       \}\par
 3963       // reset all section sizes to zero that are in unfinished sections (all others have been set to their minimum):\par
 3964       for (int i=0; i<unfinishedSections.size(); ++i)\par
 3965         sectionSizes[unfinishedSections.at(i)] = 0;\par
 3966     \}\par
 3967   \}\par
 3968   if (outerIterations == sectionCount*2)\par
 3969     qDebug() << Q_FUNC_INFO << "Exceeded maximum expected outer iteration count, layouting aborted. Input was:" << maxSizes << minSizes << stretchFactors << totalSize;\par
 3970   \par
 3971   QVector<int> result(sectionCount);\par
 3972   for (int i=0; i<sectionCount; ++i)\par
 3973     result[i] = qRound(sectionSizes.at(i));\par
 3974   return result;\par
 3975 \}\par
}
}
{\xe \v releaseElement\:QCPLayout}
{\xe \v QCPLayout\:releaseElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayout::releaseElement ({\b QCPLayoutElement} *  {\i el}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACUI}
{\bkmkend AAAAAAACUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3824 \{\par
 3825   if (el)\par
 3826   \{\par
 3827     el->mParentLayout = 0;\par
 3828     el->setParentLayerable(0);\par
 3829     el->setParent(mParentPlot);\par
 3830     // Note: Don't initializeParentPlot(0) here, because layout element will stay in same parent plot\par
 3831   \} else\par
 3832     qDebug() << Q_FUNC_INFO << "Null element passed";\par
 3833 \}\par
}
}
{\xe \v remove\:QCPLayout}
{\xe \v QCPLayout\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayout::remove ({\b QCPLayoutElement} *  {\i element})}}
\par
{\bkmkstart AAAAAAACUJ}
{\bkmkend AAAAAAACUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes and deletes the provided {\i element} . Returns true on success. If {\i element}  is not in the layout, returns false.\par
This function internally uses {\b takeAt} to remove the element from the layout and then deletes the element. Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element. To collapse empty cells, use {\b simplify}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeAt}, {\b take} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3729 \{\par
 3730   if (take(element))\par
 3731   \{\par
 3732     delete element;\par
 3733     return true;\par
 3734   \} else\par
 3735     return false;\par
 3736 \}\par
}
}
{\xe \v removeAt\:QCPLayout}
{\xe \v QCPLayout\:removeAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayout::removeAt (int  {\i index})}}
\par
{\bkmkstart AAAAAAACUK}
{\bkmkend AAAAAAACUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes and deletes the element at the provided {\i index} . Returns true on success. If {\i index}  is invalid or points to an empty cell, returns false.\par
This function internally uses {\b takeAt} to remove the element from the layout and then deletes the returned element. Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element. To collapse empty cells, use {\b simplify}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b remove}, {\b takeAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3708 \{\par
 3709   if (QCPLayoutElement *el = takeAt(index))\par
 3710   \{\par
 3711     delete el;\par
 3712     return true;\par
 3713   \} else\par
 3714     return false;\par
 3715 \}\par
}
}
{\xe \v simplify\:QCPLayout}
{\xe \v QCPLayout\:simplify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayout::simplify (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUL}
{\bkmkend AAAAAAACUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplifies the layout by collapsing empty cells. The exact behavior depends on subclasses, the default implementation does nothing.\par
Not all layouts need simplification. For example, {\b QCPLayoutInset} doesn't use explicit simplification while {\b QCPLayoutGrid} does. \par
}{
Reimplemented in {\b QCPLayoutInset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3693 \{\par
 3694 \}\par
}
}
{\xe \v sizeConstraintsChanged\:QCPLayout}
{\xe \v QCPLayout\:sizeConstraintsChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayout::sizeConstraintsChanged () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACUO}
{\bkmkend AAAAAAACUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subclasses call this method to report changed (minimum/maximum) size constraints.\par
If the parent of this layout is again a {\b QCPLayout}, forwards the call to the parent's {\b sizeConstraintsChanged}. If the parent is a QWidget (i.e. is the {\b QCustomPlot::plotLayout} of {\b QCustomPlot}), calls QWidget::updateGeometry, so if the {\b QCustomPlot} widget is inside a Qt QLayout, it may update itself and resize cells accordingly. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3763 \{\par
 3764   if (QWidget *w = qobject_cast<QWidget*>(parent()))\par
 3765     w->updateGeometry();\par
 3766   else if (QCPLayout *l = qobject_cast<QCPLayout*>(parent()))\par
 3767     l->sizeConstraintsChanged();\par
 3768 \}\par
}
}
{\xe \v take\:QCPLayout}
{\xe \v QCPLayout\:take}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayout::take ({\b QCPLayoutElement} *  {\i element}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACUP}
{\bkmkend AAAAAAACUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i element}  from the layout and returns true on success.\par
If the {\i element}  isn't in this layout, returns false.\par
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element. To collapse empty cells, use {\b simplify}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b takeAt} \par
}}{
Implemented in {\b QCPLayoutInset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v takeAt\:QCPLayout}
{\xe \v QCPLayout\:takeAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutElement} * QCPLayout::takeAt (int  {\i index}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACUS}
{\bkmkend AAAAAAACUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the element with the given {\i index}  from the layout and returns it.\par
If the {\i index}  is invalid or the cell with that index is empty, returns 0.\par
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element. To collapse empty cells, use {\b simplify}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b elementAt}, {\b take} \par
}}{
Implemented in {\b QCPLayoutInset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v update\:QCPLayout}
{\xe \v QCPLayout\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayout::update ({\b UpdatePhase}  {\i phase}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUV}
{\bkmkend AAAAAAACUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If {\i phase}  is {\b upLayout}, calls {\b updateLayout}, which subclasses may reimplement to reposition and resize their cells.\par
Finally, the call is propagated down to all child {\b QCPLayoutElements}.\par
For details about this method and the update phases, see the documentation of {\b QCPLayoutElement::update}. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3648 \{\par
 3649   QCPLayoutElement::update(phase);\par
 3650   \par
 3651   // set child element rects according to layout:\par
 3652   if (phase == upLayout)\par
 3653     updateLayout();\par
 3654   \par
 3655   // propagate update call to child elements:\par
 3656   const int elCount = elementCount();\par
 3657   for (int i=0; i<elCount; ++i)\par
 3658   \{\par
 3659     if (QCPLayoutElement *el = elementAt(i))\par
 3660       el->update(phase);\par
 3661   \}\par
 3662 \}\par
}
}
{\xe \v updateLayout\:QCPLayout}
{\xe \v QCPLayout\:updateLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayout::updateLayout (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUW}
{\bkmkend AAAAAAACUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPLayoutInset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3783 \{\par
 3784 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLayoutElement\:QCPLayout}
{\xe \v QCPLayout\:QCPLayoutElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLayoutElement}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACUZ}
{\bkmkend AAAAAAACUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPLayoutElement Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPLayoutElement}
{\xe \v QCPLayoutElement}
{\bkmkstart AAAAAAACVA}
{\bkmkend AAAAAAACVA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all objects that form the layout system. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPLayoutElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layout_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPLayoutElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layout_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b UpdatePhase} \{ {\b upPreparation}, 
{\b upMargins}, 
{\b upLayout}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SizeConstraintRect} \{ {\b scrInnerRect}, 
{\b scrOuterRect}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutElement} ({\b QCustomPlot} *{\b parentPlot}=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPLayoutElement} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayout} * {\b layout} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b rect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b outerRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b margins} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b minimumMargins} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::MarginSides {\b autoMargins} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b minimumSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b maximumSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SizeConstraintRect} {\b sizeConstraintRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPMarginGroup} * {\b marginGroup} ({\b QCP::MarginSide} side) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QHash< {\b QCP::MarginSide}, {\b QCPMarginGroup} * > {\b marginGroups} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOuterRect} (const QRect &{\b rect})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMargins} (const QMargins &{\b margins})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinimumMargins} (const QMargins &{\b margins})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAutoMargins} (QCP::MarginSides sides)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinimumSize} (const QSize &size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinimumSize} (int width, int height)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMaximumSize} (const QSize &size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMaximumSize} (int width, int height)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSizeConstraintRect} ({\b SizeConstraintRect} constraintRect)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMarginGroup} (QCP::MarginSides sides, {\b QCPMarginGroup} *group)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b update} ({\b UpdatePhase} phase)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b minimumOuterSizeHint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b maximumOuterSizeHint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QList< {\b QCPLayoutElement} * > {\b elements} (bool recursive) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b calculateAutoMargin} ({\b QCP::MarginSide} side)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b layoutChanged} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parentPlotInitialized} ({\b QCustomPlot} *{\b parentPlot}) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayout} * {\b mParentLayout}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b mMinimumSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b mMaximumSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SizeConstraintRect} {\b mSizeConstraintRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mOuterRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b mMargins}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b mMinimumMargins}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::MarginSides {\b mAutoMargins}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QHash< {\b QCP::MarginSide}, {\b QCPMarginGroup} * > {\b mMarginGroups}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayout}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPMarginGroup}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all objects that form the layout system. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an abstract base class. As such, it can't be instantiated directly, rather use one of its subclasses.\par
A Layout element is a rectangular object which can be placed in layouts. It has an outer rect ({\b QCPLayoutElement::outerRect}) and an inner rect ({\b QCPLayoutElement::rect}). The difference between outer and inner rect is called its margin. The margin can either be set to automatic or manual ({\b setAutoMargins}) on a per-side basis. If a side is set to manual, that margin can be set explicitly with {\b setMargins} and will stay fixed at that value. If it's set to automatic, the layout element subclass will control the value itself (via {\b calculateAutoMargin}).\par
Layout elements can be placed in layouts (base class {\b QCPLayout}) like {\b QCPLayoutGrid}. The top level layout is reachable via {\b QCustomPlot::plotLayout}, and is a {\b QCPLayoutGrid}. Since {\b QCPLayout} itself derives from {\b QCPLayoutElement}, layouts can be nested.\par
Thus in {\b QCustomPlot} one can divide layout elements into two categories: The ones that are invisible by themselves, because they don't draw anything. Their only purpose is to manage the position and size of other layout elements. This category of layout elements usually use {\b QCPLayout} as base class. Then there is the category of layout elements which actually draw something. For example, {\b QCPAxisRect}, {\b QCPLegend} and {\b QCPTextElement} are of this category. This does not necessarily mean that the latter category can't have child layout elements. {\b QCPLegend} for instance, actually derives from {\b QCPLayoutGrid} and the individual legend items are child layout elements in the grid layout. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v SizeConstraintRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:SizeConstraintRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPLayoutElement::SizeConstraintRect}}}
\par
{\bkmkstart AAAAAAACVB}
{\bkmkend AAAAAAACVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines to which rect of a layout element the size constraints that can be set via {\b setMinimumSize} and {\b setMaximumSize} apply. The outer rect ({\b outerRect}) includes the margins (e.g. in the case of a {\b QCPAxisRect} the axis labels), whereas the inner rect ({\b rect}) does not.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSizeConstraintRect} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v scrInnerRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:scrInnerRect}
{\qr scrInnerRect{\bkmkstart AAAAAAACVC}
{\bkmkend AAAAAAACVC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum/Maximum size constraints apply to inner rect. \par
}\cell }{\row }
{\xe \v scrOuterRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:scrOuterRect}
{\qr scrOuterRect{\bkmkstart AAAAAAACVD}
{\bkmkend AAAAAAACVD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1211                           \{ scrInnerRect \par
 1212                             , scrOuterRect \par
 1213                           \};\par
}
}
{\xe \v UpdatePhase\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:UpdatePhase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPLayoutElement::UpdatePhase}}}
\par
{\bkmkstart AAAAAAACVE}
{\bkmkend AAAAAAACVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the phases of the update process, that happens just before a replot. At each phase, {\b update} is called with the according UpdatePhase value. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v upPreparation\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:upPreparation}
{\qr upPreparation{\bkmkstart AAAAAAACVF}
{\bkmkend AAAAAAACVF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Phase used for any type of preparation that needs to be done before margin calculation and layout. \par
}\cell }{\row }
{\xe \v upMargins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:upMargins}
{\qr upMargins{\bkmkstart AAAAAAACVG}
{\bkmkend AAAAAAACVG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Phase in which the margins are calculated and set. \par
}\cell }{\row }
{\xe \v upLayout\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:upLayout}
{\qr upLayout{\bkmkstart AAAAAAACVH}
{\bkmkend AAAAAAACVH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Final phase in which the layout system places the rects of the elements. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1197                    \{ upPreparation \par
 1198                      ,upMargins    \par
 1199                      ,upLayout     \par
 1200                    \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPLayoutElement\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:QCPLayoutElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayoutElement::QCPLayoutElement ({\b QCustomPlot} *  {\i parentPlot} = {\f2 0}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACVI}
{\bkmkend AAAAAAACVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\b QCPLayoutElement} and sets default values. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3175                                                           :\par
 3176   QCPLayerable(parentPlot), // parenthood is changed as soon as layout element gets inserted into a layout (except for top level layout)\par
 3177   mParentLayout(0),\par
 3178   mMinimumSize(),\par
 3179   mMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX),\par
 3180   mSizeConstraintRect(scrInnerRect),\par
 3181   mRect(0, 0, 0, 0),\par
 3182   mOuterRect(0, 0, 0, 0),\par
 3183   mMargins(0, 0, 0, 0),\par
 3184   mMinimumMargins(0, 0, 0, 0),\par
 3185   mAutoMargins(QCP::msAll)\par
 3186 \{\par
 3187 \}\par
}
}
{\xe \v ~QCPLayoutElement\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:~QCPLayoutElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayoutElement::~QCPLayoutElement (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACVJ}
{\bkmkend AAAAAAACVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3190 \{\par
 3191   setMarginGroup(QCP::msAll, 0); // unregister at margin groups, if there are any\par
 3192   // unregister at layout:\par
 3193   if (qobject_cast<QCPLayout*>(mParentLayout)) // the qobject_cast is just a safeguard in case the layout forgets to call clear() in its dtor and this dtor is called by QObject dtor\par
 3194     mParentLayout->take(this);\par
 3195 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v applyDefaultAntialiasingHint\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void QCPLayoutElement::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABNQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1268 \{ Q_UNUSED(painter) \}\par
}
}
{\xe \v autoMargins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:autoMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::MarginSides QCPLayoutElement::autoMargins () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVK}
{\bkmkend AAAAAAACVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1225 \{ return mAutoMargins; \}\par
}
}
{\xe \v calculateAutoMargin\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:calculateAutoMargin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutElement::calculateAutoMargin ({\b QCP::MarginSide}  {\i side}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3538 \{\par
 3539   return qMax(QCP::getMarginValue(mMargins, side), QCP::getMarginValue(mMinimumMargins, side));\par
 3540 \}\par
}
}
{\xe \v draw\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void QCPLayoutElement::draw ({\b QCPPainter} *  {\i painter}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b QCPColorScaleAxisRectPrivate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPPlottableLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1269 \{ Q_UNUSED(painter) \}\par
}
}
{\xe \v elements\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:elements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLayoutElement} * > QCPLayoutElement::elements (bool  {\i recursive}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all child elements in this layout element. If {\i recursive}  is true, all sub-child elements are included in the list, too.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid There may be entries with value 0 in the returned list. (For example, {\b QCPLayoutGrid} may have empty cells which yield 0 at the respective index.) \par
}}{
Reimplemented in {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUE \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3478 \{\par
 3479   Q_UNUSED(recursive)\par
 3480   return QList<QCPLayoutElement*>();\par
 3481 \}\par
}
}
{\xe \v layout\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:layout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayout} * QCPLayoutElement::layout () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVL}
{\bkmkend AAAAAAACVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parent layout of this layout element. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1220 \{ return mParentLayout; \}\par
}
}
{\xe \v layoutChanged\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:layoutChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::layoutChanged (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3554 \{\par
 3555 \}\par
}
}
{\xe \v marginGroup\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:marginGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPMarginGroup}* QCPLayoutElement::marginGroup ({\b QCP::MarginSide}  {\i side}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVM}
{\bkmkend AAAAAAACVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1229 \{ return mMarginGroups.value(side, (QCPMarginGroup*)0); \}\par
}
}
{\xe \v marginGroups\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:marginGroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QHash<{\b QCP::MarginSide}, {\b QCPMarginGroup}*> QCPLayoutElement::marginGroups () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVN}
{\bkmkend AAAAAAACVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1230 \{ return mMarginGroups; \}\par
}
}
{\xe \v margins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:margins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPLayoutElement::margins () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVO}
{\bkmkend AAAAAAACVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1223 \{ return mMargins; \}\par
}
}
{\xe \v maximumOuterSizeHint\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:maximumOuterSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::maximumOuterSizeHint () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACVP}
{\bkmkend AAAAAAACVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the suggested maximum size this layout element (the {\b outerRect}) may be expanded to, if no manual maximum size is set.\par
if a maximum size ({\b setMaximumSize}) was not set manually, parent layouts use the returned size (usually indirectly through {\b QCPLayout::getFinalMaximumOuterSize}) to determine the maximum allowed size of this layout element.\par
A manual maximum size is considered set if it is smaller than Qt's {\f2 QWIDGETSIZE_MAX} .\par
The default implementation simply returns {\f2 QWIDGETSIZE_MAX}  for both width and height, implying no suggested maximum size. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints. \par
}{
Reimplemented in {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3466 \{\par
 3467   return QSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);\par
 3468 \}\par
}
}
{\xe \v maximumSize\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:maximumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::maximumSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVS}
{\bkmkend AAAAAAACVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1227 \{ return mMaximumSize; \}\par
}
}
{\xe \v minimumMargins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:minimumMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPLayoutElement::minimumMargins () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVT}
{\bkmkend AAAAAAACVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1224 \{ return mMinimumMargins; \}\par
}
}
{\xe \v minimumOuterSizeHint\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:minimumOuterSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::minimumOuterSizeHint () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACVU}
{\bkmkend AAAAAAACVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the suggested minimum size this layout element (the {\b outerRect}) may be compressed to, if no manual minimum size is set.\par
if a minimum size ({\b setMinimumSize}) was not set manually, parent layouts use the returned size (usually indirectly through {\b QCPLayout::getFinalMinimumOuterSize}) to determine the minimum allowed size of this layout element.\par
A manual minimum size is considered set if it is non-zero.\par
The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints. \par
}{
Reimplemented in {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPPlottableLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVW \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3447 \{\par
 3448   return QSize(mMargins.left()+mMargins.right(), mMargins.top()+mMargins.bottom());\par
 3449 \}\par
}
}
{\xe \v minimumSize\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:minimumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::minimumSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVY}
{\bkmkend AAAAAAACVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1226 \{ return mMinimumSize; \}\par
}
}
{\xe \v outerRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:outerRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayoutElement::outerRect () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACVZ}
{\bkmkend AAAAAAACVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the outer rect of this layout element. The outer rect is the inner rect expanded by the margins ({\b setMargins}, {\b setAutoMargins}). The outer rect is used (and set via {\b setOuterRect}) by the parent {\b QCPLayout} to control the size of this layout element.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1222 \{ return mOuterRect; \}\par
}
}
{\xe \v parentPlotInitialized\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:parentPlotInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::parentPlotInitialized ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSX}
{\bkmkend AAAAAAACSX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3520 \{\par
 3521   foreach (QCPLayoutElement* el, elements(false))\par
 3522   \{\par
 3523     if (!el->parentPlot())\par
 3524       el->initializeParentPlot(parentPlot);\par
 3525   \}\par
 3526 \}\par
}
}
{\xe \v rect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:rect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayoutElement::rect () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWA}
{\bkmkend AAAAAAACWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the inner rect of this layout element. The inner rect is the outer rect ({\b outerRect}, {\b setOuterRect}) shrinked by the margins ({\b setMargins}, {\b setAutoMargins}).\par
In some cases, the area between outer and inner rect is left blank. In other cases the margin area is used to display peripheral graphics while the main content is in the inner rect. This is where automatic margin calculation becomes interesting because it allows the layout element to adapt the margins to the peripheral graphics it wants to draw. For example, {\b QCPAxisRect} draws the axis labels and tick labels in the margin area, thus needs to adjust the margins (if {\b setAutoMargins} is enabled) according to the space required by the labels of the axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b outerRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1221 \{ return mRect; \}\par
}
}
{\xe \v selectTest\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLayoutElement::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layout elements are sensitive to events inside their outer rect. If {\i pos}  is within the outer rect, this method returns a value corresponding to 0.99 times the parent plot's selection tolerance. However, layout elements are not selectable by default. So if {\i onlySelectable}  is true, -1.0 is returned.\par
See {\b QCPLayerable::selectTest} for a general explanation of this virtual method.\par
{\b QCPLayoutElement} subclasses may reimplement this method to provide more specific selection test behaviour. \par
}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayoutInset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3495 \{\par
 3496   Q_UNUSED(details)\par
 3497   \par
 3498   if (onlySelectable)\par
 3499     return -1;\par
 3500   \par
 3501   if (QRectF(mOuterRect).contains(pos))\par
 3502   \{\par
 3503     if (mParentPlot)\par
 3504       return mParentPlot->selectionTolerance()*0.99;\par
 3505     else\par
 3506     \{\par
 3507       qDebug() << Q_FUNC_INFO << "parent plot not defined";\par
 3508       return -1;\par
 3509     \}\par
 3510   \} else\par
 3511     return -1;\par
 3512 \}\par
}
}
{\xe \v setAutoMargins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setAutoMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setAutoMargins (QCP::MarginSides  {\i sides})}}
\par
{\bkmkstart AAAAAAACWB}
{\bkmkend AAAAAAACWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets on which sides the margin shall be calculated automatically. If a side is calculated automatically, a minimum margin value may be provided with {\b setMinimumMargins}. If a side is set to be controlled manually, the value may be specified with {\b setMargins}.\par
Margin sides that are under automatic control may participate in a {\b QCPMarginGroup} (see {\b setMarginGroup}), to synchronize (align) it with other layout elements in the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setMinimumMargins}, {\b setMargins}, {\b QCP::MarginSide} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3265 \{\par
 3266   mAutoMargins = sides;\par
 3267 \}\par
}
}
{\xe \v setMarginGroup\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setMarginGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMarginGroup (QCP::MarginSides  {\i sides}, {\b QCPMarginGroup} *  {\i group})}}
\par
{\bkmkstart AAAAAAACWC}
{\bkmkend AAAAAAACWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the margin {\i group}  of the specified margin {\i sides} .\par
Margin groups allow synchronizing specified margins across layout elements, see the documentation of {\b QCPMarginGroup}.\par
To unset the margin group of {\i sides} , set {\i group}  to 0.\par
Note that margin groups only work for margin sides that are set to automatic ({\b setAutoMargins}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCP::MarginSide} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3365 \{\par
 3366   QVector<QCP::MarginSide> sideVector;\par
 3367   if (sides.testFlag(QCP::msLeft)) sideVector.append(QCP::msLeft);\par
 3368   if (sides.testFlag(QCP::msRight)) sideVector.append(QCP::msRight);\par
 3369   if (sides.testFlag(QCP::msTop)) sideVector.append(QCP::msTop);\par
 3370   if (sides.testFlag(QCP::msBottom)) sideVector.append(QCP::msBottom);\par
 3371   \par
 3372   for (int i=0; i<sideVector.size(); ++i)\par
 3373   \{\par
 3374     QCP::MarginSide side = sideVector.at(i);\par
 3375     if (marginGroup(side) != group)\par
 3376     \{\par
 3377       QCPMarginGroup *oldGroup = marginGroup(side);\par
 3378       if (oldGroup) // unregister at old group\par
 3379         oldGroup->removeChild(side, this);\par
 3380       \par
 3381       if (!group) // if setting to 0, remove hash entry. Else set hash entry to new group and register there\par
 3382       \{\par
 3383         mMarginGroups.remove(side);\par
 3384       \} else // setting to a new group\par
 3385       \{\par
 3386         mMarginGroups[side] = group;\par
 3387         group->addChild(side, this);\par
 3388       \}\par
 3389     \}\par
 3390   \}\par
 3391 \}\par
}
}
{\xe \v setMargins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMargins (const QMargins &  {\i margins})}}
\par
{\bkmkstart AAAAAAACWD}
{\bkmkend AAAAAAACWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the margins of this layout element. If {\b setAutoMargins} is disabled for some or all sides, this function is used to manually set the margin on those sides. Sides that are still set to be handled automatically are ignored and may have any value in {\i margins} .\par
The margin is the distance between the outer rect (controlled by the parent layout via {\b setOuterRect}) and the inner {\b rect} (which usually contains the main content of this layout element).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAutoMargins} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3229 \{\par
 3230   if (mMargins != margins)\par
 3231   \{\par
 3232     mMargins = margins;\par
 3233     mRect = mOuterRect.adjusted(mMargins.left(), mMargins.top(), -mMargins.right(), -mMargins.bottom());\par
 3234   \}\par
 3235 \}\par
}
}
{\xe \v setMaximumSize\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setMaximumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMaximumSize (const QSize &  {\i size})}}
\par
{\bkmkstart AAAAAAACWE}
{\bkmkend AAAAAAACWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the maximum size of this layout element. A parent layout tries to respect the {\i size}  here by changing row/column sizes in the layout accordingly.\par
Whether this constraint applies to the inner or the outer rect can be specified with {\b setSizeConstraintRect} (see {\b rect} and {\b outerRect}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3311 \{\par
 3312   if (mMaximumSize != size)\par
 3313   \{\par
 3314     mMaximumSize = size;\par
 3315     if (mParentLayout)\par
 3316       mParentLayout->sizeConstraintsChanged();\par
 3317   \}\par
 3318 \}\par
}
}
{\xe \v setMaximumSize\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setMaximumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMaximumSize (int  {\i width}, int  {\i height})}}
\par
{\bkmkstart AAAAAAACWF}
{\bkmkend AAAAAAACWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the maximum size of this layout element.\par
Whether this constraint applies to the inner or the outer rect can be specified with {\b setSizeConstraintRect} (see {\b rect} and {\b outerRect}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3328 \{\par
 3329   setMaximumSize(QSize(width, height));\par
 3330 \}\par
}
}
{\xe \v setMinimumMargins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setMinimumMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMinimumMargins (const QMargins &  {\i margins})}}
\par
{\bkmkstart AAAAAAACWG}
{\bkmkend AAAAAAACWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If {\b setAutoMargins} is enabled on some or all margins, this function is used to provide minimum values for those margins.\par
The minimum values are not enforced on margin sides that were set to be under manual control via {\b setAutoMargins}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAutoMargins} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3247 \{\par
 3248   if (mMinimumMargins != margins)\par
 3249   \{\par
 3250     mMinimumMargins = margins;\par
 3251   \}\par
 3252 \}\par
}
}
{\xe \v setMinimumSize\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setMinimumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMinimumSize (const QSize &  {\i size})}}
\par
{\bkmkstart AAAAAAACWH}
{\bkmkend AAAAAAACWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the minimum size of this layout element. A parent layout tries to respect the {\i size}  here by changing row/column sizes in the layout accordingly.\par
If the parent layout size is not sufficient to satisfy all minimum size constraints of its child layout elements, the layout may set a size that is actually smaller than {\i size} . {\b QCustomPlot} propagates the layout's size constraints to the outside by setting its own minimum QWidget size accordingly, so violations of {\i size}  should be exceptions.\par
Whether this constraint applies to the inner or the outer rect can be specified with {\b setSizeConstraintRect} (see {\b rect} and {\b outerRect}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3282 \{\par
 3283   if (mMinimumSize != size)\par
 3284   \{\par
 3285     mMinimumSize = size;\par
 3286     if (mParentLayout)\par
 3287       mParentLayout->sizeConstraintsChanged();\par
 3288   \}\par
 3289 \}\par
}
}
{\xe \v setMinimumSize\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setMinimumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMinimumSize (int  {\i width}, int  {\i height})}}
\par
{\bkmkstart AAAAAAACWI}
{\bkmkend AAAAAAACWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the minimum size of this layout element.\par
Whether this constraint applies to the inner or the outer rect can be specified with {\b setSizeConstraintRect} (see {\b rect} and {\b outerRect}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3299 \{\par
 3300   setMinimumSize(QSize(width, height));\par
 3301 \}\par
}
}
{\xe \v setOuterRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setOuterRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setOuterRect (const QRect &  {\i rect})}}
\par
{\bkmkstart AAAAAAACWJ}
{\bkmkend AAAAAAACWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the outer rect of this layout element. If the layout element is inside a layout, the layout sets the position and size of this layout element using this function.\par
Calling this function externally has no effect, since the layout will overwrite any changes to the outer rect upon the next replot.\par
The layout element will adapt its inner {\b rect} by applying the margins inward to the outer rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3209 \{\par
 3210   if (mOuterRect != rect)\par
 3211   \{\par
 3212     mOuterRect = rect;\par
 3213     mRect = mOuterRect.adjusted(mMargins.left(), mMargins.top(), -mMargins.right(), -mMargins.bottom());\par
 3214   \}\par
 3215 \}\par
}
}
{\xe \v setSizeConstraintRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:setSizeConstraintRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setSizeConstraintRect ({\b SizeConstraintRect}  {\i constraintRect})}}
\par
{\bkmkstart AAAAAAACWK}
{\bkmkend AAAAAAACWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets to which rect of a layout element the size constraints apply. Size constraints can be set via {\b setMinimumSize} and {\b setMaximumSize}.\par
The outer rect ({\b outerRect}) includes the margins (e.g. in the case of a {\b QCPAxisRect} the axis labels), whereas the inner rect ({\b rect}) does not.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setMinimumSize}, {\b setMaximumSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3342 \{\par
 3343   if (mSizeConstraintRect != constraintRect)\par
 3344   \{\par
 3345     mSizeConstraintRect = constraintRect;\par
 3346     if (mParentLayout)\par
 3347       mParentLayout->sizeConstraintsChanged();\par
 3348   \}\par
 3349 \}\par
}
}
{\xe \v sizeConstraintRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:sizeConstraintRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SizeConstraintRect} QCPLayoutElement::sizeConstraintRect () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACWL}
{\bkmkend AAAAAAACWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1228 \{ return mSizeConstraintRect; \}\par
}
}
{\xe \v update\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::update ({\b UpdatePhase}  {\i phase}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates the layout element and sub-elements. This function is automatically called before every replot by the parent layout element. It is called multiple times, once for every {\b UpdatePhase}. The phases are run through in the order of the enum values. For details about what happens at the different phases, see the documentation of {\b UpdatePhase}.\par
Layout elements that have child elements should call the {\b update} method of their child elements, and pass the current {\i phase}  unchanged.\par
The default implementation executes the automatic margin mechanism in the {\b upMargins} phase. Subclasses should make sure to call the base class implementation. \par
}{
Reimplemented in {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3406 \{\par
 3407   if (phase == upMargins)\par
 3408   \{\par
 3409     if (mAutoMargins != QCP::msNone)\par
 3410     \{\par
 3411       // set the margins of this layout element according to automatic margin calculation, either directly or via a margin group:\par
 3412       QMargins newMargins = mMargins;\par
 3413       QList<QCP::MarginSide> allMarginSides = QList<QCP::MarginSide>() << QCP::msLeft << QCP::msRight << QCP::msTop << QCP::msBottom;\par
 3414       foreach (QCP::MarginSide side, allMarginSides)\par
 3415       \{\par
 3416         if (mAutoMargins.testFlag(side)) // this side's margin shall be calculated automatically\par
 3417         \{\par
 3418           if (mMarginGroups.contains(side))\par
 3419             QCP::setMarginValue(newMargins, side, mMarginGroups[side]->commonMargin(side)); // this side is part of a margin group, so get the margin value from that group\par
 3420           else\par
 3421             QCP::setMarginValue(newMargins, side, calculateAutoMargin(side)); // this side is not part of a group, so calculate the value directly\par
 3422           // apply minimum margin restrictions:\par
 3423           if (QCP::getMarginValue(newMargins, side) < QCP::getMarginValue(mMinimumMargins, side))\par
 3424             QCP::setMarginValue(newMargins, side, QCP::getMarginValue(mMinimumMargins, side));\par
 3425         \}\par
 3426       \}\par
 3427       setMargins(newMargins);\par
 3428     \}\par
 3429   \}\par
 3430 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLayout\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:QCPLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLayout}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACWM}
{\bkmkend AAAAAAACWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPMarginGroup\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:QCPMarginGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPMarginGroup}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACWN}
{\bkmkend AAAAAAACWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACWO}
{\bkmkend AAAAAAACWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAutoMargins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mAutoMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::MarginSides QCPLayoutElement::mAutoMargins{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWP}
{\bkmkend AAAAAAACWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMarginGroups\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mMarginGroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QHash<{\b QCP::MarginSide}, {\b QCPMarginGroup}*> QCPLayoutElement::mMarginGroups{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWQ}
{\bkmkend AAAAAAACWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMargins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPLayoutElement::mMargins{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWR}
{\bkmkend AAAAAAACWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMaximumSize\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mMaximumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::mMaximumSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWS}
{\bkmkend AAAAAAACWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMinimumMargins\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mMinimumMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPLayoutElement::mMinimumMargins{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWT}
{\bkmkend AAAAAAACWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMinimumSize\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mMinimumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::mMinimumSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWU}
{\bkmkend AAAAAAACWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOuterRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mOuterRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayoutElement::mOuterRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWV}
{\bkmkend AAAAAAACWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentLayout\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mParentLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayout}* QCPLayoutElement::mParentLayout{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWW}
{\bkmkend AAAAAAACWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayoutElement::mRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWX}
{\bkmkend AAAAAAACWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSizeConstraintRect\:QCPLayoutElement}
{\xe \v QCPLayoutElement\:mSizeConstraintRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SizeConstraintRect} QCPLayoutElement::mSizeConstraintRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACWY}
{\bkmkend AAAAAAACWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPLayoutGrid Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPLayoutGrid}
{\xe \v QCPLayoutGrid}
{\bkmkstart AAAAAAACWZ}
{\bkmkend AAAAAAACWZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout that arranges child elements in a grid. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPLayoutGrid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layout_grid__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPLayoutGrid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layout_grid__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b FillOrder} \{ {\b foRowsFirst}, 
{\b foColumnsFirst}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutGrid} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPLayoutGrid} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rowCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b columnCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< double > {\b columnStretchFactors} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< double > {\b rowStretchFactors} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b columnSpacing} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rowSpacing} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b wrap} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FillOrder} {\b fillOrder} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColumnStretchFactor} (int column, double factor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColumnStretchFactors} (const QList< double > &factors)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRowStretchFactor} (int row, double factor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRowStretchFactors} (const QList< double > &factors)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColumnSpacing} (int pixels)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRowSpacing} (int pixels)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWrap} (int count)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFillOrder} ({\b FillOrder} order, bool rearrange=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateLayout} () {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b elementCount} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPLayoutElement} * {\b elementAt} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPLayoutElement} * {\b takeAt} (int index) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b take} ({\b QCPLayoutElement} *{\b element}) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QList< {\b QCPLayoutElement} * > {\b elements} (bool recursive) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b simplify} () {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b minimumOuterSizeHint} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b maximumOuterSizeHint} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutElement} * {\b element} (int row, int column) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addElement} (int row, int column, {\b QCPLayoutElement} *{\b element})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addElement} ({\b QCPLayoutElement} *{\b element})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasElement} (int row, int column)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b expandTo} (int newRowCount, int newColumnCount)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertRow} (int newIndex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertColumn} (int newIndex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rowColToIndex} (int row, int column) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b indexToRowCol} (int index, int &row, int &column) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getMinimumRowColSizes} (QVector< int > *minColWidths, QVector< int > *minRowHeights) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getMaximumRowColSizes} (QVector< int > *maxColWidths, QVector< int > *maxRowHeights) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QList< {\b QCPLayoutElement} * > > {\b mElements}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< double > {\b mColumnStretchFactors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< double > {\b mRowStretchFactors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mColumnSpacing}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mRowSpacing}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mWrap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FillOrder} {\b mFillOrder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout that arranges child elements in a grid. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Elements are laid out in a grid with configurable stretch factors ({\b setColumnStretchFactor}, {\b setRowStretchFactor}) and spacing ({\b setColumnSpacing}, {\b setRowSpacing}).\par
Elements can be added to cells via {\b addElement}. The grid is expanded if the specified row or column doesn't exist yet. Whether a cell contains a valid layout element can be checked with {\b hasElement}, that element can be retrieved with {\b element}. If rows and columns that only have empty cells shall be removed, call {\b simplify}. Removal of elements is either done by just adding the element to a different layout or by using the {\b QCPLayout} interface {\b take} or {\b remove}.\par
If you use {\b addElement(QCPLayoutElement*)} without explicit parameters for {\i row}  and {\i column} , the grid layout will choose the position according to the current {\b setFillOrder} and the wrapping ({\b setWrap}).\par
Row and column insertion can be performed with {\b insertRow} and {\b insertColumn}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v FillOrder\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:FillOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPLayoutGrid::FillOrder}}}
\par
{\bkmkstart AAAAAAACXA}
{\bkmkend AAAAAAACXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines in which direction the grid is filled when using {\b addElement(QCPLayoutElement*)}. The column/row at which wrapping into the next row/column occurs can be specified with {\b setWrap}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFillOrder} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v foRowsFirst\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:foRowsFirst}
{\qr foRowsFirst{\bkmkstart AAAAAAACXB}
{\bkmkend AAAAAAACXB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rows are filled first, and a new element is wrapped to the next column if the row count would exceed {\b setWrap}. \par
}\cell }{\row }
{\xe \v foColumnsFirst\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:foColumnsFirst}
{\qr foColumnsFirst{\bkmkstart AAAAAAACXC}
{\bkmkend AAAAAAACXC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Columns are filled first, and a new element is wrapped to the next row if the column count would exceed {\b setWrap}. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1344                  \{ foRowsFirst    \par
 1345                   ,foColumnsFirst \par
 1346                 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPLayoutGrid\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:QCPLayoutGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayoutGrid::QCPLayoutGrid (){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACXD}
{\bkmkend AAAAAAACXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\b QCPLayoutGrid} and sets default values. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4073                              :\par
 4074   mColumnSpacing(5),\par
 4075   mRowSpacing(5),\par
 4076   mWrap(0),\par
 4077   mFillOrder(foRowsFirst)\par
 4078 \{\par
 4079 \}\par
}
}
{\xe \v ~QCPLayoutGrid\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:~QCPLayoutGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayoutGrid::~QCPLayoutGrid (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACXE}
{\bkmkend AAAAAAACXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4082 \{\par
 4083   // clear all child layout elements. This is important because only the specific layouts know how\par
 4084   // to handle removing elements (clear calls virtual removeAt method to do that).\par
 4085   clear();\par
 4086 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addElement\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:addElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayoutGrid::addElement (int  {\i row}, int  {\i column}, {\b QCPLayoutElement} *  {\i element})}}
\par
{\bkmkstart AAAAAAACXF}
{\bkmkend AAAAAAACXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the {\i element}  to cell with {\i row}  and {\i column} . If {\i element}  is already in a layout, it is first removed from there. If {\i row}  or {\i column}  don't exist yet, the layout is expanded accordingly.\par
Returns true if the element was added successfully, i.e. if the cell at {\i row}  and {\i column}  didn't already have an element.\par
Use the overload of this method without explicit row/column index to place the element according to the configured fill order and wrapping settings.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b element}, {\b hasElement}, {\b take}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4129 \{\par
 4130   if (!hasElement(row, column))\par
 4131   \{\par
 4132     if (element && element->layout()) // remove from old layout first\par
 4133       element->layout()->take(element);\par
 4134     expandTo(row+1, column+1);\par
 4135     mElements[row][column] = element;\par
 4136     if (element)\par
 4137       adoptElement(element);\par
 4138     return true;\par
 4139   \} else\par
 4140     qDebug() << Q_FUNC_INFO << "There is already an element in the specified row/column:" << row << column;\par
 4141   return false;\par
 4142 \}\par
}
}
{\xe \v addElement\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:addElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayoutGrid::addElement ({\b QCPLayoutElement} *  {\i element})}}
\par
{\bkmkstart AAAAAAACXG}
{\bkmkend AAAAAAACXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the {\i element}  to the next empty cell according to the current fill order ({\b setFillOrder}) and wrapping ({\b setWrap}). If {\i element}  is already in a layout, it is first removed from there. If necessary, the layout is expanded to hold the new element.\par
Returns true if the element was added successfully.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFillOrder}, {\b setWrap}, {\b element}, {\b hasElement}, {\b take}, {\b remove} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4155 \{\par
 4156   int rowIndex = 0;\par
 4157   int colIndex = 0;\par
 4158   if (mFillOrder == foColumnsFirst)\par
 4159   \{\par
 4160     while (hasElement(rowIndex, colIndex))\par
 4161     \{\par
 4162       ++colIndex;\par
 4163       if (colIndex >= mWrap && mWrap > 0)\par
 4164       \{\par
 4165         colIndex = 0;\par
 4166         ++rowIndex;\par
 4167       \}\par
 4168     \}\par
 4169   \} else\par
 4170   \{\par
 4171     while (hasElement(rowIndex, colIndex))\par
 4172     \{\par
 4173       ++rowIndex;\par
 4174       if (rowIndex >= mWrap && mWrap > 0)\par
 4175       \{\par
 4176         rowIndex = 0;\par
 4177         ++colIndex;\par
 4178       \}\par
 4179     \}\par
 4180   \}\par
 4181   return addElement(rowIndex, colIndex, element);\par
 4182 \}\par
}
}
{\xe \v columnCount\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:columnCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutGrid::columnCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXH}
{\bkmkend AAAAAAACXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of columns in the layout.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rowCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1354 \{ return mElements.size() > 0 ? mElements.first().size() : 0; \}\par
}
}
{\xe \v columnSpacing\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:columnSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutGrid::columnSpacing () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXI}
{\bkmkend AAAAAAACXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1357 \{ return mColumnSpacing; \}\par
}
}
{\xe \v columnStretchFactors\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:columnStretchFactors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<double> QCPLayoutGrid::columnStretchFactors () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXJ}
{\bkmkend AAAAAAACXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1355 \{ return mColumnStretchFactors; \}\par
}
}
{\xe \v element\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:element}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutElement} * QCPLayoutGrid::element (int  {\i row}, int  {\i column}) const}}
\par
{\bkmkstart AAAAAAACXK}
{\bkmkend AAAAAAACXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the element in the cell in {\i row}  and {\i column} .\par
Returns 0 if either the row/column is invalid or if the cell is empty. In those cases, a qDebug message is printed. To check whether a cell exists and isn't empty, use {\b hasElement}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addElement}, {\b hasElement} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4097 \{\par
 4098   if (row >= 0 && row < mElements.size())\par
 4099   \{\par
 4100     if (column >= 0 && column < mElements.first().size())\par
 4101     \{\par
 4102       if (QCPLayoutElement *result = mElements.at(row).at(column))\par
 4103         return result;\par
 4104       else\par
 4105         qDebug() << Q_FUNC_INFO << "Requested cell is empty. Row:" << row << "Column:" << column;\par
 4106     \} else\par
 4107       qDebug() << Q_FUNC_INFO << "Invalid column. Row:" << row << "Column:" << column;\par
 4108   \} else\par
 4109     qDebug() << Q_FUNC_INFO << "Invalid row. Row:" << row << "Column:" << column;\par
 4110   return 0;\par
 4111 \}\par
}
}
{\xe \v elementAt\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:elementAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutElement} * QCPLayoutGrid::elementAt (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACTZ}
{\bkmkend AAAAAAACTZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note that the association of the linear {\i index}  to the row/column based cells depends on the current setting of {\b setFillOrder}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rowColToIndex} \par
}}{
Implements {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4594 \{\par
 4595   if (index >= 0 && index < elementCount())\par
 4596   \{\par
 4597     int row, col;\par
 4598     indexToRowCol(index, row, col);\par
 4599     return mElements.at(row).at(col);\par
 4600   \} else\par
 4601     return 0;\par
 4602 \}\par
}
}
{\xe \v elementCount\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:elementCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int QCPLayoutGrid::elementCount () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUC}
{\bkmkend AAAAAAACUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of elements/cells in the layout.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b elements}, {\b elementAt} \par
}}{
Implements {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1374 \{ return rowCount()*columnCount(); \}\par
}
}
{\xe \v elements\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:elements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLayoutElement} * > QCPLayoutGrid::elements (bool  {\i recursive}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUE}
{\bkmkend AAAAAAACUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all child elements in this layout element. If {\i recursive}  is true, all sub-child elements are included in the list, too.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid There may be entries with value 0 in the returned list. (For example, {\b QCPLayoutGrid} may have empty cells which yield 0 at the respective index.) \par
}}{
Reimplemented from {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4649 \{\par
 4650   QList<QCPLayoutElement*> result;\par
 4651   const int elCount = elementCount();\par
 4652 #if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)\par
 4653   result.reserve(elCount);\par
 4654 #endif\par
 4655   for (int i=0; i<elCount; ++i)\par
 4656     result.append(elementAt(i));\par
 4657   if (recursive)\par
 4658   \{\par
 4659     for (int i=0; i<elCount; ++i)\par
 4660     \{\par
 4661       if (result.at(i))\par
 4662         result << result.at(i)->elements(recursive);\par
 4663     \}\par
 4664   \}\par
 4665   return result;\par
 4666 \}\par
}
}
{\xe \v expandTo\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:expandTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::expandTo (int  {\i newRowCount}, int  {\i newColumnCount})}}
\par
{\bkmkstart AAAAAAACXL}
{\bkmkend AAAAAAACXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expands the layout to have {\i newRowCount}  rows and {\i newColumnCount}  columns. So the last valid row index will be {\i newRowCount-1} , the last valid column index will be {\i newColumnCount-1} .\par
If the current column/row count is already larger or equal to {\i newColumnCount/{\i newRowCount} ,}  this function does nothing in that dimension.\par
Newly created cells are empty, new rows and columns have the stretch factor 1.\par
Note that upon a call to {\b addElement}, the layout is expanded automatically to contain the specified row and column, using this function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b simplify} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4410 \{\par
 4411   // add rows as necessary:\par
 4412   while (rowCount() < newRowCount)\par
 4413   \{\par
 4414     mElements.append(QList<QCPLayoutElement*>());\par
 4415     mRowStretchFactors.append(1);\par
 4416   \}\par
 4417   // go through rows and expand columns as necessary:\par
 4418   int newColCount = qMax(columnCount(), newColumnCount);\par
 4419   for (int i=0; i<rowCount(); ++i)\par
 4420   \{\par
 4421     while (mElements.at(i).size() < newColCount)\par
 4422       mElements[i].append(0);\par
 4423   \}\par
 4424   while (mColumnStretchFactors.size() < newColCount)\par
 4425     mColumnStretchFactors.append(1);\par
 4426 \}\par
}
}
{\xe \v fillOrder\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:fillOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FillOrder} QCPLayoutGrid::fillOrder () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXM}
{\bkmkend AAAAAAACXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1360 \{ return mFillOrder; \}\par
}
}
{\xe \v getMaximumRowColSizes\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:getMaximumRowColSizes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::getMaximumRowColSizes (QVector< int > *  {\i maxColWidths}, QVector< int > *  {\i maxRowHeights}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACXN}
{\bkmkend AAAAAAACXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4801 \{\par
 4802   *maxColWidths = QVector<int>(columnCount(), QWIDGETSIZE_MAX);\par
 4803   *maxRowHeights = QVector<int>(rowCount(), QWIDGETSIZE_MAX);\par
 4804   for (int row=0; row<rowCount(); ++row)\par
 4805   \{\par
 4806     for (int col=0; col<columnCount(); ++col)\par
 4807     \{\par
 4808       if (QCPLayoutElement *el = mElements.at(row).at(col))\par
 4809       \{\par
 4810         QSize maxSize = getFinalMaximumOuterSize(el);\par
 4811         if (maxColWidths->at(col) > maxSize.width())\par
 4812           (*maxColWidths)[col] = maxSize.width();\par
 4813         if (maxRowHeights->at(row) > maxSize.height())\par
 4814           (*maxRowHeights)[row] = maxSize.height();\par
 4815       \}\par
 4816     \}\par
 4817   \}\par
 4818 \}\par
}
}
{\xe \v getMinimumRowColSizes\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:getMinimumRowColSizes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::getMinimumRowColSizes (QVector< int > *  {\i minColWidths}, QVector< int > *  {\i minRowHeights}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACXO}
{\bkmkend AAAAAAACXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4768 \{\par
 4769   *minColWidths = QVector<int>(columnCount(), 0);\par
 4770   *minRowHeights = QVector<int>(rowCount(), 0);\par
 4771   for (int row=0; row<rowCount(); ++row)\par
 4772   \{\par
 4773     for (int col=0; col<columnCount(); ++col)\par
 4774     \{\par
 4775       if (QCPLayoutElement *el = mElements.at(row).at(col))\par
 4776       \{\par
 4777         QSize minSize = getFinalMinimumOuterSize(el);\par
 4778         if (minColWidths->at(col) < minSize.width())\par
 4779           (*minColWidths)[col] = minSize.width();\par
 4780         if (minRowHeights->at(row) < minSize.height())\par
 4781           (*minRowHeights)[row] = minSize.height();\par
 4782       \}\par
 4783     \}\par
 4784   \}\par
 4785 \}\par
}
}
{\xe \v hasElement\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:hasElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayoutGrid::hasElement (int  {\i row}, int  {\i column})}}
\par
{\bkmkstart AAAAAAACXP}
{\bkmkend AAAAAAACXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the cell at {\i row}  and {\i column}  exists and contains a valid element, i.e. isn't empty.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b element} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4191 \{\par
 4192   if (row >= 0 && row < rowCount() && column >= 0 && column < columnCount())\par
 4193     return mElements.at(row).at(column);\par
 4194   else\par
 4195     return false;\par
 4196 \}\par
}
}
{\xe \v indexToRowCol\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:indexToRowCol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::indexToRowCol (int  {\i index}, int &  {\i row}, int &  {\i column}) const}}
\par
{\bkmkstart AAAAAAACXQ}
{\bkmkend AAAAAAACXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the linear index to row and column indices and writes the result to {\i row}  and {\i column} .\par
The way the cells are indexed depends on {\b setFillOrder}. If it is {\b foRowsFirst}, the indices increase left to right and then top to bottom. If it is {\b foColumnsFirst}, the indices increase top to bottom and then left to right.\par
If there are no cells (i.e. column or row count is zero), sets {\i row}  and {\i column}  to -1.\par
For the retrieved {\i row}  and {\i column}  to be valid, the passed {\i index}  must be valid itself, i.e. greater or equal to zero and smaller than the current {\b elementCount}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rowColToIndex} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4526 \{\par
 4527   row = -1;\par
 4528   column = -1;\par
 4529   const int nCols = columnCount();\par
 4530   const int nRows = rowCount();\par
 4531   if (nCols == 0 || nRows == 0)\par
 4532     return;\par
 4533   if (index < 0 || index >= elementCount())\par
 4534   \{\par
 4535     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
 4536     return;\par
 4537   \}\par
 4538   \par
 4539   switch (mFillOrder)\par
 4540   \{\par
 4541     case foRowsFirst:\par
 4542     \{\par
 4543       column = index / nRows;\par
 4544       row = index % nRows;\par
 4545       break;\par
 4546     \}\par
 4547     case foColumnsFirst:\par
 4548     \{\par
 4549       row = index / nCols;\par
 4550       column = index % nCols;\par
 4551       break;\par
 4552     \}\par
 4553   \}\par
 4554 \}\par
}
}
{\xe \v insertColumn\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:insertColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::insertColumn (int  {\i newIndex})}}
\par
{\bkmkstart AAAAAAACXR}
{\bkmkend AAAAAAACXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new column with empty cells at the column index {\i newIndex} . Valid values for {\i newIndex}  range from 0 (inserts a column at the left) to {\i columnCount}  (appends a column at the right).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b insertRow} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4462 \{\par
 4463   if (mElements.isEmpty() || mElements.first().isEmpty()) // if grid is completely empty, add first cell\par
 4464   \{\par
 4465     expandTo(1, 1);\par
 4466     return;\par
 4467   \}\par
 4468   \par
 4469   if (newIndex < 0)\par
 4470     newIndex = 0;\par
 4471   if (newIndex > columnCount())\par
 4472     newIndex = columnCount();\par
 4473   \par
 4474   mColumnStretchFactors.insert(newIndex, 1);\par
 4475   for (int row=0; row<rowCount(); ++row)\par
 4476     mElements[row].insert(newIndex, (QCPLayoutElement*)0);\par
 4477 \}\par
}
}
{\xe \v insertRow\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:insertRow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::insertRow (int  {\i newIndex})}}
\par
{\bkmkstart AAAAAAACXS}
{\bkmkend AAAAAAACXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new row with empty cells at the row index {\i newIndex} . Valid values for {\i newIndex}  range from 0 (inserts a row at the top) to {\i rowCount}  (appends a row at the bottom).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b insertColumn} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4435 \{\par
 4436   if (mElements.isEmpty() || mElements.first().isEmpty()) // if grid is completely empty, add first cell\par
 4437   \{\par
 4438     expandTo(1, 1);\par
 4439     return;\par
 4440   \}\par
 4441   \par
 4442   if (newIndex < 0)\par
 4443     newIndex = 0;\par
 4444   if (newIndex > rowCount())\par
 4445     newIndex = rowCount();\par
 4446   \par
 4447   mRowStretchFactors.insert(newIndex, 1);\par
 4448   QList<QCPLayoutElement*> newRow;\par
 4449   for (int col=0; col<columnCount(); ++col)\par
 4450     newRow.append((QCPLayoutElement*)0);\par
 4451   mElements.insert(newIndex, newRow);\par
 4452 \}\par
}
}
{\xe \v maximumOuterSizeHint\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:maximumOuterSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutGrid::maximumOuterSizeHint () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACVR}
{\bkmkend AAAAAAACVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the suggested maximum size this layout element (the {\b outerRect}) may be expanded to, if no manual maximum size is set.\par
if a maximum size ({\b setMaximumSize}) was not set manually, parent layouts use the returned size (usually indirectly through {\b QCPLayout::getFinalMaximumOuterSize}) to determine the maximum allowed size of this layout element.\par
A manual maximum size is considered set if it is smaller than Qt's {\f2 QWIDGETSIZE_MAX} .\par
The default implementation simply returns {\f2 QWIDGETSIZE_MAX}  for both width and height, implying no suggested maximum size. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4734 \{\par
 4735   QVector<int> maxColWidths, maxRowHeights;\par
 4736   getMaximumRowColSizes(&maxColWidths, &maxRowHeights);\par
 4737   \par
 4738   QSize result(0, 0);\par
 4739   for (int i=0; i<maxColWidths.size(); ++i)\par
 4740     result.setWidth(qMin(result.width()+maxColWidths.at(i), QWIDGETSIZE_MAX));\par
 4741   for (int i=0; i<maxRowHeights.size(); ++i)\par
 4742     result.setHeight(qMin(result.height()+maxRowHeights.at(i), QWIDGETSIZE_MAX));\par
 4743   result.rwidth() += qMax(0, columnCount()-1) * mColumnSpacing;\par
 4744   result.rheight() += qMax(0, rowCount()-1) * mRowSpacing;\par
 4745   result.rwidth() += mMargins.left()+mMargins.right();\par
 4746   result.rheight() += mMargins.top()+mMargins.bottom();\par
 4747   if (result.height() > QWIDGETSIZE_MAX)\par
 4748     result.setHeight(QWIDGETSIZE_MAX);\par
 4749   if (result.width() > QWIDGETSIZE_MAX)\par
 4750     result.setWidth(QWIDGETSIZE_MAX);\par
 4751   return result;\par
 4752 \}\par
}
}
{\xe \v minimumOuterSizeHint\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:minimumOuterSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutGrid::minimumOuterSizeHint () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACVX}
{\bkmkend AAAAAAACVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the suggested minimum size this layout element (the {\b outerRect}) may be compressed to, if no manual minimum size is set.\par
if a minimum size ({\b setMinimumSize}) was not set manually, parent layouts use the returned size (usually indirectly through {\b QCPLayout::getFinalMinimumOuterSize}) to determine the minimum allowed size of this layout element.\par
A manual minimum size is considered set if it is non-zero.\par
The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4717 \{\par
 4718   QVector<int> minColWidths, minRowHeights;\par
 4719   getMinimumRowColSizes(&minColWidths, &minRowHeights);\par
 4720   QSize result(0, 0);\par
 4721   for (int i=0; i<minColWidths.size(); ++i)\par
 4722     result.rwidth() += minColWidths.at(i);\par
 4723   for (int i=0; i<minRowHeights.size(); ++i)\par
 4724     result.rheight() += minRowHeights.at(i);\par
 4725   result.rwidth() += qMax(0, columnCount()-1) * mColumnSpacing;\par
 4726   result.rheight() += qMax(0, rowCount()-1) * mRowSpacing;\par
 4727   result.rwidth() += mMargins.left()+mMargins.right();\par
 4728   result.rheight() += mMargins.top()+mMargins.bottom();\par
 4729   return result;\par
 4730 \}\par
}
}
{\xe \v rowColToIndex\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:rowColToIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutGrid::rowColToIndex (int  {\i row}, int  {\i column}) const}}
\par
{\bkmkstart AAAAAAACXT}
{\bkmkend AAAAAAACXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts the given {\i row}  and {\i column}  to the linear index used by some methods of {\b QCPLayoutGrid} and {\b QCPLayout}.\par
The way the cells are indexed depends on {\b setFillOrder}. If it is {\b foRowsFirst}, the indices increase left to right and then top to bottom. If it is {\b foColumnsFirst}, the indices increase top to bottom and then left to right.\par
For the returned index to be valid, {\i row}  and {\i column}  must be valid indices themselves, i.e. greater or equal to zero and smaller than the current {\b rowCount}/{\b columnCount}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b indexToRowCol} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4493 \{\par
 4494   if (row >= 0 && row < rowCount())\par
 4495   \{\par
 4496     if (column >= 0 && column < columnCount())\par
 4497     \{\par
 4498       switch (mFillOrder)\par
 4499       \{\par
 4500         case foRowsFirst: return column*rowCount() + row;\par
 4501         case foColumnsFirst: return row*columnCount() + column;\par
 4502       \}\par
 4503     \} else\par
 4504       qDebug() << Q_FUNC_INFO << "row index out of bounds:" << row;\par
 4505   \} else\par
 4506     qDebug() << Q_FUNC_INFO << "column index out of bounds:" << column;\par
 4507   return 0;\par
 4508 \}\par
}
}
{\xe \v rowCount\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:rowCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutGrid::rowCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXU}
{\bkmkend AAAAAAACXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of rows in the layout.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b columnCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1353 \{ return mElements.size(); \}\par
}
}
{\xe \v rowSpacing\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:rowSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutGrid::rowSpacing () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXV}
{\bkmkend AAAAAAACXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1358 \{ return mRowSpacing; \}\par
}
}
{\xe \v rowStretchFactors\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:rowStretchFactors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<double> QCPLayoutGrid::rowStretchFactors () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACXW}
{\bkmkend AAAAAAACXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1356 \{ return mRowStretchFactors; \}\par
}
}
{\xe \v setColumnSpacing\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:setColumnSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::setColumnSpacing (int  {\i pixels})}}
\par
{\bkmkstart AAAAAAACXX}
{\bkmkend AAAAAAACXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the gap that is left blank between columns to {\i pixels} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRowSpacing} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4310 \{\par
 4311   mColumnSpacing = pixels;\par
 4312 \}\par
}
}
{\xe \v setColumnStretchFactor\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:setColumnStretchFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::setColumnStretchFactor (int  {\i column}, double  {\i factor})}}
\par
{\bkmkstart AAAAAAACXY}
{\bkmkend AAAAAAACXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the stretch {\i factor}  of {\i column} .\par
Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond their minimum and maximum widths/heights, regardless of the stretch factor. (see {\b QCPLayoutElement::setMinimumSize}, {\b QCPLayoutElement::setMaximumSize}, {\b QCPLayoutElement::setSizeConstraintRect}.)\par
The default stretch factor of newly created rows/columns is 1.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColumnStretchFactors}, {\b setRowStretchFactor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4211 \{\par
 4212   if (column >= 0 && column < columnCount())\par
 4213   \{\par
 4214     if (factor > 0)\par
 4215       mColumnStretchFactors[column] = factor;\par
 4216     else\par
 4217       qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << factor;\par
 4218   \} else\par
 4219     qDebug() << Q_FUNC_INFO << "Invalid column:" << column;\par
 4220 \}\par
}
}
{\xe \v setColumnStretchFactors\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:setColumnStretchFactors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::setColumnStretchFactors (const QList< double > &  {\i factors})}}
\par
{\bkmkstart AAAAAAACXZ}
{\bkmkend AAAAAAACXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the stretch {\i factors}  of all columns. {\i factors}  must have the size {\b columnCount}.\par
Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond their minimum and maximum widths/heights, regardless of the stretch factor. (see {\b QCPLayoutElement::setMinimumSize}, {\b QCPLayoutElement::setMaximumSize}, {\b QCPLayoutElement::setSizeConstraintRect}.)\par
The default stretch factor of newly created rows/columns is 1.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColumnStretchFactor}, {\b setRowStretchFactors} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4235 \{\par
 4236   if (factors.size() == mColumnStretchFactors.size())\par
 4237   \{\par
 4238     mColumnStretchFactors = factors;\par
 4239     for (int i=0; i<mColumnStretchFactors.size(); ++i)\par
 4240     \{\par
 4241       if (mColumnStretchFactors.at(i) <= 0)\par
 4242       \{\par
 4243         qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << mColumnStretchFactors.at(i);\par
 4244         mColumnStretchFactors[i] = 1;\par
 4245       \}\par
 4246     \}\par
 4247   \} else\par
 4248     qDebug() << Q_FUNC_INFO << "Column count not equal to passed stretch factor count:" << factors;\par
 4249 \}\par
}
}
{\xe \v setFillOrder\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:setFillOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::setFillOrder ({\b FillOrder}  {\i order}, bool  {\i rearrange} = {\f2 true})}}
\par
{\bkmkstart AAAAAAACYA}
{\bkmkend AAAAAAACYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the filling order and wrapping behaviour that is used when adding new elements with the method {\b addElement(QCPLayoutElement*)}.\par
The specified {\i order}  defines whether rows or columns are filled first. Using {\b setWrap}, you can control at which row/column count wrapping into the next column/row will occur. If you set it to zero, no wrapping will ever occur. Changing the fill order also changes the meaning of the linear index used e.g. in {\b elementAt} and {\b takeAt}.\par
If you want to have all current elements arranged in the new order, set {\i rearrange}  to true. The elements will be rearranged in a way that tries to preserve their linear index. However, empty cells are skipped during build-up of the new cell order, which shifts the succeeding element's index. The rearranging is performed even if the specified {\i order}  is already the current fill order. Thus this method can be used to re-wrap the current elements.\par
If {\i rearrange}  is false, the current element arrangement is not changed, which means the linear indexes change (because the linear index is dependent on the fill order).\par
Note that the method {\b addElement(int row, int column, QCPLayoutElement *element)} with explicitly stated row and column is not subject to wrapping and can place elements even beyond the specified wrapping point.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWrap}, {\b addElement(QCPLayoutElement*)} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4371 \{\par
 4372   // if rearranging, take all elements via linear index of old fill order:\par
 4373   const int elCount = elementCount();\par
 4374   QVector<QCPLayoutElement*> tempElements;\par
 4375   if (rearrange)\par
 4376   \{\par
 4377     tempElements.reserve(elCount);\par
 4378     for (int i=0; i<elCount; ++i)\par
 4379     \{\par
 4380       if (elementAt(i))\par
 4381         tempElements.append(takeAt(i));\par
 4382     \}\par
 4383     simplify();\par
 4384   \}\par
 4385   // change fill order as requested:\par
 4386   mFillOrder = order;\par
 4387   // if rearranging, re-insert via linear index according to new fill order:\par
 4388   if (rearrange)\par
 4389   \{\par
 4390     for (int i=0; i<tempElements.size(); ++i)\par
 4391       addElement(tempElements.at(i));\par
 4392   \}\par
 4393 \}\par
}
}
{\xe \v setRowSpacing\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:setRowSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::setRowSpacing (int  {\i pixels})}}
\par
{\bkmkstart AAAAAAACYB}
{\bkmkend AAAAAAACYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the gap that is left blank between rows to {\i pixels} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColumnSpacing} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4320 \{\par
 4321   mRowSpacing = pixels;\par
 4322 \}\par
}
}
{\xe \v setRowStretchFactor\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:setRowStretchFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::setRowStretchFactor (int  {\i row}, double  {\i factor})}}
\par
{\bkmkstart AAAAAAACYC}
{\bkmkend AAAAAAACYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the stretch {\i factor}  of {\i row} .\par
Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond their minimum and maximum widths/heights, regardless of the stretch factor. (see {\b QCPLayoutElement::setMinimumSize}, {\b QCPLayoutElement::setMaximumSize}, {\b QCPLayoutElement::setSizeConstraintRect}.)\par
The default stretch factor of newly created rows/columns is 1.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColumnStretchFactors}, {\b setRowStretchFactor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4264 \{\par
 4265   if (row >= 0 && row < rowCount())\par
 4266   \{\par
 4267     if (factor > 0)\par
 4268       mRowStretchFactors[row] = factor;\par
 4269     else\par
 4270       qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << factor;\par
 4271   \} else\par
 4272     qDebug() << Q_FUNC_INFO << "Invalid row:" << row;\par
 4273 \}\par
}
}
{\xe \v setRowStretchFactors\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:setRowStretchFactors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::setRowStretchFactors (const QList< double > &  {\i factors})}}
\par
{\bkmkstart AAAAAAACYD}
{\bkmkend AAAAAAACYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the stretch {\i factors}  of all rows. {\i factors}  must have the size {\b rowCount}.\par
Stretch factors control the relative sizes of rows and columns. Cells will not be resized beyond their minimum and maximum widths/heights, regardless of the stretch factor. (see {\b QCPLayoutElement::setMinimumSize}, {\b QCPLayoutElement::setMaximumSize}, {\b QCPLayoutElement::setSizeConstraintRect}.)\par
The default stretch factor of newly created rows/columns is 1.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRowStretchFactor}, {\b setColumnStretchFactors} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4288 \{\par
 4289   if (factors.size() == mRowStretchFactors.size())\par
 4290   \{\par
 4291     mRowStretchFactors = factors;\par
 4292     for (int i=0; i<mRowStretchFactors.size(); ++i)\par
 4293     \{\par
 4294       if (mRowStretchFactors.at(i) <= 0)\par
 4295       \{\par
 4296         qDebug() << Q_FUNC_INFO << "Invalid stretch factor, must be positive:" << mRowStretchFactors.at(i);\par
 4297         mRowStretchFactors[i] = 1;\par
 4298       \}\par
 4299     \}\par
 4300   \} else\par
 4301     qDebug() << Q_FUNC_INFO << "Row count not equal to passed stretch factor count:" << factors;\par
 4302 \}\par
}
}
{\xe \v setWrap\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:setWrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::setWrap (int  {\i count})}}
\par
{\bkmkstart AAAAAAACYE}
{\bkmkend AAAAAAACYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the maximum number of columns or rows that are used, before new elements added with {\b addElement(QCPLayoutElement*)} will start to fill the next row or column, respectively. It depends on {\b setFillOrder}, whether rows or columns are wrapped.\par
If {\i count}  is set to zero, no wrapping will ever occur.\par
If you wish to re-wrap the elements currently in the layout, call {\b setFillOrder} with {\i rearrange}  set to true (the actual fill order doesn't need to be changed for the rearranging to be done).\par
Note that the method {\b addElement(int row, int column, QCPLayoutElement *element)} with explicitly stated row and column is not subject to wrapping and can place elements even beyond the specified wrapping point.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFillOrder} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4342 \{\par
 4343   mWrap = qMax(0, count);\par
 4344 \}\par
}
}
{\xe \v simplify\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:simplify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::simplify (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUN}
{\bkmkend AAAAAAACUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simplifies the layout by collapsing rows and columns which only contain empty cells. \par
}{
Reimplemented from {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4672 \{\par
 4673   // remove rows with only empty cells:\par
 4674   for (int row=rowCount()-1; row>=0; --row)\par
 4675   \{\par
 4676     bool hasElements = false;\par
 4677     for (int col=0; col<columnCount(); ++col)\par
 4678     \{\par
 4679       if (mElements.at(row).at(col))\par
 4680       \{\par
 4681         hasElements = true;\par
 4682         break;\par
 4683       \}\par
 4684     \}\par
 4685     if (!hasElements)\par
 4686     \{\par
 4687       mRowStretchFactors.removeAt(row);\par
 4688       mElements.removeAt(row);\par
 4689       if (mElements.isEmpty()) // removed last element, also remove stretch factor (wouldn't happen below because also columnCount changed to 0 now)\par
 4690         mColumnStretchFactors.clear();\par
 4691     \}\par
 4692   \}\par
 4693   \par
 4694   // remove columns with only empty cells:\par
 4695   for (int col=columnCount()-1; col>=0; --col)\par
 4696   \{\par
 4697     bool hasElements = false;\par
 4698     for (int row=0; row<rowCount(); ++row)\par
 4699     \{\par
 4700       if (mElements.at(row).at(col))\par
 4701       \{\par
 4702         hasElements = true;\par
 4703         break;\par
 4704       \}\par
 4705     \}\par
 4706     if (!hasElements)\par
 4707     \{\par
 4708       mColumnStretchFactors.removeAt(col);\par
 4709       for (int row=0; row<rowCount(); ++row)\par
 4710         mElements[row].removeAt(col);\par
 4711     \}\par
 4712   \}\par
 4713 \}\par
}
}
{\xe \v take\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:take}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayoutGrid::take ({\b QCPLayoutElement} *  {\i element}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUR}
{\bkmkend AAAAAAACUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i element}  from the layout and returns true on success.\par
If the {\i element}  isn't in this layout, returns false.\par
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element. To collapse empty cells, use {\b simplify}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b takeAt} \par
}}{
Implements {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4630 \{\par
 4631   if (element)\par
 4632   \{\par
 4633     for (int i=0; i<elementCount(); ++i)\par
 4634     \{\par
 4635       if (elementAt(i) == element)\par
 4636       \{\par
 4637         takeAt(i);\par
 4638         return true;\par
 4639       \}\par
 4640     \}\par
 4641     qDebug() << Q_FUNC_INFO << "Element not in this layout, couldn't take";\par
 4642   \} else\par
 4643     qDebug() << Q_FUNC_INFO << "Can't take null element";\par
 4644   return false;\par
 4645 \}\par
}
}
{\xe \v takeAt\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:takeAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutElement} * QCPLayoutGrid::takeAt (int  {\i index}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUU}
{\bkmkend AAAAAAACUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note that the association of the linear {\i index}  to the row/column based cells depends on the current setting of {\b setFillOrder}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rowColToIndex} \par
}}{
Implements {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4613 \{\par
 4614   if (QCPLayoutElement *el = elementAt(index))\par
 4615   \{\par
 4616     releaseElement(el);\par
 4617     int row, col;\par
 4618     indexToRowCol(index, row, col);\par
 4619     mElements[row][col] = 0;\par
 4620     return el;\par
 4621   \} else\par
 4622   \{\par
 4623     qDebug() << Q_FUNC_INFO << "Attempt to take invalid index:" << index;\par
 4624     return 0;\par
 4625   \}\par
 4626 \}\par
}
}
{\xe \v updateLayout\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:updateLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutGrid::updateLayout (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUY}
{\bkmkend AAAAAAACUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4558 \{\par
 4559   QVector<int> minColWidths, minRowHeights, maxColWidths, maxRowHeights;\par
 4560   getMinimumRowColSizes(&minColWidths, &minRowHeights);\par
 4561   getMaximumRowColSizes(&maxColWidths, &maxRowHeights);\par
 4562   \par
 4563   int totalRowSpacing = (rowCount()-1) * mRowSpacing;\par
 4564   int totalColSpacing = (columnCount()-1) * mColumnSpacing;\par
 4565   QVector<int> colWidths = getSectionSizes(maxColWidths, minColWidths, mColumnStretchFactors.toVector(), mRect.width()-totalColSpacing);\par
 4566   QVector<int> rowHeights = getSectionSizes(maxRowHeights, minRowHeights, mRowStretchFactors.toVector(), mRect.height()-totalRowSpacing);\par
 4567   \par
 4568   // go through cells and set rects accordingly:\par
 4569   int yOffset = mRect.top();\par
 4570   for (int row=0; row<rowCount(); ++row)\par
 4571   \{\par
 4572     if (row > 0)\par
 4573       yOffset += rowHeights.at(row-1)+mRowSpacing;\par
 4574     int xOffset = mRect.left();\par
 4575     for (int col=0; col<columnCount(); ++col)\par
 4576     \{\par
 4577       if (col > 0)\par
 4578         xOffset += colWidths.at(col-1)+mColumnSpacing;\par
 4579       if (mElements.at(row).at(col))\par
 4580         mElements.at(row).at(col)->setOuterRect(QRect(xOffset, yOffset, colWidths.at(col), rowHeights.at(row)));\par
 4581     \}\par
 4582   \}\par
 4583 \}\par
}
}
{\xe \v wrap\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:wrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutGrid::wrap () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACYF}
{\bkmkend AAAAAAACYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1359 \{ return mWrap; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mColumnSpacing\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:mColumnSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutGrid::mColumnSpacing{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACYG}
{\bkmkend AAAAAAACYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mColumnStretchFactors\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:mColumnStretchFactors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<double> QCPLayoutGrid::mColumnStretchFactors{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACYH}
{\bkmkend AAAAAAACYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mElements\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:mElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QList<{\b QCPLayoutElement}*> > QCPLayoutGrid::mElements{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACYI}
{\bkmkend AAAAAAACYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mFillOrder\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:mFillOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FillOrder} QCPLayoutGrid::mFillOrder{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACYJ}
{\bkmkend AAAAAAACYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRowSpacing\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:mRowSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutGrid::mRowSpacing{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACYK}
{\bkmkend AAAAAAACYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRowStretchFactors\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:mRowStretchFactors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<double> QCPLayoutGrid::mRowStretchFactors{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACYL}
{\bkmkend AAAAAAACYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWrap\:QCPLayoutGrid}
{\xe \v QCPLayoutGrid\:mWrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutGrid::mWrap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACYM}
{\bkmkend AAAAAAACYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPLayoutInset Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPLayoutInset}
{\xe \v QCPLayoutInset}
{\bkmkstart AAAAAAACYN}
{\bkmkend AAAAAAACYN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout that places child elements aligned to the border or arbitrarily positioned. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPLayoutInset:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layout_inset__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPLayoutInset:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_layout_inset__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InsetPlacement} \{ {\b ipFree}, 
{\b ipBorderAligned}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutInset} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPLayoutInset} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InsetPlacement} {\b insetPlacement} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Alignment {\b insetAlignment} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRectF {\b insetRect} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInsetPlacement} (int index, {\b InsetPlacement} placement)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInsetAlignment} (int index, Qt::Alignment alignment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInsetRect} (int index, const QRectF &{\b rect})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateLayout} () {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b elementCount} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPLayoutElement} * {\b elementAt} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPLayoutElement} * {\b takeAt} (int index) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b take} ({\b QCPLayoutElement} *element) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b simplify} () {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addElement} ({\b QCPLayoutElement} *element, Qt::Alignment alignment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addElement} ({\b QCPLayoutElement} *element, const QRectF &{\b rect})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLayoutElement} * > {\b mElements}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b InsetPlacement} > {\b mInsetPlacement}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< Qt::Alignment > {\b mInsetAlignment}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QRectF > {\b mInsetRect}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout that places child elements aligned to the border or arbitrarily positioned. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Elements are placed either aligned to the border or at arbitrary position in the area of the layout. Which placement applies is controlled with the {\b InsetPlacement} ({\b setInsetPlacement}).\par
Elements are added via {\b addElement(QCPLayoutElement *element, Qt::Alignment alignment)} or {\b addElement(QCPLayoutElement *element, const QRectF &rect)}. If the first method is used, the inset placement will default to {\b ipBorderAligned} and the element will be aligned according to the {\i alignment}  parameter. The second method defaults to {\b ipFree} and allows placing elements at arbitrary position and size, defined by {\i rect} .\par
The alignment or rect can be set via {\b setInsetAlignment} or {\b setInsetRect}, respectively.\par
This is the layout that every {\b QCPAxisRect} has as {\b QCPAxisRect::insetLayout}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v InsetPlacement\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:InsetPlacement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPLayoutInset::InsetPlacement}}}
\par
{\bkmkstart AAAAAAACYO}
{\bkmkend AAAAAAACYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines how the placement and sizing is handled for a certain element in a {\b QCPLayoutInset}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ipFree\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:ipFree}
{\qr ipFree{\bkmkstart AAAAAAACYP}
{\bkmkend AAAAAAACYP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The element may be positioned/sized arbitrarily, see {\b setInsetRect}. \par
}\cell }{\row }
{\xe \v ipBorderAligned\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:ipBorderAligned}
{\qr ipBorderAligned{\bkmkstart AAAAAAACYQ}
{\bkmkend AAAAAAACYQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The element is aligned to one of the layout sides, see {\b setInsetAlignment}. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1420                       \{ ipFree            \par
 1421                         ,ipBorderAligned  \par
 1422                       \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPLayoutInset\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:QCPLayoutInset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayoutInset::QCPLayoutInset (){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACYR}
{\bkmkend AAAAAAACYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates an instance of {\b QCPLayoutInset} and sets default values. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4856 \{\par
 4857 \}\par
}
}
{\xe \v ~QCPLayoutInset\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:~QCPLayoutInset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLayoutInset::~QCPLayoutInset (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACYS}
{\bkmkend AAAAAAACYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4860 \{\par
 4861   // clear all child layout elements. This is important because only the specific layouts know how\par
 4862   // to handle removing elements (clear calls virtual removeAt method to do that).\par
 4863   clear();\par
 4864 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addElement\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:addElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutInset::addElement ({\b QCPLayoutElement} *  {\i element}, Qt::Alignment  {\i alignment})}}
\par
{\bkmkstart AAAAAAACYT}
{\bkmkend AAAAAAACYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the specified {\i element}  to the layout as an inset aligned at the border ({\b setInsetAlignment} is initialized with {\b ipBorderAligned}). The alignment is set to {\i alignment} .\par
{\i alignment}  is an or combination of the following alignment flags: Qt::AlignLeft, Qt::AlignHCenter, Qt::AlighRight, Qt::AlignTop, Qt::AlignVCenter, Qt::AlignBottom. Any other alignment flags will be ignored.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addElement(QCPLayoutElement *element, const QRectF &rect)} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5085 \{\par
 5086   if (element)\par
 5087   \{\par
 5088     if (element->layout()) // remove from old layout first\par
 5089       element->layout()->take(element);\par
 5090     mElements.append(element);\par
 5091     mInsetPlacement.append(ipBorderAligned);\par
 5092     mInsetAlignment.append(alignment);\par
 5093     mInsetRect.append(QRectF(0.6, 0.6, 0.4, 0.4));\par
 5094     adoptElement(element);\par
 5095   \} else\par
 5096     qDebug() << Q_FUNC_INFO << "Can't add null element";\par
 5097 \}\par
}
}
{\xe \v addElement\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:addElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutInset::addElement ({\b QCPLayoutElement} *  {\i element}, const QRectF &  {\i rect})}}
\par
{\bkmkstart AAAAAAACYU}
{\bkmkend AAAAAAACYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the specified {\i element}  to the layout as an inset with free positioning/sizing ({\b setInsetAlignment} is initialized with {\b ipFree}). The position and size is set to {\i rect} .\par
{\i rect}  is given in fractions of the whole inset layout rect. So an inset with rect (0, 0, 1, 1) will span the entire layout. An inset with rect (0.6, 0.1, 0.35, 0.35) will be in the top right corner of the layout, with 35% width and height of the parent layout.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addElement(QCPLayoutElement *element, Qt::Alignment alignment)} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5111 \{\par
 5112   if (element)\par
 5113   \{\par
 5114     if (element->layout()) // remove from old layout first\par
 5115       element->layout()->take(element);\par
 5116     mElements.append(element);\par
 5117     mInsetPlacement.append(ipFree);\par
 5118     mInsetAlignment.append(Qt::AlignRight|Qt::AlignTop);\par
 5119     mInsetRect.append(rect);\par
 5120     adoptElement(element);\par
 5121   \} else\par
 5122     qDebug() << Q_FUNC_INFO << "Can't add null element";\par
 5123 \}\par
}
}
{\xe \v elementAt\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:elementAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutElement} * QCPLayoutInset::elementAt (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACTY}
{\bkmkend AAAAAAACTY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the element in the cell with the given {\i index} . If {\i index}  is invalid, returns 0.\par
Note that even if {\i index}  is valid, the respective cell may be empty in some layouts (e.g. {\b QCPLayoutGrid}), so this function may return 0 in those cases. You may use this function to check whether a cell is empty or not.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b elements}, {\b elementCount}, {\b takeAt} \par
}}{
Implements {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACTX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5004 \{\par
 5005   if (index >= 0 && index < mElements.size())\par
 5006     return mElements.at(index);\par
 5007   else\par
 5008     return 0;\par
 5009 \}\par
}
}
{\xe \v elementCount\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:elementCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLayoutInset::elementCount () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUB}
{\bkmkend AAAAAAACUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of elements/cells in the layout.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b elements}, {\b elementAt} \par
}}{
Implements {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4998 \{\par
 4999   return mElements.size();\par
 5000 \}\par
}
}
{\xe \v insetAlignment\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:insetAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Alignment QCPLayoutInset::insetAlignment (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAACYV}
{\bkmkend AAAAAAACYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the alignment of the element with the specified {\i index} . The alignment only has a meaning, if the inset placement ({\b setInsetPlacement}) is {\b ipBorderAligned}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4885 \{\par
 4886   if (elementAt(index))\par
 4887     return mInsetAlignment.at(index);\par
 4888   else\par
 4889   \{\par
 4890     qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;\par
 4891     return 0;\par
 4892   \}\par
 4893 \}\par
}
}
{\xe \v insetPlacement\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:insetPlacement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutInset::InsetPlacement} QCPLayoutInset::insetPlacement (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAACYW}
{\bkmkend AAAAAAACYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the placement type of the element with the specified {\i index} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4870 \{\par
 4871   if (elementAt(index))\par
 4872     return mInsetPlacement.at(index);\par
 4873   else\par
 4874   \{\par
 4875     qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;\par
 4876     return ipFree;\par
 4877   \}\par
 4878 \}\par
}
}
{\xe \v insetRect\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:insetRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRectF QCPLayoutInset::insetRect (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAACYX}
{\bkmkend AAAAAAACYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the rect of the element with the specified {\i index} . The rect only has a meaning, if the inset placement ({\b setInsetPlacement}) is {\b ipFree}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4900 \{\par
 4901   if (elementAt(index))\par
 4902     return mInsetRect.at(index);\par
 4903   else\par
 4904   \{\par
 4905     qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;\par
 4906     return QRectF();\par
 4907   \}\par
 4908 \}\par
}
}
{\xe \v selectTest\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLayoutInset::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACTE}
{\bkmkend AAAAAAACTE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The inset layout is sensitive to events only at areas where its (visible) child elements are sensitive. If the selectTest method of any of the child elements returns a positive number for {\i pos} , this method returns a value corresponding to 0.99 times the parent plot's selection tolerance. The inset layout is not selectable itself by default. So if {\i onlySelectable}  is true, -1.0 is returned.\par
See {\b QCPLayerable::selectTest} for a general explanation of this virtual method. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5058 \{\par
 5059   Q_UNUSED(details)\par
 5060   if (onlySelectable)\par
 5061     return -1;\par
 5062   \par
 5063   for (int i=0; i<mElements.size(); ++i)\par
 5064   \{\par
 5065     // inset layout shall only return positive selectTest, if actually an inset object is at pos\par
 5066     // else it would block the entire underlying QCPAxisRect with its surface.\par
 5067     if (mElements.at(i)->realVisibility() && mElements.at(i)->selectTest(pos, onlySelectable) >= 0)\par
 5068       return mParentPlot->selectionTolerance()*0.99;\par
 5069   \}\par
 5070   return -1;\par
 5071 \}\par
}
}
{\xe \v setInsetAlignment\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:setInsetAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutInset::setInsetAlignment (int  {\i index}, Qt::Alignment  {\i alignment})}}
\par
{\bkmkstart AAAAAAACYY}
{\bkmkend AAAAAAACYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the inset placement ({\b setInsetPlacement}) is {\b ipBorderAligned}, this function is used to set the alignment of the element with the specified {\i index}  to {\i alignment} .\par
{\i alignment}  is an or combination of the following alignment flags: Qt::AlignLeft, Qt::AlignHCenter, Qt::AlighRight, Qt::AlignTop, Qt::AlignVCenter, Qt::AlignBottom. Any other alignment flags will be ignored. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4932 \{\par
 4933   if (elementAt(index))\par
 4934     mInsetAlignment[index] = alignment;\par
 4935   else\par
 4936     qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;\par
 4937 \}\par
}
}
{\xe \v setInsetPlacement\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:setInsetPlacement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutInset::setInsetPlacement (int  {\i index}, {\b QCPLayoutInset::InsetPlacement}  {\i placement})}}
\par
{\bkmkstart AAAAAAACYZ}
{\bkmkend AAAAAAACYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the inset placement type of the element with the specified {\i index}  to {\i placement} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b InsetPlacement} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4916 \{\par
 4917   if (elementAt(index))\par
 4918     mInsetPlacement[index] = placement;\par
 4919   else\par
 4920     qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;\par
 4921 \}\par
}
}
{\xe \v setInsetRect\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:setInsetRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutInset::setInsetRect (int  {\i index}, const QRectF &  {\i rect})}}
\par
{\bkmkstart AAAAAAACZA}
{\bkmkend AAAAAAACZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the inset placement ({\b setInsetPlacement}) is {\b ipFree}, this function is used to set the position and size of the element with the specified {\i index}  to {\i rect} .\par
{\i rect}  is given in fractions of the whole inset layout rect. So an inset with rect (0, 0, 1, 1) will span the entire layout. An inset with rect (0.6, 0.1, 0.35, 0.35) will be in the top right corner of the layout, with 35% width and height of the parent layout.\par
Note that the minimum and maximum sizes of the embedded element ({\b QCPLayoutElement::setMinimumSize}, {\b QCPLayoutElement::setMaximumSize}) are enforced. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4951 \{\par
 4952   if (elementAt(index))\par
 4953     mInsetRect[index] = rect;\par
 4954   else\par
 4955     qDebug() << Q_FUNC_INFO << "Invalid element index:" << index;\par
 4956 \}\par
}
}
{\xe \v simplify\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:simplify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutInset::simplify (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUM}
{\bkmkend AAAAAAACUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The QCPInsetLayout does not need simplification since it can never have empty cells due to its linear index structure. This method does nothing. \par
}{
Reimplemented from {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1444 \{\}\par
}
}
{\xe \v take\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:take}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayoutInset::take ({\b QCPLayoutElement} *  {\i element}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUQ}
{\bkmkend AAAAAAACUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i element}  from the layout and returns true on success.\par
If the {\i element}  isn't in this layout, returns false.\par
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element. To collapse empty cells, use {\b simplify}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b takeAt} \par
}}{
Implements {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5031 \{\par
 5032   if (element)\par
 5033   \{\par
 5034     for (int i=0; i<elementCount(); ++i)\par
 5035     \{\par
 5036       if (elementAt(i) == element)\par
 5037       \{\par
 5038         takeAt(i);\par
 5039         return true;\par
 5040       \}\par
 5041     \}\par
 5042     qDebug() << Q_FUNC_INFO << "Element not in this layout, couldn't take";\par
 5043   \} else\par
 5044     qDebug() << Q_FUNC_INFO << "Can't take null element";\par
 5045   return false;\par
 5046 \}\par
}
}
{\xe \v takeAt\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:takeAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutElement} * QCPLayoutInset::takeAt (int  {\i index}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUT}
{\bkmkend AAAAAAACUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the element with the given {\i index}  from the layout and returns it.\par
If the {\i index}  is invalid or the cell with that index is empty, returns 0.\par
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element. To collapse empty cells, use {\b simplify}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b elementAt}, {\b take} \par
}}{
Implements {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5013 \{\par
 5014   if (QCPLayoutElement *el = elementAt(index))\par
 5015   \{\par
 5016     releaseElement(el);\par
 5017     mElements.removeAt(index);\par
 5018     mInsetPlacement.removeAt(index);\par
 5019     mInsetAlignment.removeAt(index);\par
 5020     mInsetRect.removeAt(index);\par
 5021     return el;\par
 5022   \} else\par
 5023   \{\par
 5024     qDebug() << Q_FUNC_INFO << "Attempt to take invalid index:" << index;\par
 5025     return 0;\par
 5026   \}\par
 5027 \}\par
}
}
{\xe \v updateLayout\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:updateLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutInset::updateLayout (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACUX}
{\bkmkend AAAAAAACUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACUW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4960 \{\par
 4961   for (int i=0; i<mElements.size(); ++i)\par
 4962   \{\par
 4963     QCPLayoutElement *el = mElements.at(i);\par
 4964     QRect insetRect;\par
 4965     QSize finalMinSize = getFinalMinimumOuterSize(el);\par
 4966     QSize finalMaxSize = getFinalMaximumOuterSize(el);\par
 4967     if (mInsetPlacement.at(i) == ipFree)\par
 4968     \{\par
 4969       insetRect = QRect(rect().x()+rect().width()*mInsetRect.at(i).x(),\par
 4970                         rect().y()+rect().height()*mInsetRect.at(i).y(),\par
 4971                         rect().width()*mInsetRect.at(i).width(),\par
 4972                         rect().height()*mInsetRect.at(i).height());\par
 4973       if (insetRect.size().width() < finalMinSize.width())\par
 4974         insetRect.setWidth(finalMinSize.width());\par
 4975       if (insetRect.size().height() < finalMinSize.height())\par
 4976         insetRect.setHeight(finalMinSize.height());\par
 4977       if (insetRect.size().width() > finalMaxSize.width())\par
 4978         insetRect.setWidth(finalMaxSize.width());\par
 4979       if (insetRect.size().height() > finalMaxSize.height())\par
 4980         insetRect.setHeight(finalMaxSize.height());\par
 4981     \} else if (mInsetPlacement.at(i) == ipBorderAligned)\par
 4982     \{\par
 4983       insetRect.setSize(finalMinSize);\par
 4984       Qt::Alignment al = mInsetAlignment.at(i);\par
 4985       if (al.testFlag(Qt::AlignLeft)) insetRect.moveLeft(rect().x());\par
 4986       else if (al.testFlag(Qt::AlignRight)) insetRect.moveRight(rect().x()+rect().width());\par
 4987       else insetRect.moveLeft(rect().x()+rect().width()*0.5-finalMinSize.width()*0.5); // default to Qt::AlignHCenter\par
 4988       if (al.testFlag(Qt::AlignTop)) insetRect.moveTop(rect().y());\par
 4989       else if (al.testFlag(Qt::AlignBottom)) insetRect.moveBottom(rect().y()+rect().height());\par
 4990       else insetRect.moveTop(rect().y()+rect().height()*0.5-finalMinSize.height()*0.5); // default to Qt::AlignVCenter\par
 4991     \}\par
 4992     mElements.at(i)->setOuterRect(insetRect);\par
 4993   \}\par
 4994 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mElements\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:mElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPLayoutElement}*> QCPLayoutInset::mElements{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACZB}
{\bkmkend AAAAAAACZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInsetAlignment\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:mInsetAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<Qt::Alignment> QCPLayoutInset::mInsetAlignment{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACZC}
{\bkmkend AAAAAAACZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInsetPlacement\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:mInsetPlacement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b InsetPlacement}> QCPLayoutInset::mInsetPlacement{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACZD}
{\bkmkend AAAAAAACZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInsetRect\:QCPLayoutInset}
{\xe \v QCPLayoutInset\:mInsetRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QRectF> QCPLayoutInset::mInsetRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACZE}
{\bkmkend AAAAAAACZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPLegend Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPLegend}
{\xe \v QCPLegend}
{\bkmkstart AAAAAAACZF}
{\bkmkend AAAAAAACZF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a legend inside a {\b QCustomPlot}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPLegend:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_legend__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPLegend:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_legend__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SelectablePart} \{ {\b spNone} = 0x000, 
{\b spLegendBox} = 0x001, 
{\b spItems} = 0x002
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (QCPLegend::SelectableParts parts)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectableChanged} (QCPLegend::SelectableParts parts)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLegend} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPLegend} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b borderPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b font} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b textColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b iconSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iconTextPadding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b iconBorderPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b selectableParts} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b selectedParts} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedBorderPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedIconBorderPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b selectedBrush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b selectedFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b selectedTextColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBorderPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFont} (const QFont &{\b font})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTextColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIconSize} (const QSize &size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIconSize} (int width, int height)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIconTextPadding} (int padding)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIconBorderPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectableParts} (const SelectableParts &{\b selectableParts})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectedParts} (const SelectableParts &{\b selectedParts})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedBorderPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedIconBorderPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedFont} (const QFont &{\b font})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedTextColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractLegendItem} * {\b item} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPPlottableLegendItem} * {\b itemWithPlottable} (const {\b QCPAbstractPlottable} *plottable) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b itemCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasItem} ({\b QCPAbstractLegendItem} *{\b item}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasItemWithPlottable} (const {\b QCPAbstractPlottable} *plottable) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addItem} ({\b QCPAbstractLegendItem} *{\b item})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeItem} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeItem} ({\b QCPAbstractLegendItem} *{\b item})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearItems} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractLegendItem} * > {\b selectedItems} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parentPlotInitialized} ({\b QCustomPlot} *{\b parentPlot}) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b getBorderPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b getBrush} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mBorderPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mIconBorderPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mTextColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b mIconSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mIconTextPadding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b mSelectedParts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b mSelectableParts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedBorderPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedIconBorderPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mSelectedBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mSelectedFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mSelectedTextColor}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractLegendItem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a legend inside a {\b QCustomPlot}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A legend is a small box somewhere in the plot which lists plottables with their name and icon.\par
A legend is populated with legend items by calling {\b QCPAbstractPlottable::addToLegend} on the plottable, for which a legend item shall be created. In the case of the main legend ({\b QCustomPlot::legend}), simply adding plottables to the plot while {\b QCustomPlot::setAutoAddPlottableToLegend} is set to true (the default) creates corresponding legend items. The legend item associated with a certain plottable can be removed with {\b QCPAbstractPlottable::removeFromLegend}. However, {\b QCPLegend} also offers an interface to add and manipulate legend items directly: {\b item}, {\b itemWithPlottable}, {\b itemCount}, {\b addItem}, {\b removeItem}, etc.\par
Since {\b QCPLegend} derives from {\b QCPLayoutGrid}, it can be placed in any position a {\b QCPLayoutElement} may be positioned. The legend items are themselves {\b QCPLayoutElements} which are placed in the grid layout of the legend. {\b QCPLegend} only adds an interface specialized for handling child elements of type {\b QCPAbstractLegendItem}, as mentioned above. In principle, any other layout elements may also be added to a legend via the normal {\b QCPLayoutGrid} interface. See the special page about {\b The Layout System} for examples on how to add other elements to the legend and move it outside the axis rect.\par
Use the methods {\b setFillOrder} and {\b setWrap} inherited from {\b QCPLayoutGrid} to control in which order (column first or row first) the legend is filled up when calling {\b addItem}, and at which column or row wrapping occurs.\par
By default, every {\b QCustomPlot} has one legend ({\b QCustomPlot::legend}) which is placed in the inset layout of the main axis rect ({\b QCPAxisRect::insetLayout}). To move the legend to another position inside the axis rect, use the methods of the {\b QCPLayoutInset}. To move the legend outside of the axis rect, place it anywhere else with the {\b QCPLayout}/{\b QCPLayoutElement} interface. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v SelectablePart\:QCPLegend}
{\xe \v QCPLegend\:SelectablePart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPLegend::SelectablePart}}}
\par
{\bkmkstart AAAAAAACZG}
{\bkmkend AAAAAAACZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the selectable parts of a legend\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedParts}, {\b setSelectableParts} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v spNone\:QCPLegend}
{\xe \v QCPLegend\:spNone}
{\qr spNone{\bkmkstart AAAAAAACZH}
{\bkmkend AAAAAAACZH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x000}  None \par
}\cell }{\row }
{\xe \v spLegendBox\:QCPLegend}
{\xe \v QCPLegend\:spLegendBox}
{\qr spLegendBox{\bkmkstart AAAAAAACZI}
{\bkmkend AAAAAAACZI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x001}  The legend box (frame) \par
}\cell }{\row }
{\xe \v spItems\:QCPLegend}
{\xe \v QCPLegend\:spItems}
{\qr spItems{\bkmkstart AAAAAAACZJ}
{\bkmkend AAAAAAACZJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x002}  Legend items individually (see {\b selectedItems}) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4821                       \{ spNone        = 0x000 \par
 4822                         ,spLegendBox  = 0x001 \par
 4823                         ,spItems      = 0x002 \par
 4824                       \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPLegend\:QCPLegend}
{\xe \v QCPLegend\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLegend::QCPLegend (){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACZK}
{\bkmkend AAAAAAACZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b QCPLegend} instance with default values.\par
Note that by default, {\b QCustomPlot} already contains a legend ready to be used as {\b QCustomPlot::legend} \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18289 \{\par
18290   setFillOrder(QCPLayoutGrid::foRowsFirst);\par
18291   setWrap(0);\par
18292   \par
18293   setRowSpacing(3);\par
18294   setColumnSpacing(8);\par
18295   setMargins(QMargins(7, 5, 7, 4));\par
18296   setAntialiased(false);\par
18297   setIconSize(32, 18);\par
18298   \par
18299   setIconTextPadding(7);\par
18300   \par
18301   setSelectableParts(spLegendBox | spItems);\par
18302   setSelectedParts(spNone);\par
18303   \par
18304   setBorderPen(QPen(Qt::black, 0));\par
18305   setSelectedBorderPen(QPen(Qt::blue, 2));\par
18306   setIconBorderPen(Qt::NoPen);\par
18307   setSelectedIconBorderPen(QPen(Qt::blue, 2));\par
18308   setBrush(Qt::white);\par
18309   setSelectedBrush(Qt::white);\par
18310   setTextColor(Qt::black);\par
18311   setSelectedTextColor(Qt::blue);\par
18312 \}\par
}
}
{\xe \v ~QCPLegend\:QCPLegend}
{\xe \v QCPLegend\:~QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLegend::~QCPLegend (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACZL}
{\bkmkend AAAAAAACZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18315 \{\par
18316   clearItems();\par
18317   if (qobject_cast<QCustomPlot*>(mParentPlot)) // make sure this isn't called from QObject dtor when QCustomPlot is already destructed (happens when the legend is not in any layout and thus QObject-child of QCustomPlot)\par
18318     mParentPlot->legendRemoved(this);\par
18319 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addItem\:QCPLegend}
{\xe \v QCPLegend\:addItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLegend::addItem ({\b QCPAbstractLegendItem} *  {\i item})}}
\par
{\bkmkstart AAAAAAACZM}
{\bkmkend AAAAAAACZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\i item}  to the legend, if it's not present already. The element is arranged according to the current fill order ({\b setFillOrder}) and wrapping ({\b setWrap}).\par
Returns true on sucess, i.e. if the item wasn't in the list already and has been successfuly added.\par
The legend takes ownership of the item.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeItem}, {\b item}, {\b hasItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18644 \{\par
18645   return addElement(item);\par
18646 \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPLegend}
{\xe \v QCPLegend\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSE}
{\bkmkend AAAAAAACSE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18738 \{\par
18739   applyAntialiasingHint(painter, mAntialiased, QCP::aeLegend);\par
18740 \}\par
}
}
{\xe \v borderPen\:QCPLegend}
{\xe \v QCPLegend\:borderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPLegend::borderPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACZN}
{\bkmkend AAAAAAACZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4833 \{ return mBorderPen; \}\par
}
}
{\xe \v brush\:QCPLegend}
{\xe \v QCPLegend\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPLegend::brush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACZO}
{\bkmkend AAAAAAACZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4834 \{ return mBrush; \}\par
}
}
{\xe \v clearItems\:QCPLegend}
{\xe \v QCPLegend\:clearItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::clearItems ()}}
\par
{\bkmkstart AAAAAAACZP}
{\bkmkend AAAAAAACZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all items from the legend. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18697 \{\par
18698   for (int i=itemCount()-1; i>=0; --i)\par
18699     removeItem(i);\par
18700 \}\par
}
}
{\xe \v deselectEvent\:QCPLegend}
{\xe \v QCPLegend\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSH}
{\bkmkend AAAAAAACSH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18806 \{\par
18807   mSelectedParts = selectedParts(); // in case item selection has changed\par
18808   if (mSelectableParts.testFlag(spLegendBox))\par
18809   \{\par
18810     SelectableParts selBefore = mSelectedParts;\par
18811     setSelectedParts(selectedParts() & ~spLegendBox);\par
18812     if (selectionStateChanged)\par
18813       *selectionStateChanged = mSelectedParts != selBefore;\par
18814   \}\par
18815 \}\par
}
}
{\xe \v draw\:QCPLegend}
{\xe \v QCPLegend\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSJ}
{\bkmkend AAAAAAACSJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18768 \{\par
18769   // draw background rect:\par
18770   painter->setBrush(getBrush());\par
18771   painter->setPen(getBorderPen());\par
18772   painter->drawRect(mOuterRect);\par
18773 \}\par
}
}
{\xe \v font\:QCPLegend}
{\xe \v QCPLegend\:font}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPLegend::font () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACZQ}
{\bkmkend AAAAAAACZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4835 \{ return mFont; \}\par
}
}
{\xe \v getBorderPen\:QCPLegend}
{\xe \v QCPLegend\:getBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPLegend::getBorderPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACZR}
{\bkmkend AAAAAAACZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18748 \{\par
18749   return mSelectedParts.testFlag(spLegendBox) ? mSelectedBorderPen : mBorderPen;\par
18750 \}\par
}
}
{\xe \v getBrush\:QCPLegend}
{\xe \v QCPLegend\:getBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPLegend::getBrush () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACZS}
{\bkmkend AAAAAAACZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18758 \{\par
18759   return mSelectedParts.testFlag(spLegendBox) ? mSelectedBrush : mBrush;\par
18760 \}\par
}
}
{\xe \v hasItem\:QCPLegend}
{\xe \v QCPLegend\:hasItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLegend::hasItem ({\b QCPAbstractLegendItem} *  {\i item}) const}}
\par
{\bkmkstart AAAAAAACZT}
{\bkmkend AAAAAAACZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the legend contains {\i item} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b hasItemWithPlottable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18613 \{\par
18614   for (int i=0; i<itemCount(); ++i)\par
18615   \{\par
18616     if (item == this->item(i))\par
18617         return true;\par
18618   \}\par
18619   return false;\par
18620 \}\par
}
}
{\xe \v hasItemWithPlottable\:QCPLegend}
{\xe \v QCPLegend\:hasItemWithPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLegend::hasItemWithPlottable (const {\b QCPAbstractPlottable} *  {\i plottable}) const}}
\par
{\bkmkstart AAAAAAACZU}
{\bkmkend AAAAAAACZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the legend contains a {\b QCPPlottableLegendItem} which is associated with {\i plottable}  (e.g. a {\b QCPGraph}*). If such an item isn't in the legend, returns false.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemWithPlottable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18629 \{\par
18630   return itemWithPlottable(plottable);\par
18631 \}\par
}
}
{\xe \v iconBorderPen\:QCPLegend}
{\xe \v QCPLegend\:iconBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPLegend::iconBorderPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACZV}
{\bkmkend AAAAAAACZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4839 \{ return mIconBorderPen; \}\par
}
}
{\xe \v iconSize\:QCPLegend}
{\xe \v QCPLegend\:iconSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLegend::iconSize () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACZW}
{\bkmkend AAAAAAACZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4837 \{ return mIconSize; \}\par
}
}
{\xe \v iconTextPadding\:QCPLegend}
{\xe \v QCPLegend\:iconTextPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLegend::iconTextPadding () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACZX}
{\bkmkend AAAAAAACZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4838 \{ return mIconTextPadding; \}\par
}
}
{\xe \v item\:QCPLegend}
{\xe \v QCPLegend\:item}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractLegendItem} * QCPLegend::item (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAACZY}
{\bkmkend AAAAAAACZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the item with index {\i i} .\par
Note that the linear index depends on the current fill order ({\b setFillOrder}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemCount}, {\b addItem}, {\b itemWithPlottable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18571 \{\par
18572   return qobject_cast<QCPAbstractLegendItem*>(elementAt(index));\par
18573 \}\par
}
}
{\xe \v itemCount\:QCPLegend}
{\xe \v QCPLegend\:itemCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLegend::itemCount () const}}
\par
{\bkmkstart AAAAAAACZZ}
{\bkmkend AAAAAAACZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of items currently in the legend.\par
Note that if empty cells are in the legend (e.g. by calling methods of the {\b QCPLayoutGrid} base class which allows creating empty cells), they are included in the returned count.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b item} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18603 \{\par
18604   return elementCount();\par
18605 \}\par
}
}
{\xe \v itemWithPlottable\:QCPLegend}
{\xe \v QCPLegend\:itemWithPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPPlottableLegendItem} * QCPLegend::itemWithPlottable (const {\b QCPAbstractPlottable} *  {\i plottable}) const}}
\par
{\bkmkstart AAAAAAADAA}
{\bkmkend AAAAAAADAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b QCPPlottableLegendItem} which is associated with {\i plottable}  (e.g. a {\b QCPGraph}*). If such an item isn't in the legend, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b hasItemWithPlottable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18582 \{\par
18583   for (int i=0; i<itemCount(); ++i)\par
18584   \{\par
18585     if (QCPPlottableLegendItem *pli = qobject_cast<QCPPlottableLegendItem*>(item(i)))\par
18586     \{\par
18587       if (pli->plottable() == plottable)\par
18588         return pli;\par
18589     \}\par
18590   \}\par
18591   return 0;\par
18592 \}\par
}
}
{\xe \v parentPlotInitialized\:QCPLegend}
{\xe \v QCPLegend\:parentPlotInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::parentPlotInitialized ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSW}
{\bkmkend AAAAAAACSW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18831 \{\par
18832   if (parentPlot && !parentPlot->legend)\par
18833     parentPlot->legend = this;\par
18834 \}\par
}
}
{\xe \v removeItem\:QCPLegend}
{\xe \v QCPLegend\:removeItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLegend::removeItem (int  {\i index})}}
\par
{\bkmkstart AAAAAAADAB}
{\bkmkend AAAAAAADAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Removes the item with the specified {\i index}  from the legend and deletes it.\par
After successful removal, the legend is reordered according to the current fill order ({\b setFillOrder}) and wrapping ({\b setWrap}), so no empty cell remains where the removed {\i item}  was. If you don't want this, rather use the raw element interface of {\b QCPLayoutGrid}.\par
Returns true, if successful. Unlike {\b QCPLayoutGrid::removeAt}, this method only removes elements derived from {\b QCPAbstractLegendItem}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemCount}, {\b clearItems} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18662 \{\par
18663   if (QCPAbstractLegendItem *ali = item(index))\par
18664   \{\par
18665     bool success = remove(ali);\par
18666     if (success)\par
18667       setFillOrder(fillOrder(), true); // gets rid of empty cell by reordering\par
18668     return success;\par
18669   \} else\par
18670     return false;\par
18671 \}\par
}
}
{\xe \v removeItem\:QCPLegend}
{\xe \v QCPLegend\:removeItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLegend::removeItem ({\b QCPAbstractLegendItem} *  {\i item})}}
\par
{\bkmkstart AAAAAAADAC}
{\bkmkend AAAAAAADAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Removes {\i item}  from the legend and deletes it.\par
After successful removal, the legend is reordered according to the current fill order ({\b setFillOrder}) and wrapping ({\b setWrap}), so no empty cell remains where the removed {\i item}  was. If you don't want this, rather use the raw element interface of {\b QCPLayoutGrid}.\par
Returns true, if successful.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clearItems} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18686 \{\par
18687   bool success = remove(item);\par
18688   if (success)\par
18689     setFillOrder(fillOrder(), true); // gets rid of empty cell by reordering\par
18690   return success;\par
18691 \}\par
}
}
{\xe \v selectableChanged\:QCPLegend}
{\xe \v QCPLegend\:selectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::selectableChanged (QCPLegend::SelectableParts  {\i parts}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADAD}
{\bkmkend AAAAAAADAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v selectableParts\:QCPLegend}
{\xe \v QCPLegend\:selectableParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPLegend::selectableParts () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADAE}
{\bkmkend AAAAAAADAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4840 \{ return mSelectableParts; \}\par
}
}
{\xe \v selectedBorderPen\:QCPLegend}
{\xe \v QCPLegend\:selectedBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPLegend::selectedBorderPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADAF}
{\bkmkend AAAAAAADAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4842 \{ return mSelectedBorderPen; \}\par
}
}
{\xe \v selectedBrush\:QCPLegend}
{\xe \v QCPLegend\:selectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPLegend::selectedBrush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADAG}
{\bkmkend AAAAAAADAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4844 \{ return mSelectedBrush; \}\par
}
}
{\xe \v selectedFont\:QCPLegend}
{\xe \v QCPLegend\:selectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPLegend::selectedFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADAH}
{\bkmkend AAAAAAADAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4845 \{ return mSelectedFont; \}\par
}
}
{\xe \v selectedIconBorderPen\:QCPLegend}
{\xe \v QCPLegend\:selectedIconBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPLegend::selectedIconBorderPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADAI}
{\bkmkend AAAAAAADAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4843 \{ return mSelectedIconBorderPen; \}\par
}
}
{\xe \v selectedItems\:QCPLegend}
{\xe \v QCPLegend\:selectedItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractLegendItem} * > QCPLegend::selectedItems () const}}
\par
{\bkmkstart AAAAAAADAJ}
{\bkmkend AAAAAAADAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the legend items that are currently selected. If no items are selected, the list is empty.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractLegendItem::setSelected}, setSelectable \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18709 \{\par
18710   QList<QCPAbstractLegendItem*> result;\par
18711   for (int i=0; i<itemCount(); ++i)\par
18712   \{\par
18713     if (QCPAbstractLegendItem *ali = item(i))\par
18714     \{\par
18715       if (ali->selected())\par
18716         result.append(ali);\par
18717     \}\par
18718   \}\par
18719   return result;\par
18720 \}\par
}
}
{\xe \v selectedParts\:QCPLegend}
{\xe \v QCPLegend\:selectedParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLegend::SelectableParts QCPLegend::selectedParts () const}}
\par
{\bkmkstart AAAAAAADAK}
{\bkmkend AAAAAAADAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18323 \{\par
18324   // check whether any legend elements selected, if yes, add spItems to return value\par
18325   bool hasSelectedItems = false;\par
18326   for (int i=0; i<itemCount(); ++i)\par
18327   \{\par
18328     if (item(i) && item(i)->selected())\par
18329     \{\par
18330       hasSelectedItems = true;\par
18331       break;\par
18332     \}\par
18333   \}\par
18334   if (hasSelectedItems)\par
18335     return mSelectedParts | spItems;\par
18336   else\par
18337     return mSelectedParts & ~spItems;\par
18338 \}\par
}
}
{\xe \v selectedTextColor\:QCPLegend}
{\xe \v QCPLegend\:selectedTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPLegend::selectedTextColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADAL}
{\bkmkend AAAAAAADAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4846 \{ return mSelectedTextColor; \}\par
}
}
{\xe \v selectEvent\:QCPLegend}
{\xe \v QCPLegend\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACTA}
{\bkmkend AAAAAAACTA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18792 \{\par
18793   Q_UNUSED(event)\par
18794   mSelectedParts = selectedParts(); // in case item selection has changed\par
18795   if (details.value<SelectablePart>() == spLegendBox && mSelectableParts.testFlag(spLegendBox))\par
18796   \{\par
18797     SelectableParts selBefore = mSelectedParts;\par
18798     setSelectedParts(additive ? mSelectedParts^spLegendBox : mSelectedParts|spLegendBox); // no need to unset spItems in !additive case, because they will be deselected by QCustomPlot (they're normal QCPLayerables with own deselectEvent)\par
18799     if (selectionStateChanged)\par
18800       *selectionStateChanged = mSelectedParts != selBefore;\par
18801   \}\par
18802 \}\par
}
}
{\xe \v selectionCategory\:QCPLegend}
{\xe \v QCPLegend\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPLegend::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACTB}
{\bkmkend AAAAAAACTB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18819 \{\par
18820   return QCP::iSelectLegend;\par
18821 \}\par
}
}
{\xe \v selectionChanged\:QCPLegend}
{\xe \v QCPLegend\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::selectionChanged (QCPLegend::SelectableParts  {\i selection}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADAM}
{\bkmkend AAAAAAADAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this legend has changed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedParts}, {\b setSelectableParts} \par
}}}
{\xe \v selectTest\:QCPLegend}
{\xe \v QCPLegend\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLegend::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACTD}
{\bkmkend AAAAAAACTD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layout elements are sensitive to events inside their outer rect. If {\i pos}  is within the outer rect, this method returns a value corresponding to 0.99 times the parent plot's selection tolerance. However, layout elements are not selectable by default. So if {\i onlySelectable}  is true, -1.0 is returned.\par
See {\b QCPLayerable::selectTest} for a general explanation of this virtual method.\par
{\b QCPLayoutElement} subclasses may reimplement this method to provide more specific selection test behaviour. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18777 \{\par
18778   if (!mParentPlot) return -1;\par
18779   if (onlySelectable && !mSelectableParts.testFlag(spLegendBox))\par
18780     return -1;\par
18781   \par
18782   if (mOuterRect.contains(pos.toPoint()))\par
18783   \{\par
18784     if (details) details->setValue(spLegendBox);\par
18785     return mParentPlot->selectionTolerance()*0.99;\par
18786   \}\par
18787   return -1;\par
18788 \}\par
}
}
{\xe \v setBorderPen\:QCPLegend}
{\xe \v QCPLegend\:setBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setBorderPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADAN}
{\bkmkend AAAAAAADAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen, the border of the entire legend is drawn with. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18344 \{\par
18345   mBorderPen = pen;\par
18346 \}\par
}
}
{\xe \v setBrush\:QCPLegend}
{\xe \v QCPLegend\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAADAO}
{\bkmkend AAAAAAADAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush of the legend background. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18352 \{\par
18353   mBrush = brush;\par
18354 \}\par
}
}
{\xe \v setFont\:QCPLegend}
{\xe \v QCPLegend\:setFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAADAP}
{\bkmkend AAAAAAADAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the default font of legend text. Legend items that draw text (e.g. the name of a graph) will use this font by default. However, a different font can be specified on a per-item-basis by accessing the specific legend item.\par
This function will also set {\i font}  on all already existing legend items.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractLegendItem::setFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18366 \{\par
18367   mFont = font;\par
18368   for (int i=0; i<itemCount(); ++i)\par
18369   \{\par
18370     if (item(i))\par
18371       item(i)->setFont(mFont);\par
18372   \}\par
18373 \}\par
}
}
{\xe \v setIconBorderPen\:QCPLegend}
{\xe \v QCPLegend\:setIconBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setIconBorderPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADAQ}
{\bkmkend AAAAAAADAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen used to draw a border around each legend icon. Legend items that draw an icon (e.g. a visual representation of the graph) will use this pen by default.\par
If no border is wanted, set this to {\i Qt::NoPen} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18428 \{\par
18429   mIconBorderPen = pen;\par
18430 \}\par
}
}
{\xe \v setIconSize\:QCPLegend}
{\xe \v QCPLegend\:setIconSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setIconSize (const QSize &  {\i size})}}
\par
{\bkmkstart AAAAAAADAR}
{\bkmkend AAAAAAADAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the size of legend icons. Legend items that draw an icon (e.g. a visual representation of the graph) will use this size by default. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18399 \{\par
18400   mIconSize = size;\par
18401 \}\par
}
}
{\xe \v setIconSize\:QCPLegend}
{\xe \v QCPLegend\:setIconSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setIconSize (int  {\i width}, int  {\i height})}}
\par
{\bkmkstart AAAAAAADAS}
{\bkmkend AAAAAAADAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18406 \{\par
18407   mIconSize.setWidth(width);\par
18408   mIconSize.setHeight(height);\par
18409 \}\par
}
}
{\xe \v setIconTextPadding\:QCPLegend}
{\xe \v QCPLegend\:setIconTextPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setIconTextPadding (int  {\i padding})}}
\par
{\bkmkstart AAAAAAADAT}
{\bkmkend AAAAAAADAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the horizontal space in pixels between the legend icon and the text next to it. Legend items that draw an icon (e.g. a visual representation of the graph) and text (e.g. the name of the graph) will use this space by default. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18417 \{\par
18418   mIconTextPadding = padding;\par
18419 \}\par
}
}
{\xe \v setSelectableParts\:QCPLegend}
{\xe \v QCPLegend\:setSelectableParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setSelectableParts (const SelectableParts &  {\i selectable})}}
\par
{\bkmkstart AAAAAAADAU}
{\bkmkend AAAAAAADAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the user can (de-)select the parts in {\i selectable}  by clicking on the {\b QCustomPlot} surface. (When {\b QCustomPlot::setInteractions} contains {\b QCP::iSelectLegend}.)\par
However, even when {\i selectable}  is set to a value not allowing the selection of a specific part, it is still possible to set the selection of this part manually, by calling {\b setSelectedParts} directly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SelectablePart}, {\b setSelectedParts} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18443 \{\par
18444   if (mSelectableParts != selectable)\par
18445   \{\par
18446     mSelectableParts = selectable;\par
18447     emit selectableChanged(mSelectableParts);\par
18448   \}\par
18449 \}\par
}
}
{\xe \v setSelectedBorderPen\:QCPLegend}
{\xe \v QCPLegend\:setSelectedBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setSelectedBorderPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADAV}
{\bkmkend AAAAAAADAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the legend box is selected, this pen is used to draw the border instead of the normal pen set via {\b setBorderPen}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedParts}, {\b setSelectableParts}, {\b setSelectedBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18504 \{\par
18505   mSelectedBorderPen = pen;\par
18506 \}\par
}
}
{\xe \v setSelectedBrush\:QCPLegend}
{\xe \v QCPLegend\:setSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setSelectedBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAADAW}
{\bkmkend AAAAAAADAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the legend box is selected, this brush is used to draw the legend background instead of the normal brush set via {\b setBrush}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedParts}, {\b setSelectableParts}, {\b setSelectedBorderPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18525 \{\par
18526   mSelectedBrush = brush;\par
18527 \}\par
}
}
{\xe \v setSelectedFont\:QCPLegend}
{\xe \v QCPLegend\:setSelectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setSelectedFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAADAX}
{\bkmkend AAAAAAADAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the default font that is used by legend items when they are selected.\par
This function will also set {\i font}  on all already existing legend items.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFont}, {\b QCPAbstractLegendItem::setSelectedFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18537 \{\par
18538   mSelectedFont = font;\par
18539   for (int i=0; i<itemCount(); ++i)\par
18540   \{\par
18541     if (item(i))\par
18542       item(i)->setSelectedFont(font);\par
18543   \}\par
18544 \}\par
}
}
{\xe \v setSelectedIconBorderPen\:QCPLegend}
{\xe \v QCPLegend\:setSelectedIconBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setSelectedIconBorderPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADAY}
{\bkmkend AAAAAAADAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen legend items will use to draw their icon borders, when they are selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedParts}, {\b setSelectableParts}, {\b setSelectedFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18514 \{\par
18515   mSelectedIconBorderPen = pen;\par
18516 \}\par
}
}
{\xe \v setSelectedParts\:QCPLegend}
{\xe \v QCPLegend\:setSelectedParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setSelectedParts (const SelectableParts &  {\i selected})}}
\par
{\bkmkstart AAAAAAADAZ}
{\bkmkend AAAAAAADAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the selected state of the respective legend parts described by {\b SelectablePart}. When a part is selected, it uses a different pen/font and brush. If some legend items are selected and {\i selected}  doesn't contain {\b spItems}, those items become deselected.\par
The entire selection mechanism is handled automatically when {\b QCustomPlot::setInteractions} contains iSelectLegend. You only need to call this function when you wish to change the selection state manually.\par
This function can change the selection state of a part even when {\b setSelectableParts} was set to a value that actually excludes the part.\par
emits the {\b selectionChanged} signal when {\i selected}  is different from the previous selection state.\par
Note that it doesn't make sense to set the selected state {\b spItems} here when it wasn't set before, because there's no way to specify which exact items to newly select. Do this by calling {\b QCPAbstractLegendItem::setSelected} directly on the legend item you wish to select.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SelectablePart}, {\b setSelectableParts}, {\b selectTest}, {\b setSelectedBorderPen}, {\b setSelectedIconBorderPen}, {\b setSelectedBrush}, {\b setSelectedFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18473 \{\par
18474   SelectableParts newSelected = selected;\par
18475   mSelectedParts = this->selectedParts(); // update mSelectedParts in case item selection changed\par
18476 \par
18477   if (mSelectedParts != newSelected)\par
18478   \{\par
18479     if (!mSelectedParts.testFlag(spItems) && newSelected.testFlag(spItems)) // attempt to set spItems flag (can't do that)\par
18480     \{\par
18481       qDebug() << Q_FUNC_INFO << "spItems flag can not be set, it can only be unset with this function";\par
18482       newSelected &= ~spItems;\par
18483     \}\par
18484     if (mSelectedParts.testFlag(spItems) && !newSelected.testFlag(spItems)) // spItems flag was unset, so clear item selection\par
18485     \{\par
18486       for (int i=0; i<itemCount(); ++i)\par
18487       \{\par
18488         if (item(i))\par
18489           item(i)->setSelected(false);\par
18490       \}\par
18491     \}\par
18492     mSelectedParts = newSelected;\par
18493     emit selectionChanged(mSelectedParts);\par
18494   \}\par
18495 \}\par
}
}
{\xe \v setSelectedTextColor\:QCPLegend}
{\xe \v QCPLegend\:setSelectedTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setSelectedTextColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAADBA}
{\bkmkend AAAAAAADBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the default text color that is used by legend items when they are selected.\par
This function will also set {\i color}  on all already existing legend items.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTextColor}, {\b QCPAbstractLegendItem::setSelectedTextColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18554 \{\par
18555   mSelectedTextColor = color;\par
18556   for (int i=0; i<itemCount(); ++i)\par
18557   \{\par
18558     if (item(i))\par
18559       item(i)->setSelectedTextColor(color);\par
18560   \}\par
18561 \}\par
}
}
{\xe \v setTextColor\:QCPLegend}
{\xe \v QCPLegend\:setTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLegend::setTextColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAADBB}
{\bkmkend AAAAAAADBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the default color of legend text. Legend items that draw text (e.g. the name of a graph) will use this color by default. However, a different colors can be specified on a per-item-basis by accessing the specific legend item.\par
This function will also set {\i color}  on all already existing legend items.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractLegendItem::setTextColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18385 \{\par
18386   mTextColor = color;\par
18387   for (int i=0; i<itemCount(); ++i)\par
18388   \{\par
18389     if (item(i))\par
18390       item(i)->setTextColor(color);\par
18391   \}\par
18392 \}\par
}
}
{\xe \v textColor\:QCPLegend}
{\xe \v QCPLegend\:textColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPLegend::textColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADBC}
{\bkmkend AAAAAAADBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4836 \{ return mTextColor; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPAbstractLegendItem\:QCPLegend}
{\xe \v QCPLegend\:QCPAbstractLegendItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAbstractLegendItem}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADBD}
{\bkmkend AAAAAAADBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPLegend}
{\xe \v QCPLegend\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADBE}
{\bkmkend AAAAAAADBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBorderPen\:QCPLegend}
{\xe \v QCPLegend\:mBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPLegend::mBorderPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBF}
{\bkmkend AAAAAAADBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBrush\:QCPLegend}
{\xe \v QCPLegend\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPLegend::mBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBG}
{\bkmkend AAAAAAADBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mFont\:QCPLegend}
{\xe \v QCPLegend\:mFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPLegend::mFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBH}
{\bkmkend AAAAAAADBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mIconBorderPen\:QCPLegend}
{\xe \v QCPLegend\:mIconBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPLegend::mIconBorderPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBI}
{\bkmkend AAAAAAADBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mIconSize\:QCPLegend}
{\xe \v QCPLegend\:mIconSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLegend::mIconSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBJ}
{\bkmkend AAAAAAADBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mIconTextPadding\:QCPLegend}
{\xe \v QCPLegend\:mIconTextPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPLegend::mIconTextPadding{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBK}
{\bkmkend AAAAAAADBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectableParts\:QCPLegend}
{\xe \v QCPLegend\:mSelectableParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPLegend::mSelectableParts{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBL}
{\bkmkend AAAAAAADBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedBorderPen\:QCPLegend}
{\xe \v QCPLegend\:mSelectedBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPLegend::mSelectedBorderPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBM}
{\bkmkend AAAAAAADBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedBrush\:QCPLegend}
{\xe \v QCPLegend\:mSelectedBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPLegend::mSelectedBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBN}
{\bkmkend AAAAAAADBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedFont\:QCPLegend}
{\xe \v QCPLegend\:mSelectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPLegend::mSelectedFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBO}
{\bkmkend AAAAAAADBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedIconBorderPen\:QCPLegend}
{\xe \v QCPLegend\:mSelectedIconBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPLegend::mSelectedIconBorderPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBP}
{\bkmkend AAAAAAADBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedParts\:QCPLegend}
{\xe \v QCPLegend\:mSelectedParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPLegend::mSelectedParts{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBQ}
{\bkmkend AAAAAAADBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedTextColor\:QCPLegend}
{\xe \v QCPLegend\:mSelectedTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPLegend::mSelectedTextColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBR}
{\bkmkend AAAAAAADBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTextColor\:QCPLegend}
{\xe \v QCPLegend\:mTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPLegend::mTextColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADBS}
{\bkmkend AAAAAAADBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPLineEnding Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPLineEnding}
{\xe \v QCPLineEnding}
{\bkmkstart AAAAAAADBT}
{\bkmkend AAAAAAADBT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handles the different ending decorations for line-like items. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPLineEnding:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_line_ending__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b EndingStyle} \{ {\b esNone}, 
{\b esFlatArrow}, 
{\b esSpikeArrow}, 
{\b esLineArrow}, 
{\b esDisc}, 
{\b esSquare}, 
{\b esDiamond}, 
{\b esBar}, 
{\b esHalfBar}, 
{\b esSkewedBar}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} ({\b EndingStyle} {\b style}, double {\b width}=8, double {\b length}=10, bool {\b inverted}=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EndingStyle} {\b style} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b width} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b length} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b inverted} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setStyle} ({\b EndingStyle} {\b style})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWidth} (double {\b width})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLength} (double {\b length})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInverted} (bool {\b inverted})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b boundingDistance} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b realLength} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b draw} ({\b QCPPainter} *painter, const {\b QCPVector2D} &pos, const {\b QCPVector2D} &dir) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b draw} ({\b QCPPainter} *painter, const {\b QCPVector2D} &pos, double angle) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EndingStyle} {\b mStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mLength}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mInverted}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handles the different ending decorations for line-like items. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
 For every ending a line-like item has, an instance of this class exists. For example, {\b QCPItemLine} has two endings which can be set with {\b QCPItemLine::setHead} and {\b QCPItemLine::setTail}.\par
The styles themselves are defined via the enum {\b QCPLineEnding::EndingStyle}. Most decorations can be modified regarding width and length, see {\b setWidth} and {\b setLength}. The direction of the ending decoration (e.g. direction an arrow is pointing) is controlled by the line-like item. For example, when both endings of a {\b QCPItemLine} are set to be arrows, they will point to opposite directions, e.g. "outward". This can be changed by {\b setInverted}, which would make the respective arrow point inward.\par
Note that due to the overloaded {\b QCPLineEnding} constructor, you may directly specify a {\b QCPLineEnding::EndingStyle} where actually a {\b QCPLineEnding} is expected, e.g. {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v EndingStyle\:QCPLineEnding}
{\xe \v QCPLineEnding\:EndingStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPLineEnding::EndingStyle}}}
\par
{\bkmkstart AAAAAAADBU}
{\bkmkend AAAAAAADBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the type of ending decoration for line-like items, e.g. an arrow.\par
The width and length of these decorations can be controlled with the functions {\b setWidth} and {\b setLength}. Some decorations like {\b esDisc}, {\b esSquare}, {\b esDiamond} and {\b esBar} only support a width, the length property is ignored.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPItemLine::setHead}, {\b QCPItemLine::setTail}, {\b QCPItemCurve::setHead}, {\b QCPItemCurve::setTail}, {\b QCPAxis::setLowerEnding}, {\b QCPAxis::setUpperEnding} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v esNone\:QCPLineEnding}
{\xe \v QCPLineEnding\:esNone}
{\qr esNone{\bkmkstart AAAAAAADBV}
{\bkmkend AAAAAAADBV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No ending decoration. \par
}\cell }{\row }
{\xe \v esFlatArrow\:QCPLineEnding}
{\xe \v QCPLineEnding\:esFlatArrow}
{\qr esFlatArrow{\bkmkstart AAAAAAADBW}
{\bkmkend AAAAAAADBW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A filled arrow head with a straight/flat back (a triangle) \par
}\cell }{\row }
{\xe \v esSpikeArrow\:QCPLineEnding}
{\xe \v QCPLineEnding\:esSpikeArrow}
{\qr esSpikeArrow{\bkmkstart AAAAAAADBX}
{\bkmkend AAAAAAADBX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A filled arrow head with an indented back. \par
}\cell }{\row }
{\xe \v esLineArrow\:QCPLineEnding}
{\xe \v QCPLineEnding\:esLineArrow}
{\qr esLineArrow{\bkmkstart AAAAAAADBY}
{\bkmkend AAAAAAADBY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A non-filled arrow head with open back. \par
}\cell }{\row }
{\xe \v esDisc\:QCPLineEnding}
{\xe \v QCPLineEnding\:esDisc}
{\qr esDisc{\bkmkstart AAAAAAADBZ}
{\bkmkend AAAAAAADBZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A filled circle. \par
}\cell }{\row }
{\xe \v esSquare\:QCPLineEnding}
{\xe \v QCPLineEnding\:esSquare}
{\qr esSquare{\bkmkstart AAAAAAADCA}
{\bkmkend AAAAAAADCA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A filled square. \par
}\cell }{\row }
{\xe \v esDiamond\:QCPLineEnding}
{\xe \v QCPLineEnding\:esDiamond}
{\qr esDiamond{\bkmkstart AAAAAAADCB}
{\bkmkend AAAAAAADCB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A filled diamond (45 degrees rotated square) \par
}\cell }{\row }
{\xe \v esBar\:QCPLineEnding}
{\xe \v QCPLineEnding\:esBar}
{\qr esBar{\bkmkstart AAAAAAADCC}
{\bkmkend AAAAAAADCC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bar perpendicular to the line. \par
}\cell }{\row }
{\xe \v esHalfBar\:QCPLineEnding}
{\xe \v QCPLineEnding\:esHalfBar}
{\qr esHalfBar{\bkmkstart AAAAAAADCD}
{\bkmkend AAAAAAADCD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bar perpendicular to the line, pointing out to only one side (to which side can be changed with {\b setInverted}) \par
}\cell }{\row }
{\xe \v esSkewedBar\:QCPLineEnding}
{\xe \v QCPLineEnding\:esSkewedBar}
{\qr esSkewedBar{\bkmkstart AAAAAAADCE}
{\bkmkend AAAAAAADCE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bar that is skewed (skew controllable via {\b setLength}) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1484                    \{ esNone          \par
 1485                      ,esFlatArrow    \par
 1486                      ,esSpikeArrow   \par
 1487                      ,esLineArrow    \par
 1488                      ,esDisc         \par
 1489                      ,esSquare       \par
 1490                      ,esDiamond      \par
 1491                      ,esBar          \par
 1492                      ,esHalfBar      \par
 1493                      ,esSkewedBar    \par
 1494                    \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPLineEnding\:QCPLineEnding}
{\xe \v QCPLineEnding\:QCPLineEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLineEnding::QCPLineEnding ()}}
\par
{\bkmkstart AAAAAAADCF}
{\bkmkend AAAAAAADCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPLineEnding} instance with default values (style {\b esNone}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5157                              :\par
 5158   mStyle(esNone),\par
 5159   mWidth(8),\par
 5160   mLength(10),\par
 5161   mInverted(false)\par
 5162 \{\par
 5163 \}\par
}
}
{\xe \v QCPLineEnding\:QCPLineEnding}
{\xe \v QCPLineEnding\:QCPLineEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPLineEnding::QCPLineEnding ({\b QCPLineEnding::EndingStyle}  {\i style}, double  {\i width} = {\f2 8}, double  {\i length} = {\f2 10}, bool  {\i inverted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAADCG}
{\bkmkend AAAAAAADCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPLineEnding} instance with the specified values. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5168                                                                                                        :\par
 5169   mStyle(style),\par
 5170   mWidth(width),\par
 5171   mLength(length),\par
 5172   mInverted(inverted)\par
 5173 \{\par
 5174 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v boundingDistance\:QCPLineEnding}
{\xe \v QCPLineEnding\:boundingDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLineEnding::boundingDistance () const}}
\par
{\bkmkstart AAAAAAADCH}
{\bkmkend AAAAAAADCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5229 \{\par
 5230   switch (mStyle)\par
 5231   \{\par
 5232     case esNone:\par
 5233       return 0;\par
 5234       \par
 5235     case esFlatArrow:\par
 5236     case esSpikeArrow:\par
 5237     case esLineArrow:\par
 5238     case esSkewedBar:\par
 5239       return qSqrt(mWidth*mWidth+mLength*mLength); // items that have width and length\par
 5240       \par
 5241     case esDisc:\par
 5242     case esSquare:\par
 5243     case esDiamond:\par
 5244     case esBar:\par
 5245     case esHalfBar:\par
 5246       return mWidth*1.42; // items that only have a width -> width*sqrt(2)\par
 5247 \par
 5248   \}\par
 5249   return 0;\par
 5250 \}\par
}
}
{\xe \v draw\:QCPLineEnding}
{\xe \v QCPLineEnding\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLineEnding::draw ({\b QCPPainter} *  {\i painter}, const {\b QCPVector2D} &  {\i pos}, const {\b QCPVector2D} &  {\i dir}) const}}
\par
{\bkmkstart AAAAAAADCI}
{\bkmkend AAAAAAADCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5294 \{\par
 5295   if (mStyle == esNone)\par
 5296     return;\par
 5297   \par
 5298   QCPVector2D lengthVec = dir.normalized() * mLength*(mInverted ? -1 : 1);\par
 5299   if (lengthVec.isNull())\par
 5300     lengthVec = QCPVector2D(1, 0);\par
 5301   QCPVector2D widthVec = dir.normalized().perpendicular() * mWidth*0.5*(mInverted ? -1 : 1);\par
 5302   \par
 5303   QPen penBackup = painter->pen();\par
 5304   QBrush brushBackup = painter->brush();\par
 5305   QPen miterPen = penBackup;\par
 5306   miterPen.setJoinStyle(Qt::MiterJoin); // to make arrow heads spikey\par
 5307   QBrush brush(painter->pen().color(), Qt::SolidPattern);\par
 5308   switch (mStyle)\par
 5309   \{\par
 5310     case esNone: break;\par
 5311     case esFlatArrow:\par
 5312     \{\par
 5313       QPointF points[3] = \{pos.toPointF(),\par
 5314                            (pos-lengthVec+widthVec).toPointF(),\par
 5315                            (pos-lengthVec-widthVec).toPointF()\par
 5316                           \};\par
 5317       painter->setPen(miterPen);\par
 5318       painter->setBrush(brush);\par
 5319       painter->drawConvexPolygon(points, 3);\par
 5320       painter->setBrush(brushBackup);\par
 5321       painter->setPen(penBackup);\par
 5322       break;\par
 5323     \}\par
 5324     case esSpikeArrow:\par
 5325     \{\par
 5326       QPointF points[4] = \{pos.toPointF(),\par
 5327                            (pos-lengthVec+widthVec).toPointF(),\par
 5328                            (pos-lengthVec*0.8).toPointF(),\par
 5329                            (pos-lengthVec-widthVec).toPointF()\par
 5330                           \};\par
 5331       painter->setPen(miterPen);\par
 5332       painter->setBrush(brush);\par
 5333       painter->drawConvexPolygon(points, 4);\par
 5334       painter->setBrush(brushBackup);\par
 5335       painter->setPen(penBackup);\par
 5336       break;\par
 5337     \}\par
 5338     case esLineArrow:\par
 5339     \{\par
 5340       QPointF points[3] = \{(pos-lengthVec+widthVec).toPointF(),\par
 5341                            pos.toPointF(),\par
 5342                            (pos-lengthVec-widthVec).toPointF()\par
 5343                           \};\par
 5344       painter->setPen(miterPen);\par
 5345       painter->drawPolyline(points, 3);\par
 5346       painter->setPen(penBackup);\par
 5347       break;\par
 5348     \}\par
 5349     case esDisc:\par
 5350     \{\par
 5351       painter->setBrush(brush);\par
 5352       painter->drawEllipse(pos.toPointF(),  mWidth*0.5, mWidth*0.5);\par
 5353       painter->setBrush(brushBackup);\par
 5354       break;\par
 5355     \}\par
 5356     case esSquare:\par
 5357     \{\par
 5358       QCPVector2D widthVecPerp = widthVec.perpendicular();\par
 5359       QPointF points[4] = \{(pos-widthVecPerp+widthVec).toPointF(),\par
 5360                            (pos-widthVecPerp-widthVec).toPointF(),\par
 5361                            (pos+widthVecPerp-widthVec).toPointF(),\par
 5362                            (pos+widthVecPerp+widthVec).toPointF()\par
 5363                           \};\par
 5364       painter->setPen(miterPen);\par
 5365       painter->setBrush(brush);\par
 5366       painter->drawConvexPolygon(points, 4);\par
 5367       painter->setBrush(brushBackup);\par
 5368       painter->setPen(penBackup);\par
 5369       break;\par
 5370     \}\par
 5371     case esDiamond:\par
 5372     \{\par
 5373       QCPVector2D widthVecPerp = widthVec.perpendicular();\par
 5374       QPointF points[4] = \{(pos-widthVecPerp).toPointF(),\par
 5375                            (pos-widthVec).toPointF(),\par
 5376                            (pos+widthVecPerp).toPointF(),\par
 5377                            (pos+widthVec).toPointF()\par
 5378                           \};\par
 5379       painter->setPen(miterPen);\par
 5380       painter->setBrush(brush);\par
 5381       painter->drawConvexPolygon(points, 4);\par
 5382       painter->setBrush(brushBackup);\par
 5383       painter->setPen(penBackup);\par
 5384       break;\par
 5385     \}\par
 5386     case esBar:\par
 5387     \{\par
 5388       painter->drawLine((pos+widthVec).toPointF(), (pos-widthVec).toPointF());\par
 5389       break;\par
 5390     \}\par
 5391     case esHalfBar:\par
 5392     \{\par
 5393       painter->drawLine((pos+widthVec).toPointF(), pos.toPointF());\par
 5394       break;\par
 5395     \}\par
 5396     case esSkewedBar:\par
 5397     \{\par
 5398       if (qFuzzyIsNull(painter->pen().widthF()) && !painter->modes().testFlag(QCPPainter::pmNonCosmetic))\par
 5399       \{\par
 5400         // if drawing with cosmetic pen (perfectly thin stroke, happens only in vector exports), draw bar exactly on tip of line\par
 5401         painter->drawLine((pos+widthVec+lengthVec*0.2*(mInverted?-1:1)).toPointF(),\par
 5402                           (pos-widthVec-lengthVec*0.2*(mInverted?-1:1)).toPointF());\par
 5403       \} else\par
 5404       \{\par
 5405         // if drawing with thick (non-cosmetic) pen, shift bar a little in line direction to prevent line from sticking through bar slightly\par
 5406         painter->drawLine((pos+widthVec+lengthVec*0.2*(mInverted?-1:1)+dir.normalized()*qMax(1.0f, (float)painter->pen().widthF())*0.5f).toPointF(),\par
 5407                           (pos-widthVec-lengthVec*0.2*(mInverted?-1:1)+dir.normalized()*qMax(1.0f, (float)painter->pen().widthF())*0.5f).toPointF());\par
 5408       \}\par
 5409       break;\par
 5410     \}\par
 5411   \}\par
 5412 \}\par
}
}
{\xe \v draw\:QCPLineEnding}
{\xe \v QCPLineEnding\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLineEnding::draw ({\b QCPPainter} *  {\i painter}, const {\b QCPVector2D} &  {\i pos}, double  {\i angle}) const}}
\par
{\bkmkstart AAAAAAADCJ}
{\bkmkend AAAAAAADCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5420 \{\par
 5421   draw(painter, pos, QCPVector2D(qCos(angle), qSin(angle)));\par
 5422 \}\par
}
}
{\xe \v inverted\:QCPLineEnding}
{\xe \v QCPLineEnding\:inverted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLineEnding::inverted () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCK}
{\bkmkend AAAAAAADCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1504 \{ return mInverted; \}\par
}
}
{\xe \v length\:QCPLineEnding}
{\xe \v QCPLineEnding\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLineEnding::length () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCL}
{\bkmkend AAAAAAADCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1503 \{ return mLength; \}\par
}
}
{\xe \v realLength\:QCPLineEnding}
{\xe \v QCPLineEnding\:realLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLineEnding::realLength () const}}
\par
{\bkmkstart AAAAAAADCM}
{\bkmkend AAAAAAADCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Starting from the origin of this line ending (which is style specific), returns the length covered by the line ending symbol, in backward direction.\par
For example, the {\b esSpikeArrow} has a shorter real length than a {\b esFlatArrow}, even if both have the same {\b setLength} value, because the spike arrow has an inward curved back, which reduces the length along its center axis (the drawing origin for arrows is at the tip).\par
This function is used for precise, style specific placement of line endings, for example in QCPAxes. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5264 \{\par
 5265   switch (mStyle)\par
 5266   \{\par
 5267     case esNone:\par
 5268     case esLineArrow:\par
 5269     case esSkewedBar:\par
 5270     case esBar:\par
 5271     case esHalfBar:\par
 5272       return 0;\par
 5273       \par
 5274     case esFlatArrow:\par
 5275       return mLength;\par
 5276       \par
 5277     case esDisc:\par
 5278     case esSquare:\par
 5279     case esDiamond:\par
 5280       return mWidth*0.5;\par
 5281       \par
 5282     case esSpikeArrow:\par
 5283       return mLength*0.8;\par
 5284   \}\par
 5285   return 0;\par
 5286 \}\par
}
}
{\xe \v setInverted\:QCPLineEnding}
{\xe \v QCPLineEnding\:setInverted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLineEnding::setInverted (bool  {\i inverted})}}
\par
{\bkmkstart AAAAAAADCN}
{\bkmkend AAAAAAADCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the ending decoration shall be inverted. For example, an arrow decoration will point inward when {\i inverted}  is set to true.\par
Note that also the {\i width}  direction is inverted. For symmetrical ending styles like arrows or discs, this doesn't make a difference. However, asymmetric styles like {\b esHalfBar} are affected by it, which can be used to control to which side the half bar points to. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5215 \{\par
 5216   mInverted = inverted;\par
 5217 \}\par
}
}
{\xe \v setLength\:QCPLineEnding}
{\xe \v QCPLineEnding\:setLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLineEnding::setLength (double  {\i length})}}
\par
{\bkmkstart AAAAAAADCO}
{\bkmkend AAAAAAADCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the ending decoration, if the style supports it. On arrows, for example, the length defines the size in pointing direction.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWidth} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5202 \{\par
 5203   mLength = length;\par
 5204 \}\par
}
}
{\xe \v setStyle\:QCPLineEnding}
{\xe \v QCPLineEnding\:setStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLineEnding::setStyle ({\b QCPLineEnding::EndingStyle}  {\i style})}}
\par
{\bkmkstart AAAAAAADCP}
{\bkmkend AAAAAAADCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the style of the ending decoration. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5180 \{\par
 5181   mStyle = style;\par
 5182 \}\par
}
}
{\xe \v setWidth\:QCPLineEnding}
{\xe \v QCPLineEnding\:setWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLineEnding::setWidth (double  {\i width})}}
\par
{\bkmkstart AAAAAAADCQ}
{\bkmkend AAAAAAADCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the width of the ending decoration, if the style supports it. On arrows, for example, the width defines the size perpendicular to the arrow's pointing direction.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLength} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5191 \{\par
 5192   mWidth = width;\par
 5193 \}\par
}
}
{\xe \v style\:QCPLineEnding}
{\xe \v QCPLineEnding\:style}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EndingStyle} QCPLineEnding::style () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCR}
{\bkmkend AAAAAAADCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1501 \{ return mStyle; \}\par
}
}
{\xe \v width\:QCPLineEnding}
{\xe \v QCPLineEnding\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLineEnding::width () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADCS}
{\bkmkend AAAAAAADCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1502 \{ return mWidth; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mInverted\:QCPLineEnding}
{\xe \v QCPLineEnding\:mInverted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLineEnding::mInverted{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADCT}
{\bkmkend AAAAAAADCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLength\:QCPLineEnding}
{\xe \v QCPLineEnding\:mLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLineEnding::mLength{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADCU}
{\bkmkend AAAAAAADCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mStyle\:QCPLineEnding}
{\xe \v QCPLineEnding\:mStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EndingStyle} QCPLineEnding::mStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADCV}
{\bkmkend AAAAAAADCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWidth\:QCPLineEnding}
{\xe \v QCPLineEnding\:mWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLineEnding::mWidth{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADCW}
{\bkmkend AAAAAAADCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPMarginGroup Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPMarginGroup}
{\xe \v QCPMarginGroup}
{\bkmkstart AAAAAAADCX}
{\bkmkend AAAAAAADCX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A margin group allows synchronization of margin sides if working with multiple layout elements. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPMarginGroup:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_margin_group__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPMarginGroup:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_margin_group__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPMarginGroup} ({\b QCustomPlot} *parentPlot)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPMarginGroup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLayoutElement} * > {\b elements} ({\b QCP::MarginSide} side) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEmpty} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b commonMargin} ({\b QCP::MarginSide} side) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addChild} ({\b QCP::MarginSide} side, {\b QCPLayoutElement} *element)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeChild} ({\b QCP::MarginSide} side, {\b QCPLayoutElement} *element)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QHash< {\b QCP::MarginSide}, QList< {\b QCPLayoutElement} * > > {\b mChildren}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayoutElement}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A margin group allows synchronization of margin sides if working with multiple layout elements. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b QCPMarginGroup} allows you to tie a margin side of two or more layout elements together, such that they will all have the same size, based on the largest required margin in the group.\par
\par
\par
 In certain situations it is desirable that margins at specific sides are synchronized across layout elements. For example, if one {\b QCPAxisRect} is below another one in a grid layout, it will provide a cleaner look to the user if the left and right margins of the two axis rects are of the same size. The left axis of the top axis rect will then be at the same horizontal position as the left axis of the lower axis rect, making them appear aligned. The same applies for the right axes. This is what {\b QCPMarginGroup} makes possible.\par
To add/remove a specific side of a layout element to/from a margin group, use the {\b QCPLayoutElement::setMarginGroup} method. To completely break apart the margin group, either call {\b clear}, or just delete the margin group.\par
{\bkmkstart AAAAAAADCY}
{\bkmkend AAAAAAADCY}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Example
\par}
{\tc\tcl2 \v Example}
First create a margin group: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }Then set this group on the layout element sides: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }Here, we've used the first two axis rects of the plot and synchronized their left margins with each other and their right margins with each other. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPMarginGroup\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:QCPMarginGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPMarginGroup::QCPMarginGroup ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAADCZ}
{\bkmkend AAAAAAADCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPMarginGroup} instance in {\i parentPlot} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3008                                                       :\par
 3009   QObject(parentPlot),\par
 3010   mParentPlot(parentPlot)\par
 3011 \{\par
 3012   mChildren.insert(QCP::msLeft, QList<QCPLayoutElement*>());\par
 3013   mChildren.insert(QCP::msRight, QList<QCPLayoutElement*>());\par
 3014   mChildren.insert(QCP::msTop, QList<QCPLayoutElement*>());\par
 3015   mChildren.insert(QCP::msBottom, QList<QCPLayoutElement*>());\par
 3016 \}\par
}
}
{\xe \v ~QCPMarginGroup\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:~QCPMarginGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPMarginGroup::~QCPMarginGroup (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADDA}
{\bkmkend AAAAAAADDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3019 \{\par
 3020   clear();\par
 3021 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addChild\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:addChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPMarginGroup::addChild ({\b QCP::MarginSide}  {\i side}, {\b QCPLayoutElement} *  {\i element}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADDB}
{\bkmkend AAAAAAADDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3089 \{\par
 3090   if (!mChildren[side].contains(element))\par
 3091     mChildren[side].append(element);\par
 3092   else\par
 3093     qDebug() << Q_FUNC_INFO << "element is already child of this margin group side" << reinterpret_cast<quintptr>(element);\par
 3094 \}\par
}
}
{\xe \v clear\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPMarginGroup::clear ()}}
\par
{\bkmkstart AAAAAAADDC}
{\bkmkend AAAAAAADDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears this margin group. The synchronization of the margin sides that use this margin group is lifted and they will use their individual margin sizes again. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3044 \{\par
 3045   // make all children remove themselves from this margin group:\par
 3046   QHashIterator<QCP::MarginSide, QList<QCPLayoutElement*> > it(mChildren);\par
 3047   while (it.hasNext())\par
 3048   \{\par
 3049     it.next();\par
 3050     const QList<QCPLayoutElement*> elements = it.value();\par
 3051     for (int i=elements.size()-1; i>=0; --i)\par
 3052       elements.at(i)->setMarginGroup(it.key(), 0); // removes itself from mChildren via removeChild\par
 3053   \}\par
 3054 \}\par
}
}
{\xe \v commonMargin\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:commonMargin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPMarginGroup::commonMargin ({\b QCP::MarginSide}  {\i side}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADDD}
{\bkmkend AAAAAAADDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3067 \{\par
 3068   // query all automatic margins of the layout elements in this margin group side and find maximum:\par
 3069   int result = 0;\par
 3070   const QList<QCPLayoutElement*> elements = mChildren.value(side);\par
 3071   for (int i=0; i<elements.size(); ++i)\par
 3072   \{\par
 3073     if (!elements.at(i)->autoMargins().testFlag(side))\par
 3074       continue;\par
 3075     int m = qMax(elements.at(i)->calculateAutoMargin(side), QCP::getMarginValue(elements.at(i)->minimumMargins(), side));\par
 3076     if (m > result)\par
 3077       result = m;\par
 3078   \}\par
 3079   return result;\par
 3080 \}\par
}
}
{\xe \v elements\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:elements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLayoutElement} * > QCPMarginGroup::elements ({\b QCP::MarginSide}  {\i side}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDE}
{\bkmkend AAAAAAADDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all layout elements that have their margin {\i side}  associated with this margin group. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1156 \{ return mChildren.value(side); \}\par
}
}
{\xe \v isEmpty\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:isEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPMarginGroup::isEmpty () const}}
\par
{\bkmkstart AAAAAAADDF}
{\bkmkend AAAAAAADDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this margin group is empty. If this function returns true, no layout elements use this margin group to synchronize margin sides. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3028 \{\par
 3029   QHashIterator<QCP::MarginSide, QList<QCPLayoutElement*> > it(mChildren);\par
 3030   while (it.hasNext())\par
 3031   \{\par
 3032     it.next();\par
 3033     if (!it.value().isEmpty())\par
 3034       return false;\par
 3035   \}\par
 3036   return true;\par
 3037 \}\par
}
}
{\xe \v removeChild\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:removeChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPMarginGroup::removeChild ({\b QCP::MarginSide}  {\i side}, {\b QCPLayoutElement} *  {\i element}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADDG}
{\bkmkend AAAAAAADDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3103 \{\par
 3104   if (!mChildren[side].removeOne(element))\par
 3105     qDebug() << Q_FUNC_INFO << "element is not child of this margin group side" << reinterpret_cast<quintptr>(element);\par
 3106 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLayoutElement\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:QCPLayoutElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLayoutElement}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADDH}
{\bkmkend AAAAAAADDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mChildren\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:mChildren}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QHash<{\b QCP::MarginSide}, QList<{\b QCPLayoutElement}*> > QCPMarginGroup::mChildren{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADDI}
{\bkmkend AAAAAAADDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPMarginGroup}
{\xe \v QCPMarginGroup\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPMarginGroup::mParentPlot{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADDJ}
{\bkmkend AAAAAAADDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPPaintBufferPixmap Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPPaintBufferPixmap}
{\xe \v QCPPaintBufferPixmap}
{\bkmkstart AAAAAAADDK}
{\bkmkend AAAAAAADDK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A paint buffer based on QPixmap, using software raster rendering. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPPaintBufferPixmap:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_paint_buffer_pixmap__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPPaintBufferPixmap:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_paint_buffer_pixmap__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPPaintBufferPixmap} (const QSize &{\b size}, double {\b devicePixelRatio})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPPaintBufferPixmap} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPPainter} * {\b startPainting} () {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} (const QColor &color) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b reallocateBuffer} () {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mBuffer}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A paint buffer based on QPixmap, using software raster rendering. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This paint buffer is the default and fall-back paint buffer which uses software rendering and QPixmap as internal buffer. It is used if {\b QCustomPlot::setOpenGl} is false. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPPaintBufferPixmap\:QCPPaintBufferPixmap}
{\xe \v QCPPaintBufferPixmap\:QCPPaintBufferPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPPaintBufferPixmap::QCPPaintBufferPixmap (const QSize &  {\i size}, double  {\i devicePixelRatio}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAADDL}
{\bkmkend AAAAAAADDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a pixmap paint buffer instancen with the specified {\i size}  and {\i devicePixelRatio} , if applicable. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   656                                                                                      :\par
  657   QCPAbstractPaintBuffer(size, devicePixelRatio)\par
  658 \{\par
  659   QCPPaintBufferPixmap::reallocateBuffer();\par
  660 \}\par
}
}
{\xe \v ~QCPPaintBufferPixmap\:QCPPaintBufferPixmap}
{\xe \v QCPPaintBufferPixmap\:~QCPPaintBufferPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPPaintBufferPixmap::~QCPPaintBufferPixmap (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADDM}
{\bkmkend AAAAAAADDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   663 \{\par
  664 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v clear\:QCPPaintBufferPixmap}
{\xe \v QCPPaintBufferPixmap\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPaintBufferPixmap::clear (const QColor &  {\i color}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the entire buffer with the provided {\i color} . To have an empty transparent buffer, use the named color {\f2 Qt::transparent} .\par
This method must not be called if there is currently a painter (acquired with {\b startPainting}) active. \par
}{
Implements {\b QCPAbstractPaintBuffer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   685 \{\par
  686   mBuffer.fill(color);\par
  687 \}\par
}
}
{\xe \v draw\:QCPPaintBufferPixmap}
{\xe \v QCPPaintBufferPixmap\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPaintBufferPixmap::draw ({\b QCPPainter} *  {\i painter}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the contents of this buffer with the provided {\i painter} . This is the method that is used to finally join all paint buffers and draw them onto the screen. \par
}{
Implements {\b QCPAbstractPaintBuffer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   676 \{\par
  677   if (painter && painter->isActive())\par
  678     painter->drawPixmap(0, 0, mBuffer);\par
  679   else\par
  680     qDebug() << Q_FUNC_INFO << "invalid or inactive painter passed";\par
  681 \}\par
}
}
{\xe \v reallocateBuffer\:QCPPaintBufferPixmap}
{\xe \v QCPPaintBufferPixmap\:reallocateBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPaintBufferPixmap::reallocateBuffer (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reallocates the internal buffer with the currently configured size ({\b setSize}) and device pixel ratio, if applicable ({\b setDevicePixelRatio}). It is called as soon as any of those properties are changed on this paint buffer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Subclasses of {\b QCPAbstractPaintBuffer} must call their reimplementation of this method in their constructor, to perform the first allocation (this can not be done by the base class because calling pure virtual methods in base class constructors is not possible). \par
}}{
Implements {\b QCPAbstractPaintBuffer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   691 \{\par
  692   setInvalidated();\par
  693   if (!qFuzzyCompare(1.0, mDevicePixelRatio))\par
  694   \{\par
  695 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
  696     mBuffer = QPixmap(mSize*mDevicePixelRatio);\par
  697     mBuffer.setDevicePixelRatio(mDevicePixelRatio);\par
  698 #else\par
  699     qDebug() << Q_FUNC_INFO << "Device pixel ratios not supported for Qt versions before 5.4";\par
  700     mDevicePixelRatio = 1.0;\par
  701     mBuffer = QPixmap(mSize);\par
  702 #endif\par
  703   \} else\par
  704   \{\par
  705     mBuffer = QPixmap(mSize);\par
  706   \}\par
  707 \}\par
}
}
{\xe \v startPainting\:QCPPaintBufferPixmap}
{\xe \v QCPPaintBufferPixmap\:startPainting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPPainter} * QCPPaintBufferPixmap::startPainting (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPPainter} which is ready to draw to this buffer. The ownership and thus the responsibility to delete the painter after the painting operations are complete is given to the caller of this method.\par
Once you are done using the painter, delete the painter and call {\b donePainting}.\par
While a painter generated with this method is active, you must not call {\b setSize}, {\b setDevicePixelRatio} or {\b clear}.\par
This method may return 0, if a painter couldn't be activated on the buffer. This usually indicates a problem with the respective painting backend. \par
}{
Implements {\b QCPAbstractPaintBuffer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   668 \{\par
  669   QCPPainter *result = new QCPPainter(&mBuffer);\par
  670   result->setRenderHint(QPainter::HighQualityAntialiasing);\par
  671   return result;\par
  672 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBuffer\:QCPPaintBufferPixmap}
{\xe \v QCPPaintBufferPixmap\:mBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPPaintBufferPixmap::mBuffer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADDN}
{\bkmkend AAAAAAADDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPPainter Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPPainter}
{\xe \v QCPPainter}
{\bkmkstart AAAAAAADDO}
{\bkmkend AAAAAAADDO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QPainter subclass used internally. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPPainter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_painter__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPPainter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_painter__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PainterMode} \{ {\b pmDefault} = 0x00, 
{\b pmVectorized} = 0x01, 
{\b pmNoCaching} = 0x02, 
{\b pmNonCosmetic} = 0x04
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPPainter} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPPainter} (QPaintDevice *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiasing} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
PainterModes {\b modes} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasing} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMode} ({\b PainterMode} mode, bool enabled=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setModes} (PainterModes {\b modes})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b begin} (QPaintDevice *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (Qt::PenStyle penStyle)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawLine} (const QLineF &line)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawLine} (const QPointF &p1, const QPointF &p2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b save} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b restore} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b makeNonCosmetic} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
PainterModes {\b mModes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mIsAntialiasing}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QStack< bool > {\b mAntialiasingStack}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QPainter subclass used internally. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This QPainter subclass is used to provide some extended functionality e.g. for tweaking position consistency between antialiased and non-antialiased painting. Further it provides workarounds for QPainter quirks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid This class intentionally hides non-virtual functions of QPainter, e.g. setPen, save and restore. So while it is possible to pass a {\b QCPPainter} instance to a function that expects a QPainter pointer, some of the workarounds and tweaks will be unavailable to the function (because it will call the base class implementations of the functions actually hidden by {\b QCPPainter}). \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v PainterMode\:QCPPainter}
{\xe \v QCPPainter\:PainterMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPPainter::PainterMode}}}
\par
{\bkmkstart AAAAAAADDP}
{\bkmkend AAAAAAADDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines special modes the painter can operate in. They disable or enable certain subsets of features/fixes/workarounds, depending on whether they are wanted on the respective output device. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v pmDefault\:QCPPainter}
{\xe \v QCPPainter\:pmDefault}
{\qr pmDefault{\bkmkstart AAAAAAADDQ}
{\bkmkend AAAAAAADDQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x00}  Default mode for painting on screen devices \par
}\cell }{\row }
{\xe \v pmVectorized\:QCPPainter}
{\xe \v QCPPainter\:pmVectorized}
{\qr pmVectorized{\bkmkstart AAAAAAADDR}
{\bkmkend AAAAAAADDR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x01}  Mode for vectorized painting (e.g. PDF export). For example, this prevents some antialiasing fixes. \par
}\cell }{\row }
{\xe \v pmNoCaching\:QCPPainter}
{\xe \v QCPPainter\:pmNoCaching}
{\qr pmNoCaching{\bkmkstart AAAAAAADDS}
{\bkmkend AAAAAAADDS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x02}  Mode for all sorts of exports (e.g. PNG, PDF,...). For example, this prevents using cached pixmap labels \par
}\cell }{\row }
{\xe \v pmNonCosmetic\:QCPPainter}
{\xe \v QCPPainter\:pmNonCosmetic}
{\qr pmNonCosmetic{\bkmkstart AAAAAAADDT}
{\bkmkend AAAAAAADDT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x04}  Turns pen widths 0 to 1, i.e. disables cosmetic pens. (A cosmetic pen is always drawn with width 1 pixel in the vector image/pdf viewer, independent of zoom.) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   464                    \{ pmDefault       = 0x00   \par
  465                      ,pmVectorized   = 0x01   \par
  466                      ,pmNoCaching    = 0x02   \par
  467                      ,pmNonCosmetic  = 0x04   \par
  468                    \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPPainter\:QCPPainter}
{\xe \v QCPPainter\:QCPPainter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPPainter::QCPPainter ()}}
\par
{\bkmkstart AAAAAAADDU}
{\bkmkend AAAAAAADDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPPainter} instance and sets default values \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   285                        :\par
  286   QPainter(),\par
  287   mModes(pmDefault),\par
  288   mIsAntialiasing(false)\par
  289 \{\par
  290   // don't setRenderHint(QPainter::NonCosmeticDefautPen) here, because painter isn't active yet and\par
  291   // a call to begin() will follow\par
  292 \}\par
}
}
{\xe \v QCPPainter\:QCPPainter}
{\xe \v QCPPainter\:QCPPainter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPPainter::QCPPainter (QPaintDevice *  {\i device}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAADDV}
{\bkmkend AAAAAAADDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPPainter} instance on the specified paint {\i device}  and sets default values. Just like the analogous QPainter constructor, begins painting on {\i device}  immediately.\par
Like {\b begin}, this method sets QPainter::NonCosmeticDefaultPen in Qt versions before Qt5. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   300                                            :\par
  301   QPainter(device),\par
  302   mModes(pmDefault),\par
  303   mIsAntialiasing(false)\par
  304 \{\par
  305 #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0) // before Qt5, default pens used to be cosmetic if NonCosmeticDefaultPen flag isn't set. So we set it to get consistency across Qt versions.\par
  306   if (isActive())\par
  307     setRenderHint(QPainter::NonCosmeticDefaultPen);\par
  308 #endif\par
  309 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v antialiasing\:QCPPainter}
{\xe \v QCPPainter\:antialiasing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPPainter::antialiasing () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDW}
{\bkmkend AAAAAAADDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   477 \{ return testRenderHint(QPainter::Antialiasing); \}\par
}
}
{\xe \v begin\:QCPPainter}
{\xe \v QCPPainter\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPPainter::begin (QPaintDevice *  {\i device})}}
\par
{\bkmkstart AAAAAAADDX}
{\bkmkend AAAAAAADDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the QPainter::NonCosmeticDefaultPen in Qt versions before Qt5 after beginning painting on {\i device} . This is necessary to get cosmetic pen consistency across Qt versions, because since Qt5, all pens are non-cosmetic by default, and in Qt4 this render hint must be set to get that behaviour.\par
The Constructor {\b QCPPainter(QPaintDevice *device)} which directly starts painting also sets the render hint as appropriate.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this function hides the non-virtual base class implementation. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   411 \{\par
  412   bool result = QPainter::begin(device);\par
  413 #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0) // before Qt5, default pens used to be cosmetic if NonCosmeticDefaultPen flag isn't set. So we set it to get consistency across Qt versions.\par
  414   if (result)\par
  415     setRenderHint(QPainter::NonCosmeticDefaultPen);\par
  416 #endif\par
  417   return result;\par
  418 \}\par
}
}
{\xe \v drawLine\:QCPPainter}
{\xe \v QCPPainter\:drawLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::drawLine (const QLineF &  {\i line})}}
\par
{\bkmkstart AAAAAAADDY}
{\bkmkend AAAAAAADDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Works around a Qt bug introduced with Qt 4.8 which makes drawing QLineF unpredictable when antialiasing is disabled. Thus when antialiasing is disabled, it rounds the {\i line}  to integer coordinates and then passes it to the original drawLine.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this function hides the non-virtual base class implementation. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   361 \{\par
  362   if (mIsAntialiasing || mModes.testFlag(pmVectorized))\par
  363     QPainter::drawLine(line);\par
  364   else\par
  365     QPainter::drawLine(line.toLine());\par
  366 \}\par
}
}
{\xe \v drawLine\:QCPPainter}
{\xe \v QCPPainter\:drawLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::drawLine (const QPointF &  {\i p1}, const QPointF &  {\i p2}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADDZ}
{\bkmkend AAAAAAADDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   491 \{drawLine(QLineF(p1, p2));\}\par
}
}
{\xe \v makeNonCosmetic\:QCPPainter}
{\xe \v QCPPainter\:makeNonCosmetic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::makeNonCosmetic ()}}
\par
{\bkmkstart AAAAAAADEA}
{\bkmkend AAAAAAADEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Changes the pen width to 1 if it currently is 0. This function is called in the {\b setPen} overrides when the {\b pmNonCosmetic} mode is set. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   469 \{\par
  470   if (qFuzzyIsNull(pen().widthF()))\par
  471   \{\par
  472     QPen p = pen();\par
  473     p.setWidth(1);\par
  474     QPainter::setPen(p);\par
  475   \}\par
  476 \}\par
}
}
{\xe \v modes\:QCPPainter}
{\xe \v QCPPainter\:modes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PainterModes QCPPainter::modes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADEB}
{\bkmkend AAAAAAADEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   478 \{ return mModes; \}\par
}
}
{\xe \v restore\:QCPPainter}
{\xe \v QCPPainter\:restore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::restore ()}}
\par
{\bkmkstart AAAAAAADEC}
{\bkmkend AAAAAAADEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Restores the painter (see QPainter::restore). Since {\b QCPPainter} adds some new internal state to QPainter, the save/restore functions are reimplemented to also save/restore those members.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this function hides the non-virtual base class implementation.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b save} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   456 \{\par
  457   if (!mAntialiasingStack.isEmpty())\par
  458     mIsAntialiasing = mAntialiasingStack.pop();\par
  459   else\par
  460     qDebug() << Q_FUNC_INFO << "Unbalanced save/restore";\par
  461   QPainter::restore();\par
  462 \}\par
}
}
{\xe \v save\:QCPPainter}
{\xe \v QCPPainter\:save}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::save ()}}
\par
{\bkmkstart AAAAAAADED}
{\bkmkend AAAAAAADED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves the painter (see QPainter::save). Since {\b QCPPainter} adds some new internal state to QPainter, the save/restore functions are reimplemented to also save/restore those members.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this function hides the non-virtual base class implementation.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b restore} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   442 \{\par
  443   mAntialiasingStack.push(mIsAntialiasing);\par
  444   QPainter::save();\par
  445 \}\par
}
}
{\xe \v setAntialiasing\:QCPPainter}
{\xe \v QCPPainter\:setAntialiasing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::setAntialiasing (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAADEE}
{\bkmkend AAAAAAADEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether painting uses antialiasing or not. Use this method instead of using setRenderHint with QPainter::Antialiasing directly, as it allows {\b QCPPainter} to regain pixel exactness between antialiased and non-antialiased painting (Since Qt < 5.0 uses slightly different coordinate systems for AA/Non-AA painting). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   375 \{\par
  376   setRenderHint(QPainter::Antialiasing, enabled);\par
  377   if (mIsAntialiasing != enabled)\par
  378   \{\par
  379     mIsAntialiasing = enabled;\par
  380     if (!mModes.testFlag(pmVectorized)) // antialiasing half-pixel shift only needed for rasterized outputs\par
  381     \{\par
  382       if (mIsAntialiasing)\par
  383         translate(0.5, 0.5);\par
  384       else\par
  385         translate(-0.5, -0.5);\par
  386     \}\par
  387   \}\par
  388 \}\par
}
}
{\xe \v setMode\:QCPPainter}
{\xe \v QCPPainter\:setMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::setMode ({\b QCPPainter::PainterMode}  {\i mode}, bool  {\i enabled} = {\f2 true})}}
\par
{\bkmkstart AAAAAAADEF}
{\bkmkend AAAAAAADEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the mode of the painter. This controls whether the painter shall adjust its fixes/workarounds optimized for certain output devices. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   426 \{\par
  427   if (!enabled && mModes.testFlag(mode))\par
  428     mModes &= ~mode;\par
  429   else if (enabled && !mModes.testFlag(mode))\par
  430     mModes |= mode;\par
  431 \}\par
}
}
{\xe \v setModes\:QCPPainter}
{\xe \v QCPPainter\:setModes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::setModes (PainterModes  {\i modes})}}
\par
{\bkmkstart AAAAAAADEG}
{\bkmkend AAAAAAADEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the mode of the painter. This controls whether the painter shall adjust its fixes/workarounds optimized for certain output devices. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   395 \{\par
  396   mModes = modes;\par
  397 \}\par
}
}
{\xe \v setPen\:QCPPainter}
{\xe \v QCPPainter\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADEH}
{\bkmkend AAAAAAADEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen of the painter and applies certain fixes to it, depending on the mode of this {\b QCPPainter}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this function hides the non-virtual base class implementation. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   318 \{\par
  319   QPainter::setPen(pen);\par
  320   if (mModes.testFlag(pmNonCosmetic))\par
  321     makeNonCosmetic();\par
  322 \}\par
}
}
{\xe \v setPen\:QCPPainter}
{\xe \v QCPPainter\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::setPen (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAADEI}
{\bkmkend AAAAAAADEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the pen (by color) of the painter and applies certain fixes to it, depending on the mode of this {\b QCPPainter}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this function hides the non-virtual base class implementation. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   332 \{\par
  333   QPainter::setPen(color);\par
  334   if (mModes.testFlag(pmNonCosmetic))\par
  335     makeNonCosmetic();\par
  336 \}\par
}
}
{\xe \v setPen\:QCPPainter}
{\xe \v QCPPainter\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPainter::setPen (Qt::PenStyle  {\i penStyle})}}
\par
{\bkmkstart AAAAAAADEJ}
{\bkmkend AAAAAAADEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the pen (by style) of the painter and applies certain fixes to it, depending on the mode of this {\b QCPPainter}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this function hides the non-virtual base class implementation. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   346 \{\par
  347   QPainter::setPen(penStyle);\par
  348   if (mModes.testFlag(pmNonCosmetic))\par
  349     makeNonCosmetic();\par
  350 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mAntialiasingStack\:QCPPainter}
{\xe \v QCPPainter\:mAntialiasingStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QStack<bool> QCPPainter::mAntialiasingStack{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADEK}
{\bkmkend AAAAAAADEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mIsAntialiasing\:QCPPainter}
{\xe \v QCPPainter\:mIsAntialiasing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPPainter::mIsAntialiasing{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADEL}
{\bkmkend AAAAAAADEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mModes\:QCPPainter}
{\xe \v QCPPainter\:mModes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PainterModes QCPPainter::mModes{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADEM}
{\bkmkend AAAAAAADEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPPlottableInterface1D Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D}
{\bkmkstart AAAAAAADEN}
{\bkmkend AAAAAAADEN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines an abstract interface for one-dimensional plottables. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPPlottableInterface1D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_plottable_interface1_d__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPPlottableInterface1D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_plottable_interface1_d__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPPlottableInterface1D} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b dataCount} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainKey} (int index) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataSortKey} (int index) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainValue} (int index) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b dataValueRange} (int index) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b dataPixelPosition} (int index) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b sortKeyIsMainKey} () const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPDataSelection} {\b selectTestRect} (const QRectF &rect, bool onlySelectable) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findBegin} (double sortKey, bool expandedRange=true) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findEnd} (double sortKey, bool expandedRange=true) const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines an abstract interface for one-dimensional plottables. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class contains only pure virtual methods which define a common interface to the data of one-dimensional plottables.\par
For example, it is implemented by the template class {\b QCPAbstractPlottable1D} (the preferred base class for one-dimensional plottables). So if you use that template class as base class of your one-dimensional plottable, you won't have to care about implementing the 1d interface yourself.\par
If your plottable doesn't derive from {\b QCPAbstractPlottable1D} but still wants to provide a 1d interface (e.g. like {\b QCPErrorBars} does), you should inherit from both {\b QCPAbstractPlottable} and {\b QCPPlottableInterface1D} and accordingly reimplement the pure virtual methods of the 1d interface, matching your data container. Also, reimplement {\b QCPAbstractPlottable::interface1D} to return the {\f2 this}  pointer.\par
If you have a {\b QCPAbstractPlottable} pointer, you can check whether it implements this interface by calling {\b QCPAbstractPlottable::interface1D} and testing it for a non-zero return value. If it indeed implements this interface, you may use it to access the plottable's data without needing to know the exact type of the plottable or its data point type. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~QCPPlottableInterface1D\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:~QCPPlottableInterface1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual QCPPlottableInterface1D::~QCPPlottableInterface1D (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADEO}
{\bkmkend AAAAAAADEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3853 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dataCount\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:dataCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPPlottableInterface1D::dataCount () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data points of the plottable. \par
}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALO \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v dataMainKey\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:dataMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPPlottableInterface1D::dataMainKey (int  {\i index}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main key of the data point at the given {\i index} .\par
What the main key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v dataMainValue\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:dataMainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPPlottableInterface1D::dataMainValue (int  {\i index}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main value of the data point at the given {\i index} .\par
What the main value is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v dataPixelPosition\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:dataPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPPlottableInterface1D::dataPixelPosition (int  {\i index}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position on the widget surface at which the data point at the given {\i index}  appears.\par
Usually this corresponds to the point of {\b dataMainKey}/{\b dataMainValue}, in pixel coordinates. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values. For example, {\b QCPBars} apparent data values can be shifted depending on their stacking, bar grouping or configured base value. \par
}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v dataSortKey\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:dataSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPPlottableInterface1D::dataSortKey (int  {\i index}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the sort key of the data point at the given {\i index} .\par
What the sort key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v dataValueRange\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:dataValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPPlottableInterface1D::dataValueRange (int  {\i index}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the value range of the data point at the given {\i index} .\par
What the value range is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v findBegin\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:findBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPPlottableInterface1D::findBegin (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index of the data point with a (sort-)key that is equal to, just below, or just above {\i sortKey} . If {\i expandedRange}  is true, the data point just below {\i sortKey}  will be considered, otherwise the one just above.\par
This can be used in conjunction with {\b findEnd} to iterate over data points within a given key range, including or excluding the bounding data points that are just beyond the specified range.\par
If {\i expandedRange}  is true but there are no data points below {\i sortKey} , 0 is returned.\par
If the container is empty, returns 0 (in that case, {\b findEnd} will also return 0, so a loop using these methods will not iterate over the index 0).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findEnd}, {\b QCPDataContainer::findBegin} \par
}}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v findEnd\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:findEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPPlottableInterface1D::findEnd (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index one after the data point with a (sort-)key that is equal to, just above, or just below {\i sortKey} . If {\i expandedRange}  is true, the data point just above {\i sortKey}  will be considered, otherwise the one just below.\par
This can be used in conjunction with {\b findBegin} to iterate over data points within a given key range, including the bounding data points that are just below and above the specified range.\par
If {\i expandedRange}  is true but there are no data points above {\i sortKey} , the index just above the highest data point is returned.\par
If the container is empty, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findBegin}, {\b QCPDataContainer::findEnd} \par
}}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABVX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v selectTestRect\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:selectTestRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPPlottableInterface1D::selectTestRect (const QRectF &  {\i rect}, bool  {\i onlySelectable}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection containing all the data points of this plottable which are contained (or hit by) {\i rect} . This is used mainly in the selection rect interaction for data selection (data selection mechanism).\par
If {\i onlySelectable}  is true, an empty {\b QCPDataSelection} is returned if this plottable is not selectable (i.e. if {\b QCPAbstractPlottable::setSelectable} is {\b QCP::stNone}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i rect}  must be a normalized rect (positive or zero width and height). This is especially important when using the rect of {\b QCPSelectionRect::accepted}, which is not necessarily normalized. Use {\f2 QRect::normalized()}  when passing a rect which might not be normalized. \par
}}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABWD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAML \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v sortKeyIsMainKey\:QCPPlottableInterface1D}
{\xe \v QCPPlottableInterface1D\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPPlottableInterface1D::sortKeyIsMainKey () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the sort key ({\b dataSortKey}) is identical to the main key ({\b dataMainKey}).\par
What the sort and main keys are, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implemented in {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABWL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< DataType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPFinancialData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable1D< QCPBarsData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b QCPAbstractPlottable1D< QCPCurveData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPPlottableLegendItem Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPPlottableLegendItem}
{\xe \v QCPPlottableLegendItem}
{\bkmkstart AAAAAAADEP}
{\bkmkend AAAAAAADEP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A legend item representing a plottable with an icon and the plottable name. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPPlottableLegendItem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_plottable_legend_item__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPPlottableLegendItem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_plottable_legend_item__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPPlottableLegendItem} ({\b QCPLegend} *parent, {\b QCPAbstractPlottable} *{\b plottable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b plottable} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b minimumOuterSizeHint} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b getIconBorderPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b getTextColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b getFont} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b mPlottable}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A legend item representing a plottable with an icon and the plottable name. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the standard legend item for plottables. It displays an icon of the plottable next to the plottable name. The icon is drawn by the respective plottable itself ({\b QCPAbstractPlottable::drawLegendIcon}), and tries to give an intuitive symbol for the plottable. For example, the {\b QCPGraph} draws a centered horizontal line and/or a single scatter point in the middle.\par
Legend items of this type are always associated with one plottable (retrievable via the {\b plottable()} function and settable with the constructor). You may change the font of the plottable name with {\b setFont}. Icon padding and border pen is taken from the parent {\b QCPLegend}, see {\b QCPLegend::setIconBorderPen} and {\b QCPLegend::setIconTextPadding}.\par
The function {\b QCPAbstractPlottable::addToLegend}/{\b QCPAbstractPlottable::removeFromLegend} creates/removes legend items of this type.\par
Since {\b QCPLegend} is based on {\b QCPLayoutGrid}, a legend item itself is just a subclass of {\b QCPLayoutElement}. While it could be added to a legend (or any other layout) via the normal layout interface, {\b QCPLegend} has specialized functions for handling legend items conveniently, see the documentation of {\b QCPLegend}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPPlottableLegendItem\:QCPPlottableLegendItem}
{\xe \v QCPPlottableLegendItem\:QCPPlottableLegendItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPPlottableLegendItem::QCPPlottableLegendItem ({\b QCPLegend} *  {\i parent}, {\b QCPAbstractPlottable} *  {\i plottable})}}
\par
{\bkmkstart AAAAAAADEQ}
{\bkmkend AAAAAAADEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new legend item associated with {\i plottable} .\par
Once it's created, it can be added to the legend via {\b QCPLegend::addItem}.\par
A more convenient way of adding/removing a plottable to/from the legend is via the functions {\b QCPAbstractPlottable::addToLegend} and {\b QCPAbstractPlottable::removeFromLegend}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18141                                                                                                  :\par
18142   QCPAbstractLegendItem(parent),\par
18143   mPlottable(plottable)\par
18144 \{\par
18145   setAntialiased(false);\par
18146 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v draw\:QCPPlottableLegendItem}
{\xe \v QCPPlottableLegendItem\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPPlottableLegendItem::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18185 \{\par
18186   if (!mPlottable) return;\par
18187   painter->setFont(getFont());\par
18188   painter->setPen(QPen(getTextColor()));\par
18189   QSizeF iconSize = mParentLegend->iconSize();\par
18190   QRectF textRect = painter->fontMetrics().boundingRect(0, 0, 0, iconSize.height(), Qt::TextDontClip, mPlottable->name());\par
18191   QRectF iconRect(mRect.topLeft(), iconSize);\par
18192   int textHeight = qMax(textRect.height(), iconSize.height());  // if text has smaller height than icon, center text vertically in icon height, else align tops\par
18193   painter->drawText(mRect.x()+iconSize.width()+mParentLegend->iconTextPadding(), mRect.y(), textRect.width(), textHeight, Qt::TextDontClip, mPlottable->name());\par
18194   // draw icon:\par
18195   painter->save();\par
18196   painter->setClipRect(iconRect, Qt::IntersectClip);\par
18197   mPlottable->drawLegendIcon(painter, iconRect);\par
18198   painter->restore();\par
18199   // draw icon border:\par
18200   if (getIconBorderPen().style() != Qt::NoPen)\par
18201   \{\par
18202     painter->setPen(getIconBorderPen());\par
18203     painter->setBrush(Qt::NoBrush);\par
18204     int halfPen = qCeil(painter->pen().widthF()*0.5)+1;\par
18205     painter->setClipRect(mOuterRect.adjusted(-halfPen, -halfPen, halfPen, halfPen)); // extend default clip rect so thicker pens (especially during selection) are not clipped\par
18206     painter->drawRect(iconRect);\par
18207   \}\par
18208 \}\par
}
}
{\xe \v getFont\:QCPPlottableLegendItem}
{\xe \v QCPPlottableLegendItem\:getFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPPlottableLegendItem::getFont () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADER}
{\bkmkend AAAAAAADER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18174 \{\par
18175   return mSelected ? mSelectedFont : mFont;\par
18176 \}\par
}
}
{\xe \v getIconBorderPen\:QCPPlottableLegendItem}
{\xe \v QCPPlottableLegendItem\:getIconBorderPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPPlottableLegendItem::getIconBorderPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADES}
{\bkmkend AAAAAAADES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18154 \{\par
18155   return mSelected ? mParentLegend->selectedIconBorderPen() : mParentLegend->iconBorderPen();\par
18156 \}\par
}
}
{\xe \v getTextColor\:QCPPlottableLegendItem}
{\xe \v QCPPlottableLegendItem\:getTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPPlottableLegendItem::getTextColor () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADET}
{\bkmkend AAAAAAADET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18164 \{\par
18165   return mSelected ? mSelectedTextColor : mTextColor;\par
18166 \}\par
}
}
{\xe \v minimumOuterSizeHint\:QCPPlottableLegendItem}
{\xe \v QCPPlottableLegendItem\:minimumOuterSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPPlottableLegendItem::minimumOuterSizeHint () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACVW}
{\bkmkend AAAAAAACVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the suggested minimum size this layout element (the {\b outerRect}) may be compressed to, if no manual minimum size is set.\par
if a minimum size ({\b setMinimumSize}) was not set manually, parent layouts use the returned size (usually indirectly through {\b QCPLayout::getFinalMinimumOuterSize}) to determine the minimum allowed size of this layout element.\par
A manual minimum size is considered set if it is non-zero.\par
The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18218 \{\par
18219   if (!mPlottable) return QSize();\par
18220   QSize result(0, 0);\par
18221   QRect textRect;\par
18222   QFontMetrics fontMetrics(getFont());\par
18223   QSize iconSize = mParentLegend->iconSize();\par
18224   textRect = fontMetrics.boundingRect(0, 0, 0, iconSize.height(), Qt::TextDontClip, mPlottable->name());\par
18225   result.setWidth(iconSize.width() + mParentLegend->iconTextPadding() + textRect.width());\par
18226   result.setHeight(qMax(textRect.height(), iconSize.height()));\par
18227   result.rwidth() += mMargins.left()+mMargins.right();\par
18228   result.rheight() += mMargins.top()+mMargins.bottom();\par
18229   return result;\par
18230 \}\par
}
}
{\xe \v plottable\:QCPPlottableLegendItem}
{\xe \v QCPPlottableLegendItem\:plottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable}* QCPPlottableLegendItem::plottable (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADEU}
{\bkmkend AAAAAAADEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4779 \{ return mPlottable; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mPlottable\:QCPPlottableLegendItem}
{\xe \v QCPPlottableLegendItem\:mPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable}* QCPPlottableLegendItem::mPlottable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADEV}
{\bkmkend AAAAAAADEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPRange Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPRange}
{\xe \v QCPRange}
{\bkmkstart AAAAAAADEW}
{\bkmkend AAAAAAADEW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the range an axis is encompassing. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPRange:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_range__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} (double {\b lower}, double {\b upper})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b QCPRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b QCPRange} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} & {\b operator+=} (const double &value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} & {\b operator-=} (const double &value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} & {\b operator*=} (const double &value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} & {\b operator/=} (const double &value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b center} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b expand} (const {\b QCPRange} &otherRange)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b expand} (double includeCoord)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b expanded} (const {\b QCPRange} &otherRange) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b expanded} (double includeCoord) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b bounded} (double lowerBound, double upperBound) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b sanitizedForLogScale} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b sanitizedForLinScale} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contains} (double value) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b validRange} (double {\b lower}, double {\b upper})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b validRange} (const {\b QCPRange} &range)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lower}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b upper}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const double {\b minRange} = 1e-280\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const double {\b maxRange} = 1e250\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator+} (const {\b QCPRange} &, double)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator+} (double, const {\b QCPRange} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator-} (const {\b QCPRange} &range, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator*} (const {\b QCPRange} &range, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator*} (double value, const {\b QCPRange} &range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator/} (const {\b QCPRange} &range, double value)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Related Functions\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Note that these are not member functions.) \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QDebug {\b operator<<} (QDebug d, const {\b QCPRange} &range)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the range an axis is encompassing. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains a {\i lower}  and {\i upper}  double value and provides convenience input, output and modification functions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAxis::setRange} \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPRange\:QCPRange}
{\xe \v QCPRange\:QCPRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPRange::QCPRange ()}}
\par
{\bkmkstart AAAAAAADEX}
{\bkmkend AAAAAAADEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a range with {\i lower}  and {\i upper}  set to zero. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1895                    :\par
 1896   lower(0),\par
 1897   upper(0)\par
 1898 \{\par
 1899 \}\par
}
}
{\xe \v QCPRange\:QCPRange}
{\xe \v QCPRange\:QCPRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPRange::QCPRange (double  {\i lower}, double  {\i upper})}}
\par
{\bkmkstart AAAAAAADEY}
{\bkmkend AAAAAAADEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Constructs a range with the specified {\i lower}  and {\i upper}  values.\par
The resulting range will be normalized (see {\b normalize}), so if {\i lower}  is not numerically smaller than {\i upper} , they will be swapped. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1908                                              :\par
 1909   lower(lower),\par
 1910   upper(upper)\par
 1911 \{\par
 1912   normalize();\par
 1913 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v bounded\:QCPRange}
{\xe \v QCPRange\:bounded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPRange::bounded (double  {\i lowerBound}, double  {\i upperBound}) const}}
\par
{\bkmkstart AAAAAAADEZ}
{\bkmkend AAAAAAADEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns this range, possibly modified to not exceed the bounds provided as {\i lowerBound}  and {\i upperBound} . If possible, the size of the current range is preserved in the process.\par
If the range shall only be bounded at the lower side, you can set {\i upperBound}  to {\b QCPRange::maxRange}. If it shall only be bounded at the upper side, set {\i lowerBound}  to -{\b QCPRange::maxRange}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1999 \{\par
 2000   if (lowerBound > upperBound)\par
 2001     qSwap(lowerBound, upperBound);\par
 2002   \par
 2003   QCPRange result(lower, upper);\par
 2004   if (result.lower < lowerBound)\par
 2005   \{\par
 2006     result.lower = lowerBound;\par
 2007     result.upper = lowerBound + size();\par
 2008     if (result.upper > upperBound || qFuzzyCompare(size(), upperBound-lowerBound))\par
 2009       result.upper = upperBound;\par
 2010   \} else if (result.upper > upperBound)\par
 2011   \{\par
 2012     result.upper = upperBound;\par
 2013     result.lower = upperBound - size();\par
 2014     if (result.lower < lowerBound || qFuzzyCompare(size(), upperBound-lowerBound))\par
 2015       result.lower = lowerBound;\par
 2016   \}\par
 2017   \par
 2018   return result;\par
 2019 \}\par
}
}
{\xe \v center\:QCPRange}
{\xe \v QCPRange\:center}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPRange::center () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFA}
{\bkmkend AAAAAAADFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the center of the range, i.e. ({\i upper+{\i lower} )*0} .5 \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   795 \{ return (upper+lower)*0.5; \}\par
}
}
{\xe \v contains\:QCPRange}
{\xe \v QCPRange\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPRange::contains (double  {\i value}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFB}
{\bkmkend AAAAAAADFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true when {\i value}  lies within or exactly on the borders of the range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   804 \{ return value >= lower && value <= upper; \}\par
}
}
{\xe \v expand\:QCPRange}
{\xe \v QCPRange\:expand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPRange::expand (const {\b QCPRange} &  {\i otherRange})}}
\par
{\bkmkstart AAAAAAADFC}
{\bkmkend AAAAAAADFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Expands this range such that {\i otherRange}  is contained in the new range. It is assumed that both this range and {\i otherRange}  are normalized (see {\b normalize}).\par
If this range contains NaN as lower or upper bound, it will be replaced by the respective bound of {\i otherRange} .\par
If {\i otherRange}  is already inside the current range, this function does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b expanded} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1928 \{\par
 1929   if (lower > otherRange.lower || qIsNaN(lower))\par
 1930     lower = otherRange.lower;\par
 1931   if (upper < otherRange.upper || qIsNaN(upper))\par
 1932     upper = otherRange.upper;\par
 1933 \}\par
}
}
{\xe \v expand\:QCPRange}
{\xe \v QCPRange\:expand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPRange::expand (double  {\i includeCoord})}}
\par
{\bkmkstart AAAAAAADFD}
{\bkmkend AAAAAAADFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Expands this range such that {\i includeCoord}  is contained in the new range. It is assumed that this range is normalized (see {\b normalize}).\par
If this range contains NaN as lower or upper bound, the respective bound will be set to {\i includeCoord} .\par
If {\i includeCoord}  is already inside the current range, this function does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b expand} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1948 \{\par
 1949   if (lower > includeCoord || qIsNaN(lower))\par
 1950     lower = includeCoord;\par
 1951   if (upper < includeCoord || qIsNaN(upper))\par
 1952     upper = includeCoord;\par
 1953 \}\par
}
}
{\xe \v expanded\:QCPRange}
{\xe \v QCPRange\:expanded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPRange::expanded (const {\b QCPRange} &  {\i otherRange}) const}}
\par
{\bkmkstart AAAAAAADFE}
{\bkmkend AAAAAAADFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns an expanded range that contains this and {\i otherRange} . It is assumed that both this range and {\i otherRange}  are normalized (see {\b normalize}).\par
If this range contains NaN as lower or upper bound, the returned range's bound will be taken from {\i otherRange} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b expand} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1967 \{\par
 1968   QCPRange result = *this;\par
 1969   result.expand(otherRange);\par
 1970   return result;\par
 1971 \}\par
}
}
{\xe \v expanded\:QCPRange}
{\xe \v QCPRange\:expanded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPRange::expanded (double  {\i includeCoord}) const}}
\par
{\bkmkstart AAAAAAADFF}
{\bkmkend AAAAAAADFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns an expanded range that includes the specified {\i includeCoord} . It is assumed that this range is normalized (see {\b normalize}).\par
If this range contains NaN as lower or upper bound, the returned range's bound will be set to {\i includeCoord} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b expand} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1984 \{\par
 1985   QCPRange result = *this;\par
 1986   result.expand(includeCoord);\par
 1987   return result;\par
 1988 \}\par
}
}
{\xe \v normalize\:QCPRange}
{\xe \v QCPRange\:normalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPRange::normalize (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFG}
{\bkmkend AAAAAAADFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes sure {\i lower}  is numerically smaller than {\i upper} . If this is not the case, the values are swapped. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   796 \{ if (lower > upper) qSwap(lower, upper); \}\par
}
}
{\xe \v operator!=\:QCPRange}
{\xe \v QCPRange\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPRange::operator!= (const {\b QCPRange} &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFH}
{\bkmkend AAAAAAADFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   781 \{ return !(*this == other); \}\par
}
}
{\xe \v operator*=\:QCPRange}
{\xe \v QCPRange\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} & QCPRange::operator*= (const double &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFI}
{\bkmkend AAAAAAADFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies both boundaries of the range by {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   785 \{ lower*=value; upper*=value; return *this; \}\par
}
}
{\xe \v operator+=\:QCPRange}
{\xe \v QCPRange\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} & QCPRange::operator+= (const double &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFJ}
{\bkmkend AAAAAAADFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\i value}  to both boundaries of the range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   783 \{ lower+=value; upper+=value; return *this; \}\par
}
}
{\xe \v operator-=\:QCPRange}
{\xe \v QCPRange\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} & QCPRange::operator-= (const double &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFK}
{\bkmkend AAAAAAADFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtracts {\i value}  from both boundaries of the range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   784 \{ lower-=value; upper-=value; return *this; \}\par
}
}
{\xe \v operator/=\:QCPRange}
{\xe \v QCPRange\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} & QCPRange::operator/= (const double &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFL}
{\bkmkend AAAAAAADFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Divides both boundaries of the range by {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   786 \{ lower/=value; upper/=value; return *this; \}\par
}
}
{\xe \v operator==\:QCPRange}
{\xe \v QCPRange\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPRange::operator== (const {\b QCPRange} &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFM}
{\bkmkend AAAAAAADFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   780 \{ return lower == other.lower && upper == other.upper; \}\par
}
}
{\xe \v sanitizedForLinScale\:QCPRange}
{\xe \v QCPRange\:sanitizedForLinScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPRange::sanitizedForLinScale () const}}
\par
{\bkmkstart AAAAAAADFN}
{\bkmkend AAAAAAADFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a sanitized version of the range. Sanitized means for linear scales, that {\i lower}  will always be numerically smaller (or equal) to {\i upper} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2083 \{\par
 2084   QCPRange sanitizedRange(lower, upper);\par
 2085   sanitizedRange.normalize();\par
 2086   return sanitizedRange;\par
 2087 \}\par
}
}
{\xe \v sanitizedForLogScale\:QCPRange}
{\xe \v QCPRange\:sanitizedForLogScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPRange::sanitizedForLogScale () const}}
\par
{\bkmkstart AAAAAAADFO}
{\bkmkend AAAAAAADFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a sanitized version of the range. Sanitized means for logarithmic scales, that the range won't span the positive and negative sign domain, i.e. contain zero. Further {\i lower}  will always be numerically smaller (or equal) to {\i upper} .\par
If the original range does span positive and negative sign domains or contains zero, the returned range will try to approximate the original range as good as possible. If the positive interval of the original range is wider than the negative interval, the returned range will only contain the positive interval, with lower bound set to {\i rangeFac}  or {\i rangeFac}  *{\i upper} , whichever is closer to zero. Same procedure is used if the negative interval is wider than the positive interval, this time by changing the {\i upper}  bound. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2034 \{\par
 2035   double rangeFac = 1e-3;\par
 2036   QCPRange sanitizedRange(lower, upper);\par
 2037   sanitizedRange.normalize();\par
 2038   // can't have range spanning negative and positive values in log plot, so change range to fix it\par
 2039   //if (qFuzzyCompare(sanitizedRange.lower+1, 1) && !qFuzzyCompare(sanitizedRange.upper+1, 1))\par
 2040   if (sanitizedRange.lower == 0.0 && sanitizedRange.upper != 0.0)\par
 2041   \{\par
 2042     // case lower is 0\par
 2043     if (rangeFac < sanitizedRange.upper*rangeFac)\par
 2044       sanitizedRange.lower = rangeFac;\par
 2045     else\par
 2046       sanitizedRange.lower = sanitizedRange.upper*rangeFac;\par
 2047   \} //else if (!qFuzzyCompare(lower+1, 1) && qFuzzyCompare(upper+1, 1))\par
 2048   else if (sanitizedRange.lower != 0.0 && sanitizedRange.upper == 0.0)\par
 2049   \{\par
 2050     // case upper is 0\par
 2051     if (-rangeFac > sanitizedRange.lower*rangeFac)\par
 2052       sanitizedRange.upper = -rangeFac;\par
 2053     else\par
 2054       sanitizedRange.upper = sanitizedRange.lower*rangeFac;\par
 2055   \} else if (sanitizedRange.lower < 0 && sanitizedRange.upper > 0)\par
 2056   \{\par
 2057     // find out whether negative or positive interval is wider to decide which sign domain will be chosen\par
 2058     if (-sanitizedRange.lower > sanitizedRange.upper)\par
 2059     \{\par
 2060       // negative is wider, do same as in case upper is 0\par
 2061       if (-rangeFac > sanitizedRange.lower*rangeFac)\par
 2062         sanitizedRange.upper = -rangeFac;\par
 2063       else\par
 2064         sanitizedRange.upper = sanitizedRange.lower*rangeFac;\par
 2065     \} else\par
 2066     \{\par
 2067       // positive is wider, do same as in case lower is 0\par
 2068       if (rangeFac < sanitizedRange.upper*rangeFac)\par
 2069         sanitizedRange.lower = rangeFac;\par
 2070       else\par
 2071         sanitizedRange.lower = sanitizedRange.upper*rangeFac;\par
 2072     \}\par
 2073   \}\par
 2074   // due to normalization, case lower>0 && upper<0 should never occur, because that implies upper<lower\par
 2075   return sanitizedRange;\par
 2076 \}\par
}
}
{\xe \v size\:QCPRange}
{\xe \v QCPRange\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPRange::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADFP}
{\bkmkend AAAAAAADFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the size of the range, i.e. {\i upper-{\i lower}  }  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   794 \{ return upper-lower; \}\par
}
}
{\xe \v validRange\:QCPRange}
{\xe \v QCPRange\:validRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPRange::validRange (double  {\i lower}, double  {\i upper}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAADFQ}
{\bkmkend AAAAAAADFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks, whether the specified range is within valid bounds, which are defined as {\b QCPRange::maxRange} and {\b QCPRange::minRange}. A valid range means: {
\par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range bounds within -maxRange and maxRange \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range size above minRange \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range size below maxRange \par
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2098 \{\par
 2099   return (lower > -maxRange &&\par
 2100           upper < maxRange &&\par
 2101           qAbs(lower-upper) > minRange &&\par
 2102           qAbs(lower-upper) < maxRange &&\par
 2103           !(lower > 0 && qIsInf(upper/lower)) &&\par
 2104           !(upper < 0 && qIsInf(lower/upper)));\par
 2105 \}\par
}
}
{\xe \v validRange\:QCPRange}
{\xe \v QCPRange\:validRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPRange::validRange (const {\b QCPRange} &  {\i range}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAADFR}
{\bkmkend AAAAAAADFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Checks, whether the specified range is within valid bounds, which are defined as {\b QCPRange::maxRange} and {\b QCPRange::minRange}. A valid range means: {
\par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range bounds within -maxRange and maxRange \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range size above minRange \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range size below maxRange \par
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2117 \{\par
 2118   return (range.lower > -maxRange &&\par
 2119           range.upper < maxRange &&\par
 2120           qAbs(range.lower-range.upper) > minRange &&\par
 2121           qAbs(range.lower-range.upper) < maxRange &&\par
 2122           !(range.lower > 0 && qIsInf(range.upper/range.lower)) &&\par
 2123           !(range.upper < 0 && qIsInf(range.lower/range.upper)));\par
 2124 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator*\:QCPRange}
{\xe \v QCPRange\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator* (const {\b QCPRange} &  {\i range}, double  {\i value}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADFS}
{\bkmkend AAAAAAADFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies both boundaries of the range by {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   858 \{\par
  859   QCPRange result(range);\par
  860   result *= value;\par
  861   return result;\par
  862 \}\par
}
}
{\xe \v operator*\:QCPRange}
{\xe \v QCPRange\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator* (double  {\i value}, const {\b QCPRange} &  {\i range}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADFT}
{\bkmkend AAAAAAADFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies both boundaries of the range by {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   868 \{\par
  869   QCPRange result(range);\par
  870   result *= value;\par
  871   return result;\par
  872 \}\par
}
}
{\xe \v operator+\:QCPRange}
{\xe \v QCPRange\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator+ (const {\b QCPRange} &  {\i range}, double  {\i value}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADFU}
{\bkmkend AAAAAAADFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\i value}  to both boundaries of the range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   828 \{\par
  829   QCPRange result(range);\par
  830   result += value;\par
  831   return result;\par
  832 \}\par
}
}
{\xe \v operator+\:QCPRange}
{\xe \v QCPRange\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator+ (double  {\i value}, const {\b QCPRange} &  {\i range}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADFV}
{\bkmkend AAAAAAADFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\i value}  to both boundaries of the range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   838 \{\par
  839   QCPRange result(range);\par
  840   result += value;\par
  841   return result;\par
  842 \}\par
}
}
{\xe \v operator-\:QCPRange}
{\xe \v QCPRange\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator- (const {\b QCPRange} &  {\i range}, double  {\i value}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADFW}
{\bkmkend AAAAAAADFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtracts {\i value}  from both boundaries of the range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   848 \{\par
  849   QCPRange result(range);\par
  850   result -= value;\par
  851   return result;\par
  852 \}\par
}
}
{\xe \v operator/\:QCPRange}
{\xe \v QCPRange\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator/ (const {\b QCPRange} &  {\i range}, double  {\i value}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADFX}
{\bkmkend AAAAAAADFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Divides both boundaries of the range by {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   878 \{\par
  879   QCPRange result(range);\par
  880   result /= value;\par
  881   return result;\par
  882 \}\par
}
}
{\xe \v operator<<\:QCPRange}
{\xe \v QCPRange\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QDebug operator<< (QDebug  {\i d}, const {\b QCPRange} &  {\i range}){\f2 [related]}}}
\par
{\bkmkstart AAAAAAADFY}
{\bkmkend AAAAAAADFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints {\i range}  in a human readable format to the qDebug output. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   819 \{\par
  820     d.nospace() << "QCPRange(" << range.lower << ", " << range.upper << ")";\par
  821     return d.space();\par
  822 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v lower\:QCPRange}
{\xe \v QCPRange\:lower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPRange::lower}}
\par
{\bkmkstart AAAAAAADFZ}
{\bkmkend AAAAAAADFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v maxRange\:QCPRange}
{\xe \v QCPRange\:maxRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double QCPRange::maxRange = 1e250{\f2 [static]}}}
\par
{\bkmkstart AAAAAAADGA}
{\bkmkend AAAAAAADGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum values (negative and positive) the range will accept in range-changing functions. Larger absolute values would cause errors due to the 11-bit exponent of double precision numbers, corresponding to a maximum magnitude of roughly 1e308.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Do not use this constant to indicate "arbitrarily large" values in plotting logic (as values that will appear in the plot)! It is intended only as a bound to compare against, e.g. to prevent axis ranges from obtaining overflowing ranges.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b validRange}, {\b minRange} \par
}}}
{\xe \v minRange\:QCPRange}
{\xe \v QCPRange\:minRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double QCPRange::minRange = 1e-280{\f2 [static]}}}
\par
{\bkmkstart AAAAAAADGB}
{\bkmkend AAAAAAADGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum range size ({\i upper}  - {\i lower} ) the range changing functions will accept. Smaller intervals would cause errors due to the 11-bit exponent of double precision numbers, corresponding to a minimum magnitude of roughly 1e-308.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Do not use this constant to indicate "arbitrarily small" values in plotting logic (as values that will appear in the plot)! It is intended only as a bound to compare against, e.g. to prevent axis ranges from obtaining underflowing ranges.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b validRange}, {\b maxRange} \par
}}}
{\xe \v upper\:QCPRange}
{\xe \v QCPRange\:upper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPRange::upper}}
\par
{\bkmkstart AAAAAAADGC}
{\bkmkend AAAAAAADGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPScatterStyle Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPScatterStyle}
{\xe \v QCPScatterStyle}
{\bkmkstart AAAAAAADGD}
{\bkmkend AAAAAAADGD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the visual appearance of scatter points. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPScatterStyle:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_scatter_style__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ScatterProperty} \{ {\b spNone} = 0x00, 
{\b spPen} = 0x01, 
{\b spBrush} = 0x02, 
{\b spSize} = 0x04, 
{\b spShape} = 0x08, 
{\b spAll} = 0xFF
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ScatterShape} \{ {\b ssNone}, 
{\b ssDot}, 
{\b ssCross}, 
{\b ssPlus}, 
{\b ssCircle}, 
{\b ssDisc}, 
{\b ssSquare}, 
{\b ssDiamond}, 
{\b ssStar}, 
{\b ssTriangle}, 
{\b ssTriangleInverted}, 
{\b ssCrossSquare}, 
{\b ssPlusSquare}, 
{\b ssCrossCircle}, 
{\b ssPlusCircle}, 
{\b ssPeace}, 
{\b ssPixmap}, 
{\b ssCustom}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} ({\b ScatterShape} {\b shape}, double {\b size}=6)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} ({\b ScatterShape} {\b shape}, const QColor &color, double {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} ({\b ScatterShape} {\b shape}, const QColor &color, const QColor &fill, double {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} ({\b ScatterShape} {\b shape}, const QPen &{\b pen}, const QBrush &{\b brush}, double {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} (const QPixmap &{\b pixmap})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} (const QPainterPath &{\b customPath}, const QPen &{\b pen}, const QBrush &{\b brush}=Qt::NoBrush, double {\b size}=6)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScatterShape} {\b shape} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b pixmap} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPainterPath {\b customPath} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFromOther} (const {\b QCPScatterStyle} &other, ScatterProperties properties)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSize} (double {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setShape} ({\b ScatterShape} {\b shape})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPixmap} (const QPixmap &{\b pixmap})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCustomPath} (const QPainterPath &{\b customPath})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isNone} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isPenDefined} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b undefinePen} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyTo} ({\b QCPPainter} *painter, const QPen &defaultPen) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawShape} ({\b QCPPainter} *painter, const QPointF &pos) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawShape} ({\b QCPPainter} *painter, double x, double y) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScatterShape} {\b mShape}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPainterPath {\b mCustomPath}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mPenDefined}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the visual appearance of scatter points. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class holds information about shape, color and size of scatter points. In plottables like {\b QCPGraph} it is used to store how scatter points shall be drawn. For example, {\b QCPGraph::setScatterStyle} takes a {\b QCPScatterStyle} instance.\par
A scatter style consists of a shape ({\b setShape}), a line color ({\b setPen}) and possibly a fill ({\b setBrush}), if the shape provides a fillable area. Further, the size of the shape can be controlled with {\b setSize}.\par
{\bkmkstart AAAAAAADGE}
{\bkmkend AAAAAAADGE}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Specifying a scatter style
\par}
{\tc\tcl2 \v Specifying a scatter style}
You can set all these configurations either by calling the respective functions on an instance: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } Or you can use one of the various constructors that take different parameter combinations, making it easy to specify a scatter style in a single call, like so: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par}
{\bkmkstart AAAAAAADGF}
{\bkmkend AAAAAAADGF}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Leaving the color/pen up to the plottable
\par}
{\tc\tcl2 \v Leaving the color/pen up to the plottable}
There are two constructors which leave the pen undefined: {\b QCPScatterStyle()} and {\b QCPScatterStyle(ScatterShape shape, double size)}. If those constructors are used, a call to {\b isPenDefined} will return false. It leads to scatter points that inherit the pen from the plottable that uses the scatter style. Thus, if such a scatter style is passed to {\b QCPGraph}, the line color of the graph ({\b QCPGraph::setPen}) will be used by the scatter points. This makes it very convenient to set up typical scatter settings:\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } Notice that it wasn't even necessary to explicitly call a {\b QCPScatterStyle} constructor. This works because {\b QCPScatterStyle} provides a constructor that can transform a {\b ScatterShape} directly into a {\b QCPScatterStyle} instance (that's the {\b QCPScatterStyle(ScatterShape shape, double size)} constructor with a default for {\i size} ). In those cases, C++ allows directly supplying a {\b ScatterShape}, where actually a {\b QCPScatterStyle} is expected.\par}
{\bkmkstart AAAAAAADGG}
{\bkmkend AAAAAAADGG}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Custom shapes and pixmaps
\par}
{\tc\tcl2 \v Custom shapes and pixmaps}
{\b QCPScatterStyle} supports drawing custom shapes and arbitrary pixmaps as scatter points.\par
For custom shapes, you can provide a QPainterPath with the desired shape to the {\b setCustomPath} function or call the constructor that takes a painter path. The scatter shape will automatically be set to {\b ssCustom}.\par
For pixmaps, you call {\b setPixmap} with the desired QPixmap. Alternatively you can use the constructor that takes a QPixmap. The scatter shape will automatically be set to {\b ssPixmap}. Note that {\b setSize} does not influence the appearance of the pixmap. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ScatterProperty\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ScatterProperty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPScatterStyle::ScatterProperty}}}
\par
{\bkmkstart AAAAAAADGH}
{\bkmkend AAAAAAADGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the various properties of a scatter style instance. For example, this enum is used to specify which properties of {\b QCPSelectionDecorator::setScatterStyle} will be used when highlighting selected data points.\par
Specific scatter properties can be transferred between {\b QCPScatterStyle} instances via {\b setFromOther}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v spNone\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:spNone}
{\qr spNone{\bkmkstart AAAAAAADGI}
{\bkmkend AAAAAAADGI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x00}  None \par
}\cell }{\row }
{\xe \v spPen\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:spPen}
{\qr spPen{\bkmkstart AAAAAAADGJ}
{\bkmkend AAAAAAADGJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x01}  The pen property, see {\b setPen} \par
}\cell }{\row }
{\xe \v spBrush\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:spBrush}
{\qr spBrush{\bkmkstart AAAAAAADGK}
{\bkmkend AAAAAAADGK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x02}  The brush property, see {\b setBrush} \par
}\cell }{\row }
{\xe \v spSize\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:spSize}
{\qr spSize{\bkmkstart AAAAAAADGL}
{\bkmkend AAAAAAADGL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x04}  The size property, see {\b setSize} \par
}\cell }{\row }
{\xe \v spShape\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:spShape}
{\qr spShape{\bkmkstart AAAAAAADGM}
{\bkmkend AAAAAAADGM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x08}  The shape property, see {\b setShape} \par
}\cell }{\row }
{\xe \v spAll\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:spAll}
{\qr spAll{\bkmkstart AAAAAAADGN}
{\bkmkend AAAAAAADGN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0xFF}  All properties \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2300                        \{ spNone  = 0x00  \par
 2301                          ,spPen   = 0x01  \par
 2302                          ,spBrush = 0x02  \par
 2303                          ,spSize  = 0x04  \par
 2304                          ,spShape = 0x08  \par
 2305                          ,spAll   = 0xFF  \par
 2306                        \};\par
}
}
{\xe \v ScatterShape\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ScatterShape}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPScatterStyle::ScatterShape}}}
\par
{\bkmkstart AAAAAAADGO}
{\bkmkend AAAAAAADGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the shape used for scatter points.\par
On plottables/items that draw scatters, the sizes of these visualizations (with exception of {\b ssDot} and {\b ssPixmap}) can be controlled with the {\b setSize} function. Scatters are drawn with the pen and brush specified with {\b setPen} and {\b setBrush}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ssNone\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssNone}
{\qr ssNone{\bkmkstart AAAAAAADGP}
{\bkmkend AAAAAAADGP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
no scatter symbols are drawn (e.g. in {\b QCPGraph}, data only represented with lines) \par
}\cell }{\row }
{\xe \v ssDot\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssDot}
{\qr ssDot{\bkmkstart AAAAAAADGQ}
{\bkmkend AAAAAAADGQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssDot.png\} a single pixel (use {\b ssDisc} or {\b ssCircle} if you want a round shape with a certain radius) \par
}\cell }{\row }
{\xe \v ssCross\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssCross}
{\qr ssCross{\bkmkstart AAAAAAADGR}
{\bkmkend AAAAAAADGR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssCross.png\} a cross \par
}\cell }{\row }
{\xe \v ssPlus\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssPlus}
{\qr ssPlus{\bkmkstart AAAAAAADGS}
{\bkmkend AAAAAAADGS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssPlus.png\} a plus \par
}\cell }{\row }
{\xe \v ssCircle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssCircle}
{\qr ssCircle{\bkmkstart AAAAAAADGT}
{\bkmkend AAAAAAADGT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssCircle.png\} a circle \par
}\cell }{\row }
{\xe \v ssDisc\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssDisc}
{\qr ssDisc{\bkmkstart AAAAAAADGU}
{\bkmkend AAAAAAADGU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssDisc.png\} a circle which is filled with the pen's color (not the brush as with ssCircle) \par
}\cell }{\row }
{\xe \v ssSquare\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssSquare}
{\qr ssSquare{\bkmkstart AAAAAAADGV}
{\bkmkend AAAAAAADGV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssSquare.png\} a square \par
}\cell }{\row }
{\xe \v ssDiamond\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssDiamond}
{\qr ssDiamond{\bkmkstart AAAAAAADGW}
{\bkmkend AAAAAAADGW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssDiamond.png\} a diamond \par
}\cell }{\row }
{\xe \v ssStar\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssStar}
{\qr ssStar{\bkmkstart AAAAAAADGX}
{\bkmkend AAAAAAADGX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssStar.png\} a star with eight arms, i.e. a combination of cross and plus \par
}\cell }{\row }
{\xe \v ssTriangle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssTriangle}
{\qr ssTriangle{\bkmkstart AAAAAAADGY}
{\bkmkend AAAAAAADGY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssTriangle.png\} an equilateral triangle, standing on baseline \par
}\cell }{\row }
{\xe \v ssTriangleInverted\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssTriangleInverted}
{\qr ssTriangleInverted{\bkmkstart AAAAAAADGZ}
{\bkmkend AAAAAAADGZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssTriangleInverted.png\} an equilateral triangle, standing on corner \par
}\cell }{\row }
{\xe \v ssCrossSquare\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssCrossSquare}
{\qr ssCrossSquare{\bkmkstart AAAAAAADHA}
{\bkmkend AAAAAAADHA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssCrossSquare.png\} a square with a cross inside \par
}\cell }{\row }
{\xe \v ssPlusSquare\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssPlusSquare}
{\qr ssPlusSquare{\bkmkstart AAAAAAADHB}
{\bkmkend AAAAAAADHB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssPlusSquare.png\} a square with a plus inside \par
}\cell }{\row }
{\xe \v ssCrossCircle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssCrossCircle}
{\qr ssCrossCircle{\bkmkstart AAAAAAADHC}
{\bkmkend AAAAAAADHC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssCrossCircle.png\} a circle with a cross inside \par
}\cell }{\row }
{\xe \v ssPlusCircle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssPlusCircle}
{\qr ssPlusCircle{\bkmkstart AAAAAAADHD}
{\bkmkend AAAAAAADHD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssPlusCircle.png\} a circle with a plus inside \par
}\cell }{\row }
{\xe \v ssPeace\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssPeace}
{\qr ssPeace{\bkmkstart AAAAAAADHE}
{\bkmkend AAAAAAADHE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\{ssPeace.png\} a circle, with one vertical and two downward diagonal lines \par
}\cell }{\row }
{\xe \v ssPixmap\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssPixmap}
{\qr ssPixmap{\bkmkstart AAAAAAADHF}
{\bkmkend AAAAAAADHF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a custom pixmap specified by {\b setPixmap}, centered on the data point coordinates \par
}\cell }{\row }
{\xe \v ssCustom\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:ssCustom}
{\qr ssCustom{\bkmkstart AAAAAAADHG}
{\bkmkend AAAAAAADHG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
custom painter operations are performed per scatter (As QPainterPath, see {\b setCustomPath}) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2318                     \{ ssNone       \par
 2319                       ,ssDot       \par
 2320                       ,ssCross     \par
 2321                       ,ssPlus      \par
 2322                       ,ssCircle    \par
 2323                       ,ssDisc      \par
 2324                       ,ssSquare    \par
 2325                       ,ssDiamond   \par
 2326                       ,ssStar      \par
 2327                       ,ssTriangle  \par
 2328                       ,ssTriangleInverted \par
 2329                       ,ssCrossSquare      \par
 2330                       ,ssPlusSquare       \par
 2331                       ,ssCrossCircle      \par
 2332                       ,ssPlusCircle       \par
 2333                       ,ssPeace     \par
 2334                       ,ssPixmap    \par
 2335                       ,ssCustom    \par
 2336                     \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPScatterStyle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPScatterStyle::QCPScatterStyle ()}}
\par
{\bkmkstart AAAAAAADHH}
{\bkmkend AAAAAAADHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPScatterStyle} instance with size set to 6. No shape, pen or brush is defined.\par
Since the pen is undefined ({\b isPenDefined} returns false), the scatter color will be inherited from the plottable that uses this scatter style. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9909                                  :\par
 9910   mSize(6),\par
 9911   mShape(ssNone),\par
 9912   mPen(Qt::NoPen),\par
 9913   mBrush(Qt::NoBrush),\par
 9914   mPenDefined(false)\par
 9915 \{\par
 9916 \}\par
}
}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPScatterStyle::QCPScatterStyle ({\b ScatterShape}  {\i shape}, double  {\i size} = {\f2 6})}}
\par
{\bkmkstart AAAAAAADHI}
{\bkmkend AAAAAAADHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPScatterStyle} instance with shape set to {\i shape}  and size to {\i size} . No pen or brush is defined.\par
Since the pen is undefined ({\b isPenDefined} returns false), the scatter color will be inherited from the plottable that uses this scatter style. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9925                                                                 :\par
 9926   mSize(size),\par
 9927   mShape(shape),\par
 9928   mPen(Qt::NoPen),\par
 9929   mBrush(Qt::NoBrush),\par
 9930   mPenDefined(false)\par
 9931 \{\par
 9932 \}\par
}
}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPScatterStyle::QCPScatterStyle ({\b ScatterShape}  {\i shape}, const QColor &  {\i color}, double  {\i size})}}
\par
{\bkmkstart AAAAAAADHJ}
{\bkmkend AAAAAAADHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPScatterStyle} instance with shape set to {\i shape} , the pen color set to {\i color} , and size to {\i size} . No brush is defined, i.e. the scatter point will not be filled. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9938                                                                                      :\par
 9939   mSize(size),\par
 9940   mShape(shape),\par
 9941   mPen(QPen(color)),\par
 9942   mBrush(Qt::NoBrush),\par
 9943   mPenDefined(true)\par
 9944 \{\par
 9945 \}\par
}
}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPScatterStyle::QCPScatterStyle ({\b ScatterShape}  {\i shape}, const QColor &  {\i color}, const QColor &  {\i fill}, double  {\i size})}}
\par
{\bkmkstart AAAAAAADHK}
{\bkmkend AAAAAAADHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPScatterStyle} instance with shape set to {\i shape} , the pen color set to {\i color} , the brush color to {\i fill}  (with a solid pattern), and size to {\i size} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9951                                                                                                          :\par
 9952   mSize(size),\par
 9953   mShape(shape),\par
 9954   mPen(QPen(color)),\par
 9955   mBrush(QBrush(fill)),\par
 9956   mPenDefined(true)\par
 9957 \{\par
 9958 \}\par
}
}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPScatterStyle::QCPScatterStyle ({\b ScatterShape}  {\i shape}, const QPen &  {\i pen}, const QBrush &  {\i brush}, double  {\i size})}}
\par
{\bkmkstart AAAAAAADHL}
{\bkmkend AAAAAAADHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPScatterStyle} instance with shape set to {\i shape} , the pen set to {\i pen} , the brush to {\i brush} , and size to {\i size} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid In some cases it might be tempting to directly use a pen style like {\f2 Qt::NoPen}  as {\i pen}  and a color like {\f2 Qt::blue}  as {\i brush} . Notice however, that the corresponding call\par
{\f2 {\b QCPScatterStyle(QCPScatterShape::ssCircle, Qt::NoPen, Qt::blue, 5)}} \par
doesn't necessarily lead C++ to use this constructor in some cases, but might mistake {\f2 Qt::NoPen}  for a QColor and use the {\b QCPScatterStyle(ScatterShape shape, const QColor &color, const QColor &fill, double size)} constructor instead (which will lead to an unexpected look of the scatter points). To prevent this, be more explicit with the parameter types. For example, use {\f2 QBrush(Qt::blue)}  instead of just {\f2 Qt::blue} , to clearly point out to the compiler that this constructor is wanted. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9975                                                                                                       :\par
 9976   mSize(size),\par
 9977   mShape(shape),\par
 9978   mPen(pen),\par
 9979   mBrush(brush),\par
 9980   mPenDefined(pen.style() != Qt::NoPen)\par
 9981 \{\par
 9982 \}\par
}
}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPScatterStyle::QCPScatterStyle (const QPixmap &  {\i pixmap})}}
\par
{\bkmkstart AAAAAAADHM}
{\bkmkend AAAAAAADHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPScatterStyle} instance which will show the specified {\i pixmap} . The scatter shape is set to {\b ssPixmap}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9988                                                       :\par
 9989   mSize(5),\par
 9990   mShape(ssPixmap),\par
 9991   mPen(Qt::NoPen),\par
 9992   mBrush(Qt::NoBrush),\par
 9993   mPixmap(pixmap),\par
 9994   mPenDefined(false)\par
 9995 \{\par
 9996 \}\par
}
}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:QCPScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPScatterStyle::QCPScatterStyle (const QPainterPath &  {\i customPath}, const QPen &  {\i pen}, const QBrush &  {\i brush} = {\f2 Qt::NoBrush}, double  {\i size} = {\f2 6})}}
\par
{\bkmkstart AAAAAAADHN}
{\bkmkend AAAAAAADHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPScatterStyle} instance with a custom shape that is defined via {\i customPath} . The scatter shape is set to {\b ssCustom}.\par
The custom shape line will be drawn with {\i pen}  and filled with {\i brush} . The size has a slightly different meaning than for built-in scatter points: The custom path will be drawn scaled by a factor of {\i size/6.0} . Since the default {\i size}  is 6, the custom path will appear in its original size by default. To for example double the size of the path, set {\i size}  to 12. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10007                                                                                                                   :\par
10008   mSize(size),\par
10009   mShape(ssCustom),\par
10010   mPen(pen),\par
10011   mBrush(brush),\par
10012   mCustomPath(customPath),\par
10013   mPenDefined(pen.style() != Qt::NoPen)\par
10014 \{\par
10015 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v applyTo\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:applyTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::applyTo ({\b QCPPainter} *  {\i painter}, const QPen &  {\i defaultPen}) const}}
\par
{\bkmkstart AAAAAAADHO}
{\bkmkend AAAAAAADHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the pen and the brush of this scatter style to {\i painter} . If this scatter style has an undefined pen ({\b isPenDefined}), sets the pen of {\i painter}  to {\i defaultPen}  instead.\par
This function is used by plottables (or any class that wants to draw scatters) just before a number of scatters with this style shall be drawn with the {\i painter} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b drawShape} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10136 \{\par
10137   painter->setPen(mPenDefined ? mPen : defaultPen);\par
10138   painter->setBrush(mBrush);\par
10139 \}\par
}
}
{\xe \v brush\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPScatterStyle::brush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHP}
{\bkmkend AAAAAAADHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2351 \{ return mBrush; \}\par
}
}
{\xe \v customPath\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:customPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPainterPath QCPScatterStyle::customPath () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHQ}
{\bkmkend AAAAAAADHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2353 \{ return mCustomPath; \}\par
}
}
{\xe \v drawShape\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:drawShape}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::drawShape ({\b QCPPainter} *  {\i painter}, const QPointF &  {\i pos}) const}}
\par
{\bkmkstart AAAAAAADHR}
{\bkmkend AAAAAAADHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the scatter shape with {\i painter}  at position {\i pos} .\par
This function does not modify the pen or the brush on the painter, as {\b applyTo} is meant to be called before scatter points are drawn with {\b drawShape}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b applyTo} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10150 \{\par
10151   drawShape(painter, pos.x(), pos.y());\par
10152 \}\par
}
}
{\xe \v drawShape\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:drawShape}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::drawShape ({\b QCPPainter} *  {\i painter}, double  {\i x}, double  {\i y}) const}}
\par
{\bkmkstart AAAAAAADHS}
{\bkmkend AAAAAAADHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Draws the scatter shape with {\i painter}  at position {\i x}  and {\i y} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10158 \{\par
10159   double w = mSize/2.0;\par
10160   switch (mShape)\par
10161   \{\par
10162     case ssNone: break;\par
10163     case ssDot:\par
10164     \{\par
10165       painter->drawLine(QPointF(x, y), QPointF(x+0.0001, y));\par
10166       break;\par
10167     \}\par
10168     case ssCross:\par
10169     \{\par
10170       painter->drawLine(QLineF(x-w, y-w, x+w, y+w));\par
10171       painter->drawLine(QLineF(x-w, y+w, x+w, y-w));\par
10172       break;\par
10173     \}\par
10174     case ssPlus:\par
10175     \{\par
10176       painter->drawLine(QLineF(x-w,   y, x+w,   y));\par
10177       painter->drawLine(QLineF(  x, y+w,   x, y-w));\par
10178       break;\par
10179     \}\par
10180     case ssCircle:\par
10181     \{\par
10182       painter->drawEllipse(QPointF(x , y), w, w);\par
10183       break;\par
10184     \}\par
10185     case ssDisc:\par
10186     \{\par
10187       QBrush b = painter->brush();\par
10188       painter->setBrush(painter->pen().color());\par
10189       painter->drawEllipse(QPointF(x , y), w, w);\par
10190       painter->setBrush(b);\par
10191       break;\par
10192     \}\par
10193     case ssSquare:\par
10194     \{\par
10195       painter->drawRect(QRectF(x-w, y-w, mSize, mSize));\par
10196       break;\par
10197     \}\par
10198     case ssDiamond:\par
10199     \{\par
10200       QPointF lineArray[4] = \{QPointF(x-w,   y),\par
10201                               QPointF(  x, y-w),\par
10202                               QPointF(x+w,   y),\par
10203                               QPointF(  x, y+w)\};\par
10204       painter->drawPolygon(lineArray, 4);\par
10205       break;\par
10206     \}\par
10207     case ssStar:\par
10208     \{\par
10209       painter->drawLine(QLineF(x-w,   y, x+w,   y));\par
10210       painter->drawLine(QLineF(  x, y+w,   x, y-w));\par
10211       painter->drawLine(QLineF(x-w*0.707, y-w*0.707, x+w*0.707, y+w*0.707));\par
10212       painter->drawLine(QLineF(x-w*0.707, y+w*0.707, x+w*0.707, y-w*0.707));\par
10213       break;\par
10214     \}\par
10215     case ssTriangle:\par
10216     \{\par
10217       QPointF lineArray[3] = \{QPointF(x-w, y+0.755*w),\par
10218                               QPointF(x+w, y+0.755*w),\par
10219                               QPointF(  x, y-0.977*w)\};\par
10220       painter->drawPolygon(lineArray, 3);\par
10221       break;\par
10222     \}\par
10223     case ssTriangleInverted:\par
10224     \{\par
10225       QPointF lineArray[3] = \{QPointF(x-w, y-0.755*w),\par
10226                               QPointF(x+w, y-0.755*w),\par
10227                               QPointF(  x, y+0.977*w)\};\par
10228       painter->drawPolygon(lineArray, 3);\par
10229       break;\par
10230     \}\par
10231     case ssCrossSquare:\par
10232     \{\par
10233       painter->drawRect(QRectF(x-w, y-w, mSize, mSize));\par
10234       painter->drawLine(QLineF(x-w, y-w, x+w*0.95, y+w*0.95));\par
10235       painter->drawLine(QLineF(x-w, y+w*0.95, x+w*0.95, y-w));\par
10236       break;\par
10237     \}\par
10238     case ssPlusSquare:\par
10239     \{\par
10240       painter->drawRect(QRectF(x-w, y-w, mSize, mSize));\par
10241       painter->drawLine(QLineF(x-w,   y, x+w*0.95,   y));\par
10242       painter->drawLine(QLineF(  x, y+w,        x, y-w));\par
10243       break;\par
10244     \}\par
10245     case ssCrossCircle:\par
10246     \{\par
10247       painter->drawEllipse(QPointF(x, y), w, w);\par
10248       painter->drawLine(QLineF(x-w*0.707, y-w*0.707, x+w*0.670, y+w*0.670));\par
10249       painter->drawLine(QLineF(x-w*0.707, y+w*0.670, x+w*0.670, y-w*0.707));\par
10250       break;\par
10251     \}\par
10252     case ssPlusCircle:\par
10253     \{\par
10254       painter->drawEllipse(QPointF(x, y), w, w);\par
10255       painter->drawLine(QLineF(x-w,   y, x+w,   y));\par
10256       painter->drawLine(QLineF(  x, y+w,   x, y-w));\par
10257       break;\par
10258     \}\par
10259     case ssPeace:\par
10260     \{\par
10261       painter->drawEllipse(QPointF(x, y), w, w);\par
10262       painter->drawLine(QLineF(x, y-w,         x,       y+w));\par
10263       painter->drawLine(QLineF(x,   y, x-w*0.707, y+w*0.707));\par
10264       painter->drawLine(QLineF(x,   y, x+w*0.707, y+w*0.707));\par
10265       break;\par
10266     \}\par
10267     case ssPixmap:\par
10268     \{\par
10269       const double widthHalf = mPixmap.width()*0.5;\par
10270       const double heightHalf = mPixmap.height()*0.5;\par
10271 #if QT_VERSION < QT_VERSION_CHECK(4, 8, 0)\par
10272       const QRectF clipRect = painter->clipRegion().boundingRect().adjusted(-widthHalf, -heightHalf, widthHalf, heightHalf);\par
10273 #else\par
10274       const QRectF clipRect = painter->clipBoundingRect().adjusted(-widthHalf, -heightHalf, widthHalf, heightHalf);\par
10275 #endif\par
10276       if (clipRect.contains(x, y))\par
10277         painter->drawPixmap(x-widthHalf, y-heightHalf, mPixmap);\par
10278       break;\par
10279     \}\par
10280     case ssCustom:\par
10281     \{\par
10282       QTransform oldTransform = painter->transform();\par
10283       painter->translate(x, y);\par
10284       painter->scale(mSize/6.0, mSize/6.0);\par
10285       painter->drawPath(mCustomPath);\par
10286       painter->setTransform(oldTransform);\par
10287       break;\par
10288     \}\par
10289   \}\par
10290 \}\par
}
}
{\xe \v isNone\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:isNone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPScatterStyle::isNone () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHT}
{\bkmkend AAAAAAADHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the scatter shape is {\b ssNone}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setShape} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2365 \{ return mShape == ssNone; \}\par
}
}
{\xe \v isPenDefined\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:isPenDefined}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPScatterStyle::isPenDefined () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHU}
{\bkmkend AAAAAAADHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether a pen has been defined for this scatter style.\par
The pen is undefined if a constructor is called that does not carry {\i pen}  as parameter. Those are {\b QCPScatterStyle()} and {\b QCPScatterStyle(ScatterShape shape, double size)}. If the pen is undefined, the pen of the respective plottable will be used for drawing scatters.\par
If a pen was defined for this scatter style instance, and you now wish to undefine the pen, call {\b undefinePen}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2366 \{ return mPenDefined; \}\par
}
}
{\xe \v pen\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPScatterStyle::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHV}
{\bkmkend AAAAAAADHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2350 \{ return mPen; \}\par
}
}
{\xe \v pixmap\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:pixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPScatterStyle::pixmap () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHW}
{\bkmkend AAAAAAADHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2352 \{ return mPixmap; \}\par
}
}
{\xe \v setBrush\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::setBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAADHX}
{\bkmkend AAAAAAADHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used to fill scatter points to {\i brush} . Note that not all scatter shapes have fillable areas. For example, {\b ssPlus} does not while {\b ssCircle} does.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10087 \{\par
10088   mBrush = brush;\par
10089 \}\par
}
}
{\xe \v setCustomPath\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:setCustomPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::setCustomPath (const QPainterPath &  {\i customPath})}}
\par
{\bkmkstart AAAAAAADHY}
{\bkmkend AAAAAAADHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the custom shape that will be drawn as scatter point to {\i customPath} .\par
The scatter shape is automatically set to {\b ssCustom}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10110 \{\par
10111   setShape(ssCustom);\par
10112   mCustomPath = customPath;\par
10113 \}\par
}
}
{\xe \v setFromOther\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:setFromOther}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::setFromOther (const {\b QCPScatterStyle} &  {\i other}, ScatterProperties  {\i properties})}}
\par
{\bkmkstart AAAAAAADHZ}
{\bkmkend AAAAAAADHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the specified {\i properties}  from the {\i other}  scatter style to this scatter style. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10021 \{\par
10022   if (properties.testFlag(spPen))\par
10023   \{\par
10024     setPen(other.pen());\par
10025     if (!other.isPenDefined())\par
10026       undefinePen();\par
10027   \}\par
10028   if (properties.testFlag(spBrush))\par
10029     setBrush(other.brush());\par
10030   if (properties.testFlag(spSize))\par
10031     setSize(other.size());\par
10032   if (properties.testFlag(spShape))\par
10033   \{\par
10034     setShape(other.shape());\par
10035     if (other.shape() == ssPixmap)\par
10036       setPixmap(other.pixmap());\par
10037     else if (other.shape() == ssCustom)\par
10038       setCustomPath(other.customPath());\par
10039   \}\par
10040 \}\par
}
}
{\xe \v setPen\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADIA}
{\bkmkend AAAAAAADIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw scatter points to {\i pen} .\par
If the pen was previously undefined (see {\b isPenDefined}), the pen is considered defined after a call to this function, even if {\i pen}  is {\f2 Qt::NoPen} . If you have defined a pen previously by calling this function and now wish to undefine the pen, call {\b undefinePen}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10075 \{\par
10076   mPenDefined = true;\par
10077   mPen = pen;\par
10078 \}\par
}
}
{\xe \v setPixmap\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:setPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::setPixmap (const QPixmap &  {\i pixmap})}}
\par
{\bkmkstart AAAAAAADIB}
{\bkmkend AAAAAAADIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pixmap that will be drawn as scatter point to {\i pixmap} .\par
Note that {\b setSize} does not influence the appearance of the pixmap.\par
The scatter shape is automatically set to {\b ssPixmap}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10099 \{\par
10100   setShape(ssPixmap);\par
10101   mPixmap = pixmap;\par
10102 \}\par
}
}
{\xe \v setShape\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:setShape}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::setShape ({\b QCPScatterStyle::ScatterShape}  {\i shape})}}
\par
{\bkmkstart AAAAAAADIC}
{\bkmkend AAAAAAADIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the shape to {\i shape} .\par
Note that the calls {\b setPixmap} and {\b setCustomPath} automatically set the shape to {\b ssPixmap} and {\b ssCustom}, respectively.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10061 \{\par
10062   mShape = shape;\par
10063 \}\par
}
}
{\xe \v setSize\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:setSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::setSize (double  {\i size})}}
\par
{\bkmkstart AAAAAAADID}
{\bkmkend AAAAAAADID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the size (pixel diameter) of the drawn scatter points to {\i size} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setShape} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10048 \{\par
10049   mSize = size;\par
10050 \}\par
}
}
{\xe \v shape\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:shape}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScatterShape} QCPScatterStyle::shape () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADIE}
{\bkmkend AAAAAAADIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2349 \{ return mShape; \}\par
}
}
{\xe \v size\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPScatterStyle::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADIF}
{\bkmkend AAAAAAADIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2348 \{ return mSize; \}\par
}
}
{\xe \v undefinePen\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:undefinePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPScatterStyle::undefinePen ()}}
\par
{\bkmkstart AAAAAAADIG}
{\bkmkend AAAAAAADIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets this scatter style to have an undefined pen (see {\b isPenDefined} for what an undefined pen implies).\par
A call to {\b setPen} will define a pen. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10122 \{\par
10123   mPenDefined = false;\par
10124 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBrush\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPScatterStyle::mBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADIH}
{\bkmkend AAAAAAADIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mCustomPath\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:mCustomPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPainterPath QCPScatterStyle::mCustomPath{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADII}
{\bkmkend AAAAAAADII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPScatterStyle::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADIJ}
{\bkmkend AAAAAAADIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPenDefined\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:mPenDefined}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPScatterStyle::mPenDefined{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADIK}
{\bkmkend AAAAAAADIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPixmap\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:mPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPScatterStyle::mPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADIL}
{\bkmkend AAAAAAADIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mShape\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:mShape}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScatterShape} QCPScatterStyle::mShape{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADIM}
{\bkmkend AAAAAAADIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSize\:QCPScatterStyle}
{\xe \v QCPScatterStyle\:mSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPScatterStyle::mSize{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADIN}
{\bkmkend AAAAAAADIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPSelectionDecorator Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator}
{\bkmkstart AAAAAAADIO}
{\bkmkend AAAAAAADIO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls how a plottable's data selection is drawn. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPSelectionDecorator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_selection_decorator__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPSelectionDecorator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_selection_decorator__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionDecorator} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPSelectionDecorator} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b scatterStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCPScatterStyle::ScatterProperties {\b usedScatterProperties} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScatterStyle} (const {\b QCPScatterStyle} &{\b scatterStyle}, QCPScatterStyle::ScatterProperties usedProperties={\b QCPScatterStyle::spPen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setUsedScatterProperties} (const QCPScatterStyle::ScatterProperties &properties)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyPen} ({\b QCPPainter} *painter) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyBrush} ({\b QCPPainter} *painter) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b getFinalScatterStyle} (const {\b QCPScatterStyle} &unselectedStyle) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b copyFrom} (const {\b QCPSelectionDecorator} *other)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawDecoration} ({\b QCPPainter} *painter, {\b QCPDataSelection} selection)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b registerWithPlottable} ({\b QCPAbstractPlottable} *plottable)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b mScatterStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCPScatterStyle::ScatterProperties {\b mUsedScatterProperties}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b mPlottable}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractPlottable}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls how a plottable's data selection is drawn. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Each {\b QCPAbstractPlottable} instance has one {\b QCPSelectionDecorator} (accessible via {\b QCPAbstractPlottable::selectionDecorator}) and uses it when drawing selected segments of its data.\par
The selection decorator controls both pen ({\b setPen}) and brush ({\b setBrush}), as well as the scatter style ({\b setScatterStyle}) if the plottable draws scatters. Since a {\b QCPScatterStyle} is itself composed of different properties such as color shape and size, the decorator allows specifying exactly which of those properties shall be used for the selected data point, via {\b setUsedScatterProperties}.\par
A {\b QCPSelectionDecorator} subclass instance can be passed to a plottable via {\b QCPAbstractPlottable::setSelectionDecorator}, allowing greater customizability of the appearance of selected segments.\par
Use {\b copyFrom} to easily transfer the settings of one decorator to another one. This is especially useful since plottables take ownership of the passed selection decorator, and thus the same decorator instance can not be passed to multiple plottables.\par
Selection decorators can also themselves perform drawing operations by reimplementing {\b drawDecoration}, which is called by the plottable's draw method. The base class {\b QCPSelectionDecorator} does not make use of this however. For example, {\b QCPSelectionDecoratorBracket} draws brackets around selected data segments. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPSelectionDecorator\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:QCPSelectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPSelectionDecorator::QCPSelectionDecorator ()}}
\par
{\bkmkstart AAAAAAADIP}
{\bkmkend AAAAAAADIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPSelectionDecorator} instance with default values \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10331                                              :\par
10332   mPen(QColor(80, 80, 255), 2.5),\par
10333   mBrush(Qt::NoBrush),\par
10334   mScatterStyle(),\par
10335   mUsedScatterProperties(QCPScatterStyle::spNone),\par
10336   mPlottable(0)\par
10337 \{\par
10338 \}\par
}
}
{\xe \v ~QCPSelectionDecorator\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:~QCPSelectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPSelectionDecorator::~QCPSelectionDecorator (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADIQ}
{\bkmkend AAAAAAADIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10341 \{\par
10342 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v applyBrush\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:applyBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecorator::applyBrush ({\b QCPPainter} *  {\i painter}) const}}
\par
{\bkmkstart AAAAAAADIR}
{\bkmkend AAAAAAADIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush of {\i painter}  to the brush of this selection decorator.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b applyPen}, {\b getFinalScatterStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10401 \{\par
10402   painter->setBrush(mBrush);\par
10403 \}\par
}
}
{\xe \v applyPen\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:applyPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecorator::applyPen ({\b QCPPainter} *  {\i painter}) const}}
\par
{\bkmkstart AAAAAAADIS}
{\bkmkend AAAAAAADIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen of {\i painter}  to the pen of this selection decorator.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b applyBrush}, {\b getFinalScatterStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10391 \{\par
10392   painter->setPen(mPen);\par
10393 \}\par
}
}
{\xe \v brush\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPSelectionDecorator::brush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADIT}
{\bkmkend AAAAAAADIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3249 \{ return mBrush; \}\par
}
}
{\xe \v copyFrom\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:copyFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecorator::copyFrom (const {\b QCPSelectionDecorator} *  {\i other}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADIU}
{\bkmkend AAAAAAADIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies all properties (e.g. color, fill, scatter style) of the {\i other}  selection decorator to this selection decorator. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10432 \{\par
10433   setPen(other->pen());\par
10434   setBrush(other->brush());\par
10435   setScatterStyle(other->scatterStyle(), other->usedScatterProperties());\par
10436 \}\par
}
}
{\xe \v drawDecoration\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:drawDecoration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecorator::drawDecoration ({\b QCPPainter} *  {\i painter}, {\b QCPDataSelection}  {\i selection}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADIV}
{\bkmkend AAAAAAADIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is called by all plottables' draw methods to allow custom selection decorations to be drawn. Use the passed {\i painter}  to perform the drawing operations. {\i selection}  carries the data selection for which the decoration shall be drawn.\par
The default base class implementation of {\b QCPSelectionDecorator} has no special decoration, so this method does nothing. \par
}{
Reimplemented in {\b QCPSelectionDecoratorBracket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADIW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10447 \{\par
10448   Q_UNUSED(painter)\par
10449   Q_UNUSED(selection)\par
10450 \}\par
}
}
{\xe \v getFinalScatterStyle\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:getFinalScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPSelectionDecorator::getFinalScatterStyle (const {\b QCPScatterStyle} &  {\i unselectedStyle}) const}}
\par
{\bkmkstart AAAAAAADIX}
{\bkmkend AAAAAAADIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the scatter style that the parent plottable shall use for selected scatter points. The plottable's original (unselected) scatter style must be passed as {\i unselectedStyle} . Depending on the setting of {\b setUsedScatterProperties}, the returned scatter style is a mixture of this selecion decorator's scatter style ({\b setScatterStyle}), and {\i unselectedStyle} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b applyPen}, {\b applyBrush}, {\b setScatterStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10414 \{\par
10415   QCPScatterStyle result(unselectedStyle);\par
10416   result.setFromOther(mScatterStyle, mUsedScatterProperties);\par
10417   \par
10418   // if style shall inherit pen from plottable (has no own pen defined), give it the selected\par
10419   // plottable pen explicitly, so it doesn't use the unselected plottable pen when used in the\par
10420   // plottable:\par
10421   if (!result.isPenDefined())\par
10422     result.setPen(mPen);\par
10423   \par
10424   return result;\par
10425 \}\par
}
}
{\xe \v pen\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPSelectionDecorator::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADIY}
{\bkmkend AAAAAAADIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3248 \{ return mPen; \}\par
}
}
{\xe \v registerWithPlottable\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:registerWithPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPSelectionDecorator::registerWithPlottable ({\b QCPAbstractPlottable} *  {\i plottable}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADIZ}
{\bkmkend AAAAAAADIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10462 \{\par
10463   if (!mPlottable)\par
10464   \{\par
10465     mPlottable = plottable;\par
10466     return true;\par
10467   \} else\par
10468   \{\par
10469     qDebug() << Q_FUNC_INFO << "This selection decorator is already registered with plottable:" << reinterpret_cast<quintptr>(mPlottable);\par
10470     return false;\par
10471   \}\par
10472 \}\par
}
}
{\xe \v scatterStyle\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:scatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPSelectionDecorator::scatterStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADJA}
{\bkmkend AAAAAAADJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3250 \{ return mScatterStyle; \}\par
}
}
{\xe \v setBrush\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecorator::setBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAADJB}
{\bkmkend AAAAAAADJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used by the parent plottable to draw selected data segments. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10356 \{\par
10357   mBrush = brush;\par
10358 \}\par
}
}
{\xe \v setPen\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecorator::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADJC}
{\bkmkend AAAAAAADJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used by the parent plottable to draw selected data segments. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10348 \{\par
10349   mPen = pen;\par
10350 \}\par
}
}
{\xe \v setScatterStyle\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:setScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecorator::setScatterStyle (const {\b QCPScatterStyle} &  {\i scatterStyle}, QCPScatterStyle::ScatterProperties  {\i usedProperties} = {\f2 {\b QCPScatterStyle::spPen}})}}
\par
{\bkmkstart AAAAAAADJD}
{\bkmkend AAAAAAADJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the scatter style that will be used by the parent plottable to draw scatters in selected data segments.\par
{\i usedProperties}  specifies which parts of the passed {\i scatterStyle}  will be used by the plottable. The used properties can also be changed via {\b setUsedScatterProperties}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10368 \{\par
10369   mScatterStyle = scatterStyle;\par
10370   setUsedScatterProperties(usedProperties);\par
10371 \}\par
}
}
{\xe \v setUsedScatterProperties\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:setUsedScatterProperties}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecorator::setUsedScatterProperties (const QCPScatterStyle::ScatterProperties &  {\i properties})}}
\par
{\bkmkstart AAAAAAADJE}
{\bkmkend AAAAAAADJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use this method to define which properties of the scatter style (set via {\b setScatterStyle}) will be used for selected data segments. All properties of the scatter style that are not specified in {\i properties}  will remain as specified in the plottable's original scatter style.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPScatterStyle::ScatterProperty} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10381 \{\par
10382   mUsedScatterProperties = properties;\par
10383 \}\par
}
}
{\xe \v usedScatterProperties\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:usedScatterProperties}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPScatterStyle::ScatterProperties QCPSelectionDecorator::usedScatterProperties () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADJF}
{\bkmkend AAAAAAADJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3251 \{ return mUsedScatterProperties; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPAbstractPlottable\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:QCPAbstractPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAbstractPlottable}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADJG}
{\bkmkend AAAAAAADJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBrush\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPSelectionDecorator::mBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADJH}
{\bkmkend AAAAAAADJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPSelectionDecorator::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADJI}
{\bkmkend AAAAAAADJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPlottable\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:mPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable}* QCPSelectionDecorator::mPlottable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADJJ}
{\bkmkend AAAAAAADJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScatterStyle\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:mScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPSelectionDecorator::mScatterStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADJK}
{\bkmkend AAAAAAADJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mUsedScatterProperties\:QCPSelectionDecorator}
{\xe \v QCPSelectionDecorator\:mUsedScatterProperties}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPScatterStyle::ScatterProperties QCPSelectionDecorator::mUsedScatterProperties{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADJL}
{\bkmkend AAAAAAADJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPSelectionDecoratorBracket Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket}
{\bkmkstart AAAAAAADJM}
{\bkmkend AAAAAAADJM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A selection decorator which draws brackets around each selected data segment. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPSelectionDecoratorBracket:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_selection_decorator_bracket__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPSelectionDecoratorBracket:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_selection_decorator_bracket__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b BracketStyle} \{ {\b bsSquareBracket}, 
{\b bsHalfEllipse}, 
{\b bsEllipse}, 
{\b bsPlus}, 
{\b bsUserStyle}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionDecoratorBracket} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPSelectionDecoratorBracket} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b bracketPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b bracketBrush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bracketWidth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bracketHeight} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BracketStyle} {\b bracketStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b tangentToData} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tangentAverage} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBracketPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBracketBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBracketWidth} (int width)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBracketHeight} (int height)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBracketStyle} ({\b BracketStyle} style)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTangentToData} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTangentAverage} (int pointCount)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawBracket} ({\b QCPPainter} *painter, int direction) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawDecoration} ({\b QCPPainter} *painter, {\b QCPDataSelection} selection) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getTangentAngle} (const {\b QCPPlottableInterface1D} *interface1d, int dataIndex, int direction) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointF {\b getPixelCoordinates} (const {\b QCPPlottableInterface1D} *interface1d, int dataIndex) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mBracketPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBracketBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mBracketWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mBracketHeight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BracketStyle} {\b mBracketStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mTangentToData}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mTangentAverage}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A selection decorator which draws brackets around each selected data segment. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Additionally to the regular highlighting of selected segments via color, fill and scatter style, this {\b QCPSelectionDecorator} subclass draws markers at the begin and end of each selected data segment of the plottable.\par
The shape of the markers can be controlled with {\b setBracketStyle}, {\b setBracketWidth} and {\b setBracketHeight}. The color/fill can be controlled with {\b setBracketPen} and {\b setBracketBrush}.\par
To introduce custom bracket styles, it is only necessary to sublcass {\b QCPSelectionDecoratorBracket} and reimplement {\b drawBracket}. The rest will be managed by the base class. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v BracketStyle\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:BracketStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPSelectionDecoratorBracket::BracketStyle}}}
\par
{\bkmkstart AAAAAAADJN}
{\bkmkend AAAAAAADJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines which shape is drawn at the boundaries of selected data ranges.\par
Some of the bracket styles further allow specifying a height and/or width, see {\b setBracketHeight} and {\b setBracketWidth}. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v bsSquareBracket\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bsSquareBracket}
{\qr bsSquareBracket{\bkmkstart AAAAAAADJO}
{\bkmkend AAAAAAADJO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A square bracket is drawn. \par
}\cell }{\row }
{\xe \v bsHalfEllipse\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bsHalfEllipse}
{\qr bsHalfEllipse{\bkmkstart AAAAAAADJP}
{\bkmkend AAAAAAADJP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A half ellipse is drawn. The size of the ellipse is given by the bracket width/height properties. \par
}\cell }{\row }
{\xe \v bsEllipse\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bsEllipse}
{\qr bsEllipse{\bkmkstart AAAAAAADJQ}
{\bkmkend AAAAAAADJQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An ellipse is drawn. The size of the ellipse is given by the bracket width/height properties. \par
}\cell }{\row }
{\xe \v bsPlus\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bsPlus}
{\qr bsPlus{\bkmkstart AAAAAAADJR}
{\bkmkend AAAAAAADJR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plus is drawn. \par
}\cell }{\row }
{\xe \v bsUserStyle\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bsUserStyle}
{\qr bsUserStyle{\bkmkstart AAAAAAADJS}
{\bkmkend AAAAAAADJS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start custom bracket styles at this index when subclassing and reimplementing {\b drawBracket}. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4524                     \{ bsSquareBracket \par
 4525                       ,bsHalfEllipse   \par
 4526                       ,bsEllipse       \par
 4527                       ,bsPlus         \par
 4528                       ,bsUserStyle    \par
 4529   \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPSelectionDecoratorBracket\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:QCPSelectionDecoratorBracket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPSelectionDecoratorBracket::QCPSelectionDecoratorBracket ()}}
\par
{\bkmkstart AAAAAAADJT}
{\bkmkend AAAAAAADJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPSelectionDecoratorBracket} instance with default values. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16387                                                            :\par
16388   mBracketPen(QPen(Qt::black)),\par
16389   mBracketBrush(Qt::NoBrush),\par
16390   mBracketWidth(5),\par
16391   mBracketHeight(50),\par
16392   mBracketStyle(bsSquareBracket),\par
16393   mTangentToData(false),\par
16394   mTangentAverage(2)\par
16395 \{\par
16396   \par
16397 \}\par
}
}
{\xe \v ~QCPSelectionDecoratorBracket\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:~QCPSelectionDecoratorBracket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPSelectionDecoratorBracket::~QCPSelectionDecoratorBracket (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADJU}
{\bkmkend AAAAAAADJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16400 \{\par
16401 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v bracketBrush\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bracketBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPSelectionDecoratorBracket::bracketBrush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADJV}
{\bkmkend AAAAAAADJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4537 \{ return mBracketBrush; \}\par
}
}
{\xe \v bracketHeight\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bracketHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPSelectionDecoratorBracket::bracketHeight () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADJW}
{\bkmkend AAAAAAADJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4539 \{ return mBracketHeight; \}\par
}
}
{\xe \v bracketPen\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bracketPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPSelectionDecoratorBracket::bracketPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADJX}
{\bkmkend AAAAAAADJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4536 \{ return mBracketPen; \}\par
}
}
{\xe \v bracketStyle\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bracketStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BracketStyle} QCPSelectionDecoratorBracket::bracketStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADJY}
{\bkmkend AAAAAAADJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4540 \{ return mBracketStyle; \}\par
}
}
{\xe \v bracketWidth\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:bracketWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPSelectionDecoratorBracket::bracketWidth () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADJZ}
{\bkmkend AAAAAAADJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4538 \{ return mBracketWidth; \}\par
}
}
{\xe \v drawBracket\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:drawBracket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecoratorBracket::drawBracket ({\b QCPPainter} *  {\i painter}, int  {\i direction}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADKA}
{\bkmkend AAAAAAADKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the bracket shape with {\i painter} . The parameter {\i direction}  is either -1 or 1 and indicates whether the bracket shall point to the left or the right (i.e. is a closing or opening bracket, respectively).\par
The passed {\i painter}  already contains all transformations that are necessary to position and rotate the bracket appropriately. Painting operations can be performed as if drawing upright brackets on flat data with horizontal key axis, with (0, 0) being the center of the bracket.\par
If you wish to sublcass {\b QCPSelectionDecoratorBracket} in order to provide custom bracket shapes (see {\b QCPSelectionDecoratorBracket::bsUserStyle}), this is the method you should reimplement. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16492 \{\par
16493   switch (mBracketStyle)\par
16494   \{\par
16495     case bsSquareBracket:\par
16496     \{\par
16497       painter->drawLine(QLineF(mBracketWidth*direction, -mBracketHeight*0.5, 0, -mBracketHeight*0.5));\par
16498       painter->drawLine(QLineF(mBracketWidth*direction, mBracketHeight*0.5, 0, mBracketHeight*0.5));\par
16499       painter->drawLine(QLineF(0, -mBracketHeight*0.5, 0, mBracketHeight*0.5));\par
16500       break;\par
16501     \}\par
16502     case bsHalfEllipse:\par
16503     \{\par
16504       painter->drawArc(-mBracketWidth*0.5, -mBracketHeight*0.5, mBracketWidth, mBracketHeight, -90*16, -180*16*direction);\par
16505       break;\par
16506     \}\par
16507     case bsEllipse:\par
16508     \{\par
16509       painter->drawEllipse(-mBracketWidth*0.5, -mBracketHeight*0.5, mBracketWidth, mBracketHeight);\par
16510       break;\par
16511     \}\par
16512     case bsPlus:\par
16513     \{\par
16514       painter->drawLine(QLineF(0, -mBracketHeight*0.5, 0, mBracketHeight*0.5));\par
16515       painter->drawLine(QLineF(-mBracketWidth*0.5, 0, mBracketWidth*0.5, 0));\par
16516       break;\par
16517     \}\par
16518     default:\par
16519     \{\par
16520       qDebug() << Q_FUNC_INFO << "unknown/custom bracket style can't be handeld by default implementation:" << static_cast<int>(mBracketStyle);\par
16521       break;\par
16522     \}\par
16523   \}\par
16524 \}\par
}
}
{\xe \v drawDecoration\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:drawDecoration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecoratorBracket::drawDecoration ({\b QCPPainter} *  {\i painter}, {\b QCPDataSelection}  {\i selection}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADIW}
{\bkmkend AAAAAAADIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the bracket decoration on the data points at the begin and end of each selected data segment given in {\i seletion} .\par
It uses the method {\b drawBracket} to actually draw the shapes.\par
}{
Reimplemented from {\b QCPSelectionDecorator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADIV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16535 \{\par
16536   if (!mPlottable || selection.isEmpty()) return;\par
16537   \par
16538   if (QCPPlottableInterface1D *interface1d = mPlottable->interface1D())\par
16539   \{\par
16540     foreach (const QCPDataRange &dataRange, selection.dataRanges())\par
16541     \{\par
16542       // determine position and (if tangent mode is enabled) angle of brackets:\par
16543       int openBracketDir = (mPlottable->keyAxis() && !mPlottable->keyAxis()->rangeReversed()) ? 1 : -1;\par
16544       int closeBracketDir = -openBracketDir;\par
16545       QPointF openBracketPos = getPixelCoordinates(interface1d, dataRange.begin());\par
16546       QPointF closeBracketPos = getPixelCoordinates(interface1d, dataRange.end()-1);\par
16547       double openBracketAngle = 0;\par
16548       double closeBracketAngle = 0;\par
16549       if (mTangentToData)\par
16550       \{\par
16551         openBracketAngle = getTangentAngle(interface1d, dataRange.begin(), openBracketDir);\par
16552         closeBracketAngle = getTangentAngle(interface1d, dataRange.end()-1, closeBracketDir);\par
16553       \}\par
16554       // draw opening bracket:\par
16555       QTransform oldTransform = painter->transform();\par
16556       painter->setPen(mBracketPen);\par
16557       painter->setBrush(mBracketBrush);\par
16558       painter->translate(openBracketPos);\par
16559       painter->rotate(openBracketAngle/M_PI*180.0);\par
16560       drawBracket(painter, openBracketDir);\par
16561       painter->setTransform(oldTransform);\par
16562       // draw closing bracket:\par
16563       painter->setPen(mBracketPen);\par
16564       painter->setBrush(mBracketBrush);\par
16565       painter->translate(closeBracketPos);\par
16566       painter->rotate(closeBracketAngle/M_PI*180.0);\par
16567       drawBracket(painter, closeBracketDir);\par
16568       painter->setTransform(oldTransform);\par
16569     \}\par
16570   \}\par
16571 \}\par
}
}
{\xe \v getPixelCoordinates\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:getPixelCoordinates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPSelectionDecoratorBracket::getPixelCoordinates (const {\b QCPPlottableInterface1D} *  {\i interface1d}, int  {\i dataIndex}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADKB}
{\bkmkend AAAAAAADKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16634 \{\par
16635   QCPAxis *keyAxis = mPlottable->keyAxis();\par
16636   QCPAxis *valueAxis = mPlottable->valueAxis();\par
16637   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(0, 0); \}\par
16638   \par
16639   if (keyAxis->orientation() == Qt::Horizontal)\par
16640     return QPointF(keyAxis->coordToPixel(interface1d->dataMainKey(dataIndex)), valueAxis->coordToPixel(interface1d->dataMainValue(dataIndex)));\par
16641   else\par
16642     return QPointF(valueAxis->coordToPixel(interface1d->dataMainValue(dataIndex)), keyAxis->coordToPixel(interface1d->dataMainKey(dataIndex)));\par
16643 \}\par
}
}
{\xe \v getTangentAngle\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:getTangentAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPSelectionDecoratorBracket::getTangentAngle (const {\b QCPPlottableInterface1D} *  {\i interface1d}, int  {\i dataIndex}, int  {\i direction}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADKC}
{\bkmkend AAAAAAADKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16587 \{\par
16588   if (!interface1d || dataIndex < 0 || dataIndex >= interface1d->dataCount())\par
16589     return 0;\par
16590   direction = direction < 0 ? -1 : 1; // enforce direction is either -1 or 1\par
16591   \par
16592   // how many steps we can actually go from index in the given direction without exceeding data bounds:\par
16593   int averageCount;\par
16594   if (direction < 0)\par
16595     averageCount = qMin(mTangentAverage, dataIndex);\par
16596   else\par
16597     averageCount = qMin(mTangentAverage, interface1d->dataCount()-1-dataIndex);\par
16598   qDebug() << averageCount;\par
16599   // calculate point average of averageCount points:\par
16600   QVector<QPointF> points(averageCount);\par
16601   QPointF pointsAverage;\par
16602   int currentIndex = dataIndex;\par
16603   for (int i=0; i<averageCount; ++i)\par
16604   \{\par
16605     points[i] = getPixelCoordinates(interface1d, currentIndex);\par
16606     pointsAverage += points[i];\par
16607     currentIndex += direction;\par
16608   \}\par
16609   pointsAverage /= (double)averageCount;\par
16610   \par
16611   // calculate slope of linear regression through points:\par
16612   double numSum = 0;\par
16613   double denomSum = 0;\par
16614   for (int i=0; i<averageCount; ++i)\par
16615   \{\par
16616     const double dx = points.at(i).x()-pointsAverage.x();\par
16617     const double dy = points.at(i).y()-pointsAverage.y();\par
16618     numSum += dx*dy;\par
16619     denomSum += dx*dx;\par
16620   \}\par
16621   if (!qFuzzyIsNull(denomSum) && !qFuzzyIsNull(numSum))\par
16622   \{\par
16623     return qAtan2(numSum, denomSum);\par
16624   \} else // undetermined angle, probably mTangentAverage == 1, so using only one data point\par
16625     return 0;\par
16626 \}\par
}
}
{\xe \v setBracketBrush\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:setBracketBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecoratorBracket::setBracketBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAADKD}
{\bkmkend AAAAAAADKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used to draw the brackets at the beginning and end of each selected data segment. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16417 \{\par
16418   mBracketBrush = brush;\par
16419 \}\par
}
}
{\xe \v setBracketHeight\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:setBracketHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecoratorBracket::setBracketHeight (int  {\i height})}}
\par
{\bkmkstart AAAAAAADKE}
{\bkmkend AAAAAAADKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the height of the drawn bracket. The height dimension is always perpendicular to the key axis of the data, or the tangent direction of the current data slope, if {\b setTangentToData} is enabled. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16437 \{\par
16438   mBracketHeight = height;\par
16439 \}\par
}
}
{\xe \v setBracketPen\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:setBracketPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecoratorBracket::setBracketPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADKF}
{\bkmkend AAAAAAADKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the brackets at the beginning and end of each selected data segment. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16408 \{\par
16409   mBracketPen = pen;\par
16410 \}\par
}
}
{\xe \v setBracketStyle\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:setBracketStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecoratorBracket::setBracketStyle ({\b QCPSelectionDecoratorBracket::BracketStyle}  {\i style})}}
\par
{\bkmkstart AAAAAAADKG}
{\bkmkend AAAAAAADKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the shape that the bracket/marker will have.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBracketWidth}, {\b setBracketHeight} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16447 \{\par
16448   mBracketStyle = style;\par
16449 \}\par
}
}
{\xe \v setBracketWidth\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:setBracketWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecoratorBracket::setBracketWidth (int  {\i width})}}
\par
{\bkmkstart AAAAAAADKH}
{\bkmkend AAAAAAADKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the width of the drawn bracket. The width dimension is always parallel to the key axis of the data, or the tangent direction of the current data slope, if {\b setTangentToData} is enabled. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16427 \{\par
16428   mBracketWidth = width;\par
16429 \}\par
}
}
{\xe \v setTangentAverage\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:setTangentAverage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecoratorBracket::setTangentAverage (int  {\i pointCount})}}
\par
{\bkmkstart AAAAAAADKI}
{\bkmkend AAAAAAADKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls over how many data points the slope shall be averaged, when brackets shall be aligned with the data (if {\b setTangentToData} is true).\par
From the position of the bracket, {\i pointCount}  points towards the selected data range will be taken into account. The smallest value of {\i pointCount}  is 1, which is effectively equivalent to disabling {\b setTangentToData}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16472 \{\par
16473   mTangentAverage = pointCount;\par
16474   if (mTangentAverage < 1)\par
16475     mTangentAverage = 1;\par
16476 \}\par
}
}
{\xe \v setTangentToData\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:setTangentToData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionDecoratorBracket::setTangentToData (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAADKJ}
{\bkmkend AAAAAAADKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the brackets will be rotated such that they align with the slope of the data at the position that they appear in.\par
For noisy data, it might be more visually appealing to average the slope over multiple data points. This can be configured via {\b setTangentAverage}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16459 \{\par
16460   mTangentToData = enabled;\par
16461 \}\par
}
}
{\xe \v tangentAverage\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:tangentAverage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPSelectionDecoratorBracket::tangentAverage () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADKK}
{\bkmkend AAAAAAADKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4542 \{ return mTangentAverage; \}\par
}
}
{\xe \v tangentToData\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:tangentToData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPSelectionDecoratorBracket::tangentToData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADKL}
{\bkmkend AAAAAAADKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4541 \{ return mTangentToData; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mBracketBrush\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:mBracketBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPSelectionDecoratorBracket::mBracketBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADKM}
{\bkmkend AAAAAAADKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBracketHeight\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:mBracketHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPSelectionDecoratorBracket::mBracketHeight{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADKN}
{\bkmkend AAAAAAADKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBracketPen\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:mBracketPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPSelectionDecoratorBracket::mBracketPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADKO}
{\bkmkend AAAAAAADKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBracketStyle\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:mBracketStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BracketStyle} QCPSelectionDecoratorBracket::mBracketStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADKP}
{\bkmkend AAAAAAADKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBracketWidth\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:mBracketWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPSelectionDecoratorBracket::mBracketWidth{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADKQ}
{\bkmkend AAAAAAADKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTangentAverage\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:mTangentAverage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPSelectionDecoratorBracket::mTangentAverage{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADKR}
{\bkmkend AAAAAAADKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTangentToData\:QCPSelectionDecoratorBracket}
{\xe \v QCPSelectionDecoratorBracket\:mTangentToData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPSelectionDecoratorBracket::mTangentToData{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADKS}
{\bkmkend AAAAAAADKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPSelectionRect Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPSelectionRect}
{\xe \v QCPSelectionRect}
{\bkmkstart AAAAAAADKT}
{\bkmkend AAAAAAADKT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides rect/rubber-band data selection and range zoom interaction. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPSelectionRect:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_selection_rect__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPSelectionRect:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_selection_rect__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b started} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b changed} (const QRect &{\b rect}, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b canceled} (const QRect &{\b rect}, QInputEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b accepted} (const QRect &{\b rect}, QMouseEvent *event)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionRect} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPSelectionRect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b rect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b range} (const {\b QCPAxis} *axis) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isActive} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b cancel} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b startSelection} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b moveSelection} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b endSelection} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b keyPressEvent} (QKeyEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mActive}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides rect/rubber-band data selection and range zoom interaction. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b QCPSelectionRect} is used by {\b QCustomPlot} when the {\b QCustomPlot::setSelectionRectMode} is not {\b QCP::srmNone}. When the user drags the mouse across the plot, the current selection rect instance ({\b QCustomPlot::setSelectionRect}) is forwarded these events and makes sure an according rect shape is drawn. At the begin, during, and after completion of the interaction, it emits the corresponding signals {\b started}, {\b changed}, {\b canceled}, and {\b accepted}.\par
The {\b QCustomPlot} instance connects own slots to the current selection rect instance, in order to react to an accepted selection rect interaction accordingly.\par
{\b isActive} can be used to check whether the selection rect is currently active. An ongoing selection interaction can be cancelled programmatically via calling {\b cancel} at any time.\par
The appearance of the selection rect can be controlled via {\b setPen} and {\b setBrush}.\par
If you wish to provide custom behaviour, e.g. a different visual representation of the selection rect ({\b QCPSelectionRect::draw}), you can subclass {\b QCPSelectionRect} and pass an instance of your subclass to {\b QCustomPlot::setSelectionRect}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPSelectionRect\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:QCPSelectionRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPSelectionRect::QCPSelectionRect ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAADKU}
{\bkmkend AAAAAAADKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b QCPSelectionRect} instance. To make {\b QCustomPlot} use the selection rect instance, pass it to {\b QCustomPlot::setSelectionRect}. {\i parentPlot}  should be set to the same {\b QCustomPlot} widget. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2813                                                           :\par
 2814   QCPLayerable(parentPlot),\par
 2815   mPen(QBrush(Qt::gray), 0, Qt::DashLine),\par
 2816   mBrush(Qt::NoBrush),\par
 2817   mActive(false)\par
 2818 \{\par
 2819 \}\par
}
}
{\xe \v ~QCPSelectionRect\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:~QCPSelectionRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPSelectionRect::~QCPSelectionRect (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADKV}
{\bkmkend AAAAAAADKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2822 \{\par
 2823   cancel();\par
 2824 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v accepted\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:accepted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::accepted (const QRect &  {\i rect}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADKW}
{\bkmkend AAAAAAADKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection interaction was completed by the user releasing the mouse button.\par
Note that {\i rect}  may have a negative width or height, if the selection is being dragged to the upper or left side of the selection rect origin. \par
}}
{\xe \v applyDefaultAntialiasingHint\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSF}
{\bkmkend AAAAAAACSF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2935 \{\par
 2936   applyAntialiasingHint(painter, mAntialiased, QCP::aeOther);\par
 2937 \}\par
}
}
{\xe \v brush\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPSelectionRect::brush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADKX}
{\bkmkend AAAAAAADKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1105 \{ return mBrush; \}\par
}
}
{\xe \v cancel\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:cancel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::cancel ()}}
\par
{\bkmkstart AAAAAAADKY}
{\bkmkend AAAAAAADKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If there is currently a selection interaction going on ({\b isActive}), the interaction is canceled. The selection rect will emit the {\b canceled} signal. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2871 \{\par
 2872   if (mActive)\par
 2873   \{\par
 2874     mActive = false;\par
 2875     emit canceled(mRect, 0);\par
 2876   \}\par
 2877 \}\par
}
}
{\xe \v canceled\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:canceled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::canceled (const QRect &  {\i rect}, QInputEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADKZ}
{\bkmkend AAAAAAADKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection interaction was cancelled. Note that {\i event}  is 0 if the selection interaction was cancelled programmatically, by a call to {\b cancel}.\par
The user may cancel the selection interaction by pressing the escape key. In this case, {\i event}  holds the respective input event.\par
Note that {\i rect}  may have a negative width or height, if the selection is being dragged to the upper or left side of the selection rect origin. \par
}}
{\xe \v changed\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:changed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::changed (const QRect &  {\i rect}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADLA}
{\bkmkend AAAAAAADLA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted while the selection rect interaction is ongoing and the {\i rect}  has changed its size due to the user moving the mouse.\par
Note that {\i rect}  may have a negative width or height, if the selection is being dragged to the upper or left side of the selection rect origin. \par
}}
{\xe \v draw\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSK}
{\bkmkend AAAAAAACSK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2946 \{\par
 2947   if (mActive)\par
 2948   \{\par
 2949     painter->setPen(mPen);\par
 2950     painter->setBrush(mBrush);\par
 2951     painter->drawRect(mRect);\par
 2952   \}\par
 2953 \}\par
}
}
{\xe \v endSelection\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:endSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::endSelection (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADLB}
{\bkmkend AAAAAAADLB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2912 \{\par
 2913   mRect.setBottomRight(event->pos());\par
 2914   mActive = false;\par
 2915   emit accepted(mRect, event);\par
 2916 \}\par
}
}
{\xe \v isActive\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPSelectionRect::isActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADLC}
{\bkmkend AAAAAAADLC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if there is currently a selection going on, i.e. the user has started dragging a selection rect, but hasn't released the mouse button yet.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b cancel} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1106 \{ return mActive; \}\par
}
}
{\xe \v keyPressEvent\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:keyPressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::keyPressEvent (QKeyEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADLD}
{\bkmkend AAAAAAADLD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2925 \{\par
 2926   if (event->key() == Qt::Key_Escape && mActive)\par
 2927   \{\par
 2928     mActive = false;\par
 2929     emit canceled(mRect, event);\par
 2930   \}\par
 2931 \}\par
}
}
{\xe \v moveSelection\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:moveSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::moveSelection (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADLE}
{\bkmkend AAAAAAADLE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2899 \{\par
 2900   mRect.setBottomRight(event->pos());\par
 2901   emit changed(mRect, event);\par
 2902   layer()->replot();\par
 2903 \}\par
}
}
{\xe \v pen\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPSelectionRect::pen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADLF}
{\bkmkend AAAAAAADLF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1104 \{ return mPen; \}\par
}
}
{\xe \v range\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPSelectionRect::range (const {\b QCPAxis} *  {\i axis}) const}}
\par
{\bkmkstart AAAAAAADLG}
{\bkmkend AAAAAAADLG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A convenience function which returns the coordinate range of the provided {\i axis} , that this selection rect currently encompasses. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2831 \{\par
 2832   if (axis)\par
 2833   \{\par
 2834     if (axis->orientation() == Qt::Horizontal)\par
 2835       return QCPRange(axis->pixelToCoord(mRect.left()), axis->pixelToCoord(mRect.left()+mRect.width()));\par
 2836     else\par
 2837       return QCPRange(axis->pixelToCoord(mRect.top()+mRect.height()), axis->pixelToCoord(mRect.top()));\par
 2838   \} else\par
 2839   \{\par
 2840     qDebug() << Q_FUNC_INFO << "called with axis zero";\par
 2841     return QCPRange();\par
 2842   \}\par
 2843 \}\par
}
}
{\xe \v rect\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:rect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPSelectionRect::rect () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADLH}
{\bkmkend AAAAAAADLH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1102 \{ return mRect; \}\par
}
}
{\xe \v setBrush\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::setBrush (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAADLI}
{\bkmkend AAAAAAADLI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the brush that will be used to fill the selection rect. By default the selection rect is not filled, i.e. {\i brush}  is {\f2 Qt::NoBrush} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2862 \{\par
 2863   mBrush = brush;\par
 2864 \}\par
}
}
{\xe \v setPen\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::setPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADLJ}
{\bkmkend AAAAAAADLJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that will be used to draw the selection rect outline.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2851 \{\par
 2852   mPen = pen;\par
 2853 \}\par
}
}
{\xe \v started\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:started}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::started (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADLK}
{\bkmkend AAAAAAADLK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when a selection rect interaction was initiated, i.e. the user just started dragging the selection rect with the mouse. \par
}}
{\xe \v startSelection\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:startSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPSelectionRect::startSelection (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADLL}
{\bkmkend AAAAAAADLL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2886 \{\par
 2887   mActive = true;\par
 2888   mRect = QRect(event->pos(), event->pos());\par
 2889   emit started(event);\par
 2890 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCustomPlot\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADLM}
{\bkmkend AAAAAAADLM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mActive\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:mActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPSelectionRect::mActive{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLN}
{\bkmkend AAAAAAADLN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBrush\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPSelectionRect::mBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLO}
{\bkmkend AAAAAAADLO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPSelectionRect::mPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLP}
{\bkmkend AAAAAAADLP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRect\:QCPSelectionRect}
{\xe \v QCPSelectionRect\:mRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPSelectionRect::mRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLQ}
{\bkmkend AAAAAAADLQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPStatisticalBox Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPStatisticalBox}
{\xe \v QCPStatisticalBox}
{\bkmkstart AAAAAAADLR}
{\bkmkend AAAAAAADLR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a single statistical box in a plot. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPStatisticalBox:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_statistical_box__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPStatisticalBox:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_statistical_box__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPStatisticalBox} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPStatisticalBoxDataContainer} > {\b data} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b width} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b whiskerWidth} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b whiskerPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b whiskerBarPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b whiskerAntialiased} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b medianPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b outlierStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (QSharedPointer< {\b QCPStatisticalBoxDataContainer} > {\b data})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (const QVector< double > &keys, const QVector< double > &minimum, const QVector< double > &lowerQuartile, const QVector< double > &median, const QVector< double > &upperQuartile, const QVector< double > &maximum, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWidth} (double {\b width})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWhiskerWidth} (double {\b width})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWhiskerPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWhiskerBarPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWhiskerAntialiased} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMedianPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOutlierStyle} (const {\b QCPScatterStyle} &style)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (const QVector< double > &keys, const QVector< double > &minimum, const QVector< double > &lowerQuartile, const QVector< double > &median, const QVector< double > &upperQuartile, const QVector< double > &maximum, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum, const QVector< double > &outliers=QVector< double >())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPDataSelection} {\b selectTestRect} (const QRectF &rect, bool onlySelectable) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawStatisticalBox} ({\b QCPPainter} *painter, {\b QCPStatisticalBoxDataContainer::const_iterator} it, const {\b QCPScatterStyle} &{\b outlierStyle}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getVisibleDataBounds} ({\b QCPStatisticalBoxDataContainer::const_iterator} &begin, {\b QCPStatisticalBoxDataContainer::const_iterator} &end) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRectF {\b getQuartileBox} ({\b QCPStatisticalBoxDataContainer::const_iterator} it) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QLineF > {\b getWhiskerBackboneLines} ({\b QCPStatisticalBoxDataContainer::const_iterator} it) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QLineF > {\b getWhiskerBarLines} ({\b QCPStatisticalBoxDataContainer::const_iterator} it) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mWhiskerWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mWhiskerPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mWhiskerBarPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mWhiskerAntialiased}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mMedianPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b mOutlierStyle}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a single statistical box in a plot. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
To plot data, assign it with the {\b setData} or {\b addData} functions. Alternatively, you can also access and modify the data via the {\b data} method, which returns a pointer to the internal {\b QCPStatisticalBoxDataContainer}.\par
Additionally each data point can itself have a list of outliers, drawn as scatter points at the key coordinate of the respective statistical box data point. They can either be set by using the respective {\b addData} method or accessing the individual data points through {\b data}, and setting the {\f2 QVector<double> outliers}  of the data points directly.\par
{\bkmkstart AAAAAAADLS}
{\bkmkend AAAAAAADLS}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Changing the appearance
\par}
{\tc\tcl2 \v Changing the appearance}
The appearance of each data point box, ranging from the lower to the upper quartile, is controlled via {\b setPen} and {\b setBrush}. You may change the width of the boxes with {\b setWidth} in plot coordinates.\par
Each data point's visual representation also consists of two whiskers. Whiskers are the lines which reach from the upper quartile to the maximum, and from the lower quartile to the minimum. The appearance of the whiskers can be modified with: {\b setWhiskerPen}, {\b setWhiskerBarPen}, {\b setWhiskerWidth}. The whisker width is the width of the bar perpendicular to the whisker at the top (for maximum) and bottom (for minimum). If the whisker pen is changed, make sure to set the {\f2 capStyle}  to {\f2 Qt::FlatCap} . Otherwise the backbone line might exceed the whisker bars by a few pixels due to the pen cap being not perfectly flat.\par
The median indicator line inside the box has its own pen, {\b setMedianPen}.\par
The outlier data points are drawn as normal scatter points. Their look can be controlled with {\b setOutlierStyle}\par}
{\bkmkstart AAAAAAADLT}
{\bkmkend AAAAAAADLT}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
Like all data representing objects in {\b QCustomPlot}, the {\b QCPStatisticalBox} is a plottable ({\b QCPAbstractPlottable}). So the plottable-interface of {\b QCustomPlot} applies ({\b QCustomPlot::plottable}, {\b QCustomPlot::removePlottable}, etc.)\par
Usually, you first create an instance: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }which registers it with the {\b QCustomPlot} instance of the passed axes. Note that this {\b QCustomPlot} instance takes ownership of the plottable, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. The newly created plottable can be modified, e.g.: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPStatisticalBox\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:QCPStatisticalBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPStatisticalBox::QCPStatisticalBox ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAADLU}
{\bkmkend AAAAAAADLU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a statistical box which uses {\i keyAxis}  as its key axis ("x") and {\i valueAxis}  as its value axis ("y"). {\i keyAxis}  and {\i valueAxis}  must reside in the same {\b QCustomPlot} instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.\par
The created {\b QCPStatisticalBox} is automatically registered with the {\b QCustomPlot} instance inferred from {\i keyAxis} . This {\b QCustomPlot} instance takes ownership of the {\b QCPStatisticalBox}, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24465                                                                          :\par
24466   QCPAbstractPlottable1D<QCPStatisticalBoxData>(keyAxis, valueAxis),\par
24467   mWidth(0.5),\par
24468   mWhiskerWidth(0.2),\par
24469   mWhiskerPen(Qt::black, 0, Qt::DashLine, Qt::FlatCap),\par
24470   mWhiskerBarPen(Qt::black),\par
24471   mWhiskerAntialiased(false),\par
24472   mMedianPen(Qt::black, 3, Qt::SolidLine, Qt::FlatCap),\par
24473   mOutlierStyle(QCPScatterStyle::ssCircle, Qt::blue, 6)\par
24474 \{\par
24475   setPen(QPen(Qt::black));\par
24476   setBrush(Qt::NoBrush);\par
24477 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addData\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::addData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i minimum}, const QVector< double > &  {\i lowerQuartile}, const QVector< double > &  {\i median}, const QVector< double > &  {\i upperQuartile}, const QVector< double > &  {\i maximum}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAADLV}
{\bkmkend AAAAAAADLV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided points in {\i keys} , {\i minimum} , {\i lowerQuartile} , {\i median} , {\i upperQuartile}  and {\i maximum}  to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24612 \{\par
24613   if (keys.size() != minimum.size() || minimum.size() != lowerQuartile.size() || lowerQuartile.size() != median.size() ||\par
24614       median.size() != upperQuartile.size() || upperQuartile.size() != maximum.size() || maximum.size() != keys.size())\par
24615     qDebug() << Q_FUNC_INFO << "keys, minimum, lowerQuartile, median, upperQuartile, maximum have different sizes:"\par
24616              << keys.size() << minimum.size() << lowerQuartile.size() << median.size() << upperQuartile.size() << maximum.size();\par
24617   const int n = qMin(keys.size(), qMin(minimum.size(), qMin(lowerQuartile.size(), qMin(median.size(), qMin(upperQuartile.size(), maximum.size())))));\par
24618   QVector<QCPStatisticalBoxData> tempData(n);\par
24619   QVector<QCPStatisticalBoxData>::iterator it = tempData.begin();\par
24620   const QVector<QCPStatisticalBoxData>::iterator itEnd = tempData.end();\par
24621   int i = 0;\par
24622   while (it != itEnd)\par
24623   \{\par
24624     it->key = keys[i];\par
24625     it->minimum = minimum[i];\par
24626     it->lowerQuartile = lowerQuartile[i];\par
24627     it->median = median[i];\par
24628     it->upperQuartile = upperQuartile[i];\par
24629     it->maximum = maximum[i];\par
24630     ++it;\par
24631     ++i;\par
24632   \}\par
24633   mDataContainer->add(tempData, alreadySorted); // don't modify tempData beyond this to prevent copy on write\par
24634 \}\par
}
}
{\xe \v addData\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::addData (double  {\i key}, double  {\i minimum}, double  {\i lowerQuartile}, double  {\i median}, double  {\i upperQuartile}, double  {\i maximum}, const QVector< double > &  {\i outliers} = {\f2 QVector<double>()})}}
\par
{\bkmkstart AAAAAAADLW}
{\bkmkend AAAAAAADLW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Adds the provided data point as {\i key} , {\i minimum} , {\i lowerQuartile} , {\i median} , {\i upperQuartile}  and {\i maximum}  to the current data.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24645 \{\par
24646   mDataContainer->add(QCPStatisticalBoxData(key, minimum, lowerQuartile, median, upperQuartile, maximum, outliers));\par
24647 \}\par
}
}
{\xe \v data\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer< {\b QCPStatisticalBoxDataContainer} > QCPStatisticalBox::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADLX}
{\bkmkend AAAAAAADLX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a shared pointer to the internal data storage of type {\b QCPStatisticalBoxDataContainer}. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular {\b setData} or {\b addData} methods. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5618 \{ return mDataContainer; \}\par
}
}
{\xe \v draw\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24745 \{\par
24746   if (mDataContainer->isEmpty()) return;\par
24747   QCPAxis *keyAxis = mKeyAxis.data();\par
24748   QCPAxis *valueAxis = mValueAxis.data();\par
24749   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
24750   \par
24751   QCPStatisticalBoxDataContainer::const_iterator visibleBegin, visibleEnd;\par
24752   getVisibleDataBounds(visibleBegin, visibleEnd);\par
24753   \par
24754   // loop over and draw segments of unselected/selected data:\par
24755   QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;\par
24756   getDataSegments(selectedSegments, unselectedSegments);\par
24757   allSegments << unselectedSegments << selectedSegments;\par
24758   for (int i=0; i<allSegments.size(); ++i)\par
24759   \{\par
24760     bool isSelectedSegment = i >= unselectedSegments.size();\par
24761     QCPStatisticalBoxDataContainer::const_iterator begin = visibleBegin;\par
24762     QCPStatisticalBoxDataContainer::const_iterator end = visibleEnd;\par
24763     mDataContainer->limitIteratorsToDataRange(begin, end, allSegments.at(i));\par
24764     if (begin == end)\par
24765       continue;\par
24766     \par
24767     for (QCPStatisticalBoxDataContainer::const_iterator it=begin; it!=end; ++it)\par
24768     \{\par
24769       // check data validity if flag set:\par
24770 # ifdef QCUSTOMPLOT_CHECK_DATA\par
24771       if (QCP::isInvalidData(it->key, it->minimum) ||\par
24772           QCP::isInvalidData(it->lowerQuartile, it->median) ||\par
24773           QCP::isInvalidData(it->upperQuartile, it->maximum))\par
24774         qDebug() << Q_FUNC_INFO << "Data point at" << it->key << "of drawn range has invalid data." << "Plottable name:" << name();\par
24775       for (int i=0; i<it->outliers.size(); ++i)\par
24776         if (QCP::isInvalidData(it->outliers.at(i)))\par
24777           qDebug() << Q_FUNC_INFO << "Data point outlier at" << it->key << "of drawn range invalid." << "Plottable name:" << name();\par
24778 # endif\par
24779       \par
24780       if (isSelectedSegment && mSelectionDecorator)\par
24781       \{\par
24782         mSelectionDecorator->applyPen(painter);\par
24783         mSelectionDecorator->applyBrush(painter);\par
24784       \} else\par
24785       \{\par
24786         painter->setPen(mPen);\par
24787         painter->setBrush(mBrush);\par
24788       \}\par
24789       QCPScatterStyle finalOutlierStyle = mOutlierStyle;\par
24790       if (isSelectedSegment && mSelectionDecorator)\par
24791         finalOutlierStyle = mSelectionDecorator->getFinalScatterStyle(mOutlierStyle);\par
24792       drawStatisticalBox(painter, it, finalOutlierStyle);\par
24793     \}\par
24794   \}\par
24795   \par
24796   // draw other selection decoration that isn't just line/scatter pens and brushes:\par
24797   if (mSelectionDecorator)\par
24798     mSelectionDecorator->drawDecoration(painter, selection());\par
24799 \}\par
}
}
{\xe \v drawLegendIcon\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24803 \{\par
24804   // draw filled rect:\par
24805   applyDefaultAntialiasingHint(painter);\par
24806   painter->setPen(mPen);\par
24807   painter->setBrush(mBrush);\par
24808   QRectF r = QRectF(0, 0, rect.width()*0.67, rect.height()*0.67);\par
24809   r.moveCenter(rect.center());\par
24810   painter->drawRect(r);\par
24811 \}\par
}
}
{\xe \v drawStatisticalBox\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:drawStatisticalBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::drawStatisticalBox ({\b QCPPainter} *  {\i painter}, {\b QCPStatisticalBoxDataContainer::const_iterator}  {\i it}, const {\b QCPScatterStyle} &  {\i outlierStyle}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADLY}
{\bkmkend AAAAAAADLY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws the graphical representation of a single statistical box with the data given by the iterator {\i it}  with the provided {\i painter} .\par
If the statistical box has a set of outlier data points, they are drawn with {\i outlierStyle} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b getQuartileBox}, {\b getWhiskerBackboneLines}, {\b getWhiskerBarLines} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24822 \{\par
24823   // draw quartile box:\par
24824   applyDefaultAntialiasingHint(painter);\par
24825   const QRectF quartileBox = getQuartileBox(it);\par
24826   painter->drawRect(quartileBox);\par
24827   // draw median line with cliprect set to quartile box:\par
24828   painter->save();\par
24829   painter->setClipRect(quartileBox, Qt::IntersectClip);\par
24830   painter->setPen(mMedianPen);\par
24831   painter->drawLine(QLineF(coordsToPixels(it->key-mWidth*0.5, it->median), coordsToPixels(it->key+mWidth*0.5, it->median)));\par
24832   painter->restore();\par
24833   // draw whisker lines:\par
24834   applyAntialiasingHint(painter, mWhiskerAntialiased, QCP::aePlottables);\par
24835   painter->setPen(mWhiskerPen);\par
24836   painter->drawLines(getWhiskerBackboneLines(it));\par
24837   painter->setPen(mWhiskerBarPen);\par
24838   painter->drawLines(getWhiskerBarLines(it));\par
24839   // draw outliers:\par
24840   applyScattersAntialiasingHint(painter);\par
24841   outlierStyle.applyTo(painter, mPen);\par
24842   for (int i=0; i<it->outliers.size(); ++i)\par
24843     outlierStyle.drawShape(painter, coordsToPixels(it->key, it->outliers.at(i)));\par
24844 \}\par
}
}
{\xe \v getKeyRange\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPStatisticalBox::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24724 \{\par
24725   QCPRange range = mDataContainer->keyRange(foundRange, inSignDomain);\par
24726   // determine exact range by including width of bars/flags:\par
24727   if (foundRange)\par
24728   \{\par
24729     if (inSignDomain != QCP::sdPositive || range.lower-mWidth*0.5 > 0)\par
24730       range.lower -= mWidth*0.5;\par
24731     if (inSignDomain != QCP::sdNegative || range.upper+mWidth*0.5 < 0)\par
24732       range.upper += mWidth*0.5;\par
24733   \}\par
24734   return range;\par
24735 \}\par
}
}
{\xe \v getQuartileBox\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:getQuartileBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRectF QCPStatisticalBox::getQuartileBox ({\b QCPStatisticalBoxDataContainer::const_iterator}  {\i it}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLZ}
{\bkmkend AAAAAAADLZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24881 \{\par
24882   QRectF result;\par
24883   result.setTopLeft(coordsToPixels(it->key-mWidth*0.5, it->upperQuartile));\par
24884   result.setBottomRight(coordsToPixels(it->key+mWidth*0.5, it->lowerQuartile));\par
24885   return result;\par
24886 \}\par
}
}
{\xe \v getValueRange\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPStatisticalBox::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implements {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24739 \{\par
24740   return mDataContainer->valueRange(foundRange, inSignDomain, inKeyRange);\par
24741 \}\par
}
}
{\xe \v getVisibleDataBounds\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:getVisibleDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::getVisibleDataBounds ({\b QCPStatisticalBoxDataContainer::const_iterator} &  {\i begin}, {\b QCPStatisticalBoxDataContainer::const_iterator} &  {\i end}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADMA}
{\bkmkend AAAAAAADMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24861 \{\par
24862   if (!mKeyAxis)\par
24863   \{\par
24864     qDebug() << Q_FUNC_INFO << "invalid key axis";\par
24865     begin = mDataContainer->constEnd();\par
24866     end = mDataContainer->constEnd();\par
24867     return;\par
24868   \}\par
24869   begin = mDataContainer->findBegin(mKeyAxis.data()->range().lower-mWidth*0.5); // subtract half width of box to include partially visible data points\par
24870   end = mDataContainer->findEnd(mKeyAxis.data()->range().upper+mWidth*0.5); // add half width of box to include partially visible data points\par
24871 \}\par
}
}
{\xe \v getWhiskerBackboneLines\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:getWhiskerBackboneLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QLineF > QCPStatisticalBox::getWhiskerBackboneLines ({\b QCPStatisticalBoxDataContainer::const_iterator}  {\i it}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADMB}
{\bkmkend AAAAAAADMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24897 \{\par
24898   QVector<QLineF> result(2);\par
24899   result[0].setPoints(coordsToPixels(it->key, it->lowerQuartile), coordsToPixels(it->key, it->minimum)); // min backbone\par
24900   result[1].setPoints(coordsToPixels(it->key, it->upperQuartile), coordsToPixels(it->key, it->maximum)); // max backbone\par
24901   return result;\par
24902 \}\par
}
}
{\xe \v getWhiskerBarLines\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:getWhiskerBarLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QLineF > QCPStatisticalBox::getWhiskerBarLines ({\b QCPStatisticalBoxDataContainer::const_iterator}  {\i it}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADMC}
{\bkmkend AAAAAAADMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24912 \{\par
24913   QVector<QLineF> result(2);\par
24914   result[0].setPoints(coordsToPixels(it->key-mWhiskerWidth*0.5, it->minimum), coordsToPixels(it->key+mWhiskerWidth*0.5, it->minimum)); // min bar\par
24915   result[1].setPoints(coordsToPixels(it->key-mWhiskerWidth*0.5, it->maximum), coordsToPixels(it->key+mWhiskerWidth*0.5, it->maximum)); // max bar\par
24916   return result;\par
24917 \}\par
}
}
{\xe \v medianPen\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:medianPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPStatisticalBox::medianPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADMD}
{\bkmkend AAAAAAADMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5624 \{ return mMedianPen; \}\par
}
}
{\xe \v outlierStyle\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:outlierStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPStatisticalBox::outlierStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADME}
{\bkmkend AAAAAAADME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5625 \{ return mOutlierStyle; \}\par
}
}
{\xe \v selectTest\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBox::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Reimplemented from {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24674 \{\par
24675   Q_UNUSED(details)\par
24676   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
24677     return -1;\par
24678   if (!mKeyAxis || !mValueAxis)\par
24679     return -1;\par
24680   \par
24681   if (mKeyAxis->axisRect()->rect().contains(pos.toPoint()))\par
24682   \{\par
24683     // get visible data range:\par
24684     QCPStatisticalBoxDataContainer::const_iterator visibleBegin, visibleEnd;\par
24685     QCPStatisticalBoxDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();\par
24686     getVisibleDataBounds(visibleBegin, visibleEnd);\par
24687     double minDistSqr = std::numeric_limits<double>::max();\par
24688     for (QCPStatisticalBoxDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)\par
24689     \{\par
24690       if (getQuartileBox(it).contains(pos)) // quartile box\par
24691       \{\par
24692         double currentDistSqr = mParentPlot->selectionTolerance()*0.99 * mParentPlot->selectionTolerance()*0.99;\par
24693         if (currentDistSqr < minDistSqr)\par
24694         \{\par
24695           minDistSqr = currentDistSqr;\par
24696           closestDataPoint = it;\par
24697         \}\par
24698       \} else // whiskers\par
24699       \{\par
24700         const QVector<QLineF> whiskerBackbones(getWhiskerBackboneLines(it));\par
24701         for (int i=0; i<whiskerBackbones.size(); ++i)\par
24702         \{\par
24703           double currentDistSqr = QCPVector2D(pos).distanceSquaredToLine(whiskerBackbones.at(i));\par
24704           if (currentDistSqr < minDistSqr)\par
24705           \{\par
24706             minDistSqr = currentDistSqr;\par
24707             closestDataPoint = it;\par
24708           \}\par
24709         \}\par
24710       \}\par
24711     \}\par
24712     if (details)\par
24713     \{\par
24714       int pointIndex = closestDataPoint-mDataContainer->constBegin();\par
24715       details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));\par
24716     \}\par
24717     return qSqrt(minDistSqr);\par
24718   \}\par
24719   return -1;\par
24720 \}\par
}
}
{\xe \v selectTestRect\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:selectTestRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPStatisticalBox::selectTestRect (const QRectF &  {\i rect}, bool  {\i onlySelectable}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data selection containing all the data points of this plottable which are contained (or hit by) {\i rect} . This is used mainly in the selection rect interaction for data selection (data selection mechanism).\par
If {\i onlySelectable}  is true, an empty {\b QCPDataSelection} is returned if this plottable is not selectable (i.e. if {\b QCPAbstractPlottable::setSelectable} is {\b QCP::stNone}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i rect}  must be a normalized rect (positive or zero width and height). This is especially important when using the rect of {\b QCPSelectionRect::accepted}, which is not necessarily normalized. Use {\f2 QRect::normalized()}  when passing a rect which might not be normalized. \par
}}{
Reimplemented from {\b QCPAbstractPlottable1D< QCPStatisticalBoxData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24653 \{\par
24654   QCPDataSelection result;\par
24655   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
24656     return result;\par
24657   if (!mKeyAxis || !mValueAxis)\par
24658     return result;\par
24659   \par
24660   QCPStatisticalBoxDataContainer::const_iterator visibleBegin, visibleEnd;\par
24661   getVisibleDataBounds(visibleBegin, visibleEnd);\par
24662   \par
24663   for (QCPStatisticalBoxDataContainer::const_iterator it=visibleBegin; it!=visibleEnd; ++it)\par
24664   \{\par
24665     if (rect.intersects(getQuartileBox(it)))\par
24666       result.addDataRange(QCPDataRange(it-mDataContainer->constBegin(), it-mDataContainer->constBegin()+1), false);\par
24667   \}\par
24668   result.simplify();\par
24669   return result;\par
24670 \}\par
}
}
{\xe \v setData\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::setData (QSharedPointer< {\b QCPStatisticalBoxDataContainer} >  {\i data})}}
\par
{\bkmkstart AAAAAAADMF}
{\bkmkend AAAAAAADMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data container with the provided {\i data}  container.\par
Since a QSharedPointer is used, multiple QCPStatisticalBoxes may share the same data container safely. Modifying the data in the container will then affect all statistical boxes that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } If you do not wish to share containers, but create a copy from an existing container, rather use the {\b QCPDataContainer<DataType>::set} method on the statistical box data container directly: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24496 \{\par
24497   mDataContainer = data;\par
24498 \}\par
}
}
{\xe \v setData\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::setData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i minimum}, const QVector< double > &  {\i lowerQuartile}, const QVector< double > &  {\i median}, const QVector< double > &  {\i upperQuartile}, const QVector< double > &  {\i maximum}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAADMG}
{\bkmkend AAAAAAADMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Replaces the current data with the provided points in {\i keys} , {\i minimum} , {\i lowerQuartile} , {\i median} , {\i upperQuartile}  and {\i maximum} . The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24511 \{\par
24512   mDataContainer->clear();\par
24513   addData(keys, minimum, lowerQuartile, median, upperQuartile, maximum, alreadySorted);\par
24514 \}\par
}
}
{\xe \v setMedianPen\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:setMedianPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::setMedianPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADMH}
{\bkmkend AAAAAAADMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen used for drawing the median indicator line inside the statistical boxes. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24584 \{\par
24585   mMedianPen = pen;\par
24586 \}\par
}
}
{\xe \v setOutlierStyle\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:setOutlierStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::setOutlierStyle (const {\b QCPScatterStyle} &  {\i style})}}
\par
{\bkmkstart AAAAAAADMI}
{\bkmkend AAAAAAADMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the appearance of the outlier data points.\par
Outliers can be specified with the method {\b addData(double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum, const QVector<double> &outliers)} \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24595 \{\par
24596   mOutlierStyle = style;\par
24597 \}\par
}
}
{\xe \v setWhiskerAntialiased\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:setWhiskerAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::setWhiskerAntialiased (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAADMJ}
{\bkmkend AAAAAAADMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the statistical boxes whiskers are drawn with antialiasing or not.\par
Note that antialiasing settings may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24576 \{\par
24577   mWhiskerAntialiased = enabled;\par
24578 \}\par
}
}
{\xe \v setWhiskerBarPen\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:setWhiskerBarPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::setWhiskerBarPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADMK}
{\bkmkend AAAAAAADMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen used for drawing the whisker bars. Those are the lines parallel to the key axis at each end of the whisker backbone.\par
Whiskers are the lines which reach from the upper quartile to the maximum, and from the lower quartile to the minimum.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWhiskerPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24565 \{\par
24566   mWhiskerBarPen = pen;\par
24567 \}\par
}
}
{\xe \v setWhiskerPen\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:setWhiskerPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::setWhiskerPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAADML}
{\bkmkend AAAAAAADML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen used for drawing the whisker backbone.\par
Whiskers are the lines which reach from the upper quartile to the maximum, and from the lower quartile to the minimum.\par
Make sure to set the {\f2 capStyle}  of the passed {\i pen}  to {\f2 Qt::FlatCap} . Otherwise the backbone line might exceed the whisker bars by a few pixels due to the pen cap being not perfectly flat.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWhiskerBarPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24551 \{\par
24552   mWhiskerPen = pen;\par
24553 \}\par
}
}
{\xe \v setWhiskerWidth\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:setWhiskerWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::setWhiskerWidth (double  {\i width})}}
\par
{\bkmkstart AAAAAAADMM}
{\bkmkend AAAAAAADMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the width of the whiskers in key coordinates.\par
Whiskers are the lines which reach from the upper quartile to the maximum, and from the lower quartile to the minimum.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWidth} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24535 \{\par
24536   mWhiskerWidth = width;\par
24537 \}\par
}
}
{\xe \v setWidth\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:setWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPStatisticalBox::setWidth (double  {\i width})}}
\par
{\bkmkstart AAAAAAADMN}
{\bkmkend AAAAAAADMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the width of the boxes in key coordinates.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setWhiskerWidth} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24522 \{\par
24523   mWidth = width;\par
24524 \}\par
}
}
{\xe \v whiskerAntialiased\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:whiskerAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPStatisticalBox::whiskerAntialiased () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADMO}
{\bkmkend AAAAAAADMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5623 \{ return mWhiskerAntialiased; \}\par
}
}
{\xe \v whiskerBarPen\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:whiskerBarPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPStatisticalBox::whiskerBarPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADMP}
{\bkmkend AAAAAAADMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5622 \{ return mWhiskerBarPen; \}\par
}
}
{\xe \v whiskerPen\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:whiskerPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPStatisticalBox::whiskerPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADMQ}
{\bkmkend AAAAAAADMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5621 \{ return mWhiskerPen; \}\par
}
}
{\xe \v whiskerWidth\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:whiskerWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBox::whiskerWidth () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADMR}
{\bkmkend AAAAAAADMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5620 \{ return mWhiskerWidth; \}\par
}
}
{\xe \v width\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBox::width () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADMS}
{\bkmkend AAAAAAADMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5619 \{ return mWidth; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPLegend\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADMT}
{\bkmkend AAAAAAADMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADMU}
{\bkmkend AAAAAAADMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mMedianPen\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:mMedianPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPStatisticalBox::mMedianPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADMV}
{\bkmkend AAAAAAADMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOutlierStyle\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:mOutlierStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPStatisticalBox::mOutlierStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADMW}
{\bkmkend AAAAAAADMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWhiskerAntialiased\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:mWhiskerAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPStatisticalBox::mWhiskerAntialiased{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADMX}
{\bkmkend AAAAAAADMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWhiskerBarPen\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:mWhiskerBarPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPStatisticalBox::mWhiskerBarPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADMY}
{\bkmkend AAAAAAADMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWhiskerPen\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:mWhiskerPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPStatisticalBox::mWhiskerPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADMZ}
{\bkmkend AAAAAAADMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWhiskerWidth\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:mWhiskerWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBox::mWhiskerWidth{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADNA}
{\bkmkend AAAAAAADNA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mWidth\:QCPStatisticalBox}
{\xe \v QCPStatisticalBox\:mWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBox::mWidth{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADNB}
{\bkmkend AAAAAAADNB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPStatisticalBoxData Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData}
{\bkmkstart AAAAAAADNC}
{\bkmkend AAAAAAADNC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPStatisticalBox}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPStatisticalBoxData:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_statistical_box_data__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPStatisticalBoxData} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPStatisticalBoxData} (double {\b key}, double {\b minimum}, double {\b lowerQuartile}, double {\b median}, double {\b upperQuartile}, double {\b maximum}, const QVector< double > &{\b outliers}=QVector< double >())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sortKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainKey} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mainValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b valueRange} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b QCPStatisticalBoxData} {\b fromSortKey} (double {\b sortKey})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b sortKeyIsMainKey} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b minimum}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lowerQuartile}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b median}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b upperQuartile}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b maximum}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< double > {\b outliers}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPStatisticalBox}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The stored data is:\par
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i key:}  coordinate on the key axis of this data point (this is the {\i mainKey}  and the {\i sortKey} )\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i minimum:}  the position of the lower whisker, typically the minimum measurement of the sample that's not considered an outlier.\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i lowerQuartile:}  the lower end of the box. The lower and the upper quartiles are the two statistical quartiles around the median of the sample, they should contain 50% of the sample data.\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i median:}  the value of the median mark inside the quartile box. The median separates the sample data in half (50% of the sample data is below/above the median). (This is the {\i mainValue} )\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i upperQuartile:}  the upper end of the box. The lower and the upper quartiles are the two statistical quartiles around the median of the sample, they should contain 50% of the sample data.\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i maximum:}  the position of the upper whisker, typically the maximum measurement of the sample that's not considered an outlier.\par
}
{
\par\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i outliers:}  a QVector of outlier values that will be drawn as scatter points at the {\i key}  coordinate of this data point (see {\b QCPStatisticalBox::setOutlierStyle})\par
}
The container for storing multiple data points is {\b QCPStatisticalBoxDataContainer}. It is a typedef for {\b QCPDataContainer} with {\b QCPStatisticalBoxData} as the DataType template parameter. See the documentation there for an explanation regarding the data type's generic methods.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b QCPStatisticalBoxDataContainer} \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPStatisticalBoxData\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:QCPStatisticalBoxData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPStatisticalBoxData::QCPStatisticalBoxData ()}}
\par
{\bkmkstart AAAAAAADND}
{\bkmkend AAAAAAADND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a data point with key and all values set to zero. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24366                                              :\par
24367   key(0),\par
24368   minimum(0),\par
24369   lowerQuartile(0),\par
24370   median(0),\par
24371   upperQuartile(0),\par
24372   maximum(0)\par
24373 \{\par
24374 \}\par
}
}
{\xe \v QCPStatisticalBoxData\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:QCPStatisticalBoxData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPStatisticalBoxData::QCPStatisticalBoxData (double  {\i key}, double  {\i minimum}, double  {\i lowerQuartile}, double  {\i median}, double  {\i upperQuartile}, double  {\i maximum}, const QVector< double > &  {\i outliers} = {\f2 QVector<double>()})}}
\par
{\bkmkstart AAAAAAADNE}
{\bkmkend AAAAAAADNE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a data point with the specified {\i key} , {\i minimum} , {\i lowerQuartile} , {\i median} , {\i upperQuartile} , {\i maximum}  and optionally a number of {\i outliers} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24380                                                                                                                                                                                    :\par
24381   key(key),\par
24382   minimum(minimum),\par
24383   lowerQuartile(lowerQuartile),\par
24384   median(median),\par
24385   upperQuartile(upperQuartile),\par
24386   maximum(maximum),\par
24387   outliers(outliers)\par
24388 \{\par
24389 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fromSortKey\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:fromSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b QCPStatisticalBoxData} QCPStatisticalBoxData::fromSortKey (double  {\i sortKey}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAADNF}
{\bkmkend AAAAAAADNF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a data point with the specified {\i sortKey} . All other members are set to zero.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5570 \{ return QCPStatisticalBoxData(sortKey, 0, 0, 0, 0, 0); \}\par
}
}
{\xe \v mainKey\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:mainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBoxData::mainKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADNG}
{\bkmkend AAAAAAADNG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i key}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5573 \{ return key; \}\par
}
}
{\xe \v mainValue\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:mainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBoxData::mainValue () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADNH}
{\bkmkend AAAAAAADNH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i median}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5574 \{ return median; \}\par
}
}
{\xe \v sortKey\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:sortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBoxData::sortKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADNI}
{\bkmkend AAAAAAADNI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\i key}  member of this data point.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5569 \{ return key; \}\par
}
}
{\xe \v sortKeyIsMainKey\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static static bool QCPStatisticalBoxData::sortKeyIsMainKey (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAADNJ}
{\bkmkend AAAAAAADNJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Since the member {\i key}  is both the data point key coordinate and the data ordering parameter, this method returns true.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5571 \{ return true; \}\par
}
}
{\xe \v valueRange\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:valueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPStatisticalBoxData::valueRange () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADNK}
{\bkmkend AAAAAAADNK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPRange} spanning from the {\i minimum}  to the {\i maximum}  member of this statistical box data point, possibly further expanded by outliers.\par
For a general explanation of what this method is good for in the context of the data container, see the documentation of {\b QCPDataContainer}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5577   \{\par
 5578     QCPRange result(minimum, maximum);\par
 5579     for (QVector<double>::const_iterator it = outliers.constBegin(); it != outliers.constEnd(); ++it)\par
 5580       result.expand(*it);\par
 5581     return result;\par
 5582   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v key\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBoxData::key}}
\par
{\bkmkstart AAAAAAADNL}
{\bkmkend AAAAAAADNL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lowerQuartile\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:lowerQuartile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBoxData::lowerQuartile}}
\par
{\bkmkstart AAAAAAADNM}
{\bkmkend AAAAAAADNM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v maximum\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:maximum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBoxData::maximum}}
\par
{\bkmkstart AAAAAAADNN}
{\bkmkend AAAAAAADNN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v median\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:median}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBoxData::median}}
\par
{\bkmkstart AAAAAAADNO}
{\bkmkend AAAAAAADNO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v minimum\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:minimum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBoxData::minimum}}
\par
{\bkmkstart AAAAAAADNP}
{\bkmkend AAAAAAADNP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outliers\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:outliers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<double> QCPStatisticalBoxData::outliers}}
\par
{\bkmkstart AAAAAAADNQ}
{\bkmkend AAAAAAADNQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v upperQuartile\:QCPStatisticalBoxData}
{\xe \v QCPStatisticalBoxData\:upperQuartile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPStatisticalBoxData::upperQuartile}}
\par
{\bkmkstart AAAAAAADNR}
{\bkmkend AAAAAAADNR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPTextElement Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPTextElement}
{\xe \v QCPTextElement}
{\bkmkstart AAAAAAADNS}
{\bkmkend AAAAAAADNS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout element displaying a text. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCPTextElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_text_element__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCPTextElement:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_text_element__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (bool {\b selected})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectableChanged} (bool {\b selectable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clicked} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b doubleClicked} (QMouseEvent *event)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPTextElement} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPTextElement} ({\b QCustomPlot} *{\b parentPlot}, const QString &{\b text})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPTextElement} ({\b QCustomPlot} *{\b parentPlot}, const QString &{\b text}, double pointSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPTextElement} ({\b QCustomPlot} *{\b parentPlot}, const QString &{\b text}, const QString &fontFamily, double pointSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPTextElement} ({\b QCustomPlot} *{\b parentPlot}, const QString &{\b text}, const QFont &{\b font})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b text} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b textFlags} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b font} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b textColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b selectedFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b selectedTextColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b selectable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b selected} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setText} (const QString &{\b text})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTextFlags} (int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFont} (const QFont &{\b font})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTextColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedFont} (const QFont &{\b font})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedTextColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectable} (bool {\b selectable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelected} (bool {\b selected})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseDoubleClickEvent} (QMouseEvent *event, const QVariant &details) {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b minimumOuterSizeHint} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b maximumOuterSizeHint} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mainFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mainTextColor} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mText}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mTextFlags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mTextColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mSelectedFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mSelectedTextColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mTextBoundingRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mSelectable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mSelected}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout element displaying a text. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The text may be specified with {\b setText}, the formatting can be controlled with {\b setFont}, {\b setTextColor}, and {\b setTextFlags}.\par
A text element can be added as follows: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPTextElement\:QCPTextElement}
{\xe \v QCPTextElement\:QCPTextElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPTextElement::QCPTextElement ({\b QCustomPlot} *  {\i parentPlot}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAADNT}
{\bkmkend AAAAAAADNT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Creates a new {\b QCPTextElement} instance and sets default values. The initial text is empty ({\b setText}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18886                                                       :\par
18887   QCPLayoutElement(parentPlot),\par
18888   mText(),\par
18889   mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),\par
18890   mFont(QFont(QLatin1String("sans serif"), 12)), // will be taken from parentPlot if available, see below\par
18891   mTextColor(Qt::black),\par
18892   mSelectedFont(QFont(QLatin1String("sans serif"), 12)), // will be taken from parentPlot if available, see below\par
18893   mSelectedTextColor(Qt::blue),\par
18894   mSelectable(false),\par
18895   mSelected(false)\par
18896 \{\par
18897   if (parentPlot)\par
18898   \{\par
18899     mFont = parentPlot->font();\par
18900     mSelectedFont = parentPlot->font();\par
18901   \}\par
18902   setMargins(QMargins(2, 2, 2, 2));\par
18903 \}\par
}
}
{\xe \v QCPTextElement\:QCPTextElement}
{\xe \v QCPTextElement\:QCPTextElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPTextElement::QCPTextElement ({\b QCustomPlot} *  {\i parentPlot}, const QString &  {\i text})}}
\par
{\bkmkstart AAAAAAADNU}
{\bkmkend AAAAAAADNU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Creates a new {\b QCPTextElement} instance and sets default values.\par
The initial text is set to {\i text} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18911                                                                            :\par
18912   QCPLayoutElement(parentPlot),\par
18913   mText(text),\par
18914   mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),\par
18915   mFont(QFont(QLatin1String("sans serif"), 12)), // will be taken from parentPlot if available, see below\par
18916   mTextColor(Qt::black),\par
18917   mSelectedFont(QFont(QLatin1String("sans serif"), 12)), // will be taken from parentPlot if available, see below\par
18918   mSelectedTextColor(Qt::blue),\par
18919   mSelectable(false),\par
18920   mSelected(false)\par
18921 \{\par
18922   if (parentPlot)\par
18923   \{\par
18924     mFont = parentPlot->font();\par
18925     mSelectedFont = parentPlot->font();\par
18926   \}\par
18927   setMargins(QMargins(2, 2, 2, 2));\par
18928 \}\par
}
}
{\xe \v QCPTextElement\:QCPTextElement}
{\xe \v QCPTextElement\:QCPTextElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPTextElement::QCPTextElement ({\b QCustomPlot} *  {\i parentPlot}, const QString &  {\i text}, double  {\i pointSize})}}
\par
{\bkmkstart AAAAAAADNV}
{\bkmkend AAAAAAADNV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Creates a new {\b QCPTextElement} instance and sets default values.\par
The initial text is set to {\i text}  with {\i pointSize} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18936                                                                                              :\par
18937   QCPLayoutElement(parentPlot),\par
18938   mText(text),\par
18939   mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),\par
18940   mFont(QFont(QLatin1String("sans serif"), pointSize)), // will be taken from parentPlot if available, see below\par
18941   mTextColor(Qt::black),\par
18942   mSelectedFont(QFont(QLatin1String("sans serif"), pointSize)), // will be taken from parentPlot if available, see below\par
18943   mSelectedTextColor(Qt::blue),\par
18944   mSelectable(false),\par
18945   mSelected(false)\par
18946 \{\par
18947   if (parentPlot)\par
18948   \{\par
18949     mFont = parentPlot->font();\par
18950     mFont.setPointSizeF(pointSize);\par
18951     mSelectedFont = parentPlot->font();\par
18952     mSelectedFont.setPointSizeF(pointSize);\par
18953   \}\par
18954   setMargins(QMargins(2, 2, 2, 2));\par
18955 \}\par
}
}
{\xe \v QCPTextElement\:QCPTextElement}
{\xe \v QCPTextElement\:QCPTextElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPTextElement::QCPTextElement ({\b QCustomPlot} *  {\i parentPlot}, const QString &  {\i text}, const QString &  {\i fontFamily}, double  {\i pointSize})}}
\par
{\bkmkstart AAAAAAADNW}
{\bkmkend AAAAAAADNW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Creates a new {\b QCPTextElement} instance and sets default values.\par
The initial text is set to {\i text}  with {\i pointSize}  and the specified {\i fontFamily} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18963                                                                                                                         :\par
18964   QCPLayoutElement(parentPlot),\par
18965   mText(text),\par
18966   mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),\par
18967   mFont(QFont(fontFamily, pointSize)),\par
18968   mTextColor(Qt::black),\par
18969   mSelectedFont(QFont(fontFamily, pointSize)),\par
18970   mSelectedTextColor(Qt::blue),\par
18971   mSelectable(false),\par
18972   mSelected(false)\par
18973 \{\par
18974   setMargins(QMargins(2, 2, 2, 2));\par
18975 \}\par
}
}
{\xe \v QCPTextElement\:QCPTextElement}
{\xe \v QCPTextElement\:QCPTextElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPTextElement::QCPTextElement ({\b QCustomPlot} *  {\i parentPlot}, const QString &  {\i text}, const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAADNX}
{\bkmkend AAAAAAADNX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Creates a new {\b QCPTextElement} instance and sets default values.\par
The initial text is set to {\i text}  with the specified {\i font} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18983                                                                                               :\par
18984   QCPLayoutElement(parentPlot),\par
18985   mText(text),\par
18986   mTextFlags(Qt::AlignCenter|Qt::TextWordWrap),\par
18987   mFont(font),\par
18988   mTextColor(Qt::black),\par
18989   mSelectedFont(font),\par
18990   mSelectedTextColor(Qt::blue),\par
18991   mSelectable(false),\par
18992   mSelected(false)\par
18993 \{\par
18994   setMargins(QMargins(2, 2, 2, 2));\par
18995 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v applyDefaultAntialiasingHint\:QCPTextElement}
{\xe \v QCPTextElement\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSD}
{\bkmkend AAAAAAACSD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19105 \{\par
19106   applyAntialiasingHint(painter, mAntialiased, QCP::aeOther);\par
19107 \}\par
}
}
{\xe \v clicked\:QCPTextElement}
{\xe \v QCPTextElement\:clicked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::clicked (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADNY}
{\bkmkend AAAAAAADNY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the text element is clicked.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b doubleClicked}, {\b selectTest} \par
}}}
{\xe \v deselectEvent\:QCPTextElement}
{\xe \v QCPTextElement\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSG}
{\bkmkend AAAAAAACSG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19153 \{\par
19154   if (mSelectable)\par
19155   \{\par
19156     bool selBefore = mSelected;\par
19157     setSelected(false);\par
19158     if (selectionStateChanged)\par
19159       *selectionStateChanged = mSelected != selBefore;\par
19160   \}\par
19161 \}\par
}
}
{\xe \v doubleClicked\:QCPTextElement}
{\xe \v QCPTextElement\:doubleClicked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::doubleClicked (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADNZ}
{\bkmkend AAAAAAADNZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the text element is double clicked.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clicked}, {\b selectTest} \par
}}}
{\xe \v draw\:QCPTextElement}
{\xe \v QCPTextElement\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSI}
{\bkmkend AAAAAAACSI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19111 \{\par
19112   painter->setFont(mainFont());\par
19113   painter->setPen(QPen(mainTextColor()));\par
19114   painter->drawText(mRect, Qt::AlignCenter, mText, &mTextBoundingRect);\par
19115 \}\par
}
}
{\xe \v font\:QCPTextElement}
{\xe \v QCPTextElement\:font}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPTextElement::font () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOA}
{\bkmkend AAAAAAADOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4948 \{ return mFont; \}\par
}
}
{\xe \v mainFont\:QCPTextElement}
{\xe \v QCPTextElement\:mainFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPTextElement::mainFont () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADOB}
{\bkmkend AAAAAAADOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19226 \{\par
19227   return mSelected ? mSelectedFont : mFont;\par
19228 \}\par
}
}
{\xe \v mainTextColor\:QCPTextElement}
{\xe \v QCPTextElement\:mainTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPTextElement::mainTextColor () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADOC}
{\bkmkend AAAAAAADOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19236 \{\par
19237   return mSelected ? mSelectedTextColor : mTextColor;\par
19238 \}\par
}
}
{\xe \v maximumOuterSizeHint\:QCPTextElement}
{\xe \v QCPTextElement\:maximumOuterSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPTextElement::maximumOuterSizeHint () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACVQ}
{\bkmkend AAAAAAACVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the suggested maximum size this layout element (the {\b outerRect}) may be expanded to, if no manual maximum size is set.\par
if a maximum size ({\b setMaximumSize}) was not set manually, parent layouts use the returned size (usually indirectly through {\b QCPLayout::getFinalMaximumOuterSize}) to determine the maximum allowed size of this layout element.\par
A manual maximum size is considered set if it is smaller than Qt's {\f2 QWIDGETSIZE_MAX} .\par
The default implementation simply returns {\f2 QWIDGETSIZE_MAX}  for both width and height, implying no suggested maximum size. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19129 \{\par
19130   QFontMetrics metrics(mFont);\par
19131   QSize result(metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size());\par
19132   result.setWidth(QWIDGETSIZE_MAX);\par
19133   result.rheight() += mMargins.top()+mMargins.bottom();\par
19134   return result;\par
19135 \}\par
}
}
{\xe \v minimumOuterSizeHint\:QCPTextElement}
{\xe \v QCPTextElement\:minimumOuterSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPTextElement::minimumOuterSizeHint () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACVV}
{\bkmkend AAAAAAACVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the suggested minimum size this layout element (the {\b outerRect}) may be compressed to, if no manual minimum size is set.\par
if a minimum size ({\b setMinimumSize}) was not set manually, parent layouts use the returned size (usually indirectly through {\b QCPLayout::getFinalMinimumOuterSize}) to determine the minimum allowed size of this layout element.\par
A manual minimum size is considered set if it is non-zero.\par
The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints. \par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACVU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19119 \{\par
19120   QFontMetrics metrics(mFont);\par
19121   QSize result(metrics.boundingRect(0, 0, 0, 0, Qt::AlignCenter, mText).size());\par
19122   result.rwidth() += mMargins.left()+mMargins.right();\par
19123   result.rheight() += mMargins.top()+mMargins.bottom();\par
19124   return result;\par
19125 \}\par
}
}
{\xe \v mouseDoubleClickEvent\:QCPTextElement}
{\xe \v QCPTextElement\:mouseDoubleClickEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::mouseDoubleClickEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSP}
{\bkmkend AAAAAAACSP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Emits the {\b doubleClicked} signal.\par
}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACSO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19215 \{\par
19216   Q_UNUSED(details)\par
19217   emit doubleClicked(event);\par
19218 \}\par
}
}
{\xe \v mousePressEvent\:QCPTextElement}
{\xe \v QCPTextElement\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::mousePressEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSQ}
{\bkmkend AAAAAAACSQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accepts the mouse event in order to emit the according click signal in the {\b mouseReleaseEvent}.\par
}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19192 \{\par
19193   Q_UNUSED(details)\par
19194   event->accept();\par
19195 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPTextElement}
{\xe \v QCPTextElement\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::mouseReleaseEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSR}
{\bkmkend AAAAAAACSR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Emits the {\b clicked} signal if the cursor hasn't moved by more than a few pixels since the {\b mousePressEvent}.\par
}{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19204 \{\par
19205   if ((QPointF(event->pos())-startPos).manhattanLength() <= 3)\par
19206     emit clicked(event);\par
19207 \}\par
}
}
{\xe \v selectable\:QCPTextElement}
{\xe \v QCPTextElement\:selectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPTextElement::selectable () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOD}
{\bkmkend AAAAAAADOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4952 \{ return mSelectable; \}\par
}
}
{\xe \v selectableChanged\:QCPTextElement}
{\xe \v QCPTextElement\:selectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::selectableChanged (bool  {\i selectable}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADOE}
{\bkmkend AAAAAAADOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v selected\:QCPTextElement}
{\xe \v QCPTextElement\:selected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPTextElement::selected () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOF}
{\bkmkend AAAAAAADOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4953 \{ return mSelected; \}\par
}
}
{\xe \v selectedFont\:QCPTextElement}
{\xe \v QCPTextElement\:selectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPTextElement::selectedFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOG}
{\bkmkend AAAAAAADOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4950 \{ return mSelectedFont; \}\par
}
}
{\xe \v selectedTextColor\:QCPTextElement}
{\xe \v QCPTextElement\:selectedTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPTextElement::selectedTextColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOH}
{\bkmkend AAAAAAADOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4951 \{ return mSelectedTextColor; \}\par
}
}
{\xe \v selectEvent\:QCPTextElement}
{\xe \v QCPTextElement\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACSZ}
{\bkmkend AAAAAAACSZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19139 \{\par
19140   Q_UNUSED(event)\par
19141   Q_UNUSED(details)\par
19142   if (mSelectable)\par
19143   \{\par
19144     bool selBefore = mSelected;\par
19145     setSelected(additive ? !mSelected : true);\par
19146     if (selectionStateChanged)\par
19147       *selectionStateChanged = mSelected != selBefore;\par
19148   \}\par
19149 \}\par
}
}
{\xe \v selectionChanged\:QCPTextElement}
{\xe \v QCPTextElement\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::selectionChanged (bool  {\i selected}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADOI}
{\bkmkend AAAAAAADOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state has changed to {\i selected} , either by user interaction or by a direct call to {\b setSelected}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelected}, {\b setSelectable} \par
}}}
{\xe \v selectTest\:QCPTextElement}
{\xe \v QCPTextElement\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPTextElement::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACTC}
{\bkmkend AAAAAAACTC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns 0.99*selectionTolerance (see {\b QCustomPlot::setSelectionTolerance}) when {\i pos}  is within the bounding box of the text element's text. Note that this bounding box is updated in the draw call.\par
If {\i pos}  is outside the text's bounding box or if {\i onlySelectable}  is true and this text element is not selectable ({\b setSelectable}), returns -1.\par
}{
Reimplemented from {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19174 \{\par
19175   Q_UNUSED(details)\par
19176   if (onlySelectable && !mSelectable)\par
19177     return -1;\par
19178   \par
19179   if (mTextBoundingRect.contains(pos.toPoint()))\par
19180     return mParentPlot->selectionTolerance()*0.99;\par
19181   else\par
19182     return -1;\par
19183 \}\par
}
}
{\xe \v setFont\:QCPTextElement}
{\xe \v QCPTextElement\:setFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::setFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAADOJ}
{\bkmkend AAAAAAADOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i font}  of the text.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTextColor}, {\b setSelectedFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19038 \{\par
19039   mFont = font;\par
19040 \}\par
}
}
{\xe \v setSelectable\:QCPTextElement}
{\xe \v QCPTextElement\:setSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::setSelectable (bool  {\i selectable})}}
\par
{\bkmkstart AAAAAAADOK}
{\bkmkend AAAAAAADOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the user may select this text element.\par
Note that even when {\i selectable}  is set to {\f2 false} , the selection state may be changed programmatically via {\b setSelected}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19079 \{\par
19080   if (mSelectable != selectable)\par
19081   \{\par
19082     mSelectable = selectable;\par
19083     emit selectableChanged(mSelectable);\par
19084   \}\par
19085 \}\par
}
}
{\xe \v setSelected\:QCPTextElement}
{\xe \v QCPTextElement\:setSelected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::setSelected (bool  {\i selected})}}
\par
{\bkmkstart AAAAAAADOL}
{\bkmkend AAAAAAADOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the selection state of this text element to {\i selected} . If the selection has changed, {\b selectionChanged} is emitted.\par
Note that this function can change the selection state independently of the current {\b setSelectable} state. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19095 \{\par
19096   if (mSelected != selected)\par
19097   \{\par
19098     mSelected = selected;\par
19099     emit selectionChanged(mSelected);\par
19100   \}\par
19101 \}\par
}
}
{\xe \v setSelectedFont\:QCPTextElement}
{\xe \v QCPTextElement\:setSelectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::setSelectedFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAADOM}
{\bkmkend AAAAAAADOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i font}  of the text that will be used if the text element is selected ({\b setSelected}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19058 \{\par
19059   mSelectedFont = font;\par
19060 \}\par
}
}
{\xe \v setSelectedTextColor\:QCPTextElement}
{\xe \v QCPTextElement\:setSelectedTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::setSelectedTextColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAADON}
{\bkmkend AAAAAAADON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i color}  of the text that will be used if the text element is selected ({\b setSelected}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTextColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19068 \{\par
19069   mSelectedTextColor = color;\par
19070 \}\par
}
}
{\xe \v setText\:QCPTextElement}
{\xe \v QCPTextElement\:setText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::setText (const QString &  {\i text})}}
\par
{\bkmkstart AAAAAAADOO}
{\bkmkend AAAAAAADOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the text that will be displayed to {\i text} . Multiple lines can be created by insertion of "\\n".\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFont}, {\b setTextColor}, {\b setTextFlags} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19003 \{\par
19004   mText = text;\par
19005 \}\par
}
}
{\xe \v setTextColor\:QCPTextElement}
{\xe \v QCPTextElement\:setTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::setTextColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAADOP}
{\bkmkend AAAAAAADOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i color}  of the text.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setFont}, {\b setSelectedTextColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19048 \{\par
19049   mTextColor = color;\par
19050 \}\par
}
}
{\xe \v setTextFlags\:QCPTextElement}
{\xe \v QCPTextElement\:setTextFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPTextElement::setTextFlags (int  {\i flags})}}
\par
{\bkmkstart AAAAAAADOQ}
{\bkmkend AAAAAAADOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets options for text alignment and wrapping behaviour. {\i flags}  is a bitwise OR-combination of {\f2 Qt::AlignmentFlag}  and {\f2 Qt::TextFlag}  enums.\par
Possible enums are:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::AlignLeft\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::AlignRight\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::AlignHCenter\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::AlignJustify\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::AlignTop\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::AlignBottom\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::AlignVCenter\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::AlignCenter\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::TextDontClip\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::TextSingleLine\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::TextExpandTabs\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::TextShowMnemonic\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::TextWordWrap\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Qt::TextIncludeTrailingSpaces \par}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19028 \{\par
19029   mTextFlags = flags;\par
19030 \}\par
}
}
{\xe \v text\:QCPTextElement}
{\xe \v QCPTextElement\:text}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPTextElement::text () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOR}
{\bkmkend AAAAAAADOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4946 \{ return mText; \}\par
}
}
{\xe \v textColor\:QCPTextElement}
{\xe \v QCPTextElement\:textColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPTextElement::textColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOS}
{\bkmkend AAAAAAADOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4949 \{ return mTextColor; \}\par
}
}
{\xe \v textFlags\:QCPTextElement}
{\xe \v QCPTextElement\:textFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPTextElement::textFlags () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOT}
{\bkmkend AAAAAAADOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4947 \{ return mTextFlags; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mFont\:QCPTextElement}
{\xe \v QCPTextElement\:mFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPTextElement::mFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADOU}
{\bkmkend AAAAAAADOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectable\:QCPTextElement}
{\xe \v QCPTextElement\:mSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPTextElement::mSelectable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADOV}
{\bkmkend AAAAAAADOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelected\:QCPTextElement}
{\xe \v QCPTextElement\:mSelected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPTextElement::mSelected{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADOW}
{\bkmkend AAAAAAADOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedFont\:QCPTextElement}
{\xe \v QCPTextElement\:mSelectedFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPTextElement::mSelectedFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADOX}
{\bkmkend AAAAAAADOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedTextColor\:QCPTextElement}
{\xe \v QCPTextElement\:mSelectedTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPTextElement::mSelectedTextColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADOY}
{\bkmkend AAAAAAADOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mText\:QCPTextElement}
{\xe \v QCPTextElement\:mText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPTextElement::mText{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADOZ}
{\bkmkend AAAAAAADOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTextBoundingRect\:QCPTextElement}
{\xe \v QCPTextElement\:mTextBoundingRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPTextElement::mTextBoundingRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADPA}
{\bkmkend AAAAAAADPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTextColor\:QCPTextElement}
{\xe \v QCPTextElement\:mTextColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPTextElement::mTextColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADPB}
{\bkmkend AAAAAAADPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTextFlags\:QCPTextElement}
{\xe \v QCPTextElement\:mTextFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPTextElement::mTextFlags{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADPC}
{\bkmkend AAAAAAADPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPVector2D Class Reference\par \pard\plain 
{\tc\tcl2 \v QCPVector2D}
{\xe \v QCPVector2D}
{\bkmkstart AAAAAAADPD}
{\bkmkend AAAAAAADPD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents two doubles as a mathematical 2D vector. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPVector2D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_c_p_vector2_d__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} (double {\b x}, double {\b y})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} (const QPoint &point)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} (const QPointF &point)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b x} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b y} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double & {\b rx} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double & {\b ry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setX} (double {\b x})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setY} (double {\b y})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b length} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lengthSquared} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b toPoint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointF {\b toPointF} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isNull} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b normalize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} {\b normalized} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} {\b perpendicular} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dot} (const {\b QCPVector2D} &vec) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceSquaredToLine} (const {\b QCPVector2D} &start, const {\b QCPVector2D} &end) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceSquaredToLine} (const QLineF &line) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceToStraightLine} (const {\b QCPVector2D} &base, const {\b QCPVector2D} &direction) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} & {\b operator*=} (double factor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} & {\b operator/=} (double divisor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} & {\b operator+=} (const {\b QCPVector2D} &vector)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPVector2D} & {\b operator-=} (const {\b QCPVector2D} &vector)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator*} (double factor, const {\b QCPVector2D} &vec)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator*} (const {\b QCPVector2D} &vec, double factor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator/} (const {\b QCPVector2D} &vec, double divisor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator+} (const {\b QCPVector2D} &vec1, const {\b QCPVector2D} &vec2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator-} (const {\b QCPVector2D} &vec1, const {\b QCPVector2D} &vec2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator-} (const {\b QCPVector2D} &vec)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Related Functions\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Note that these are not member functions.) \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QDebug {\b operator<<} (QDebug d, const {\b QCPVector2D} &vec)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents two doubles as a mathematical 2D vector. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class acts as a replacement for QVector2D with the advantage of double precision instead of single, and some convenience methods tailored for the {\b QCustomPlot} library. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCPVector2D\:QCPVector2D}
{\xe \v QCPVector2D\:QCPVector2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPVector2D::QCPVector2D ()}}
\par
{\bkmkstart AAAAAAADPE}
{\bkmkend AAAAAAADPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPVector2D} object and initializes the x and y coordinates to 0. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   111                          :\par
  112   mX(0),\par
  113   mY(0)\par
  114 \{\par
  115 \}\par
}
}
{\xe \v QCPVector2D\:QCPVector2D}
{\xe \v QCPVector2D\:QCPVector2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPVector2D::QCPVector2D (double  {\i x}, double  {\i y})}}
\par
{\bkmkstart AAAAAAADPF}
{\bkmkend AAAAAAADPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPVector2D} object and initializes the {\i x}  and {\i y}  coordinates with the specified values. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   121                                            :\par
  122   mX(x),\par
  123   mY(y)\par
  124 \{\par
  125 \}\par
}
}
{\xe \v QCPVector2D\:QCPVector2D}
{\xe \v QCPVector2D\:QCPVector2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPVector2D::QCPVector2D (const QPoint &  {\i point})}}
\par
{\bkmkstart AAAAAAADPG}
{\bkmkend AAAAAAADPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPVector2D} object and initializes the x and y coordinates respective coordinates of the specified {\i point} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   131                                             :\par
  132   mX(point.x()),\par
  133   mY(point.y())\par
  134 \{\par
  135 \}\par
}
}
{\xe \v QCPVector2D\:QCPVector2D}
{\xe \v QCPVector2D\:QCPVector2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPVector2D::QCPVector2D (const QPointF &  {\i point})}}
\par
{\bkmkstart AAAAAAADPH}
{\bkmkend AAAAAAADPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPVector2D} object and initializes the x and y coordinates respective coordinates of the specified {\i point} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   141                                              :\par
  142   mX(point.x()),\par
  143   mY(point.y())\par
  144 \{\par
  145 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v distanceSquaredToLine\:QCPVector2D}
{\xe \v QCPVector2D\:distanceSquaredToLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPVector2D::distanceSquaredToLine (const {\b QCPVector2D} &  {\i start}, const {\b QCPVector2D} &  {\i end}) const}}
\par
{\bkmkstart AAAAAAADPI}
{\bkmkend AAAAAAADPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns the squared shortest distance of this vector (interpreted as a point) to the finite line segment given by {\i start}  and {\i end} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b distanceToStraightLine} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   179 \{\par
  180   QCPVector2D v(end-start);\par
  181   double vLengthSqr = v.lengthSquared();\par
  182   if (!qFuzzyIsNull(vLengthSqr))\par
  183   \{\par
  184     double mu = v.dot(*this-start)/vLengthSqr;\par
  185     if (mu < 0)\par
  186       return (*this-start).lengthSquared();\par
  187     else if (mu > 1)\par
  188       return (*this-end).lengthSquared();\par
  189     else\par
  190       return ((start + mu*v)-*this).lengthSquared();\par
  191   \} else\par
  192     return (*this-start).lengthSquared();\par
  193 \}\par
}
}
{\xe \v distanceSquaredToLine\:QCPVector2D}
{\xe \v QCPVector2D\:distanceSquaredToLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPVector2D::distanceSquaredToLine (const QLineF &  {\i line}) const}}
\par
{\bkmkstart AAAAAAADPJ}
{\bkmkend AAAAAAADPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns the squared shortest distance of this vector (interpreted as a point) to the finite line segment given by {\i line} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b distanceToStraightLine} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   203 \{\par
  204   return distanceSquaredToLine(QCPVector2D(line.p1()), QCPVector2D(line.p2()));\par
  205 \}\par
}
}
{\xe \v distanceToStraightLine\:QCPVector2D}
{\xe \v QCPVector2D\:distanceToStraightLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPVector2D::distanceToStraightLine (const {\b QCPVector2D} &  {\i base}, const {\b QCPVector2D} &  {\i direction}) const}}
\par
{\bkmkstart AAAAAAADPK}
{\bkmkend AAAAAAADPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the shortest distance of this vector (interpreted as a point) to the infinite straight line given by a {\i base}  point and a {\i direction}  vector.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b distanceSquaredToLine} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   214 \{\par
  215   return qAbs((*this-base).dot(direction.perpendicular()))/direction.length();\par
  216 \}\par
}
}
{\xe \v dot\:QCPVector2D}
{\xe \v QCPVector2D\:dot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPVector2D::dot (const {\b QCPVector2D} &  {\i vec}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADPL}
{\bkmkend AAAAAAADPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the dot/scalar product of this vector with the specified vector {\i vec} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   410 \{ return mX*vec.mX+mY*vec.mY; \}\par
}
}
{\xe \v isNull\:QCPVector2D}
{\xe \v QCPVector2D\:isNull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPVector2D::isNull () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADPM}
{\bkmkend AAAAAAADPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this vector is null. A vector is null if {\f2 qIsNull}  returns true for both x and y coordinates, i.e. if both are binary equal to 0. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   406 \{ return qIsNull(mX) && qIsNull(mY); \}\par
}
}
{\xe \v length\:QCPVector2D}
{\xe \v QCPVector2D\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPVector2D::length () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADPN}
{\bkmkend AAAAAAADPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the length of this vector.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b lengthSquared} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   401 \{ return qSqrt(mX*mX+mY*mY); \}\par
}
}
{\xe \v lengthSquared\:QCPVector2D}
{\xe \v QCPVector2D\:lengthSquared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPVector2D::lengthSquared () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADPO}
{\bkmkend AAAAAAADPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the squared length of this vector. In some situations, e.g. when just trying to find the shortest vector of a group, this is faster than calculating {\b length}, because it avoids calculation of a square root.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b length} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   402 \{ return mX*mX+mY*mY; \}\par
}
}
{\xe \v normalize\:QCPVector2D}
{\xe \v QCPVector2D\:normalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPVector2D::normalize ()}}
\par
{\bkmkstart AAAAAAADPP}
{\bkmkend AAAAAAADPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalizes this vector. After this operation, the length of the vector is equal to 1.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b normalized}, {\b length}, {\b lengthSquared} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   153 \{\par
  154   double len = length();\par
  155   mX /= len;\par
  156   mY /= len;\par
  157 \}\par
}
}
{\xe \v normalized\:QCPVector2D}
{\xe \v QCPVector2D\:normalized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPVector2D} QCPVector2D::normalized () const}}
\par
{\bkmkstart AAAAAAADPQ}
{\bkmkend AAAAAAADPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a normalized version of this vector. The length of the returned vector is equal to 1.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b normalize}, {\b length}, {\b lengthSquared} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165 \{\par
  166   QCPVector2D result(mX, mY);\par
  167   result.normalize();\par
  168   return result;\par
  169 \}\par
}
}
{\xe \v operator*=\:QCPVector2D}
{\xe \v QCPVector2D\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPVector2D} & QCPVector2D::operator*= (double  {\i factor})}}
\par
{\bkmkstart AAAAAAADPR}
{\bkmkend AAAAAAADPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scales this vector by the given {\i factor} , i.e. the x and y components are multiplied by {\i factor} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   223 \{\par
  224   mX *= factor;\par
  225   mY *= factor;\par
  226   return *this;\par
  227 \}\par
}
}
{\xe \v operator+=\:QCPVector2D}
{\xe \v QCPVector2D\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPVector2D} & QCPVector2D::operator+= (const {\b QCPVector2D} &  {\i vector})}}
\par
{\bkmkstart AAAAAAADPS}
{\bkmkend AAAAAAADPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the given {\i vector}  to this vector component-wise. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   244 \{\par
  245   mX += vector.mX;\par
  246   mY += vector.mY;\par
  247   return *this;\par
  248 \}\par
}
}
{\xe \v operator-=\:QCPVector2D}
{\xe \v QCPVector2D\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPVector2D} & QCPVector2D::operator-= (const {\b QCPVector2D} &  {\i vector})}}
\par
{\bkmkstart AAAAAAADPT}
{\bkmkend AAAAAAADPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
subtracts the given {\i vector}  from this vector component-wise. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   254 \{\par
  255   mX -= vector.mX;\par
  256   mY -= vector.mY;\par
  257   return *this;\par
  258 \}\par
}
}
{\xe \v operator/=\:QCPVector2D}
{\xe \v QCPVector2D\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPVector2D} & QCPVector2D::operator/= (double  {\i divisor})}}
\par
{\bkmkstart AAAAAAADPU}
{\bkmkend AAAAAAADPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scales this vector by the given {\i divisor} , i.e. the x and y components are divided by {\i divisor} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   234 \{\par
  235   mX /= divisor;\par
  236   mY /= divisor;\par
  237   return *this;\par
  238 \}\par
}
}
{\xe \v perpendicular\:QCPVector2D}
{\xe \v QCPVector2D\:perpendicular}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPVector2D} QCPVector2D::perpendicular () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADPV}
{\bkmkend AAAAAAADPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector perpendicular to this vector, with the same length. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   409 \{ return QCPVector2D(-mY, mX); \}\par
}
}
{\xe \v rx\:QCPVector2D}
{\xe \v QCPVector2D\:rx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double& QCPVector2D::rx (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADPW}
{\bkmkend AAAAAAADPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   393 \{ return mX; \}\par
}
}
{\xe \v ry\:QCPVector2D}
{\xe \v QCPVector2D\:ry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double& QCPVector2D::ry (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADPX}
{\bkmkend AAAAAAADPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   394 \{ return mY; \}\par
}
}
{\xe \v setX\:QCPVector2D}
{\xe \v QCPVector2D\:setX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPVector2D::setX (double  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADPY}
{\bkmkend AAAAAAADPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the x coordinate of this vector to {\i x} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setY} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   397 \{ mX = x; \}\par
}
}
{\xe \v setY\:QCPVector2D}
{\xe \v QCPVector2D\:setY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPVector2D::setY (double  {\i y}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADPZ}
{\bkmkend AAAAAAADPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the y coordinate of this vector to {\i y} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setX} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   398 \{ mY = y; \}\par
}
}
{\xe \v toPoint\:QCPVector2D}
{\xe \v QCPVector2D\:toPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPVector2D::toPoint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADQA}
{\bkmkend AAAAAAADQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a QPoint which has the x and y coordinates of this vector, truncating any floating point information.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b toPointF} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   403 \{ return QPoint(mX, mY); \}\par
}
}
{\xe \v toPointF\:QCPVector2D}
{\xe \v QCPVector2D\:toPointF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPVector2D::toPointF () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADQB}
{\bkmkend AAAAAAADQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a QPointF which has the x and y coordinates of this vector.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b toPoint} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   404 \{ return QPointF(mX, mY); \}\par
}
}
{\xe \v x\:QCPVector2D}
{\xe \v QCPVector2D\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPVector2D::x () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADQC}
{\bkmkend AAAAAAADQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   391 \{ return mX; \}\par
}
}
{\xe \v y\:QCPVector2D}
{\xe \v QCPVector2D\:y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPVector2D::y () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADQD}
{\bkmkend AAAAAAADQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   392 \{ return mY; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator*\:QCPVector2D}
{\xe \v QCPVector2D\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator* (double  {\i factor}, const {\b QCPVector2D} &  {\i vec}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADQE}
{\bkmkend AAAAAAADQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   433 \{ return QCPVector2D(vec.mX*factor, vec.mY*factor); \}\par
}
}
{\xe \v operator*\:QCPVector2D}
{\xe \v QCPVector2D\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator* (const {\b QCPVector2D} &  {\i vec}, double  {\i factor}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADQF}
{\bkmkend AAAAAAADQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   434 \{ return QCPVector2D(vec.mX*factor, vec.mY*factor); \}\par
}
}
{\xe \v operator+\:QCPVector2D}
{\xe \v QCPVector2D\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator+ (const {\b QCPVector2D} &  {\i vec1}, const {\b QCPVector2D} &  {\i vec2}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADQG}
{\bkmkend AAAAAAADQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   436 \{ return QCPVector2D(vec1.mX+vec2.mX, vec1.mY+vec2.mY); \}\par
}
}
{\xe \v operator-\:QCPVector2D}
{\xe \v QCPVector2D\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator- (const {\b QCPVector2D} &  {\i vec1}, const {\b QCPVector2D} &  {\i vec2}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADQH}
{\bkmkend AAAAAAADQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   437 \{ return QCPVector2D(vec1.mX-vec2.mX, vec1.mY-vec2.mY); \}\par
}
}
{\xe \v operator-\:QCPVector2D}
{\xe \v QCPVector2D\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator- (const {\b QCPVector2D} &  {\i vec}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADQI}
{\bkmkend AAAAAAADQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   438 \{ return QCPVector2D(-vec.mX, -vec.mY); \}\par
}
}
{\xe \v operator/\:QCPVector2D}
{\xe \v QCPVector2D\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator/ (const {\b QCPVector2D} &  {\i vec}, double  {\i divisor}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADQJ}
{\bkmkend AAAAAAADQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   435 \{ return QCPVector2D(vec.mX/divisor, vec.mY/divisor); \}\par
}
}
{\xe \v operator<<\:QCPVector2D}
{\xe \v QCPVector2D\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QDebug operator<< (QDebug  {\i d}, const {\b QCPVector2D} &  {\i vec}){\f2 [related]}}}
\par
{\bkmkstart AAAAAAADQK}
{\bkmkend AAAAAAADQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints {\i vec}  in a human readable format to the qDebug output. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   445 \{\par
  446     d.nospace() << "QCPVector2D(" << vec.x() << ", " << vec.y() << ")";\par
  447     return d.space();\par
  448 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCustomPlot Class Reference\par \pard\plain 
{\tc\tcl2 \v QCustomPlot}
{\xe \v QCustomPlot}
{\bkmkstart AAAAAAADQL}
{\bkmkend AAAAAAADQL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The central class of the library. This is the QWidget which displays the plot and interacts with the user. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Inheritance diagram for QCustomPlot:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_custom_plot__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for QCustomPlot:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_q_custom_plot__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LayerInsertMode} \{ {\b limBelow}, 
{\b limAbove}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b RefreshPriority} \{ {\b rpImmediateRefresh}, 
{\b rpQueuedRefresh}, 
{\b rpRefreshHint}, 
{\b rpQueuedReplot}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseDoubleClick} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mousePress} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseMove} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseRelease} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseWheel} (QWheelEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b plottableClick} ({\b QCPAbstractPlottable} *{\b plottable}, int dataIndex, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b plottableDoubleClick} ({\b QCPAbstractPlottable} *{\b plottable}, int dataIndex, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b itemClick} ({\b QCPAbstractItem} *{\b item}, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b itemDoubleClick} ({\b QCPAbstractItem} *{\b item}, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b axisClick} ({\b QCPAxis} *axis, {\b QCPAxis::SelectablePart} part, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b axisDoubleClick} ({\b QCPAxis} *axis, {\b QCPAxis::SelectablePart} part, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b legendClick} ({\b QCPLegend} *{\b legend}, {\b QCPAbstractLegendItem} *{\b item}, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b legendDoubleClick} ({\b QCPLegend} *{\b legend}, {\b QCPAbstractLegendItem} *{\b item}, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChangedByUser} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b beforeReplot} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b afterReplot} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} (QWidget *parent=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCustomPlot} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b viewport} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b bufferDevicePixelRatio} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b background} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b backgroundScaled} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b backgroundScaledMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutGrid} * {\b plotLayout} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b antialiasedElements} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b notAntialiasedElements} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b autoAddPlottableToLegend} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QCP::Interactions {\b interactions} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b selectionTolerance} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b noAntialiasingOnDrag} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::PlottingHints {\b plottingHints} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::KeyboardModifier {\b multiSelectModifier} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionRectMode} {\b selectionRectMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionRect} * {\b selectionRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b openGl} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setViewport} (const QRect &rect)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBufferDevicePixelRatio} (double ratio)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QPixmap &pm)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode=Qt::KeepAspectRatioByExpanding)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QBrush &brush)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackgroundScaled} (bool scaled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackgroundScaledMode} (Qt::AspectRatioMode mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedElements} (const QCP::AntialiasedElements &{\b antialiasedElements})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedElement} ({\b QCP::AntialiasedElement} antialiasedElement, bool enabled=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNotAntialiasedElements} (const QCP::AntialiasedElements &{\b notAntialiasedElements})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNotAntialiasedElement} ({\b QCP::AntialiasedElement} notAntialiasedElement, bool enabled=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAutoAddPlottableToLegend} (bool on)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInteractions} (const QCP::Interactions &{\b interactions})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInteraction} (const {\b QCP::Interaction} &interaction, bool enabled=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectionTolerance} (int pixels)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNoAntialiasingOnDrag} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPlottingHints} (const QCP::PlottingHints &hints)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPlottingHint} ({\b QCP::PlottingHint} hint, bool enabled=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMultiSelectModifier} (Qt::KeyboardModifier modifier)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectionRectMode} ({\b QCP::SelectionRectMode} mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectionRect} ({\b QCPSelectionRect} *{\b selectionRect})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOpenGl} (bool enabled, int multisampling=16)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b plottable} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b plottable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removePlottable} ({\b QCPAbstractPlottable} *{\b plottable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removePlottable} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b clearPlottables} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b plottableCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractPlottable} * > {\b selectedPlottables} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable} * {\b plottableAt} (const QPointF &pos, bool onlySelectable=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasPlottable} ({\b QCPAbstractPlottable} *{\b plottable}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b graph} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b graph} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b addGraph} ({\b QCPAxis} *keyAxis=0, {\b QCPAxis} *valueAxis=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeGraph} ({\b QCPGraph} *{\b graph})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeGraph} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b clearGraphs} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b graphCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPGraph} * > {\b selectedGraphs} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractItem} * {\b item} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractItem} * {\b item} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeItem} ({\b QCPAbstractItem} *{\b item})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeItem} (int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b clearItems} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b itemCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractItem} * > {\b selectedItems} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractItem} * {\b itemAt} (const QPointF &pos, bool onlySelectable=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasItem} ({\b QCPAbstractItem} *{\b item}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b layer} (const QString &name) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b layer} (int index) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b currentLayer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setCurrentLayer} (const QString &name)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setCurrentLayer} ({\b QCPLayer} *{\b layer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b layerCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addLayer} (const QString &name, {\b QCPLayer} *otherLayer=0, {\b LayerInsertMode} insertMode={\b limAbove})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeLayer} ({\b QCPLayer} *{\b layer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveLayer} ({\b QCPLayer} *{\b layer}, {\b QCPLayer} *otherLayer, {\b LayerInsertMode} insertMode={\b limAbove})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b axisRectCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b axisRect} (int index=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxisRect} * > {\b axisRects} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutElement} * {\b layoutElementAt} (const QPointF &pos) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b axisRectAt} (const QPointF &pos) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b rescaleAxes} (bool onlyVisiblePlottables=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b selectedAxes} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLegend} * > {\b selectedLegends} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b deselectAll} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b savePdf} (const QString &fileName, int width=0, int height=0, {\b QCP::ExportPen} exportPen={\b QCP::epAllowCosmetic}, const QString &pdfCreator=QString(), const QString &pdfTitle=QString())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b savePng} (const QString &fileName, int width=0, int height=0, double scale=1.0, int quality=-1, int resolution=96, {\b QCP::ResolutionUnit} resolutionUnit={\b QCP::ruDotsPerInch})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveJpg} (const QString &fileName, int width=0, int height=0, double scale=1.0, int quality=-1, int resolution=96, {\b QCP::ResolutionUnit} resolutionUnit={\b QCP::ruDotsPerInch})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveBmp} (const QString &fileName, int width=0, int height=0, double scale=1.0, int resolution=96, {\b QCP::ResolutionUnit} resolutionUnit={\b QCP::ruDotsPerInch})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b saveRastered} (const QString &fileName, int width, int height, double scale, const char *format, int quality=-1, int resolution=96, {\b QCP::ResolutionUnit} resolutionUnit={\b QCP::ruDotsPerInch})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b toPixmap} (int width=0, int height=0, double scale=1.0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toPainter} ({\b QCPPainter} *painter, int width=0, int height=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b replot} ({\b QCustomPlot::RefreshPriority} refreshPriority={\b QCustomPlot::rpRefreshHint})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b xAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b yAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b xAxis2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b yAxis2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLegend} * {\b legend}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b minimumSizeHint} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b sizeHint} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b paintEvent} (QPaintEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b resizeEvent} (QResizeEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseDoubleClickEvent} (QMouseEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateLayout} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b axisRemoved} ({\b QCPAxis} *axis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b legendRemoved} ({\b QCPLegend} *{\b legend})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual Q_SLOT void {\b processRectSelection} (QRect rect, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual Q_SLOT void {\b processRectZoom} (QRect rect, QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual Q_SLOT void {\b processPointSelection} (QMouseEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b registerPlottable} ({\b QCPAbstractPlottable} *{\b plottable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b registerGraph} ({\b QCPGraph} *{\b graph})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b registerItem} ({\b QCPAbstractItem} *{\b item})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateLayerIndices} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayerable} * {\b layerableAt} (const QPointF &pos, bool onlySelectable, QVariant *selectionDetails=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLayerable} * > {\b layerableListAt} (const QPointF &pos, bool onlySelectable, QList< QVariant > *selectionDetails=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawBackground} ({\b QCPPainter} *painter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupPaintBuffers} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPaintBuffer} * {\b createPaintBuffer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasInvalidatedPaintBuffers} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setupOpenGl} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b freeOpenGl} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mViewport}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mBufferDevicePixelRatio}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutGrid} * {\b mPlotLayout}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAutoAddPlottableToLegend}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractPlottable} * > {\b mPlottables}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPGraph} * > {\b mGraphs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractItem} * > {\b mItems}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPLayer} * > {\b mLayers}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mAntialiasedElements}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mNotAntialiasedElements}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::Interactions {\b mInteractions}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mSelectionTolerance}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mNoAntialiasingOnDrag}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBackgroundBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mBackgroundPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mScaledBackgroundPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mBackgroundScaled}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b mBackgroundScaledMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b mCurrentLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::PlottingHints {\b mPlottingHints}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::KeyboardModifier {\b mMultiSelectModifier}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionRectMode} {\b mSelectionRectMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionRect} * {\b mSelectionRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mOpenGl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QSharedPointer< {\b QCPAbstractPaintBuffer} > > {\b mPaintBuffers}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b mMousePressPos}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mMouseHasMoved}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPLayerable} > {\b mMouseEventLayerable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPLayerable} > {\b mMouseSignalLayerable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b mMouseEventLayerableDetails}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b mMouseSignalLayerableDetails}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mReplotting}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mReplotQueued}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mOpenGlMultisamples}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mOpenGlAntialiasedElementsBackup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mOpenGlCacheLabelsBackup}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractPlottable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPGraph}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractItem}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The central class of the library. This is the QWidget which displays the plot and interacts with the user. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For tutorials on how to use {\b QCustomPlot}, see the website\par
{\f2 http://www.qcustomplot.com/} \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v LayerInsertMode\:QCustomPlot}
{\xe \v QCustomPlot\:LayerInsertMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCustomPlot::LayerInsertMode}}}
\par
{\bkmkstart AAAAAAADQM}
{\bkmkend AAAAAAADQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines how a layer should be inserted relative to an other layer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v limBelow\:QCustomPlot}
{\xe \v QCustomPlot\:limBelow}
{\qr limBelow{\bkmkstart AAAAAAADQN}
{\bkmkend AAAAAAADQN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layer is inserted below other layer. \par
}\cell }{\row }
{\xe \v limAbove\:QCustomPlot}
{\xe \v QCustomPlot\:limAbove}
{\qr limAbove{\bkmkstart AAAAAAADQO}
{\bkmkend AAAAAAADQO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layer is inserted above other layer. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3603                        \{ limBelow  \par
 3604                          ,limAbove \par
 3605                        \};\par
}
}
{\xe \v RefreshPriority\:QCustomPlot}
{\xe \v QCustomPlot\:RefreshPriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCustomPlot::RefreshPriority}}}
\par
{\bkmkstart AAAAAAADQP}
{\bkmkend AAAAAAADQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines with what timing the {\b QCustomPlot} surface is refreshed after a replot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b replot} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v rpImmediateRefresh\:QCustomPlot}
{\xe \v QCustomPlot\:rpImmediateRefresh}
{\qr rpImmediateRefresh{\bkmkstart AAAAAAADQQ}
{\bkmkend AAAAAAADQQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replots immediately and repaints the widget immediately by calling QWidget::repaint() after the replot. \par
}\cell }{\row }
{\xe \v rpQueuedRefresh\:QCustomPlot}
{\xe \v QCustomPlot\:rpQueuedRefresh}
{\qr rpQueuedRefresh{\bkmkstart AAAAAAADQR}
{\bkmkend AAAAAAADQR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replots immediately, but queues the widget repaint, by calling QWidget::update() after the replot. This way multiple redundant widget repaints can be avoided. \par
}\cell }{\row }
{\xe \v rpRefreshHint\:QCustomPlot}
{\xe \v QCustomPlot\:rpRefreshHint}
{\qr rpRefreshHint{\bkmkstart AAAAAAADQS}
{\bkmkend AAAAAAADQS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether to use immediate or queued refresh depends on whether the plotting hint {\b QCP::phImmediateRefresh} is set, see {\b setPlottingHints}. \par
}\cell }{\row }
{\xe \v rpQueuedReplot\:QCustomPlot}
{\xe \v QCustomPlot\:rpQueuedReplot}
{\qr rpQueuedReplot{\bkmkstart AAAAAAADQT}
{\bkmkend AAAAAAADQT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queues the entire replot for the next event loop iteration. This way multiple redundant replots can be avoided. The actual replot is then done with {\b rpRefreshHint} priority. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3613                        \{ rpImmediateRefresh \par
 3614                          ,rpQueuedRefresh   \par
 3615                          ,rpRefreshHint     \par
 3616                          ,rpQueuedReplot    \par
 3617                        \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v QCustomPlot\:QCustomPlot}
{\xe \v QCustomPlot\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCustomPlot::QCustomPlot (QWidget *  {\i parent} = {\f2 0}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAADQU}
{\bkmkend AAAAAAADQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b QCustomPlot} and sets reasonable default values. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12848                                         :\par
12849   QWidget(parent),\par
12850   xAxis(0),\par
12851   yAxis(0),\par
12852   xAxis2(0),\par
12853   yAxis2(0),\par
12854   legend(0),\par
12855   mBufferDevicePixelRatio(1.0), // will be adapted to primary screen below\par
12856   mPlotLayout(0),\par
12857   mAutoAddPlottableToLegend(true),\par
12858   mAntialiasedElements(QCP::aeNone),\par
12859   mNotAntialiasedElements(QCP::aeNone),\par
12860   mInteractions(0),\par
12861   mSelectionTolerance(8),\par
12862   mNoAntialiasingOnDrag(false),\par
12863   mBackgroundBrush(Qt::white, Qt::SolidPattern),\par
12864   mBackgroundScaled(true),\par
12865   mBackgroundScaledMode(Qt::KeepAspectRatioByExpanding),\par
12866   mCurrentLayer(0),\par
12867   mPlottingHints(QCP::phCacheLabels|QCP::phImmediateRefresh),\par
12868   mMultiSelectModifier(Qt::ControlModifier),\par
12869   mSelectionRectMode(QCP::srmNone),\par
12870   mSelectionRect(0),\par
12871   mOpenGl(false),\par
12872   mMouseHasMoved(false),\par
12873   mMouseEventLayerable(0),\par
12874   mMouseSignalLayerable(0),\par
12875   mReplotting(false),\par
12876   mReplotQueued(false),\par
12877   mOpenGlMultisamples(16),\par
12878   mOpenGlAntialiasedElementsBackup(QCP::aeNone),\par
12879   mOpenGlCacheLabelsBackup(true)\par
12880 \{\par
12881   setAttribute(Qt::WA_NoMousePropagation);\par
12882   setAttribute(Qt::WA_OpaquePaintEvent);\par
12883   setFocusPolicy(Qt::ClickFocus);\par
12884   setMouseTracking(true);\par
12885   QLocale currentLocale = locale();\par
12886   currentLocale.setNumberOptions(QLocale::OmitGroupSeparator);\par
12887   setLocale(currentLocale);\par
12888 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
12889 #  ifdef QCP_DEVICEPIXELRATIO_FLOAT\par
12890   setBufferDevicePixelRatio(QWidget::devicePixelRatioF());\par
12891 #  else\par
12892   setBufferDevicePixelRatio(QWidget::devicePixelRatio());\par
12893 #  endif\par
12894 #endif\par
12895   \par
12896   mOpenGlAntialiasedElementsBackup = mAntialiasedElements;\par
12897   mOpenGlCacheLabelsBackup = mPlottingHints.testFlag(QCP::phCacheLabels);\par
12898   // create initial layers:\par
12899   mLayers.append(new QCPLayer(this, QLatin1String("background")));\par
12900   mLayers.append(new QCPLayer(this, QLatin1String("grid")));\par
12901   mLayers.append(new QCPLayer(this, QLatin1String("main")));\par
12902   mLayers.append(new QCPLayer(this, QLatin1String("axes")));\par
12903   mLayers.append(new QCPLayer(this, QLatin1String("legend")));\par
12904   mLayers.append(new QCPLayer(this, QLatin1String("overlay")));\par
12905   updateLayerIndices();\par
12906   setCurrentLayer(QLatin1String("main"));\par
12907   layer(QLatin1String("overlay"))->setMode(QCPLayer::lmBuffered);\par
12908   \par
12909   // create initial layout, axis rect and legend:\par
12910   mPlotLayout = new QCPLayoutGrid;\par
12911   mPlotLayout->initializeParentPlot(this);\par
12912   mPlotLayout->setParent(this); // important because if parent is QWidget, QCPLayout::sizeConstraintsChanged will call QWidget::updateGeometry\par
12913   mPlotLayout->setLayer(QLatin1String("main"));\par
12914   QCPAxisRect *defaultAxisRect = new QCPAxisRect(this, true);\par
12915   mPlotLayout->addElement(0, 0, defaultAxisRect);\par
12916   xAxis = defaultAxisRect->axis(QCPAxis::atBottom);\par
12917   yAxis = defaultAxisRect->axis(QCPAxis::atLeft);\par
12918   xAxis2 = defaultAxisRect->axis(QCPAxis::atTop);\par
12919   yAxis2 = defaultAxisRect->axis(QCPAxis::atRight);\par
12920   legend = new QCPLegend;\par
12921   legend->setVisible(false);\par
12922   defaultAxisRect->insetLayout()->addElement(legend, Qt::AlignRight|Qt::AlignTop);\par
12923   defaultAxisRect->insetLayout()->setMargins(QMargins(12, 12, 12, 12));\par
12924   \par
12925   defaultAxisRect->setLayer(QLatin1String("background"));\par
12926   xAxis->setLayer(QLatin1String("axes"));\par
12927   yAxis->setLayer(QLatin1String("axes"));\par
12928   xAxis2->setLayer(QLatin1String("axes"));\par
12929   yAxis2->setLayer(QLatin1String("axes"));\par
12930   xAxis->grid()->setLayer(QLatin1String("grid"));\par
12931   yAxis->grid()->setLayer(QLatin1String("grid"));\par
12932   xAxis2->grid()->setLayer(QLatin1String("grid"));\par
12933   yAxis2->grid()->setLayer(QLatin1String("grid"));\par
12934   legend->setLayer(QLatin1String("legend"));\par
12935   \par
12936   // create selection rect instance:\par
12937   mSelectionRect = new QCPSelectionRect(this);\par
12938   mSelectionRect->setLayer(QLatin1String("overlay"));\par
12939   \par
12940   setViewport(rect()); // needs to be called after mPlotLayout has been created\par
12941   \par
12942   replot(rpQueuedReplot);\par
12943 \}\par
}
}
{\xe \v ~QCustomPlot\:QCustomPlot}
{\xe \v QCustomPlot\:~QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCustomPlot::~QCustomPlot (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADQV}
{\bkmkend AAAAAAADQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12946 \{\par
12947   clearPlottables();\par
12948   clearItems();\par
12949 \par
12950   if (mPlotLayout)\par
12951   \{\par
12952     delete mPlotLayout;\par
12953     mPlotLayout = 0;\par
12954   \}\par
12955   \par
12956   mCurrentLayer = 0;\par
12957   qDeleteAll(mLayers); // don't use removeLayer, because it would prevent the last layer to be removed\par
12958   mLayers.clear();\par
12959 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addGraph\:QCustomPlot}
{\xe \v QCustomPlot\:addGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph} * QCustomPlot::addGraph ({\b QCPAxis} *  {\i keyAxis} = {\f2 0}, {\b QCPAxis} *  {\i valueAxis} = {\f2 0})}}
\par
{\bkmkstart AAAAAAADQW}
{\bkmkend AAAAAAADQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new graph inside the plot. If {\i keyAxis}  and {\i valueAxis}  are left unspecified (0), the bottom (xAxis) is used as key and the left (yAxis) is used as value axis. If specified, {\i keyAxis}  and {\i valueAxis}  must reside in this {\b QCustomPlot}.\par
{\i keyAxis}  will be used as key axis (typically "x") and {\i valueAxis}  as value axis (typically "y") for the graph.\par
Returns a pointer to the newly created graph, or 0 if adding the graph failed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graph}, {\b graphCount}, {\b removeGraph}, {\b clearGraphs} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13699 \{\par
13700   if (!keyAxis) keyAxis = xAxis;\par
13701   if (!valueAxis) valueAxis = yAxis;\par
13702   if (!keyAxis || !valueAxis)\par
13703   \{\par
13704     qDebug() << Q_FUNC_INFO << "can't use default QCustomPlot xAxis or yAxis, because at least one is invalid (has been deleted)";\par
13705     return 0;\par
13706   \}\par
13707   if (keyAxis->parentPlot() != this || valueAxis->parentPlot() != this)\par
13708   \{\par
13709     qDebug() << Q_FUNC_INFO << "passed keyAxis or valueAxis doesn't have this QCustomPlot as parent";\par
13710     return 0;\par
13711   \}\par
13712   \par
13713   QCPGraph *newGraph = new QCPGraph(keyAxis, valueAxis);\par
13714   newGraph->setName(QLatin1String("Graph ")+QString::number(mGraphs.size()));\par
13715   return newGraph;\par
13716 \}\par
}
}
{\xe \v addLayer\:QCustomPlot}
{\xe \v QCustomPlot\:addLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::addLayer (const QString &  {\i name}, {\b QCPLayer} *  {\i otherLayer} = {\f2 0}, {\b QCustomPlot::LayerInsertMode}  {\i insertMode} = {\f2 {\b limAbove}})}}
\par
{\bkmkstart AAAAAAADQX}
{\bkmkend AAAAAAADQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new layer to this {\b QCustomPlot} instance. The new layer will have the name {\i name} , which must be unique. Depending on {\i insertMode} , it is positioned either below or above {\i otherLayer} .\par
Returns true on success, i.e. if there is no other layer named {\i name}  and {\i otherLayer}  is a valid layer inside this {\b QCustomPlot}.\par
If {\i otherLayer}  is 0, the highest layer in the {\b QCustomPlot} will be used.\par
For an explanation of what layers are in {\b QCustomPlot}, see the documentation of {\b QCPLayer}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layer}, {\b moveLayer}, {\b removeLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14059 \{\par
14060   if (!otherLayer)\par
14061     otherLayer = mLayers.last();\par
14062   if (!mLayers.contains(otherLayer))\par
14063   \{\par
14064     qDebug() << Q_FUNC_INFO << "otherLayer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(otherLayer);\par
14065     return false;\par
14066   \}\par
14067   if (layer(name))\par
14068   \{\par
14069     qDebug() << Q_FUNC_INFO << "A layer exists already with the name" << name;\par
14070     return false;\par
14071   \}\par
14072     \par
14073   QCPLayer *newLayer = new QCPLayer(this, name);\par
14074   mLayers.insert(otherLayer->index() + (insertMode==limAbove ? 1:0), newLayer);\par
14075   updateLayerIndices();\par
14076   setupPaintBuffers(); // associates new layer with the appropriate paint buffer\par
14077   return true;\par
14078 \}\par
}
}
{\xe \v afterReplot\:QCustomPlot}
{\xe \v QCustomPlot\:afterReplot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::afterReplot (){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADQY}
{\bkmkend AAAAAAADQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted immediately after a replot has taken place (caused by a call to the slot {\b replot}).\par
It is safe to mutually connect the replot slot with this signal on two QCustomPlots to make them replot synchronously, it won't cause an infinite recursion.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b replot}, {\b beforeReplot} \par
}}}
{\xe \v antialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:antialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::antialiasedElements () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADQZ}
{\bkmkend AAAAAAADQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3630 \{ return mAntialiasedElements; \}\par
}
}
{\xe \v autoAddPlottableToLegend\:QCustomPlot}
{\xe \v QCustomPlot\:autoAddPlottableToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::autoAddPlottableToLegend () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADRA}
{\bkmkend AAAAAAADRA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3632 \{ return mAutoAddPlottableToLegend; \}\par
}
}
{\xe \v axisClick\:QCustomPlot}
{\xe \v QCustomPlot\:axisClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::axisClick ({\b QCPAxis} *  {\i axis}, {\b QCPAxis::SelectablePart}  {\i part}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADRB}
{\bkmkend AAAAAAADRB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when an axis is clicked.\par
{\i event}  is the mouse event that caused the click, {\i axis}  is the axis that received the click and {\i part}  indicates the part of the axis that was clicked.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisDoubleClick} \par
}}}
{\xe \v axisDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:axisDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::axisDoubleClick ({\b QCPAxis} *  {\i axis}, {\b QCPAxis::SelectablePart}  {\i part}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADRC}
{\bkmkend AAAAAAADRC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when an axis is double clicked.\par
{\i event}  is the mouse event that caused the click, {\i axis}  is the axis that received the click and {\i part}  indicates the part of the axis that was clicked.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisClick} \par
}}}
{\xe \v axisRect\:QCustomPlot}
{\xe \v QCustomPlot\:axisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect} * QCustomPlot::axisRect (int  {\i index} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAADRD}
{\bkmkend AAAAAAADRD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the axis rect with {\i index} .\par
Initially, only one axis rect (with index 0) exists in the plot. If multiple axis rects were added, all of them may be accessed with this function in a linear fashion (even when they are nested in a layout hierarchy or inside other axis rects via {\b QCPAxisRect::insetLayout}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisRectCount}, {\b axisRects} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14195 \{\par
14196   const QList<QCPAxisRect*> rectList = axisRects();\par
14197   if (index >= 0 && index < rectList.size())\par
14198   \{\par
14199     return rectList.at(index);\par
14200   \} else\par
14201   \{\par
14202     qDebug() << Q_FUNC_INFO << "invalid axis rect index" << index;\par
14203     return 0;\par
14204   \}\par
14205 \}\par
}
}
{\xe \v axisRectAt\:QCustomPlot}
{\xe \v QCustomPlot\:axisRectAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect} * QCustomPlot::axisRectAt (const QPointF &  {\i pos}) const}}
\par
{\bkmkstart AAAAAAADRE}
{\bkmkend AAAAAAADRE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the layout element of type {\b QCPAxisRect} at pixel position {\i pos} . This method ignores other layout elements even if they are visually in front of the axis rect (e.g. a {\b QCPLegend}). If there is no axis rect at that position, returns 0.\par
Only visible axis rects are used. If {\b QCPLayoutElement::setVisible} on the axis rect itself or on any of its parent elements is set to false, it will not be considered.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layoutElementAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14275 \{\par
14276   QCPAxisRect *result = 0;\par
14277   QCPLayoutElement *currentElement = mPlotLayout;\par
14278   bool searchSubElements = true;\par
14279   while (searchSubElements && currentElement)\par
14280   \{\par
14281     searchSubElements = false;\par
14282     foreach (QCPLayoutElement *subElement, currentElement->elements(false))\par
14283     \{\par
14284       if (subElement && subElement->realVisibility() && subElement->selectTest(pos, false) >= 0)\par
14285       \{\par
14286         currentElement = subElement;\par
14287         searchSubElements = true;\par
14288         if (QCPAxisRect *ar = qobject_cast<QCPAxisRect*>(currentElement))\par
14289           result = ar;\par
14290         break;\par
14291       \}\par
14292     \}\par
14293   \}\par
14294   return result;\par
14295 \}\par
}
}
{\xe \v axisRectCount\:QCustomPlot}
{\xe \v QCustomPlot\:axisRectCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::axisRectCount () const}}
\par
{\bkmkstart AAAAAAADRF}
{\bkmkend AAAAAAADRF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of axis rects in the plot.\par
All axis rects can be accessed via {\b QCustomPlot::axisRect()}.\par
Initially, only one axis rect exists in the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisRect}, {\b axisRects} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14181 \{\par
14182   return axisRects().size();\par
14183 \}\par
}
}
{\xe \v axisRects\:QCustomPlot}
{\xe \v QCustomPlot\:axisRects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxisRect} * > QCustomPlot::axisRects () const}}
\par
{\bkmkstart AAAAAAADRG}
{\bkmkend AAAAAAADRG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all axis rects in the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisRectCount}, {\b axisRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14213 \{\par
14214   QList<QCPAxisRect*> result;\par
14215   QStack<QCPLayoutElement*> elementStack;\par
14216   if (mPlotLayout)\par
14217     elementStack.push(mPlotLayout);\par
14218   \par
14219   while (!elementStack.isEmpty())\par
14220   \{\par
14221     foreach (QCPLayoutElement *element, elementStack.pop()->elements(false))\par
14222     \{\par
14223       if (element)\par
14224       \{\par
14225         elementStack.push(element);\par
14226         if (QCPAxisRect *ar = qobject_cast<QCPAxisRect*>(element))\par
14227           result.append(ar);\par
14228       \}\par
14229     \}\par
14230   \}\par
14231   \par
14232   return result;\par
14233 \}\par
}
}
{\xe \v axisRemoved\:QCustomPlot}
{\xe \v QCustomPlot\:axisRemoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::axisRemoved ({\b QCPAxis} *  {\i axis}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADRH}
{\bkmkend AAAAAAADRH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15231 \{\par
15232   if (xAxis == axis)\par
15233     xAxis = 0;\par
15234   if (xAxis2 == axis)\par
15235     xAxis2 = 0;\par
15236   if (yAxis == axis)\par
15237     yAxis = 0;\par
15238   if (yAxis2 == axis)\par
15239     yAxis2 = 0;\par
15240   \par
15241   // Note: No need to take care of range drag axes and range zoom axes, because they are stored in smart pointers\par
15242 \}\par
}
}
{\xe \v background\:QCustomPlot}
{\xe \v QCustomPlot\:background}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCustomPlot::background () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADRI}
{\bkmkend AAAAAAADRI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3626 \{ return mBackgroundPixmap; \}\par
}
}
{\xe \v backgroundScaled\:QCustomPlot}
{\xe \v QCustomPlot\:backgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::backgroundScaled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADRJ}
{\bkmkend AAAAAAADRJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3627 \{ return mBackgroundScaled; \}\par
}
}
{\xe \v backgroundScaledMode\:QCustomPlot}
{\xe \v QCustomPlot\:backgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCustomPlot::backgroundScaledMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADRK}
{\bkmkend AAAAAAADRK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3628 \{ return mBackgroundScaledMode; \}\par
}
}
{\xe \v beforeReplot\:QCustomPlot}
{\xe \v QCustomPlot\:beforeReplot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::beforeReplot (){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADRL}
{\bkmkend AAAAAAADRL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted immediately before a replot takes place (caused by a call to the slot {\b replot}).\par
It is safe to mutually connect the replot slot with this signal on two QCustomPlots to make them replot synchronously, it won't cause an infinite recursion.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b replot}, {\b afterReplot} \par
}}}
{\xe \v bufferDevicePixelRatio\:QCustomPlot}
{\xe \v QCustomPlot\:bufferDevicePixelRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCustomPlot::bufferDevicePixelRatio () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADRM}
{\bkmkend AAAAAAADRM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3625 \{ return mBufferDevicePixelRatio; \}\par
}
}
{\xe \v clearGraphs\:QCustomPlot}
{\xe \v QCustomPlot\:clearGraphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::clearGraphs ()}}
\par
{\bkmkstart AAAAAAADRN}
{\bkmkend AAAAAAADRN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all graphs from the plot and deletes them. Corresponding legend items are also removed from the default legend ({\b QCustomPlot::legend}).\par
Returns the number of graphs removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeGraph} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13754 \{\par
13755   int c = mGraphs.size();\par
13756   for (int i=c-1; i >= 0; --i)\par
13757     removeGraph(mGraphs[i]);\par
13758   return c;\par
13759 \}\par
}
}
{\xe \v clearItems\:QCustomPlot}
{\xe \v QCustomPlot\:clearItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::clearItems ()}}
\par
{\bkmkstart AAAAAAADRO}
{\bkmkend AAAAAAADRO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all items from the plot and deletes them.\par
Returns the number of items removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13870 \{\par
13871   int c = mItems.size();\par
13872   for (int i=c-1; i >= 0; --i)\par
13873     removeItem(mItems[i]);\par
13874   return c;\par
13875 \}\par
}
}
{\xe \v clearPlottables\:QCustomPlot}
{\xe \v QCustomPlot\:clearPlottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::clearPlottables ()}}
\par
{\bkmkstart AAAAAAADRP}
{\bkmkend AAAAAAADRP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all plottables from the plot and deletes them. Corresponding legend items are also removed from the default legend ({\b QCustomPlot::legend}).\par
Returns the number of plottables removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removePlottable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13572 \{\par
13573   int c = mPlottables.size();\par
13574   for (int i=c-1; i >= 0; --i)\par
13575     removePlottable(mPlottables[i]);\par
13576   return c;\par
13577 \}\par
}
}
{\xe \v createPaintBuffer\:QCustomPlot}
{\xe \v QCustomPlot\:createPaintBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPaintBuffer} * QCustomPlot::createPaintBuffer (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADRQ}
{\bkmkend AAAAAAADRQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15109 \{\par
15110   if (mOpenGl)\par
15111   \{\par
15112 #if defined(QCP_OPENGL_FBO)\par
15113     return new QCPPaintBufferGlFbo(viewport().size(), mBufferDevicePixelRatio, mGlContext, mGlPaintDevice);\par
15114 #elif defined(QCP_OPENGL_PBUFFER)\par
15115     return new QCPPaintBufferGlPbuffer(viewport().size(), mBufferDevicePixelRatio, mOpenGlMultisamples);\par
15116 #else\par
15117     qDebug() << Q_FUNC_INFO << "OpenGL enabled even though no support for it compiled in, this shouldn't have happened. Falling back to pixmap paint buffer.";\par
15118     return new QCPPaintBufferPixmap(viewport().size(), mBufferDevicePixelRatio);\par
15119 #endif\par
15120   \} else\par
15121     return new QCPPaintBufferPixmap(viewport().size(), mBufferDevicePixelRatio);\par
15122 \}\par
}
}
{\xe \v currentLayer\:QCustomPlot}
{\xe \v QCustomPlot\:currentLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer} * QCustomPlot::currentLayer () const}}
\par
{\bkmkstart AAAAAAADRR}
{\bkmkend AAAAAAADRR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the layer that is set as current layer (see {\b setCurrentLayer}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13989 \{\par
13990   return mCurrentLayer;\par
13991 \}\par
}
}
{\xe \v deselectAll\:QCustomPlot}
{\xe \v QCustomPlot\:deselectAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::deselectAll ()}}
\par
{\bkmkstart AAAAAAADRS}
{\bkmkend AAAAAAADRS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deselects all layerables (plottables, items, axes, legends,...) of the {\b QCustomPlot}.\par
Since calling this function is not a user interaction, this does not emit the {\b selectionChangedByUser} signal. The individual selectionChanged signals are emitted though, if the objects were previously selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b selectedPlottables}, {\b selectedItems}, {\b selectedAxes}, {\b selectedLegends} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14363 \{\par
14364   foreach (QCPLayer *layer, mLayers)\par
14365   \{\par
14366     foreach (QCPLayerable *layerable, layer->children())\par
14367       layerable->deselectEvent(0);\par
14368   \}\par
14369 \}\par
}
}
{\xe \v draw\:QCustomPlot}
{\xe \v QCustomPlot\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADRT}
{\bkmkend AAAAAAADRT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14966 \{\par
14967   updateLayout();\par
14968   \par
14969   // draw viewport background pixmap:\par
14970   drawBackground(painter);\par
14971 \par
14972   // draw all layered objects (grid, axes, plottables, items, legend,...):\par
14973   foreach (QCPLayer *layer, mLayers)\par
14974     layer->draw(painter);\par
14975   \par
14976   /* Debug code to draw all layout element rects\par
14977   foreach (QCPLayoutElement* el, findChildren<QCPLayoutElement*>())\par
14978   \{\par
14979     painter->setBrush(Qt::NoBrush);\par
14980     painter->setPen(QPen(QColor(0, 0, 0, 100), 0, Qt::DashLine));\par
14981     painter->drawRect(el->rect());\par
14982     painter->setPen(QPen(QColor(255, 0, 0, 100), 0, Qt::DashLine));\par
14983     painter->drawRect(el->outerRect());\par
14984   \}\par
14985   */\par
14986 \}\par
}
}
{\xe \v drawBackground\:QCustomPlot}
{\xe \v QCustomPlot\:drawBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::drawBackground ({\b QCPPainter} *  {\i painter}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADRU}
{\bkmkend AAAAAAADRU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15022 \{\par
15023   // Note: background color is handled in individual replot/save functions\par
15024 \par
15025   // draw background pixmap (on top of fill, if brush specified):\par
15026   if (!mBackgroundPixmap.isNull())\par
15027   \{\par
15028     if (mBackgroundScaled)\par
15029     \{\par
15030       // check whether mScaledBackground needs to be updated:\par
15031       QSize scaledSize(mBackgroundPixmap.size());\par
15032       scaledSize.scale(mViewport.size(), mBackgroundScaledMode);\par
15033       if (mScaledBackgroundPixmap.size() != scaledSize)\par
15034         mScaledBackgroundPixmap = mBackgroundPixmap.scaled(mViewport.size(), mBackgroundScaledMode, Qt::SmoothTransformation);\par
15035       painter->drawPixmap(mViewport.topLeft(), mScaledBackgroundPixmap, QRect(0, 0, mViewport.width(), mViewport.height()) & mScaledBackgroundPixmap.rect());\par
15036     \} else\par
15037     \{\par
15038       painter->drawPixmap(mViewport.topLeft(), mBackgroundPixmap, QRect(0, 0, mViewport.width(), mViewport.height()));\par
15039     \}\par
15040   \}\par
15041 \}\par
}
}
{\xe \v freeOpenGl\:QCustomPlot}
{\xe \v QCustomPlot\:freeOpenGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::freeOpenGl (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADRV}
{\bkmkend AAAAAAADRV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15217 \{\par
15218 #ifdef QCP_OPENGL_FBO\par
15219   mGlPaintDevice.clear();\par
15220   mGlContext.clear();\par
15221   mGlSurface.clear();\par
15222 #endif\par
15223 \}\par
}
}
{\xe \v graph\:QCustomPlot}
{\xe \v QCustomPlot\:graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph} * QCustomPlot::graph (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAADRW}
{\bkmkend AAAAAAADRW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the graph with {\i index} . If the index is invalid, returns 0.\par
There is an overloaded version of this function with no parameter which returns the last created graph, see {\b QCustomPlot::graph()}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graphCount}, {\b addGraph} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13659 \{\par
13660   if (index >= 0 && index < mGraphs.size())\par
13661   \{\par
13662     return mGraphs.at(index);\par
13663   \} else\par
13664   \{\par
13665     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13666     return 0;\par
13667   \}\par
13668 \}\par
}
}
{\xe \v graph\:QCustomPlot}
{\xe \v QCustomPlot\:graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph} * QCustomPlot::graph () const}}
\par
{\bkmkstart AAAAAAADRX}
{\bkmkend AAAAAAADRX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns the last graph, that was created with {\b addGraph}. If there are no graphs in the plot, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graphCount}, {\b addGraph} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13678 \{\par
13679   if (!mGraphs.isEmpty())\par
13680   \{\par
13681     return mGraphs.last();\par
13682   \} else\par
13683     return 0;\par
13684 \}\par
}
}
{\xe \v graphCount\:QCustomPlot}
{\xe \v QCustomPlot\:graphCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::graphCount () const}}
\par
{\bkmkstart AAAAAAADRY}
{\bkmkend AAAAAAADRY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of currently existing graphs in the plot\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graph}, {\b addGraph} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13767 \{\par
13768   return mGraphs.size();\par
13769 \}\par
}
}
{\xe \v hasInvalidatedPaintBuffers\:QCustomPlot}
{\xe \v QCustomPlot\:hasInvalidatedPaintBuffers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::hasInvalidatedPaintBuffers (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADRZ}
{\bkmkend AAAAAAADRZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method returns whether any of the paint buffers held by this {\b QCustomPlot} instance are invalidated.\par
If any buffer is invalidated, a partial replot ({\b QCPLayer::replot}) is not allowed and always causes a full replot ({\b QCustomPlot::replot}) of all layers. This is the case when for example the layer order has changed, new layers were added, layers were removed, or layer modes were changed ({\b QCPLayer::setMode}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractPaintBuffer::setInvalidated} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15136 \{\par
15137   for (int i=0; i<mPaintBuffers.size(); ++i)\par
15138   \{\par
15139     if (mPaintBuffers.at(i)->invalidated())\par
15140       return true;\par
15141   \}\par
15142   return false;\par
15143 \}\par
}
}
{\xe \v hasItem\:QCustomPlot}
{\xe \v QCustomPlot\:hasItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::hasItem ({\b QCPAbstractItem} *  {\i item}) const}}
\par
{\bkmkstart AAAAAAADSA}
{\bkmkend AAAAAAADSA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this {\b QCustomPlot} contains the {\i item} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b item} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13945 \{\par
13946   return mItems.contains(item);\par
13947 \}\par
}
}
{\xe \v hasPlottable\:QCustomPlot}
{\xe \v QCustomPlot\:hasPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::hasPlottable ({\b QCPAbstractPlottable} *  {\i plottable}) const}}
\par
{\bkmkstart AAAAAAADSB}
{\bkmkend AAAAAAADSB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this {\b QCustomPlot} instance contains the {\i plottable} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13646 \{\par
13647   return mPlottables.contains(plottable);\par
13648 \}\par
}
}
{\xe \v interactions\:QCustomPlot}
{\xe \v QCustomPlot\:interactions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QCP::Interactions QCustomPlot::interactions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADSC}
{\bkmkend AAAAAAADSC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3633 \{ return mInteractions; \}\par
}
}
{\xe \v item\:QCustomPlot}
{\xe \v QCustomPlot\:item}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractItem} * QCustomPlot::item (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAADSD}
{\bkmkend AAAAAAADSD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the item with {\i index} . If the index is invalid, returns 0.\par
There is an overloaded version of this function with no parameter which returns the last added item, see {\b QCustomPlot::item()}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13799 \{\par
13800   if (index >= 0 && index < mItems.size())\par
13801   \{\par
13802     return mItems.at(index);\par
13803   \} else\par
13804   \{\par
13805     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13806     return 0;\par
13807   \}\par
13808 \}\par
}
}
{\xe \v item\:QCustomPlot}
{\xe \v QCustomPlot\:item}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractItem} * QCustomPlot::item () const}}
\par
{\bkmkstart AAAAAAADSE}
{\bkmkend AAAAAAADSE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns the last item that was added to this plot. If there are no items in the plot, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13818 \{\par
13819   if (!mItems.isEmpty())\par
13820   \{\par
13821     return mItems.last();\par
13822   \} else\par
13823     return 0;\par
13824 \}\par
}
}
{\xe \v itemAt\:QCustomPlot}
{\xe \v QCustomPlot\:itemAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractItem} * QCustomPlot::itemAt (const QPointF &  {\i pos}, bool  {\i onlySelectable} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAADSF}
{\bkmkend AAAAAAADSF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the item at the pixel position {\i pos} . Items that only consist of single lines (e.g. {\b QCPItemLine} or {\b QCPItemCurve}) have a tolerance band around them, see {\b setSelectionTolerance}. If multiple items come into consideration, the one closest to {\i pos}  is returned.\par
If {\i onlySelectable}  is true, only items that are selectable ({\b QCPAbstractItem::setSelectable}) are considered.\par
If there is no item at {\i pos} , the return value is 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableAt}, {\b layoutElementAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13917 \{\par
13918   QCPAbstractItem *resultItem = 0;\par
13919   double resultDistance = mSelectionTolerance; // only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value\par
13920   \par
13921   foreach (QCPAbstractItem *item, mItems)\par
13922   \{\par
13923     if (onlySelectable && !item->selectable()) // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPAbstractItem::selectable\par
13924       continue;\par
13925     if (!item->clipToAxisRect() || item->clipRect().contains(pos.toPoint())) // only consider clicks inside axis cliprect of the item if actually clipped to it\par
13926     \{\par
13927       double currentDistance = item->selectTest(pos, false);\par
13928       if (currentDistance >= 0 && currentDistance < resultDistance)\par
13929       \{\par
13930         resultItem = item;\par
13931         resultDistance = currentDistance;\par
13932       \}\par
13933     \}\par
13934   \}\par
13935   \par
13936   return resultItem;\par
13937 \}\par
}
}
{\xe \v itemClick\:QCustomPlot}
{\xe \v QCustomPlot\:itemClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::itemClick ({\b QCPAbstractItem} *  {\i item}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADSG}
{\bkmkend AAAAAAADSG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when an item is clicked.\par
{\i event}  is the mouse event that caused the click and {\i item}  is the item that received the click.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemDoubleClick} \par
}}}
{\xe \v itemCount\:QCustomPlot}
{\xe \v QCustomPlot\:itemCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::itemCount () const}}
\par
{\bkmkstart AAAAAAADSH}
{\bkmkend AAAAAAADSH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of currently existing items in the plot\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b item} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13883 \{\par
13884   return mItems.size();\par
13885 \}\par
}
}
{\xe \v itemDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:itemDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::itemDoubleClick ({\b QCPAbstractItem} *  {\i item}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADSI}
{\bkmkend AAAAAAADSI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when an item is double clicked.\par
{\i event}  is the mouse event that caused the click and {\i item}  is the item that received the click.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemClick} \par
}}}
{\xe \v layer\:QCustomPlot}
{\xe \v QCustomPlot\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer} * QCustomPlot::layer (const QString &  {\i name}) const}}
\par
{\bkmkstart AAAAAAADSJ}
{\bkmkend AAAAAAADSJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the layer with the specified {\i name} . If there is no layer with the specified name, 0 is returned.\par
Layer names are case-sensitive.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer}, {\b removeLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13958 \{\par
13959   foreach (QCPLayer *layer, mLayers)\par
13960   \{\par
13961     if (layer->name() == name)\par
13962       return layer;\par
13963   \}\par
13964   return 0;\par
13965 \}\par
}
}
{\xe \v layer\:QCustomPlot}
{\xe \v QCustomPlot\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer} * QCustomPlot::layer (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAADSK}
{\bkmkend AAAAAAADSK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns the layer by {\i index} . If the index is invalid, 0 is returned.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer}, {\b removeLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13974 \{\par
13975   if (index >= 0 && index < mLayers.size())\par
13976   \{\par
13977     return mLayers.at(index);\par
13978   \} else\par
13979   \{\par
13980     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13981     return 0;\par
13982   \}\par
13983 \}\par
}
}
{\xe \v layerableAt\:QCustomPlot}
{\xe \v QCustomPlot\:layerableAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayerable} * QCustomPlot::layerableAt (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i selectionDetails} = {\f2 0}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADSL}
{\bkmkend AAAAAAADSL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15538 \{\par
15539   QList<QVariant> details;\par
15540   QList<QCPLayerable*> candidates = layerableListAt(pos, onlySelectable, selectionDetails ? &details : 0);\par
15541   if (selectionDetails && !details.isEmpty())\par
15542     *selectionDetails = details.first();\par
15543   if (!candidates.isEmpty())\par
15544     return candidates.first();\par
15545   else\par
15546     return 0;\par
15547 \}\par
}
}
{\xe \v layerableListAt\:QCustomPlot}
{\xe \v QCustomPlot\:layerableListAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLayerable} * > QCustomPlot::layerableListAt (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QList< QVariant > *  {\i selectionDetails} = {\f2 0}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADSM}
{\bkmkend AAAAAAADSM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15568 \{\par
15569   QList<QCPLayerable*> result;\par
15570   for (int layerIndex=mLayers.size()-1; layerIndex>=0; --layerIndex)\par
15571   \{\par
15572     const QList<QCPLayerable*> layerables = mLayers.at(layerIndex)->children();\par
15573     for (int i=layerables.size()-1; i>=0; --i)\par
15574     \{\par
15575       if (!layerables.at(i)->realVisibility())\par
15576         continue;\par
15577       QVariant details;\par
15578       double dist = layerables.at(i)->selectTest(pos, onlySelectable, selectionDetails ? &details : 0);\par
15579       if (dist >= 0 && dist < selectionTolerance())\par
15580       \{\par
15581         result.append(layerables.at(i));\par
15582         if (selectionDetails)\par
15583           selectionDetails->append(details);\par
15584       \}\par
15585     \}\par
15586   \}\par
15587   return result;\par
15588 \}\par
}
}
{\xe \v layerCount\:QCustomPlot}
{\xe \v QCustomPlot\:layerCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::layerCount () const}}
\par
{\bkmkstart AAAAAAADSN}
{\bkmkend AAAAAAADSN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of currently existing layers in the plot\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layer}, {\b addLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14041 \{\par
14042   return mLayers.size();\par
14043 \}\par
}
}
{\xe \v layoutElementAt\:QCustomPlot}
{\xe \v QCustomPlot\:layoutElementAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutElement} * QCustomPlot::layoutElementAt (const QPointF &  {\i pos}) const}}
\par
{\bkmkstart AAAAAAADSO}
{\bkmkend AAAAAAADSO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the layout element at pixel position {\i pos} . If there is no element at that position, returns 0.\par
Only visible elements are used. If {\b QCPLayoutElement::setVisible} on the element itself or on any of its parent elements is set to false, it will not be considered.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemAt}, {\b plottableAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14245 \{\par
14246   QCPLayoutElement *currentElement = mPlotLayout;\par
14247   bool searchSubElements = true;\par
14248   while (searchSubElements && currentElement)\par
14249   \{\par
14250     searchSubElements = false;\par
14251     foreach (QCPLayoutElement *subElement, currentElement->elements(false))\par
14252     \{\par
14253       if (subElement && subElement->realVisibility() && subElement->selectTest(pos, false) >= 0)\par
14254       \{\par
14255         currentElement = subElement;\par
14256         searchSubElements = true;\par
14257         break;\par
14258       \}\par
14259     \}\par
14260   \}\par
14261   return currentElement;\par
14262 \}\par
}
}
{\xe \v legendClick\:QCustomPlot}
{\xe \v QCustomPlot\:legendClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::legendClick ({\b QCPLegend} *  {\i legend}, {\b QCPAbstractLegendItem} *  {\i item}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADSP}
{\bkmkend AAAAAAADSP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when a legend (item) is clicked.\par
{\i event}  is the mouse event that caused the click, {\i legend}  is the legend that received the click and {\i item}  is the legend item that received the click. If only the legend and no item is clicked, {\i item}  is 0. This happens for a click inside the legend padding or the space between two items.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b legendDoubleClick} \par
}}}
{\xe \v legendDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:legendDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::legendDoubleClick ({\b QCPLegend} *  {\i legend}, {\b QCPAbstractLegendItem} *  {\i item}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADSQ}
{\bkmkend AAAAAAADSQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when a legend (item) is double clicked.\par
{\i event}  is the mouse event that caused the click, {\i legend}  is the legend that received the click and {\i item}  is the legend item that received the click. If only the legend and no item is clicked, {\i item}  is 0. This happens for a click inside the legend padding or the space between two items.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b legendClick} \par
}}}
{\xe \v legendRemoved\:QCustomPlot}
{\xe \v QCustomPlot\:legendRemoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::legendRemoved ({\b QCPLegend} *  {\i legend}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADSR}
{\bkmkend AAAAAAADSR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15250 \{\par
15251   if (this->legend == legend)\par
15252     this->legend = 0;\par
15253 \}\par
}
}
{\xe \v minimumSizeHint\:QCustomPlot}
{\xe \v QCustomPlot\:minimumSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCustomPlot::minimumSizeHint () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADSS}
{\bkmkend AAAAAAADSS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14699 \{\par
14700   return mPlotLayout->minimumOuterSizeHint();\par
14701 \}\par
}
}
{\xe \v mouseDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:mouseDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseDoubleClick (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADST}
{\bkmkend AAAAAAADST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse double click event. \par
}}
{\xe \v mouseDoubleClickEvent\:QCustomPlot}
{\xe \v QCustomPlot\:mouseDoubleClickEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseDoubleClickEvent (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADSU}
{\bkmkend AAAAAAADSU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14756 \{\par
14757   emit mouseDoubleClick(event);\par
14758   mMouseHasMoved = false;\par
14759   mMousePressPos = event->pos();\par
14760   \par
14761   // determine layerable under the cursor (this event is called instead of the second press event in a double-click):\par
14762   QList<QVariant> details;\par
14763   QList<QCPLayerable*> candidates = layerableListAt(mMousePressPos, false, &details);\par
14764   for (int i=0; i<candidates.size(); ++i)\par
14765   \{\par
14766     event->accept(); // default impl of QCPLayerable's mouse events ignore the event, in that case propagate to next candidate in list\par
14767     candidates.at(i)->mouseDoubleClickEvent(event, details.at(i));\par
14768     if (event->isAccepted())\par
14769     \{\par
14770       mMouseEventLayerable = candidates.at(i);\par
14771       mMouseEventLayerableDetails = details.at(i);\par
14772       break;\par
14773     \}\par
14774   \}\par
14775   \par
14776   // emit specialized object double click signals:\par
14777   if (!candidates.isEmpty())\par
14778   \{\par
14779     if (QCPAbstractPlottable *ap = qobject_cast<QCPAbstractPlottable*>(candidates.first()))\par
14780     \{\par
14781       int dataIndex = 0;\par
14782       if (!details.first().value<QCPDataSelection>().isEmpty())\par
14783         dataIndex = details.first().value<QCPDataSelection>().dataRange().begin();\par
14784       emit plottableDoubleClick(ap, dataIndex, event);\par
14785     \} else if (QCPAxis *ax = qobject_cast<QCPAxis*>(candidates.first()))\par
14786       emit axisDoubleClick(ax, details.first().value<QCPAxis::SelectablePart>(), event);\par
14787     else if (QCPAbstractItem *ai = qobject_cast<QCPAbstractItem*>(candidates.first()))\par
14788       emit itemDoubleClick(ai, event);\par
14789     else if (QCPLegend *lg = qobject_cast<QCPLegend*>(candidates.first()))\par
14790       emit legendDoubleClick(lg, 0, event);\par
14791     else if (QCPAbstractLegendItem *li = qobject_cast<QCPAbstractLegendItem*>(candidates.first()))\par
14792       emit legendDoubleClick(li->parentLegend(), li, event);\par
14793   \}\par
14794   \par
14795   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14796 \}\par
}
}
{\xe \v mouseMove\:QCustomPlot}
{\xe \v QCustomPlot\:mouseMove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseMove (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADSV}
{\bkmkend AAAAAAADSV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse move event.\par
It is emitted before {\b QCustomPlot} handles any other mechanism like range dragging. So a slot connected to this signal can still influence the behaviour e.g. with {\b QCPAxisRect::setRangeDrag} or {\b QCPAxisRect::setRangeDragAxes}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid It is discouraged to change the drag-axes with {\b QCPAxisRect::setRangeDragAxes} here, because the dragging starting point was saved the moment the mouse was pressed. Thus it only has a meaning for the range drag axes that were set at that moment. If you want to change the drag axes, consider doing this in the {\b mousePress} signal instead. \par
}}}
{\xe \v mouseMoveEvent\:QCustomPlot}
{\xe \v QCustomPlot\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseMoveEvent (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADSW}
{\bkmkend AAAAAAADSW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14858 \{\par
14859   emit mouseMove(event);\par
14860   \par
14861   if (!mMouseHasMoved && (mMousePressPos-event->pos()).manhattanLength() > 3)\par
14862     mMouseHasMoved = true; // moved too far from mouse press position, don't handle as click on mouse release\par
14863   \par
14864   if (mSelectionRect && mSelectionRect->isActive())\par
14865     mSelectionRect->moveSelection(event);\par
14866   else if (mMouseEventLayerable) // call event of affected layerable:\par
14867     mMouseEventLayerable->mouseMoveEvent(event, mMousePressPos);\par
14868   \par
14869   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14870 \}\par
}
}
{\xe \v mousePress\:QCustomPlot}
{\xe \v QCustomPlot\:mousePress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mousePress (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADSX}
{\bkmkend AAAAAAADSX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse press event.\par
It is emitted before {\b QCustomPlot} handles any other mechanism like range dragging. So a slot connected to this signal can still influence the behaviour e.g. with {\b QCPAxisRect::setRangeDrag} or {\b QCPAxisRect::setRangeDragAxes}. \par
}}
{\xe \v mousePressEvent\:QCustomPlot}
{\xe \v QCustomPlot\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mousePressEvent (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADSY}
{\bkmkend AAAAAAADSY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14808 \{\par
14809   emit mousePress(event);\par
14810   // save some state to tell in releaseEvent whether it was a click:\par
14811   mMouseHasMoved = false;\par
14812   mMousePressPos = event->pos();\par
14813   \par
14814   if (mSelectionRect && mSelectionRectMode != QCP::srmNone)\par
14815   \{\par
14816     if (mSelectionRectMode != QCP::srmZoom || qobject_cast<QCPAxisRect*>(axisRectAt(mMousePressPos))) // in zoom mode only activate selection rect if on an axis rect\par
14817       mSelectionRect->startSelection(event);\par
14818   \} else\par
14819   \{\par
14820     // no selection rect interaction, prepare for click signal emission and forward event to layerable under the cursor:\par
14821     QList<QVariant> details;\par
14822     QList<QCPLayerable*> candidates = layerableListAt(mMousePressPos, false, &details);\par
14823     if (!candidates.isEmpty())\par
14824     \{\par
14825       mMouseSignalLayerable = candidates.first(); // candidate for signal emission is always topmost hit layerable (signal emitted in release event)\par
14826       mMouseSignalLayerableDetails = details.first();\par
14827     \}\par
14828     // forward event to topmost candidate which accepts the event:\par
14829     for (int i=0; i<candidates.size(); ++i)\par
14830     \{\par
14831       event->accept(); // default impl of QCPLayerable's mouse events call ignore() on the event, in that case propagate to next candidate in list\par
14832       candidates.at(i)->mousePressEvent(event, details.at(i));\par
14833       if (event->isAccepted())\par
14834       \{\par
14835         mMouseEventLayerable = candidates.at(i);\par
14836         mMouseEventLayerableDetails = details.at(i);\par
14837         break;\par
14838       \}\par
14839     \}\par
14840   \}\par
14841   \par
14842   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14843 \}\par
}
}
{\xe \v mouseRelease\:QCustomPlot}
{\xe \v QCustomPlot\:mouseRelease}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseRelease (QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADSZ}
{\bkmkend AAAAAAADSZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse release event.\par
It is emitted before {\b QCustomPlot} handles any other mechanisms like object selection. So a slot connected to this signal can still influence the behaviour e.g. with {\b setInteractions} or {\b QCPAbstractPlottable::setSelectable}. \par
}}
{\xe \v mouseReleaseEvent\:QCustomPlot}
{\xe \v QCustomPlot\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseReleaseEvent (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADTA}
{\bkmkend AAAAAAADTA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14887 \{\par
14888   emit mouseRelease(event);\par
14889   \par
14890   if (!mMouseHasMoved) // mouse hasn't moved (much) between press and release, so handle as click\par
14891   \{\par
14892     if (mSelectionRect && mSelectionRect->isActive()) // a simple click shouldn't successfully finish a selection rect, so cancel it here\par
14893       mSelectionRect->cancel();\par
14894     if (event->button() == Qt::LeftButton)\par
14895       processPointSelection(event);\par
14896     \par
14897     // emit specialized click signals of QCustomPlot instance:\par
14898     if (QCPAbstractPlottable *ap = qobject_cast<QCPAbstractPlottable*>(mMouseSignalLayerable))\par
14899     \{\par
14900       int dataIndex = 0;\par
14901       if (!mMouseSignalLayerableDetails.value<QCPDataSelection>().isEmpty())\par
14902         dataIndex = mMouseSignalLayerableDetails.value<QCPDataSelection>().dataRange().begin();\par
14903       emit plottableClick(ap, dataIndex, event);\par
14904     \} else if (QCPAxis *ax = qobject_cast<QCPAxis*>(mMouseSignalLayerable))\par
14905       emit axisClick(ax, mMouseSignalLayerableDetails.value<QCPAxis::SelectablePart>(), event);\par
14906     else if (QCPAbstractItem *ai = qobject_cast<QCPAbstractItem*>(mMouseSignalLayerable))\par
14907       emit itemClick(ai, event);\par
14908     else if (QCPLegend *lg = qobject_cast<QCPLegend*>(mMouseSignalLayerable))\par
14909       emit legendClick(lg, 0, event);\par
14910     else if (QCPAbstractLegendItem *li = qobject_cast<QCPAbstractLegendItem*>(mMouseSignalLayerable))\par
14911       emit legendClick(li->parentLegend(), li, event);\par
14912     mMouseSignalLayerable = 0;\par
14913   \}\par
14914   \par
14915   if (mSelectionRect && mSelectionRect->isActive()) // Note: if a click was detected above, the selection rect is canceled there\par
14916   \{\par
14917     // finish selection rect, the appropriate action will be taken via signal-slot connection:\par
14918     mSelectionRect->endSelection(event);\par
14919   \} else\par
14920   \{\par
14921     // call event of affected layerable:\par
14922     if (mMouseEventLayerable)\par
14923     \{\par
14924       mMouseEventLayerable->mouseReleaseEvent(event, mMousePressPos);\par
14925       mMouseEventLayerable = 0;\par
14926     \}\par
14927   \}\par
14928   \par
14929   if (noAntialiasingOnDrag())\par
14930     replot(rpQueuedReplot);\par
14931   \par
14932   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14933 \}\par
}
}
{\xe \v mouseWheel\:QCustomPlot}
{\xe \v QCustomPlot\:mouseWheel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::mouseWheel (QWheelEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADTB}
{\bkmkend AAAAAAADTB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the {\b QCustomPlot} receives a mouse wheel event.\par
It is emitted before {\b QCustomPlot} handles any other mechanisms like range zooming. So a slot connected to this signal can still influence the behaviour e.g. with {\b QCPAxisRect::setRangeZoom}, {\b QCPAxisRect::setRangeZoomAxes} or {\b QCPAxisRect::setRangeZoomFactor}. \par
}}
{\xe \v moveLayer\:QCustomPlot}
{\xe \v QCustomPlot\:moveLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::moveLayer ({\b QCPLayer} *  {\i layer}, {\b QCPLayer} *  {\i otherLayer}, {\b QCustomPlot::LayerInsertMode}  {\i insertMode} = {\f2 {\b limAbove}})}}
\par
{\bkmkstart AAAAAAADTC}
{\bkmkend AAAAAAADTC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the specified {\i layer}  either above or below {\i otherLayer} . Whether it's placed above or below is controlled with {\i insertMode} .\par
Returns true on success, i.e. when both {\i layer}  and {\i otherLayer}  are valid layers in the {\b QCustomPlot}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layer}, {\b addLayer}, {\b moveLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14144 \{\par
14145   if (!mLayers.contains(layer))\par
14146   \{\par
14147     qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);\par
14148     return false;\par
14149   \}\par
14150   if (!mLayers.contains(otherLayer))\par
14151   \{\par
14152     qDebug() << Q_FUNC_INFO << "otherLayer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(otherLayer);\par
14153     return false;\par
14154   \}\par
14155   \par
14156   if (layer->index() > otherLayer->index())\par
14157     mLayers.move(layer->index(), otherLayer->index() + (insertMode==limAbove ? 1:0));\par
14158   else if (layer->index() < otherLayer->index())\par
14159     mLayers.move(layer->index(), otherLayer->index() + (insertMode==limAbove ? 0:-1));\par
14160   \par
14161   // invalidate the paint buffers that are responsible for the layers:\par
14162   if (!layer->mPaintBuffer.isNull())\par
14163     layer->mPaintBuffer.data()->setInvalidated();\par
14164   if (!otherLayer->mPaintBuffer.isNull())\par
14165     otherLayer->mPaintBuffer.data()->setInvalidated();\par
14166   \par
14167   updateLayerIndices();\par
14168   return true;\par
14169 \}\par
}
}
{\xe \v multiSelectModifier\:QCustomPlot}
{\xe \v QCustomPlot\:multiSelectModifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::KeyboardModifier QCustomPlot::multiSelectModifier () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTD}
{\bkmkend AAAAAAADTD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3637 \{ return mMultiSelectModifier; \}\par
}
}
{\xe \v noAntialiasingOnDrag\:QCustomPlot}
{\xe \v QCustomPlot\:noAntialiasingOnDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::noAntialiasingOnDrag () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTE}
{\bkmkend AAAAAAADTE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3635 \{ return mNoAntialiasingOnDrag; \}\par
}
}
{\xe \v notAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:notAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::notAntialiasedElements () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTF}
{\bkmkend AAAAAAADTF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3631 \{ return mNotAntialiasedElements; \}\par
}
}
{\xe \v openGl\:QCustomPlot}
{\xe \v QCustomPlot\:openGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::openGl () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTG}
{\bkmkend AAAAAAADTG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3640 \{ return mOpenGl; \}\par
}
}
{\xe \v paintEvent\:QCustomPlot}
{\xe \v QCustomPlot\:paintEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::paintEvent (QPaintEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADTH}
{\bkmkend AAAAAAADTH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14719 \{\par
14720   Q_UNUSED(event);\par
14721   QCPPainter painter(this);\par
14722   if (painter.isActive())\par
14723   \{\par
14724     painter.setRenderHint(QPainter::HighQualityAntialiasing); // to make Antialiasing look good if using the OpenGL graphicssystem\par
14725     if (mBackgroundBrush.style() != Qt::NoBrush)\par
14726       painter.fillRect(mViewport, mBackgroundBrush);\par
14727     drawBackground(&painter);\par
14728     for (int bufferIndex = 0; bufferIndex < mPaintBuffers.size(); ++bufferIndex)\par
14729       mPaintBuffers.at(bufferIndex)->draw(&painter);\par
14730   \}\par
14731 \}\par
}
}
{\xe \v plotLayout\:QCustomPlot}
{\xe \v QCustomPlot\:plotLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutGrid} * QCustomPlot::plotLayout () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTI}
{\bkmkend AAAAAAADTI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the top level layout of this {\b QCustomPlot} instance. It is a {\b QCPLayoutGrid}, initially containing just one cell with the main {\b QCPAxisRect} inside. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3629 \{ return mPlotLayout; \}\par
}
}
{\xe \v plottable\:QCustomPlot}
{\xe \v QCustomPlot\:plottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable} * QCustomPlot::plottable (int  {\i index})}}
\par
{\bkmkstart AAAAAAADTJ}
{\bkmkend AAAAAAADTJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the plottable with {\i index} . If the index is invalid, returns 0.\par
There is an overloaded version of this function with no parameter which returns the last added plottable, see {\b QCustomPlot::plottable()}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13494 \{\par
13495   if (index >= 0 && index < mPlottables.size())\par
13496   \{\par
13497     return mPlottables.at(index);\par
13498   \} else\par
13499   \{\par
13500     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13501     return 0;\par
13502   \}\par
13503 \}\par
}
}
{\xe \v plottable\:QCustomPlot}
{\xe \v QCustomPlot\:plottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable} * QCustomPlot::plottable ()}}
\par
{\bkmkstart AAAAAAADTK}
{\bkmkend AAAAAAADTK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Returns the last plottable that was added to the plot. If there are no plottables in the plot, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableCount} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13513 \{\par
13514   if (!mPlottables.isEmpty())\par
13515   \{\par
13516     return mPlottables.last();\par
13517   \} else\par
13518     return 0;\par
13519 \}\par
}
}
{\xe \v plottableAt\:QCustomPlot}
{\xe \v QCustomPlot\:plottableAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAbstractPlottable} * QCustomPlot::plottableAt (const QPointF &  {\i pos}, bool  {\i onlySelectable} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAADTL}
{\bkmkend AAAAAAADTL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the plottable at the pixel position {\i pos} . Plottables that only consist of single lines (like graphs) have a tolerance band around them, see {\b setSelectionTolerance}. If multiple plottables come into consideration, the one closest to {\i pos}  is returned.\par
If {\i onlySelectable}  is true, only plottables that are selectable ({\b QCPAbstractPlottable::setSelectable}) are considered.\par
If there is no plottable at {\i pos} , the return value is 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b itemAt}, {\b layoutElementAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13620 \{\par
13621   QCPAbstractPlottable *resultPlottable = 0;\par
13622   double resultDistance = mSelectionTolerance; // only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value\par
13623   \par
13624   foreach (QCPAbstractPlottable *plottable, mPlottables)\par
13625   \{\par
13626     if (onlySelectable && !plottable->selectable()) // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPabstractPlottable::selectable\par
13627       continue;\par
13628     if ((plottable->keyAxis()->axisRect()->rect() & plottable->valueAxis()->axisRect()->rect()).contains(pos.toPoint())) // only consider clicks inside the rect that is spanned by the plottable's key/value axes\par
13629     \{\par
13630       double currentDistance = plottable->selectTest(pos, false);\par
13631       if (currentDistance >= 0 && currentDistance < resultDistance)\par
13632       \{\par
13633         resultPlottable = plottable;\par
13634         resultDistance = currentDistance;\par
13635       \}\par
13636     \}\par
13637   \}\par
13638   \par
13639   return resultPlottable;\par
13640 \}\par
}
}
{\xe \v plottableClick\:QCustomPlot}
{\xe \v QCustomPlot\:plottableClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::plottableClick ({\b QCPAbstractPlottable} *  {\i plottable}, int  {\i dataIndex}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADTM}
{\bkmkend AAAAAAADTM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when a plottable is clicked.\par
{\i event}  is the mouse event that caused the click and {\i plottable}  is the plottable that received the click. The parameter {\i dataIndex}  indicates the data point that was closest to the click position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableDoubleClick} \par
}}}
{\xe \v plottableCount\:QCustomPlot}
{\xe \v QCustomPlot\:plottableCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::plottableCount () const}}
\par
{\bkmkstart AAAAAAADTN}
{\bkmkend AAAAAAADTN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of currently existing plottables in the plot\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13585 \{\par
13586   return mPlottables.size();\par
13587 \}\par
}
}
{\xe \v plottableDoubleClick\:QCustomPlot}
{\xe \v QCustomPlot\:plottableDoubleClick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::plottableDoubleClick ({\b QCPAbstractPlottable} *  {\i plottable}, int  {\i dataIndex}, QMouseEvent *  {\i event}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADTO}
{\bkmkend AAAAAAADTO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when a plottable is double clicked.\par
{\i event}  is the mouse event that caused the click and {\i plottable}  is the plottable that received the click. The parameter {\i dataIndex}  indicates the data point that was closest to the click position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottableClick} \par
}}}
{\xe \v plottingHints\:QCustomPlot}
{\xe \v QCustomPlot\:plottingHints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::PlottingHints QCustomPlot::plottingHints () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTP}
{\bkmkend AAAAAAADTP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3636 \{ return mPlottingHints; \}\par
}
}
{\xe \v processPointSelection\:QCustomPlot}
{\xe \v QCustomPlot\:processPointSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::processPointSelection (QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADTQ}
{\bkmkend AAAAAAADTQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15387 \{\par
15388   QVariant details;\par
15389   QCPLayerable *clickedLayerable = layerableAt(event->pos(), true, &details);\par
15390   bool selectionStateChanged = false;\par
15391   bool additive = mInteractions.testFlag(QCP::iMultiSelect) && event->modifiers().testFlag(mMultiSelectModifier);\par
15392   // deselect all other layerables if not additive selection:\par
15393   if (!additive)\par
15394   \{\par
15395     foreach (QCPLayer *layer, mLayers)\par
15396     \{\par
15397       foreach (QCPLayerable *layerable, layer->children())\par
15398       \{\par
15399         if (layerable != clickedLayerable && mInteractions.testFlag(layerable->selectionCategory()))\par
15400         \{\par
15401           bool selChanged = false;\par
15402           layerable->deselectEvent(&selChanged);\par
15403           selectionStateChanged |= selChanged;\par
15404         \}\par
15405       \}\par
15406     \}\par
15407   \}\par
15408   if (clickedLayerable && mInteractions.testFlag(clickedLayerable->selectionCategory()))\par
15409   \{\par
15410     // a layerable was actually clicked, call its selectEvent:\par
15411     bool selChanged = false;\par
15412     clickedLayerable->selectEvent(event, additive, details, &selChanged);\par
15413     selectionStateChanged |= selChanged;\par
15414   \}\par
15415   if (selectionStateChanged)\par
15416   \{\par
15417     emit selectionChangedByUser();\par
15418     replot(rpQueuedReplot);\par
15419   \}\par
15420 \}\par
}
}
{\xe \v processRectSelection\:QCustomPlot}
{\xe \v QCustomPlot\:processRectSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::processRectSelection (QRect  {\i rect}, QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADTR}
{\bkmkend AAAAAAADTR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15273 \{\par
15274   bool selectionStateChanged = false;\par
15275   \par
15276   if (mInteractions.testFlag(QCP::iSelectPlottables))\par
15277   \{\par
15278     QMap<int, QPair<QCPAbstractPlottable*, QCPDataSelection> > potentialSelections; // map key is number of selected data points, so we have selections sorted by size\par
15279     QRectF rectF(rect.normalized());\par
15280     if (QCPAxisRect *affectedAxisRect = axisRectAt(rectF.topLeft()))\par
15281     \{\par
15282       // determine plottables that were hit by the rect and thus are candidates for selection:\par
15283       foreach (QCPAbstractPlottable *plottable, affectedAxisRect->plottables())\par
15284       \{\par
15285         if (QCPPlottableInterface1D *plottableInterface = plottable->interface1D())\par
15286         \{\par
15287           QCPDataSelection dataSel = plottableInterface->selectTestRect(rectF, true);\par
15288           if (!dataSel.isEmpty())\par
15289             potentialSelections.insertMulti(dataSel.dataPointCount(), QPair<QCPAbstractPlottable*, QCPDataSelection>(plottable, dataSel));\par
15290         \}\par
15291       \}\par
15292       \par
15293       if (!mInteractions.testFlag(QCP::iMultiSelect))\par
15294       \{\par
15295         // only leave plottable with most selected points in map, since we will only select a single plottable:\par
15296         if (!potentialSelections.isEmpty())\par
15297         \{\par
15298           QMap<int, QPair<QCPAbstractPlottable*, QCPDataSelection> >::iterator it = potentialSelections.begin();\par
15299           while (it != potentialSelections.end()-1) // erase all except last element\par
15300             it = potentialSelections.erase(it);\par
15301         \}\par
15302       \}\par
15303       \par
15304       bool additive = event->modifiers().testFlag(mMultiSelectModifier);\par
15305       // deselect all other layerables if not additive selection:\par
15306       if (!additive)\par
15307       \{\par
15308         // emit deselection except to those plottables who will be selected afterwards:\par
15309         foreach (QCPLayer *layer, mLayers)\par
15310         \{\par
15311           foreach (QCPLayerable *layerable, layer->children())\par
15312           \{\par
15313             if ((potentialSelections.isEmpty() || potentialSelections.constBegin()->first != layerable) && mInteractions.testFlag(layerable->selectionCategory()))\par
15314             \{\par
15315               bool selChanged = false;\par
15316               layerable->deselectEvent(&selChanged);\par
15317               selectionStateChanged |= selChanged;\par
15318             \}\par
15319           \}\par
15320         \}\par
15321       \}\par
15322       \par
15323       // go through selections in reverse (largest selection first) and emit select events:\par
15324       QMap<int, QPair<QCPAbstractPlottable*, QCPDataSelection> >::const_iterator it = potentialSelections.constEnd();\par
15325       while (it != potentialSelections.constBegin())\par
15326       \{\par
15327         --it;\par
15328         if (mInteractions.testFlag(it.value().first->selectionCategory()))\par
15329         \{\par
15330           bool selChanged = false;\par
15331           it.value().first->selectEvent(event, additive, QVariant::fromValue(it.value().second), &selChanged);\par
15332           selectionStateChanged |= selChanged;\par
15333         \}\par
15334       \}\par
15335     \}\par
15336   \}\par
15337   \par
15338   if (selectionStateChanged)\par
15339   \{\par
15340     emit selectionChangedByUser();\par
15341     replot(rpQueuedReplot);\par
15342   \} else if (mSelectionRect)\par
15343     mSelectionRect->layer()->replot();\par
15344 \}\par
}
}
{\xe \v processRectZoom\:QCustomPlot}
{\xe \v QCustomPlot\:processRectZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::processRectZoom (QRect  {\i rect}, QMouseEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADTS}
{\bkmkend AAAAAAADTS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15358 \{\par
15359   Q_UNUSED(event)\par
15360   if (QCPAxisRect *axisRect = axisRectAt(rect.topLeft()))\par
15361   \{\par
15362     QList<QCPAxis*> affectedAxes = QList<QCPAxis*>() << axisRect->rangeZoomAxes(Qt::Horizontal) << axisRect->rangeZoomAxes(Qt::Vertical);\par
15363     affectedAxes.removeAll(static_cast<QCPAxis*>(0));\par
15364     axisRect->zoom(QRectF(rect), affectedAxes);\par
15365   \}\par
15366   replot(rpQueuedReplot); // always replot to make selection rect disappear\par
15367 \}\par
}
}
{\xe \v registerGraph\:QCustomPlot}
{\xe \v QCustomPlot\:registerGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::registerGraph ({\b QCPGraph} *  {\i graph}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADTT}
{\bkmkend AAAAAAADTT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15465 \{\par
15466   if (!graph)\par
15467   \{\par
15468     qDebug() << Q_FUNC_INFO << "passed graph is zero";\par
15469     return false;\par
15470   \}\par
15471   if (mGraphs.contains(graph))\par
15472   \{\par
15473     qDebug() << Q_FUNC_INFO << "graph already registered with this QCustomPlot";\par
15474     return false;\par
15475   \}\par
15476   \par
15477   mGraphs.append(graph);\par
15478   return true;\par
15479 \}\par
}
}
{\xe \v registerItem\:QCustomPlot}
{\xe \v QCustomPlot\:registerItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::registerItem ({\b QCPAbstractItem} *  {\i item}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADTU}
{\bkmkend AAAAAAADTU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15492 \{\par
15493   if (mItems.contains(item))\par
15494   \{\par
15495     qDebug() << Q_FUNC_INFO << "item already added to this QCustomPlot:" << reinterpret_cast<quintptr>(item);\par
15496     return false;\par
15497   \}\par
15498   if (item->parentPlot() != this)\par
15499   \{\par
15500     qDebug() << Q_FUNC_INFO << "item not created with this QCustomPlot as parent:" << reinterpret_cast<quintptr>(item);\par
15501     return false;\par
15502   \}\par
15503   \par
15504   mItems.append(item);\par
15505   if (!item->layer()) // usually the layer is already set in the constructor of the item (via QCPLayerable constructor)\par
15506     item->setLayer(currentLayer());\par
15507   return true;\par
15508 \}\par
}
}
{\xe \v registerPlottable\:QCustomPlot}
{\xe \v QCustomPlot\:registerPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::registerPlottable ({\b QCPAbstractPlottable} *  {\i plottable}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADTV}
{\bkmkend AAAAAAADTV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15434 \{\par
15435   if (mPlottables.contains(plottable))\par
15436   \{\par
15437     qDebug() << Q_FUNC_INFO << "plottable already added to this QCustomPlot:" << reinterpret_cast<quintptr>(plottable);\par
15438     return false;\par
15439   \}\par
15440   if (plottable->parentPlot() != this)\par
15441   \{\par
15442     qDebug() << Q_FUNC_INFO << "plottable not created with this QCustomPlot as parent:" << reinterpret_cast<quintptr>(plottable);\par
15443     return false;\par
15444   \}\par
15445   \par
15446   mPlottables.append(plottable);\par
15447   // possibly add plottable to legend:\par
15448   if (mAutoAddPlottableToLegend)\par
15449     plottable->addToLegend();\par
15450   if (!plottable->layer()) // usually the layer is already set in the constructor of the plottable (via QCPLayerable constructor)\par
15451     plottable->setLayer(currentLayer());\par
15452   return true;\par
15453 \}\par
}
}
{\xe \v removeGraph\:QCustomPlot}
{\xe \v QCustomPlot\:removeGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeGraph ({\b QCPGraph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAADTW}
{\bkmkend AAAAAAADTW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i graph}  from the plot and deletes it. If necessary, the corresponding legend item is also removed from the default legend ({\b QCustomPlot::legend}). If any other graphs in the plot have a channel fill set towards the removed graph, the channel fill property of those graphs is reset to zero (no channel fill).\par
Returns true on success.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clearGraphs} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13729 \{\par
13730   return removePlottable(graph);\par
13731 \}\par
}
}
{\xe \v removeGraph\:QCustomPlot}
{\xe \v QCustomPlot\:removeGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeGraph (int  {\i index})}}
\par
{\bkmkstart AAAAAAADTX}
{\bkmkend AAAAAAADTX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Removes and deletes the graph by its {\i index} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13738 \{\par
13739   if (index >= 0 && index < mGraphs.size())\par
13740     return removeGraph(mGraphs[index]);\par
13741   else\par
13742     return false;\par
13743 \}\par
}
}
{\xe \v removeItem\:QCustomPlot}
{\xe \v QCustomPlot\:removeItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeItem ({\b QCPAbstractItem} *  {\i item})}}
\par
{\bkmkstart AAAAAAADTY}
{\bkmkend AAAAAAADTY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified item from the plot and deletes it.\par
Returns true on success.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clearItems} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13834 \{\par
13835   if (mItems.contains(item))\par
13836   \{\par
13837     delete item;\par
13838     mItems.removeOne(item);\par
13839     return true;\par
13840   \} else\par
13841   \{\par
13842     qDebug() << Q_FUNC_INFO << "item not in list:" << reinterpret_cast<quintptr>(item);\par
13843     return false;\par
13844   \}\par
13845 \}\par
}
}
{\xe \v removeItem\:QCustomPlot}
{\xe \v QCustomPlot\:removeItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeItem (int  {\i index})}}
\par
{\bkmkstart AAAAAAADTZ}
{\bkmkend AAAAAAADTZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Removes and deletes the item by its {\i index} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13852 \{\par
13853   if (index >= 0 && index < mItems.size())\par
13854     return removeItem(mItems[index]);\par
13855   else\par
13856   \{\par
13857     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13858     return false;\par
13859   \}\par
13860 \}\par
}
}
{\xe \v removeLayer\:QCustomPlot}
{\xe \v QCustomPlot\:removeLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removeLayer ({\b QCPLayer} *  {\i layer})}}
\par
{\bkmkstart AAAAAAADUA}
{\bkmkend AAAAAAADUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i layer}  and returns true on success.\par
All layerables (e.g. plottables and items) on the removed layer will be moved to the layer below {\i layer} . If {\i layer}  is the bottom layer, the layerables are moved to the layer above. In both cases, the total rendering order of all layerables in the {\b QCustomPlot} is preserved.\par
If {\i layer}  is the current layer ({\b setCurrentLayer}), the layer below (or above, if bottom layer) becomes the new current layer.\par
It is not possible to remove the last layer of the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b layer}, {\b addLayer}, {\b moveLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14095 \{\par
14096   if (!mLayers.contains(layer))\par
14097   \{\par
14098     qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);\par
14099     return false;\par
14100   \}\par
14101   if (mLayers.size() < 2)\par
14102   \{\par
14103     qDebug() << Q_FUNC_INFO << "can't remove last layer";\par
14104     return false;\par
14105   \}\par
14106   \par
14107   // append all children of this layer to layer below (if this is lowest layer, prepend to layer above)\par
14108   int removedIndex = layer->index();\par
14109   bool isFirstLayer = removedIndex==0;\par
14110   QCPLayer *targetLayer = isFirstLayer ? mLayers.at(removedIndex+1) : mLayers.at(removedIndex-1);\par
14111   QList<QCPLayerable*> children = layer->children();\par
14112   if (isFirstLayer) // prepend in reverse order (so order relative to each other stays the same)\par
14113   \{\par
14114     for (int i=children.size()-1; i>=0; --i)\par
14115       children.at(i)->moveToLayer(targetLayer, true);\par
14116   \} else  // append normally\par
14117   \{\par
14118     for (int i=0; i<children.size(); ++i)\par
14119       children.at(i)->moveToLayer(targetLayer, false);\par
14120   \}\par
14121   // if removed layer is current layer, change current layer to layer below/above:\par
14122   if (layer == mCurrentLayer)\par
14123     setCurrentLayer(targetLayer);\par
14124   // invalidate the paint buffer that was responsible for this layer:\par
14125   if (!layer->mPaintBuffer.isNull())\par
14126     layer->mPaintBuffer.data()->setInvalidated();\par
14127   // remove layer:\par
14128   delete layer;\par
14129   mLayers.removeOne(layer);\par
14130   updateLayerIndices();\par
14131   return true;\par
14132 \}\par
}
}
{\xe \v removePlottable\:QCustomPlot}
{\xe \v QCustomPlot\:removePlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removePlottable ({\b QCPAbstractPlottable} *  {\i plottable})}}
\par
{\bkmkstart AAAAAAADUB}
{\bkmkend AAAAAAADUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified plottable from the plot and deletes it. If necessary, the corresponding legend item is also removed from the default legend ({\b QCustomPlot::legend}).\par
Returns true on success.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clearPlottables} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13530 \{\par
13531   if (!mPlottables.contains(plottable))\par
13532   \{\par
13533     qDebug() << Q_FUNC_INFO << "plottable not in list:" << reinterpret_cast<quintptr>(plottable);\par
13534     return false;\par
13535   \}\par
13536   \par
13537   // remove plottable from legend:\par
13538   plottable->removeFromLegend();\par
13539   // special handling for QCPGraphs to maintain the simple graph interface:\par
13540   if (QCPGraph *graph = qobject_cast<QCPGraph*>(plottable))\par
13541     mGraphs.removeOne(graph);\par
13542   // remove plottable:\par
13543   delete plottable;\par
13544   mPlottables.removeOne(plottable);\par
13545   return true;\par
13546 \}\par
}
}
{\xe \v removePlottable\:QCustomPlot}
{\xe \v QCustomPlot\:removePlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::removePlottable (int  {\i index})}}
\par
{\bkmkstart AAAAAAADUC}
{\bkmkend AAAAAAADUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Removes and deletes the plottable by its {\i index} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13553 \{\par
13554   if (index >= 0 && index < mPlottables.size())\par
13555     return removePlottable(mPlottables[index]);\par
13556   else\par
13557   \{\par
13558     qDebug() << Q_FUNC_INFO << "index out of bounds:" << index;\par
13559     return false;\par
13560   \}\par
13561 \}\par
}
}
{\xe \v replot\:QCustomPlot}
{\xe \v QCustomPlot\:replot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::replot ({\b QCustomPlot::RefreshPriority}  {\i refreshPriority} = {\f2 {\b QCustomPlot::rpRefreshHint}})}}
\par
{\bkmkstart AAAAAAADUD}
{\bkmkend AAAAAAADUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Causes a complete replot into the internal paint buffer(s). Finally, the widget surface is refreshed with the new buffer contents. This is the method that must be called to make changes to the plot, e.g. on the axis ranges or data points of graphs, visible.\par
The parameter {\i refreshPriority}  can be used to fine-tune the timing of the replot. For example if your application calls {\b replot} very quickly in succession (e.g. multiple independent functions change some aspects of the plot and each wants to make sure the change gets replotted), it is advisable to set {\i refreshPriority}  to {\b QCustomPlot::rpQueuedReplot}. This way, the actual replotting is deferred to the next event loop iteration. Multiple successive calls of {\b replot} with this priority will only cause a single replot, avoiding redundant replots and improving performance.\par
Under a few circumstances, {\b QCustomPlot} causes a replot by itself. Those are resize events of the {\b QCustomPlot} widget and user interactions (object selection and range dragging/zooming).\par
Before the replot happens, the signal {\b beforeReplot} is emitted. After the replot, {\b afterReplot} is emitted. It is safe to mutually connect the replot slot with any of those two signals on two QCustomPlots to make them replot synchronously, it won't cause an infinite recursion.\par
If a layer is in mode {\b QCPLayer::lmBuffered} ({\b QCPLayer::setMode}), it is also possible to replot only that specific layer via {\b QCPLayer::replot}. See the documentation there for details. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14397 \{\par
14398   if (refreshPriority == QCustomPlot::rpQueuedReplot)\par
14399   \{\par
14400     if (!mReplotQueued)\par
14401     \{\par
14402       mReplotQueued = true;\par
14403       QTimer::singleShot(0, this, SLOT(replot()));\par
14404     \}\par
14405     return;\par
14406   \}\par
14407   \par
14408   if (mReplotting) // incase signals loop back to replot slot\par
14409     return;\par
14410   mReplotting = true;\par
14411   mReplotQueued = false;\par
14412   emit beforeReplot();\par
14413   \par
14414   updateLayout();\par
14415   // draw all layered objects (grid, axes, plottables, items, legend,...) into their buffers:\par
14416   setupPaintBuffers();\par
14417   foreach (QCPLayer *layer, mLayers)\par
14418     layer->drawToPaintBuffer();\par
14419   for (int i=0; i<mPaintBuffers.size(); ++i)\par
14420     mPaintBuffers.at(i)->setInvalidated(false);\par
14421   \par
14422   if ((refreshPriority == rpRefreshHint && mPlottingHints.testFlag(QCP::phImmediateRefresh)) || refreshPriority==rpImmediateRefresh)\par
14423     repaint();\par
14424   else\par
14425     update();\par
14426   \par
14427   emit afterReplot();\par
14428   mReplotting = false;\par
14429 \}\par
}
}
{\xe \v rescaleAxes\:QCustomPlot}
{\xe \v QCustomPlot\:rescaleAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::rescaleAxes (bool  {\i onlyVisiblePlottables} = {\f2 false})}}
\par
{\bkmkstart AAAAAAADUE}
{\bkmkend AAAAAAADUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the axes such that all plottables (like graphs) in the plot are fully visible.\par
if {\i onlyVisiblePlottables}  is set to true, only the plottables that have their visibility set to true ({\b QCPLayerable::setVisible}), will be used to rescale the axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractPlottable::rescaleAxes}, {\b QCPAxis::rescale} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14440 \{\par
14441   QList<QCPAxis*> allAxes;\par
14442   foreach (QCPAxisRect *rect, axisRects())\par
14443     allAxes << rect->axes();\par
14444   \par
14445   foreach (QCPAxis *axis, allAxes)\par
14446     axis->rescale(onlyVisiblePlottables);\par
14447 \}\par
}
}
{\xe \v resizeEvent\:QCustomPlot}
{\xe \v QCustomPlot\:resizeEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::resizeEvent (QResizeEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADUF}
{\bkmkend AAAAAAADUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14739 \{\par
14740   Q_UNUSED(event)\par
14741   // resize and repaint the buffer:\par
14742   setViewport(rect());\par
14743   replot(rpQueuedRefresh); // queued refresh is important here, to prevent painting issues in some contexts (e.g. MDI subwindow)\par
14744 \}\par
}
}
{\xe \v saveBmp\:QCustomPlot}
{\xe \v QCustomPlot\:saveBmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::saveBmp (const QString &  {\i fileName}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, double  {\i scale} = {\f2 1.0}, int  {\i resolution} = {\f2 96}, {\b QCP::ResolutionUnit}  {\i resolutionUnit} = {\f2 {\b QCP::ruDotsPerInch}})}}
\par
{\bkmkstart AAAAAAADUG}
{\bkmkend AAAAAAADUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves a BMP image file to {\i fileName}  on disc. The output plot will have the dimensions {\i width}  and {\i height}  in pixels, multiplied by {\i scale} . If either {\i width}  or {\i height}  is zero, the current width and height of the {\b QCustomPlot} widget is used instead. Line widths and texts etc. are not scaled up when larger widths/heights are used. If you want that effect, use the {\i scale}  parameter.\par
For example, if you set both {\i width}  and {\i height}  to 100 and {\i scale}  to 2, you will end up with an image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths, texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full 200*200 pixel resolution.\par
If you use a high scaling factor, it is recommended to enable antialiasing for all elements by temporarily setting {\b QCustomPlot::setAntialiasedElements} to {\b QCP::aeAll} as this allows {\b QCustomPlot} to place objects with sub-pixel accuracy.\par
The {\i resolution}  will be written to the image file header and has no direct consequence for the quality or the pixel size. However, if opening the image with a tool which respects the metadata, it will be able to scale the image to match either a given size in real units of length (inch, centimeters, etc.), or the target display DPI. You can specify in which units {\i resolution}  is given, by setting {\i resolutionUnit} . The {\i resolution}  is converted to the format's expected resolution unit internally.\par
Returns true on success. If this function fails, most likely the BMP format isn't supported by the system, see Qt docs about QImageWriter::supportedImageFormats().\par
The objects of the plot will appear in the current selection state. If you don't want any selected objects to be painted in their selected look, deselect everything with {\b deselectAll} before calling this function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If calling this function inside the constructor of the parent of the {\b QCustomPlot} widget (i.e. the {\b MainWindow} constructor, if {\b QCustomPlot} is inside the {\b MainWindow}), always provide explicit non-zero widths and heights. If you leave {\i width}  or {\i height}  as 0 (default), this function uses the current width and height of the {\b QCustomPlot} widget. However, in Qt, these aren't defined yet inside the constructor, so you would get an image that has strange widths/heights.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b savePdf}, {\b savePng}, {\b saveJpg}, {\b saveRastered} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14686 \{\par
14687   return saveRastered(fileName, width, height, scale, "BMP", -1, resolution, resolutionUnit);\par
14688 \}\par
}
}
{\xe \v saveJpg\:QCustomPlot}
{\xe \v QCustomPlot\:saveJpg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::saveJpg (const QString &  {\i fileName}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, double  {\i scale} = {\f2 1.0}, int  {\i quality} = {\f2 -1}, int  {\i resolution} = {\f2 96}, {\b QCP::ResolutionUnit}  {\i resolutionUnit} = {\f2 {\b QCP::ruDotsPerInch}})}}
\par
{\bkmkstart AAAAAAADUH}
{\bkmkend AAAAAAADUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves a JPEG image file to {\i fileName}  on disc. The output plot will have the dimensions {\i width}  and {\i height}  in pixels, multiplied by {\i scale} . If either {\i width}  or {\i height}  is zero, the current width and height of the {\b QCustomPlot} widget is used instead. Line widths and texts etc. are not scaled up when larger widths/heights are used. If you want that effect, use the {\i scale}  parameter.\par
For example, if you set both {\i width}  and {\i height}  to 100 and {\i scale}  to 2, you will end up with an image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths, texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full 200*200 pixel resolution.\par
If you use a high scaling factor, it is recommended to enable antialiasing for all elements by temporarily setting {\b QCustomPlot::setAntialiasedElements} to {\b QCP::aeAll} as this allows {\b QCustomPlot} to place objects with sub-pixel accuracy.\par
image compression can be controlled with the {\i quality}  parameter which must be between 0 and 100 or -1 to use the default setting.\par
The {\i resolution}  will be written to the image file header and has no direct consequence for the quality or the pixel size. However, if opening the image with a tool which respects the metadata, it will be able to scale the image to match either a given size in real units of length (inch, centimeters, etc.), or the target display DPI. You can specify in which units {\i resolution}  is given, by setting {\i resolutionUnit} . The {\i resolution}  is converted to the format's expected resolution unit internally.\par
Returns true on success. If this function fails, most likely the JPEG format isn't supported by the system, see Qt docs about QImageWriter::supportedImageFormats().\par
The objects of the plot will appear in the current selection state. If you don't want any selected objects to be painted in their selected look, deselect everything with {\b deselectAll} before calling this function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If calling this function inside the constructor of the parent of the {\b QCustomPlot} widget (i.e. the {\b MainWindow} constructor, if {\b QCustomPlot} is inside the {\b MainWindow}), always provide explicit non-zero widths and heights. If you leave {\i width}  or {\i height}  as 0 (default), this function uses the current width and height of the {\b QCustomPlot} widget. However, in Qt, these aren't defined yet inside the constructor, so you would get an image that has strange widths/heights.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b savePdf}, {\b savePng}, {\b saveBmp}, {\b saveRastered} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14642 \{\par
14643   return saveRastered(fileName, width, height, scale, "JPG", quality, resolution, resolutionUnit);\par
14644 \}\par
}
}
{\xe \v savePdf\:QCustomPlot}
{\xe \v QCustomPlot\:savePdf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::savePdf (const QString &  {\i fileName}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, {\b QCP::ExportPen}  {\i exportPen} = {\f2 {\b QCP::epAllowCosmetic}}, const QString &  {\i pdfCreator} = {\f2 QString()}, const QString &  {\i pdfTitle} = {\f2 QString()})}}
\par
{\bkmkstart AAAAAAADUI}
{\bkmkend AAAAAAADUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves a PDF with the vectorized plot to the file {\i fileName} . The axis ratio as well as the scale of texts and lines will be derived from the specified {\i width}  and {\i height} . This means, the output will look like the normal on-screen output of a {\b QCustomPlot} widget with the corresponding pixel width and height. If either {\i width}  or {\i height}  is zero, the exported image will have the same dimensions as the {\b QCustomPlot} widget currently has.\par
Setting {\i exportPen}  to {\b QCP::epNoCosmetic} allows to disable the use of cosmetic pens when drawing to the PDF file. Cosmetic pens are pens with numerical width 0, which are always drawn as a one pixel wide line, no matter what zoom factor is set in the PDF-Viewer. For more information about cosmetic pens, see the QPainter and QPen documentation.\par
The objects of the plot will appear in the current selection state. If you don't want any selected objects to be painted in their selected look, deselect everything with {\b deselectAll} before calling this function.\par
Returns true on success.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
\par\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If you plan on editing the exported PDF file with a vector graphics editor like Inkscape, it is advised to set {\i exportPen}  to {\b QCP::epNoCosmetic} to avoid losing those cosmetic lines (which might be quite many, because cosmetic pens are the default for e.g. axes and tick marks). \par\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If calling this function inside the constructor of the parent of the {\b QCustomPlot} widget (i.e. the {\b MainWindow} constructor, if {\b QCustomPlot} is inside the {\b MainWindow}), always provide explicit non-zero widths and heights. If you leave {\i width}  or {\i height}  as 0 (default), this function uses the current width and height of the {\b QCustomPlot} widget. However, in Qt, these aren't defined yet inside the constructor, so you would get an image that has strange widths/heights.\par
}
{\i pdfCreator}  and {\i pdfTitle}  may be used to set the according metadata fields in the resulting PDF file.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid On Android systems, this method does nothing and issues an according qDebug warning message. This is also the case if for other reasons the define flag {\f2 QT_NO_PRINTER}  is set.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b savePng}, {\b saveBmp}, {\b saveJpg}, {\b saveRastered} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14487 \{\par
14488   bool success = false;\par
14489 #ifdef QT_NO_PRINTER\par
14490   Q_UNUSED(fileName)\par
14491   Q_UNUSED(exportPen)\par
14492   Q_UNUSED(width)\par
14493   Q_UNUSED(height)\par
14494   Q_UNUSED(pdfCreator)\par
14495   Q_UNUSED(pdfTitle)\par
14496   qDebug() << Q_FUNC_INFO << "Qt was built without printer support (QT_NO_PRINTER). PDF not created.";\par
14497 #else\par
14498   int newWidth, newHeight;\par
14499   if (width == 0 || height == 0)\par
14500   \{\par
14501     newWidth = this->width();\par
14502     newHeight = this->height();\par
14503   \} else\par
14504   \{\par
14505     newWidth = width;\par
14506     newHeight = height;\par
14507   \}\par
14508   \par
14509   QPrinter printer(QPrinter::ScreenResolution);\par
14510   printer.setOutputFileName(fileName);\par
14511   printer.setOutputFormat(QPrinter::PdfFormat);\par
14512   printer.setColorMode(QPrinter::Color);\par
14513   printer.printEngine()->setProperty(QPrintEngine::PPK_Creator, pdfCreator);\par
14514   printer.printEngine()->setProperty(QPrintEngine::PPK_DocumentName, pdfTitle);\par
14515   QRect oldViewport = viewport();\par
14516   setViewport(QRect(0, 0, newWidth, newHeight));\par
14517 #if QT_VERSION < QT_VERSION_CHECK(5, 3, 0)\par
14518   printer.setFullPage(true);\par
14519   printer.setPaperSize(viewport().size(), QPrinter::DevicePixel);\par
14520 #else\par
14521   QPageLayout pageLayout;\par
14522   pageLayout.setMode(QPageLayout::FullPageMode);\par
14523   pageLayout.setOrientation(QPageLayout::Portrait);\par
14524   pageLayout.setMargins(QMarginsF(0, 0, 0, 0));\par
14525   pageLayout.setPageSize(QPageSize(viewport().size(), QPageSize::Point, QString(), QPageSize::ExactMatch));\par
14526   printer.setPageLayout(pageLayout);\par
14527 #endif\par
14528   QCPPainter printpainter;\par
14529   if (printpainter.begin(&printer))\par
14530   \{\par
14531     printpainter.setMode(QCPPainter::pmVectorized);\par
14532     printpainter.setMode(QCPPainter::pmNoCaching);\par
14533     printpainter.setMode(QCPPainter::pmNonCosmetic, exportPen==QCP::epNoCosmetic);\par
14534     printpainter.setWindow(mViewport);\par
14535     if (mBackgroundBrush.style() != Qt::NoBrush &&\par
14536         mBackgroundBrush.color() != Qt::white &&\par
14537         mBackgroundBrush.color() != Qt::transparent &&\par
14538         mBackgroundBrush.color().alpha() > 0) // draw pdf background color if not white/transparent\par
14539       printpainter.fillRect(viewport(), mBackgroundBrush);\par
14540     draw(&printpainter);\par
14541     printpainter.end();\par
14542     success = true;\par
14543   \}\par
14544   setViewport(oldViewport);\par
14545 #endif // QT_NO_PRINTER\par
14546   return success;\par
14547 \}\par
}
}
{\xe \v savePng\:QCustomPlot}
{\xe \v QCustomPlot\:savePng}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::savePng (const QString &  {\i fileName}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, double  {\i scale} = {\f2 1.0}, int  {\i quality} = {\f2 -1}, int  {\i resolution} = {\f2 96}, {\b QCP::ResolutionUnit}  {\i resolutionUnit} = {\f2 {\b QCP::ruDotsPerInch}})}}
\par
{\bkmkstart AAAAAAADUJ}
{\bkmkend AAAAAAADUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves a PNG image file to {\i fileName}  on disc. The output plot will have the dimensions {\i width}  and {\i height}  in pixels, multiplied by {\i scale} . If either {\i width}  or {\i height}  is zero, the current width and height of the {\b QCustomPlot} widget is used instead. Line widths and texts etc. are not scaled up when larger widths/heights are used. If you want that effect, use the {\i scale}  parameter.\par
For example, if you set both {\i width}  and {\i height}  to 100 and {\i scale}  to 2, you will end up with an image file of size 200*200 in which all graphical elements are scaled up by factor 2 (line widths, texts, etc.). This scaling is not done by stretching a 100*100 image, the result will have full 200*200 pixel resolution.\par
If you use a high scaling factor, it is recommended to enable antialiasing for all elements by temporarily setting {\b QCustomPlot::setAntialiasedElements} to {\b QCP::aeAll} as this allows {\b QCustomPlot} to place objects with sub-pixel accuracy.\par
image compression can be controlled with the {\i quality}  parameter which must be between 0 and 100 or -1 to use the default setting.\par
The {\i resolution}  will be written to the image file header and has no direct consequence for the quality or the pixel size. However, if opening the image with a tool which respects the metadata, it will be able to scale the image to match either a given size in real units of length (inch, centimeters, etc.), or the target display DPI. You can specify in which units {\i resolution}  is given, by setting {\i resolutionUnit} . The {\i resolution}  is converted to the format's expected resolution unit internally.\par
Returns true on success. If this function fails, most likely the PNG format isn't supported by the system, see Qt docs about QImageWriter::supportedImageFormats().\par
The objects of the plot will appear in the current selection state. If you don't want any selected objects to be painted in their selected look, deselect everything with {\b deselectAll} before calling this function.\par
If you want the PNG to have a transparent background, call {\b setBackground(const QBrush &brush)} with no brush (Qt::NoBrush) or a transparent color (Qt::transparent), before saving.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If calling this function inside the constructor of the parent of the {\b QCustomPlot} widget (i.e. the {\b MainWindow} constructor, if {\b QCustomPlot} is inside the {\b MainWindow}), always provide explicit non-zero widths and heights. If you leave {\i width}  or {\i height}  as 0 (default), this function uses the current width and height of the {\b QCustomPlot} widget. However, in Qt, these aren't defined yet inside the constructor, so you would get an image that has strange widths/heights.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b savePdf}, {\b saveBmp}, {\b saveJpg}, {\b saveRastered} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14595 \{\par
14596   return saveRastered(fileName, width, height, scale, "PNG", quality, resolution, resolutionUnit);\par
14597 \}\par
}
}
{\xe \v saveRastered\:QCustomPlot}
{\xe \v QCustomPlot\:saveRastered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::saveRastered (const QString &  {\i fileName}, int  {\i width}, int  {\i height}, double  {\i scale}, const char *  {\i format}, int  {\i quality} = {\f2 -1}, int  {\i resolution} = {\f2 96}, {\b QCP::ResolutionUnit}  {\i resolutionUnit} = {\f2 {\b QCP::ruDotsPerInch}})}}
\par
{\bkmkstart AAAAAAADUK}
{\bkmkend AAAAAAADUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves the plot to a rastered image file {\i fileName}  in the image format {\i format} . The plot is sized to {\i width}  and {\i height}  in pixels and scaled with {\i scale} . (width 100 and scale 2.0 lead to a full resolution file with width 200.) If the {\i format}  supports compression, {\i quality}  may be between 0 and 100 to control it.\par
Returns true on success. If this function fails, most likely the given {\i format}  isn't supported by the system, see Qt docs about QImageWriter::supportedImageFormats().\par
The {\i resolution}  will be written to the image file header (if the file format supports this) and has no direct consequence for the quality or the pixel size. However, if opening the image with a tool which respects the metadata, it will be able to scale the image to match either a given size in real units of length (inch, centimeters, etc.), or the target display DPI. You can specify in which units {\i resolution}  is given, by setting {\i resolutionUnit} . The {\i resolution}  is converted to the format's expected resolution unit internally.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b saveBmp}, {\b saveJpg}, {\b savePng}, {\b savePdf} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15609 \{\par
15610   QImage buffer = toPixmap(width, height, scale).toImage();\par
15611   \par
15612   int dotsPerMeter = 0;\par
15613   switch (resolutionUnit)\par
15614   \{\par
15615     case QCP::ruDotsPerMeter: dotsPerMeter = resolution; break;\par
15616     case QCP::ruDotsPerCentimeter: dotsPerMeter = resolution*100; break;\par
15617     case QCP::ruDotsPerInch: dotsPerMeter = resolution/0.0254; break;\par
15618   \}\par
15619   buffer.setDotsPerMeterX(dotsPerMeter); // this is saved together with some image formats, e.g. PNG, and is relevant when opening image in other tools\par
15620   buffer.setDotsPerMeterY(dotsPerMeter); // this is saved together with some image formats, e.g. PNG, and is relevant when opening image in other tools\par
15621   if (!buffer.isNull())\par
15622     return buffer.save(fileName, format, quality);\par
15623   else\par
15624     return false;\par
15625 \}\par
}
}
{\xe \v selectedAxes\:QCustomPlot}
{\xe \v QCustomPlot\:selectedAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCustomPlot::selectedAxes () const}}
\par
{\bkmkstart AAAAAAADUL}
{\bkmkend AAAAAAADUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the axes that currently have selected parts, i.e. whose selection state is not {\b QCPAxis::spNone}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectedPlottables}, {\b selectedLegends}, {\b setInteractions}, {\b QCPAxis::setSelectedParts}, {\b QCPAxis::setSelectableParts} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14305 \{\par
14306   QList<QCPAxis*> result, allAxes;\par
14307   foreach (QCPAxisRect *rect, axisRects())\par
14308     allAxes << rect->axes();\par
14309   \par
14310   foreach (QCPAxis *axis, allAxes)\par
14311   \{\par
14312     if (axis->selectedParts() != QCPAxis::spNone)\par
14313       result.append(axis);\par
14314   \}\par
14315   \par
14316   return result;\par
14317 \}\par
}
}
{\xe \v selectedGraphs\:QCustomPlot}
{\xe \v QCustomPlot\:selectedGraphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPGraph} * > QCustomPlot::selectedGraphs () const}}
\par
{\bkmkstart AAAAAAADUM}
{\bkmkend AAAAAAADUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of the selected graphs. If no graphs are currently selected, the list is empty.\par
If you are not only interested in selected graphs but other plottables like {\b QCPCurve}, {\b QCPBars}, etc., use {\b selectedPlottables}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b selectedPlottables}, {\b QCPAbstractPlottable::setSelectable}, {\b QCPAbstractPlottable::setSelection} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13780 \{\par
13781   QList<QCPGraph*> result;\par
13782   foreach (QCPGraph *graph, mGraphs)\par
13783   \{\par
13784     if (graph->selected())\par
13785       result.append(graph);\par
13786   \}\par
13787   return result;\par
13788 \}\par
}
}
{\xe \v selectedItems\:QCustomPlot}
{\xe \v QCustomPlot\:selectedItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractItem} * > QCustomPlot::selectedItems () const}}
\par
{\bkmkstart AAAAAAADUN}
{\bkmkend AAAAAAADUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of the selected items. If no items are currently selected, the list is empty.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b QCPAbstractItem::setSelectable}, {\b QCPAbstractItem::setSelected} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13893 \{\par
13894   QList<QCPAbstractItem*> result;\par
13895   foreach (QCPAbstractItem *item, mItems)\par
13896   \{\par
13897     if (item->selected())\par
13898       result.append(item);\par
13899   \}\par
13900   return result;\par
13901 \}\par
}
}
{\xe \v selectedLegends\:QCustomPlot}
{\xe \v QCustomPlot\:selectedLegends}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLegend} * > QCustomPlot::selectedLegends () const}}
\par
{\bkmkstart AAAAAAADUO}
{\bkmkend AAAAAAADUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the legends that currently have selected parts, i.e. whose selection state is not {\b QCPLegend::spNone}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectedPlottables}, {\b selectedAxes}, {\b setInteractions}, {\b QCPLegend::setSelectedParts}, {\b QCPLegend::setSelectableParts}, {\b QCPLegend::selectedItems} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14327 \{\par
14328   QList<QCPLegend*> result;\par
14329   \par
14330   QStack<QCPLayoutElement*> elementStack;\par
14331   if (mPlotLayout)\par
14332     elementStack.push(mPlotLayout);\par
14333   \par
14334   while (!elementStack.isEmpty())\par
14335   \{\par
14336     foreach (QCPLayoutElement *subElement, elementStack.pop()->elements(false))\par
14337     \{\par
14338       if (subElement)\par
14339       \{\par
14340         elementStack.push(subElement);\par
14341         if (QCPLegend *leg = qobject_cast<QCPLegend*>(subElement))\par
14342         \{\par
14343           if (leg->selectedParts() != QCPLegend::spNone)\par
14344             result.append(leg);\par
14345         \}\par
14346       \}\par
14347     \}\par
14348   \}\par
14349   \par
14350   return result;\par
14351 \}\par
}
}
{\xe \v selectedPlottables\:QCustomPlot}
{\xe \v QCustomPlot\:selectedPlottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractPlottable} * > QCustomPlot::selectedPlottables () const}}
\par
{\bkmkstart AAAAAAADUP}
{\bkmkend AAAAAAADUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of the selected plottables. If no plottables are currently selected, the list is empty.\par
There is a convenience function if you're only interested in selected graphs, see {\b selectedGraphs}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b QCPAbstractPlottable::setSelectable}, {\b QCPAbstractPlottable::setSelection} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13597 \{\par
13598   QList<QCPAbstractPlottable*> result;\par
13599   foreach (QCPAbstractPlottable *plottable, mPlottables)\par
13600   \{\par
13601     if (plottable->selected())\par
13602       result.append(plottable);\par
13603   \}\par
13604   return result;\par
13605 \}\par
}
}
{\xe \v selectionChangedByUser\:QCustomPlot}
{\xe \v QCustomPlot\:selectionChangedByUser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::selectionChangedByUser (){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAADUQ}
{\bkmkend AAAAAAADUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted after the user has changed the selection in the {\b QCustomPlot}, e.g. by clicking. It is not emitted when the selection state of an object has changed programmatically by a direct call to {\f2 setSelected()} /{\f2 setSelection()}  on an object or by calling {\b deselectAll}.\par
In addition to this signal, selectable objects also provide individual signals, for example {\b QCPAxis::selectionChanged} or {\b QCPAbstractPlottable::selectionChanged}. Note that those signals are emitted even if the selection state is changed programmatically.\par
See the documentation of {\b setInteractions} for details about the selection mechanism.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectedPlottables}, {\b selectedGraphs}, {\b selectedItems}, {\b selectedAxes}, {\b selectedLegends} \par
}}}
{\xe \v selectionRect\:QCustomPlot}
{\xe \v QCustomPlot\:selectionRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionRect} * QCustomPlot::selectionRect () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADUR}
{\bkmkend AAAAAAADUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allows access to the currently used {\b QCPSelectionRect} instance (or subclass thereof), that is used to handle and draw selection rect interactions (see {\b setSelectionRectMode}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectionRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3639 \{ return mSelectionRect; \}\par
}
}
{\xe \v selectionRectMode\:QCustomPlot}
{\xe \v QCustomPlot\:selectionRectMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionRectMode} QCustomPlot::selectionRectMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADUS}
{\bkmkend AAAAAAADUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3638 \{ return mSelectionRectMode; \}\par
}
}
{\xe \v selectionTolerance\:QCustomPlot}
{\xe \v QCustomPlot\:selectionTolerance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::selectionTolerance () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADUT}
{\bkmkend AAAAAAADUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3634 \{ return mSelectionTolerance; \}\par
}
}
{\xe \v setAntialiasedElement\:QCustomPlot}
{\xe \v QCustomPlot\:setAntialiasedElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setAntialiasedElement ({\b QCP::AntialiasedElement}  {\i antialiasedElement}, bool  {\i enabled} = {\f2 true})}}
\par
{\bkmkstart AAAAAAADUU}
{\bkmkend AAAAAAADUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the specified {\i antialiasedElement}  is forcibly drawn antialiased.\par
See {\b setAntialiasedElements} for details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setNotAntialiasedElement} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12995 \{\par
12996   if (!enabled && mAntialiasedElements.testFlag(antialiasedElement))\par
12997     mAntialiasedElements &= ~antialiasedElement;\par
12998   else if (enabled && !mAntialiasedElements.testFlag(antialiasedElement))\par
12999     mAntialiasedElements |= antialiasedElement;\par
13000   \par
13001   // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:\par
13002   if ((mNotAntialiasedElements & mAntialiasedElements) != 0)\par
13003     mNotAntialiasedElements |= ~mAntialiasedElements;\par
13004 \}\par
}
}
{\xe \v setAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:setAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setAntialiasedElements (const QCP::AntialiasedElements &  {\i antialiasedElements})}}
\par
{\bkmkstart AAAAAAADUV}
{\bkmkend AAAAAAADUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which elements are forcibly drawn antialiased as an {\i or}  combination of {\b QCP::AntialiasedElement}.\par
This overrides the antialiasing settings for whole element groups, normally controlled with the {\i setAntialiasing}  function on the individual elements. If an element is neither specified in {\b setAntialiasedElements} nor in {\b setNotAntialiasedElements}, the antialiasing setting on each individual element instance is used.\par
For example, if {\i antialiasedElements}  contains {\b QCP::aePlottables}, all plottables will be drawn antialiased, no matter what the specific {\b QCPAbstractPlottable::setAntialiased} value was set to.\par
if an element in {\i antialiasedElements}  is already set in {\b setNotAntialiasedElements}, it is removed from there.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setNotAntialiasedElements} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12979 \{\par
12980   mAntialiasedElements = antialiasedElements;\par
12981   \par
12982   // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:\par
12983   if ((mNotAntialiasedElements & mAntialiasedElements) != 0)\par
12984     mNotAntialiasedElements |= ~mAntialiasedElements;\par
12985 \}\par
}
}
{\xe \v setAutoAddPlottableToLegend\:QCustomPlot}
{\xe \v QCustomPlot\:setAutoAddPlottableToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setAutoAddPlottableToLegend (bool  {\i on})}}
\par
{\bkmkstart AAAAAAADUW}
{\bkmkend AAAAAAADUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If set to true, adding a plottable (e.g. a graph) to the {\b QCustomPlot} automatically also adds the plottable to the legend ({\b QCustomPlot::legend}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addGraph}, {\b QCPLegend::addItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13059 \{\par
13060   mAutoAddPlottableToLegend = on;\par
13061 \}\par
}
}
{\xe \v setBackground\:QCustomPlot}
{\xe \v QCustomPlot\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackground (const QPixmap &  {\i pm})}}
\par
{\bkmkstart AAAAAAADUX}
{\bkmkend AAAAAAADUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets {\i pm}  as the viewport background pixmap (see {\b setViewport}). The pixmap is always drawn below all other objects in the plot.\par
For cases where the provided pixmap doesn't have the same size as the viewport, scaling can be enabled with {\b setBackgroundScaled} and the scaling mode (whether and how the aspect ratio is preserved) can be set with {\b setBackgroundScaledMode}. To set all these options in one call, consider using the overloaded version of this function.\par
If a background brush was set with {\b setBackground(const QBrush &brush)}, the viewport will first be filled with that brush, before drawing the background pixmap. This can be useful for background pixmaps with translucent areas.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackgroundScaled}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13421 \{\par
13422   mBackgroundPixmap = pm;\par
13423   mScaledBackgroundPixmap = QPixmap();\par
13424 \}\par
}
}
{\xe \v setBackground\:QCustomPlot}
{\xe \v QCustomPlot\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackground (const QPixmap &  {\i pm}, bool  {\i scaled}, Qt::AspectRatioMode  {\i mode} = {\f2 Qt::KeepAspectRatioByExpanding})}}
\par
{\bkmkstart AAAAAAADUY}
{\bkmkend AAAAAAADUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Allows setting the background pixmap of the viewport, whether it shall be scaled and how it shall be scaled in one call.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground(const QPixmap &pm)}, {\b setBackgroundScaled}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13452 \{\par
13453   mBackgroundPixmap = pm;\par
13454   mScaledBackgroundPixmap = QPixmap();\par
13455   mBackgroundScaled = scaled;\par
13456   mBackgroundScaledMode = mode;\par
13457 \}\par
}
}
{\xe \v setBackground\:QCustomPlot}
{\xe \v QCustomPlot\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackground (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAADUZ}
{\bkmkend AAAAAAADUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the background brush of the viewport (see {\b setViewport}).\par
Before drawing everything else, the background is filled with {\i brush} . If a background pixmap was set with {\b setBackground(const QPixmap &pm)}, this brush will be used to fill the viewport before the background pixmap is drawn. This can be useful for background pixmaps with translucent areas.\par
Set {\i brush}  to Qt::NoBrush or Qt::Transparent to leave background transparent. This can be useful for exporting to image formats which support transparency, e.g. {\b savePng}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackgroundScaled}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13440 \{\par
13441   mBackgroundBrush = brush;\par
13442 \}\par
}
}
{\xe \v setBackgroundScaled\:QCustomPlot}
{\xe \v QCustomPlot\:setBackgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackgroundScaled (bool  {\i scaled})}}
\par
{\bkmkstart AAAAAAADVA}
{\bkmkend AAAAAAADVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the viewport background pixmap shall be scaled to fit the viewport. If {\i scaled}  is set to true, control whether and how the aspect ratio of the original pixmap is preserved with {\b setBackgroundScaledMode}.\par
Note that the scaled version of the original pixmap is buffered, so there is no performance penalty on replots. (Except when the viewport dimensions are changed continuously.)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13470 \{\par
13471   mBackgroundScaled = scaled;\par
13472 \}\par
}
}
{\xe \v setBackgroundScaledMode\:QCustomPlot}
{\xe \v QCustomPlot\:setBackgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBackgroundScaledMode (Qt::AspectRatioMode  {\i mode})}}
\par
{\bkmkstart AAAAAAADVB}
{\bkmkend AAAAAAADVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If scaling of the viewport background pixmap is enabled ({\b setBackgroundScaled}), use this function to define whether and how the aspect ratio of the original pixmap is preserved.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground}, {\b setBackgroundScaled} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13481 \{\par
13482   mBackgroundScaledMode = mode;\par
13483 \}\par
}
}
{\xe \v setBufferDevicePixelRatio\:QCustomPlot}
{\xe \v QCustomPlot\:setBufferDevicePixelRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setBufferDevicePixelRatio (double  {\i ratio})}}
\par
{\bkmkstart AAAAAAADVC}
{\bkmkend AAAAAAADVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the device pixel ratio used by the paint buffers of this {\b QCustomPlot} instance.\par
Normally, this doesn't need to be set manually, because it is initialized with the regular {\i QWidget::devicePixelRatio}  which is configured by Qt to fit the display device (e.g. 1 for normal displays, 2 for High-DPI displays).\par
Device pixel ratios are supported by Qt only for Qt versions since 5.4. If this method is called when {\b QCustomPlot} is being used with older Qt versions, outputs an according qDebug message and leaves the internal buffer device pixel ratio at 1.0. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13390 \{\par
13391   if (!qFuzzyCompare(ratio, mBufferDevicePixelRatio))\par
13392   \{\par
13393 #ifdef QCP_DEVICEPIXELRATIO_SUPPORTED\par
13394     mBufferDevicePixelRatio = ratio;\par
13395     for (int i=0; i<mPaintBuffers.size(); ++i)\par
13396       mPaintBuffers.at(i)->setDevicePixelRatio(mBufferDevicePixelRatio);\par
13397     // Note: axis label cache has devicePixelRatio as part of cache hash, so no need to manually clear cache here\par
13398 #else\par
13399     qDebug() << Q_FUNC_INFO << "Device pixel ratios not supported for Qt versions before 5.4";\par
13400     mBufferDevicePixelRatio = 1.0;\par
13401 #endif\par
13402   \}\par
13403 \}\par
}
}
{\xe \v setCurrentLayer\:QCustomPlot}
{\xe \v QCustomPlot\:setCurrentLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::setCurrentLayer (const QString &  {\i name})}}
\par
{\bkmkstart AAAAAAADVD}
{\bkmkend AAAAAAADVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the layer with the specified {\i name}  to be the current layer. All layerables ({\b QCPLayerable}), e.g. plottables and items, are created on the current layer.\par
Returns true on success, i.e. if there is a layer with the specified {\i name}  in the {\b QCustomPlot}.\par
Layer names are case-sensitive.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer}, {\b removeLayer}, {\b QCPLayerable::setLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14004 \{\par
14005   if (QCPLayer *newCurrentLayer = layer(name))\par
14006   \{\par
14007     return setCurrentLayer(newCurrentLayer);\par
14008   \} else\par
14009   \{\par
14010     qDebug() << Q_FUNC_INFO << "layer with name doesn't exist:" << name;\par
14011     return false;\par
14012   \}\par
14013 \}\par
}
}
{\xe \v setCurrentLayer\:QCustomPlot}
{\xe \v QCustomPlot\:setCurrentLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::setCurrentLayer ({\b QCPLayer} *  {\i layer})}}
\par
{\bkmkstart AAAAAAADVE}
{\bkmkend AAAAAAADVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.\par
Sets the provided {\i layer}  to be the current layer.\par
Returns true on success, i.e. when {\i layer}  is a valid layer in the {\b QCustomPlot}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addLayer}, {\b moveLayer}, {\b removeLayer} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14024 \{\par
14025   if (!mLayers.contains(layer))\par
14026   \{\par
14027     qDebug() << Q_FUNC_INFO << "layer not a layer of this QCustomPlot:" << reinterpret_cast<quintptr>(layer);\par
14028     return false;\par
14029   \}\par
14030   \par
14031   mCurrentLayer = layer;\par
14032   return true;\par
14033 \}\par
}
}
{\xe \v setInteraction\:QCustomPlot}
{\xe \v QCustomPlot\:setInteraction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setInteraction (const {\b QCP::Interaction} &  {\i interaction}, bool  {\i enabled} = {\f2 true})}}
\par
{\bkmkstart AAAAAAADVF}
{\bkmkend AAAAAAADVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the single {\i interaction}  of this {\b QCustomPlot} to {\i enabled} .\par
For details about the interaction system, see {\b setInteractions}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13130 \{\par
13131   if (!enabled && mInteractions.testFlag(interaction))\par
13132     mInteractions &= ~interaction;\par
13133   else if (enabled && !mInteractions.testFlag(interaction))\par
13134     mInteractions |= interaction;\par
13135 \}\par
}
}
{\xe \v setInteractions\:QCustomPlot}
{\xe \v QCustomPlot\:setInteractions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setInteractions (const QCP::Interactions &  {\i interactions})}}
\par
{\bkmkstart AAAAAAADVG}
{\bkmkend AAAAAAADVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the possible interactions of this {\b QCustomPlot} as an or-combination of {\b QCP::Interaction} enums. There are the following types of interactions:\par
{\b Axis range manipulation}  is controlled via {\b QCP::iRangeDrag} and {\b QCP::iRangeZoom}. When the respective interaction is enabled, the user may drag axes ranges and zoom with the mouse wheel. For details how to control which axes the user may drag/zoom and in what orientations, see {\b QCPAxisRect::setRangeDrag}, {\b QCPAxisRect::setRangeZoom}, {\b QCPAxisRect::setRangeDragAxes}, {\b QCPAxisRect::setRangeZoomAxes}.\par
{\b Plottable data selection}  is controlled by {\b QCP::iSelectPlottables}. If {\b QCP::iSelectPlottables} is set, the user may select plottables (graphs, curves, bars,...) and their data by clicking on them or in their vicinity ({\b setSelectionTolerance}). Whether the user can actually select a plottable and its data can further be restricted with the {\b QCPAbstractPlottable::setSelectable} method on the specific plottable. For details, see the special page about the data selection mechanism. To retrieve a list of all currently selected plottables, call {\b selectedPlottables}. If you're only interested in QCPGraphs, you may use the convenience function {\b selectedGraphs}.\par
{\b Item selection}  is controlled by {\b QCP::iSelectItems}. If {\b QCP::iSelectItems} is set, the user may select items ({\b QCPItemLine}, {\b QCPItemText},...) by clicking on them or in their vicinity. To find out whether a specific item is selected, call {\b QCPAbstractItem::selected()}. To retrieve a list of all currently selected items, call {\b selectedItems}.\par
{\b Axis selection}  is controlled with {\b QCP::iSelectAxes}. If {\b QCP::iSelectAxes} is set, the user may select parts of the axes by clicking on them. What parts exactly (e.g. Axis base line, tick labels, axis label) are selectable can be controlled via {\b QCPAxis::setSelectableParts} for each axis. To retrieve a list of all axes that currently contain selected parts, call {\b selectedAxes}. Which parts of an axis are selected, can be retrieved with {\b QCPAxis::selectedParts()}.\par
{\b Legend selection}  is controlled with {\b QCP::iSelectLegend}. If this is set, the user may select the legend itself or individual items by clicking on them. What parts exactly are selectable can be controlled via {\b QCPLegend::setSelectableParts}. To find out whether the legend or any of its child items are selected, check the value of {\b QCPLegend::selectedParts}. To find out which child items are selected, call {\b QCPLegend::selectedItems}.\par
{\b All other selectable elements}  The selection of all other selectable objects (e.g. {\b QCPTextElement}, or your own layerable subclasses) is controlled with {\b QCP::iSelectOther}. If set, the user may select those objects by clicking on them. To find out which are currently selected, you need to check their selected state explicitly.\par
If the selection state has changed by user interaction, the {\b selectionChangedByUser} signal is emitted. Each selectable object additionally emits an individual selectionChanged signal whenever their selection state has changed, i.e. not only by user interaction.\par
To allow multiple objects to be selected by holding the selection modifier ({\b setMultiSelectModifier}), set the flag {\b QCP::iMultiSelect}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid In addition to the selection mechanism presented here, {\b QCustomPlot} always emits corresponding signals, when an object is clicked or double clicked. see {\b plottableClick} and {\b plottableDoubleClick} for example.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteraction}, {\b setSelectionTolerance} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13118 \{\par
13119   mInteractions = interactions;\par
13120 \}\par
}
}
{\xe \v setMultiSelectModifier\:QCustomPlot}
{\xe \v QCustomPlot\:setMultiSelectModifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setMultiSelectModifier (Qt::KeyboardModifier  {\i modifier})}}
\par
{\bkmkstart AAAAAAADVH}
{\bkmkend AAAAAAADVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the keyboard modifier that will be recognized as multi-select-modifier.\par
If {\b QCP::iMultiSelect} is specified in {\b setInteractions}, the user may select multiple objects (or data points) by clicking on them one after the other while holding down {\i modifier} .\par
By default the multi-select-modifier is set to Qt::ControlModifier.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13207 \{\par
13208   mMultiSelectModifier = modifier;\par
13209 \}\par
}
}
{\xe \v setNoAntialiasingOnDrag\:QCustomPlot}
{\xe \v QCustomPlot\:setNoAntialiasingOnDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setNoAntialiasingOnDrag (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAADVI}
{\bkmkend AAAAAAADVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether antialiasing is disabled for this {\b QCustomPlot} while the user is dragging axes ranges. If many objects, especially plottables, are drawn antialiased, this greatly improves performance during dragging. Thus it creates a more responsive user experience. As soon as the user stops dragging, the last replot is done with normal antialiasing, to restore high image quality.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAntialiasedElements}, {\b setNotAntialiasedElements} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13165 \{\par
13166   mNoAntialiasingOnDrag = enabled;\par
13167 \}\par
}
}
{\xe \v setNotAntialiasedElement\:QCustomPlot}
{\xe \v QCustomPlot\:setNotAntialiasedElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setNotAntialiasedElement ({\b QCP::AntialiasedElement}  {\i notAntialiasedElement}, bool  {\i enabled} = {\f2 true})}}
\par
{\bkmkstart AAAAAAADVJ}
{\bkmkend AAAAAAADVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the specified {\i notAntialiasedElement}  is forcibly drawn not antialiased.\par
See {\b setNotAntialiasedElements} for details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAntialiasedElement} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13041 \{\par
13042   if (!enabled && mNotAntialiasedElements.testFlag(notAntialiasedElement))\par
13043     mNotAntialiasedElements &= ~notAntialiasedElement;\par
13044   else if (enabled && !mNotAntialiasedElements.testFlag(notAntialiasedElement))\par
13045     mNotAntialiasedElements |= notAntialiasedElement;\par
13046   \par
13047   // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:\par
13048   if ((mNotAntialiasedElements & mAntialiasedElements) != 0)\par
13049     mAntialiasedElements |= ~mNotAntialiasedElements;\par
13050 \}\par
}
}
{\xe \v setNotAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:setNotAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setNotAntialiasedElements (const QCP::AntialiasedElements &  {\i notAntialiasedElements})}}
\par
{\bkmkstart AAAAAAADVK}
{\bkmkend AAAAAAADVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which elements are forcibly drawn not antialiased as an {\i or}  combination of {\b QCP::AntialiasedElement}.\par
This overrides the antialiasing settings for whole element groups, normally controlled with the {\i setAntialiasing}  function on the individual elements. If an element is neither specified in {\b setAntialiasedElements} nor in {\b setNotAntialiasedElements}, the antialiasing setting on each individual element instance is used.\par
For example, if {\i notAntialiasedElements}  contains {\b QCP::aePlottables}, no plottables will be drawn antialiased, no matter what the specific {\b QCPAbstractPlottable::setAntialiased} value was set to.\par
if an element in {\i notAntialiasedElements}  is already set in {\b setAntialiasedElements}, it is removed from there.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAntialiasedElements} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13025 \{\par
13026   mNotAntialiasedElements = notAntialiasedElements;\par
13027   \par
13028   // make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:\par
13029   if ((mNotAntialiasedElements & mAntialiasedElements) != 0)\par
13030     mAntialiasedElements |= ~mNotAntialiasedElements;\par
13031 \}\par
}
}
{\xe \v setOpenGl\:QCustomPlot}
{\xe \v QCustomPlot\:setOpenGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setOpenGl (bool  {\i enabled}, int  {\i multisampling} = {\f2 16})}}
\par
{\bkmkstart AAAAAAADVL}
{\bkmkend AAAAAAADVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This is still an experimental feature and its performance depends on the system that it runs on. Having multiple {\b QCustomPlot} widgets in one application with enabled OpenGL rendering might cause context conflicts on some systems.\par
}This method allows to enable OpenGL plot rendering, for increased plotting performance of graphically demanding plots (thick lines, translucent fills, etc.).\par
If {\i enabled}  is set to true, {\b QCustomPlot} will try to initialize OpenGL and, if successful, continue plotting with hardware acceleration. The parameter {\i multisampling}  controls how many samples will be used per pixel, it essentially controls the antialiasing quality. If {\i multisampling}  is set too high for the current graphics hardware, the maximum allowed value will be used.\par
You can test whether switching to OpenGL rendering was successful by checking whether the according getter {\i {\b QCustomPlot::openGl()}}  returns true. If the OpenGL initialization fails, rendering continues with the regular software rasterizer, and an according qDebug output is generated.\par
If switching to OpenGL was successful, this method disables label caching ({\b setPlottingHint(QCP::phCacheLabels, false)}) and turns on {\b QCustomPlot}'s antialiasing override for all elements ({\b setAntialiasedElements(QCP::aeAll)}), leading to a higher quality output. The antialiasing override allows for pixel-grid aligned drawing in the OpenGL paint device. As stated before, in OpenGL rendering the actual antialiasing of the plot is controlled with {\i multisampling} . If {\i enabled}  is set to false, the antialiasing/label caching settings are restored to what they were before OpenGL was enabled, if they weren't altered in the meantime.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid OpenGL support is only enabled if {\b QCustomPlot} is compiled with the macro {\f2 QCUSTOMPLOT_USE_OPENGL}  defined. This define must be set before including the {\b QCustomPlot} header both during compilation of the {\b QCustomPlot} library as well as when compiling your application. It is best to just include the line {\f2 DEFINES += QCUSTOMPLOT_USE_OPENGL}  in the respective qmake project files. \par
If you are using a Qt version before 5.0, you must also add the module "opengl" to your {\f2 QT}  variable in the qmake project files. For Qt versions 5.0 and higher, {\b QCustomPlot} switches to a newer OpenGL interface which is already in the "gui" module. \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13318 \{\par
13319   mOpenGlMultisamples = qMax(0, multisampling);\par
13320 #ifdef QCUSTOMPLOT_USE_OPENGL\par
13321   mOpenGl = enabled;\par
13322   if (mOpenGl)\par
13323   \{\par
13324     if (setupOpenGl())\par
13325     \{\par
13326       // backup antialiasing override and labelcaching setting so we can restore upon disabling OpenGL\par
13327       mOpenGlAntialiasedElementsBackup = mAntialiasedElements;\par
13328       mOpenGlCacheLabelsBackup = mPlottingHints.testFlag(QCP::phCacheLabels);\par
13329       // set antialiasing override to antialias all (aligns gl pixel grid properly), and disable label caching (would use software rasterizer for pixmap caches):\par
13330       setAntialiasedElements(QCP::aeAll);\par
13331       setPlottingHint(QCP::phCacheLabels, false);\par
13332     \} else\par
13333     \{\par
13334       qDebug() << Q_FUNC_INFO << "Failed to enable OpenGL, continuing plotting without hardware acceleration.";\par
13335       mOpenGl = false;\par
13336     \}\par
13337   \} else\par
13338   \{\par
13339     // restore antialiasing override and labelcaching to what it was before enabling OpenGL, if nobody changed it in the meantime:\par
13340     if (mAntialiasedElements == QCP::aeAll)\par
13341       setAntialiasedElements(mOpenGlAntialiasedElementsBackup);\par
13342     if (!mPlottingHints.testFlag(QCP::phCacheLabels))\par
13343       setPlottingHint(QCP::phCacheLabels, mOpenGlCacheLabelsBackup);\par
13344     freeOpenGl();\par
13345   \}\par
13346   // recreate all paint buffers:\par
13347   mPaintBuffers.clear();\par
13348   setupPaintBuffers();\par
13349 #else\par
13350   Q_UNUSED(enabled)\par
13351   qDebug() << Q_FUNC_INFO << "QCustomPlot can't use OpenGL because QCUSTOMPLOT_USE_OPENGL was not defined during compilation (add 'DEFINES += QCUSTOMPLOT_USE_OPENGL' to your qmake .pro file)";\par
13352 #endif\par
13353 \}\par
}
}
{\xe \v setPlottingHint\:QCustomPlot}
{\xe \v QCustomPlot\:setPlottingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setPlottingHint ({\b QCP::PlottingHint}  {\i hint}, bool  {\i enabled} = {\f2 true})}}
\par
{\bkmkstart AAAAAAADVM}
{\bkmkend AAAAAAADVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the specified plotting {\i hint}  to {\i enabled} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPlottingHints} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13185 \{\par
13186   QCP::PlottingHints newHints = mPlottingHints;\par
13187   if (!enabled)\par
13188     newHints &= ~hint;\par
13189   else\par
13190     newHints |= hint;\par
13191   \par
13192   if (newHints != mPlottingHints)\par
13193     setPlottingHints(newHints);\par
13194 \}\par
}
}
{\xe \v setPlottingHints\:QCustomPlot}
{\xe \v QCustomPlot\:setPlottingHints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setPlottingHints (const QCP::PlottingHints &  {\i hints})}}
\par
{\bkmkstart AAAAAAADVN}
{\bkmkend AAAAAAADVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the plotting hints for this {\b QCustomPlot} instance as an {\i or}  combination of {\b QCP::PlottingHint}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPlottingHint} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13175 \{\par
13176   mPlottingHints = hints;\par
13177 \}\par
}
}
{\xe \v setSelectionRect\:QCustomPlot}
{\xe \v QCustomPlot\:setSelectionRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setSelectionRect ({\b QCPSelectionRect} *  {\i selectionRect})}}
\par
{\bkmkstart AAAAAAADVO}
{\bkmkend AAAAAAADVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\b QCPSelectionRect} instance that {\b QCustomPlot} will use if {\i mode}  is not {\b QCP::srmNone} and the user performs a click-and-drag interaction. {\b QCustomPlot} takes ownership of the passed {\i selectionRect} . It can be accessed later via {\b selectionRect}.\par
This method is useful if you wish to replace the default {\b QCPSelectionRect} instance with an instance of a {\b QCPSelectionRect} subclass, to introduce custom behaviour of the selection rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectionRectMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13265 \{\par
13266   if (mSelectionRect)\par
13267     delete mSelectionRect;\par
13268   \par
13269   mSelectionRect = selectionRect;\par
13270   \par
13271   if (mSelectionRect)\par
13272   \{\par
13273     // establish connections with new selection rect:\par
13274     if (mSelectionRectMode == QCP::srmSelect)\par
13275       connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectSelection(QRect,QMouseEvent*)));\par
13276     else if (mSelectionRectMode == QCP::srmZoom)\par
13277       connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectZoom(QRect,QMouseEvent*)));\par
13278   \}\par
13279 \}\par
}
}
{\xe \v setSelectionRectMode\:QCustomPlot}
{\xe \v QCustomPlot\:setSelectionRectMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setSelectionRectMode ({\b QCP::SelectionRectMode}  {\i mode})}}
\par
{\bkmkstart AAAAAAADVP}
{\bkmkend AAAAAAADVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how {\b QCustomPlot} processes mouse click-and-drag interactions by the user.\par
If {\i mode}  is {\b QCP::srmNone}, the mouse drag is forwarded to the underlying objects. For example, {\b QCPAxisRect} may process a mouse drag by dragging axis ranges, see {\b QCPAxisRect::setRangeDrag}. If {\i mode}  is not {\b QCP::srmNone}, the current selection rect ({\b selectionRect}) becomes activated and allows e.g. rect zooming and data point selection.\par
If you wish to provide your user both with axis range dragging and data selection/range zooming, use this method to switch between the modes just before the interaction is processed, e.g. in reaction to the {\b mousePress} or {\b mouseMove} signals. For example you could check whether the user is holding a certain keyboard modifier, and then decide which {\i mode}  shall be set.\par
If a selection rect interaction is currently active, and {\i mode}  is set to {\b QCP::srmNone}, the interaction is canceled ({\b QCPSelectionRect::cancel}). Switching between any of the other modes will keep the selection rect active. Upon completion of the interaction, the behaviour is as defined by the currently set {\i mode} , not the mode that was set when the interaction started.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b setSelectionRect}, {\b QCPSelectionRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13232 \{\par
13233   if (mSelectionRect)\par
13234   \{\par
13235     if (mode == QCP::srmNone)\par
13236       mSelectionRect->cancel(); // when switching to none, we immediately want to abort a potentially active selection rect\par
13237     \par
13238     // disconnect old connections:\par
13239     if (mSelectionRectMode == QCP::srmSelect)\par
13240       disconnect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectSelection(QRect,QMouseEvent*)));\par
13241     else if (mSelectionRectMode == QCP::srmZoom)\par
13242       disconnect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectZoom(QRect,QMouseEvent*)));\par
13243     \par
13244     // establish new ones:\par
13245     if (mode == QCP::srmSelect)\par
13246       connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectSelection(QRect,QMouseEvent*)));\par
13247     else if (mode == QCP::srmZoom)\par
13248       connect(mSelectionRect, SIGNAL(accepted(QRect,QMouseEvent*)), this, SLOT(processRectZoom(QRect,QMouseEvent*)));\par
13249   \}\par
13250   \par
13251   mSelectionRectMode = mode;\par
13252 \}\par
}
}
{\xe \v setSelectionTolerance\:QCustomPlot}
{\xe \v QCustomPlot\:setSelectionTolerance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setSelectionTolerance (int  {\i pixels})}}
\par
{\bkmkstart AAAAAAADVQ}
{\bkmkend AAAAAAADVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the tolerance that is used to decide whether a click selects an object (e.g. a plottable) or not.\par
If the user clicks in the vicinity of the line of e.g. a {\b QCPGraph}, it's only regarded as a potential selection when the minimum distance between the click position and the graph line is smaller than {\i pixels} . Objects that are defined by an area (e.g. {\b QCPBars}) only react to clicks directly inside the area and ignore this selection tolerance. In other words, it only has meaning for parts of objects that are too thin to exactly hit with a click and thus need such a tolerance.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setInteractions}, {\b QCPLayerable::selectTest} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13151 \{\par
13152   mSelectionTolerance = pixels;\par
13153 \}\par
}
}
{\xe \v setupOpenGl\:QCustomPlot}
{\xe \v QCustomPlot\:setupOpenGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::setupOpenGl (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADVR}
{\bkmkend AAAAAAADVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15159 \{\par
15160 #ifdef QCP_OPENGL_FBO\par
15161   freeOpenGl();\par
15162   QSurfaceFormat proposedSurfaceFormat;\par
15163   proposedSurfaceFormat.setSamples(mOpenGlMultisamples);\par
15164 #ifdef QCP_OPENGL_OFFSCREENSURFACE\par
15165   QOffscreenSurface *surface = new QOffscreenSurface;\par
15166 #else\par
15167   QWindow *surface = new QWindow;\par
15168   surface->setSurfaceType(QSurface::OpenGLSurface);\par
15169 #endif\par
15170   surface->setFormat(proposedSurfaceFormat);\par
15171   surface->create();\par
15172   mGlSurface = QSharedPointer<QSurface>(surface);\par
15173   mGlContext = QSharedPointer<QOpenGLContext>(new QOpenGLContext);\par
15174   mGlContext->setFormat(mGlSurface->format());\par
15175   if (!mGlContext->create())\par
15176   \{\par
15177     qDebug() << Q_FUNC_INFO << "Failed to create OpenGL context";\par
15178     mGlContext.clear();\par
15179     mGlSurface.clear();\par
15180     return false;\par
15181   \}\par
15182   if (!mGlContext->makeCurrent(mGlSurface.data())) // context needs to be current to create paint device\par
15183   \{\par
15184     qDebug() << Q_FUNC_INFO << "Failed to make opengl context current";\par
15185     mGlContext.clear();\par
15186     mGlSurface.clear();\par
15187     return false;\par
15188   \}\par
15189   if (!QOpenGLFramebufferObject::hasOpenGLFramebufferObjects())\par
15190   \{\par
15191     qDebug() << Q_FUNC_INFO << "OpenGL of this system doesn't support frame buffer objects";\par
15192     mGlContext.clear();\par
15193     mGlSurface.clear();\par
15194     return false;\par
15195   \}\par
15196   mGlPaintDevice = QSharedPointer<QOpenGLPaintDevice>(new QOpenGLPaintDevice);\par
15197   return true;\par
15198 #elif defined(QCP_OPENGL_PBUFFER)\par
15199   return QGLFormat::hasOpenGL();\par
15200 #else\par
15201   return false;\par
15202 #endif\par
15203 \}\par
}
}
{\xe \v setupPaintBuffers\:QCustomPlot}
{\xe \v QCustomPlot\:setupPaintBuffers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setupPaintBuffers (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADVS}
{\bkmkend AAAAAAADVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15063 \{\par
15064   int bufferIndex = 0;\par
15065   if (mPaintBuffers.isEmpty())\par
15066     mPaintBuffers.append(QSharedPointer<QCPAbstractPaintBuffer>(createPaintBuffer()));\par
15067   \par
15068   for (int layerIndex = 0; layerIndex < mLayers.size(); ++layerIndex)\par
15069   \{\par
15070     QCPLayer *layer = mLayers.at(layerIndex);\par
15071     if (layer->mode() == QCPLayer::lmLogical)\par
15072     \{\par
15073       layer->mPaintBuffer = mPaintBuffers.at(bufferIndex).toWeakRef();\par
15074     \} else if (layer->mode() == QCPLayer::lmBuffered)\par
15075     \{\par
15076       ++bufferIndex;\par
15077       if (bufferIndex >= mPaintBuffers.size())\par
15078         mPaintBuffers.append(QSharedPointer<QCPAbstractPaintBuffer>(createPaintBuffer()));\par
15079       layer->mPaintBuffer = mPaintBuffers.at(bufferIndex).toWeakRef();\par
15080       if (layerIndex < mLayers.size()-1 && mLayers.at(layerIndex+1)->mode() == QCPLayer::lmLogical) // not last layer, and next one is logical, so prepare another buffer for next layerables\par
15081       \{\par
15082         ++bufferIndex;\par
15083         if (bufferIndex >= mPaintBuffers.size())\par
15084           mPaintBuffers.append(QSharedPointer<QCPAbstractPaintBuffer>(createPaintBuffer()));\par
15085       \}\par
15086     \}\par
15087   \}\par
15088   // remove unneeded buffers:\par
15089   while (mPaintBuffers.size()-1 > bufferIndex)\par
15090     mPaintBuffers.removeLast();\par
15091   // resize buffers to viewport size and clear contents:\par
15092   for (int i=0; i<mPaintBuffers.size(); ++i)\par
15093   \{\par
15094     mPaintBuffers.at(i)->setSize(viewport().size()); // won't do anything if already correct size\par
15095     mPaintBuffers.at(i)->clear(Qt::transparent);\par
15096     mPaintBuffers.at(i)->setInvalidated();\par
15097   \}\par
15098 \}\par
}
}
{\xe \v setViewport\:QCustomPlot}
{\xe \v QCustomPlot\:setViewport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::setViewport (const QRect &  {\i rect})}}
\par
{\bkmkstart AAAAAAADVT}
{\bkmkend AAAAAAADVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the viewport of this {\b QCustomPlot}. Usually users of {\b QCustomPlot} don't need to change the viewport manually.\par
The viewport is the area in which the plot is drawn. All mechanisms, e.g. margin caluclation take the viewport to be the outer border of the plot. The viewport normally is the rect() of the {\b QCustomPlot} widget, i.e. a rect with top left (0, 0) and size of the {\b QCustomPlot} widget.\par
Don't confuse the viewport with the axis rect ({\b QCustomPlot::axisRect}). An axis rect is typically an area enclosed by four axes, where the graphs/plottables are drawn in. The viewport is larger and contains also the axes themselves, their tick numbers, their labels, or even additional axis rects, color scales and other layout elements.\par
This function is used to allow arbitrary size exports with {\b toPixmap}, {\b savePng}, {\b savePdf}, etc. by temporarily changing the viewport size. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13372 \{\par
13373   mViewport = rect;\par
13374   if (mPlotLayout)\par
13375     mPlotLayout->setOuterRect(mViewport);\par
13376 \}\par
}
}
{\xe \v sizeHint\:QCustomPlot}
{\xe \v QCustomPlot\:sizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCustomPlot::sizeHint () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVU}
{\bkmkend AAAAAAADVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14709 \{\par
14710   return mPlotLayout->minimumOuterSizeHint();\par
14711 \}\par
}
}
{\xe \v toPainter\:QCustomPlot}
{\xe \v QCustomPlot\:toPainter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::toPainter ({\b QCPPainter} *  {\i painter}, int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0})}}
\par
{\bkmkstart AAAAAAADVV}
{\bkmkend AAAAAAADVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renders the plot using the passed {\i painter} .\par
The plot is sized to {\i width}  and {\i height}  in pixels. If the {\i painter's}  scale is not 1.0, the resulting plot will appear scaled accordingly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If you are restricted to using a QPainter (instead of {\b QCPPainter}), create a temporary QPicture and open a {\b QCPPainter} on it. Then call {\b toPainter} with this {\b QCPPainter}. After ending the paint operation on the picture, draw it with the QPainter. This will reproduce the painter actions the {\b QCPPainter} took, with a QPainter.\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b toPixmap} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15692 \{\par
15693   // this method is somewhat similar to toPixmap. Change something here, and a change in toPixmap might be necessary, too.\par
15694   int newWidth, newHeight;\par
15695   if (width == 0 || height == 0)\par
15696   \{\par
15697     newWidth = this->width();\par
15698     newHeight = this->height();\par
15699   \} else\par
15700   \{\par
15701     newWidth = width;\par
15702     newHeight = height;\par
15703   \}\par
15704 \par
15705   if (painter->isActive())\par
15706   \{\par
15707     QRect oldViewport = viewport();\par
15708     setViewport(QRect(0, 0, newWidth, newHeight));\par
15709     painter->setMode(QCPPainter::pmNoCaching);\par
15710     if (mBackgroundBrush.style() != Qt::NoBrush) // unlike in toPixmap, we can't do QPixmap::fill for Qt::SolidPattern brush style, so we also draw solid fills with fillRect here\par
15711       painter->fillRect(mViewport, mBackgroundBrush);\par
15712     draw(painter);\par
15713     setViewport(oldViewport);\par
15714   \} else\par
15715     qDebug() << Q_FUNC_INFO << "Passed painter is not active";\par
15716 \}\par
}
}
{\xe \v toPixmap\:QCustomPlot}
{\xe \v QCustomPlot\:toPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCustomPlot::toPixmap (int  {\i width} = {\f2 0}, int  {\i height} = {\f2 0}, double  {\i scale} = {\f2 1.0})}}
\par
{\bkmkstart AAAAAAADVW}
{\bkmkend AAAAAAADVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renders the plot to a pixmap and returns it.\par
The plot is sized to {\i width}  and {\i height}  in pixels and scaled with {\i scale} . (width 100 and scale 2.0 lead to a full resolution pixmap with width 200.)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b toPainter}, {\b saveRastered}, {\b saveBmp}, {\b savePng}, {\b saveJpg}, {\b savePdf} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15636 \{\par
15637   // this method is somewhat similar to toPainter. Change something here, and a change in toPainter might be necessary, too.\par
15638   int newWidth, newHeight;\par
15639   if (width == 0 || height == 0)\par
15640   \{\par
15641     newWidth = this->width();\par
15642     newHeight = this->height();\par
15643   \} else\par
15644   \{\par
15645     newWidth = width;\par
15646     newHeight = height;\par
15647   \}\par
15648   int scaledWidth = qRound(scale*newWidth);\par
15649   int scaledHeight = qRound(scale*newHeight);\par
15650 \par
15651   QPixmap result(scaledWidth, scaledHeight);\par
15652   result.fill(mBackgroundBrush.style() == Qt::SolidPattern ? mBackgroundBrush.color() : Qt::transparent); // if using non-solid pattern, make transparent now and draw brush pattern later\par
15653   QCPPainter painter;\par
15654   painter.begin(&result);\par
15655   if (painter.isActive())\par
15656   \{\par
15657     QRect oldViewport = viewport();\par
15658     setViewport(QRect(0, 0, newWidth, newHeight));\par
15659     painter.setMode(QCPPainter::pmNoCaching);\par
15660     if (!qFuzzyCompare(scale, 1.0))\par
15661     \{\par
15662       if (scale > 1.0) // for scale < 1 we always want cosmetic pens where possible, because else lines might disappear for very small scales\par
15663         painter.setMode(QCPPainter::pmNonCosmetic);\par
15664       painter.scale(scale, scale);\par
15665     \}\par
15666     if (mBackgroundBrush.style() != Qt::SolidPattern && mBackgroundBrush.style() != Qt::NoBrush) // solid fills were done a few lines above with QPixmap::fill\par
15667       painter.fillRect(mViewport, mBackgroundBrush);\par
15668     draw(&painter);\par
15669     setViewport(oldViewport);\par
15670     painter.end();\par
15671   \} else // might happen if pixmap has width or height zero\par
15672   \{\par
15673     qDebug() << Q_FUNC_INFO << "Couldn't activate painter on pixmap";\par
15674     return QPixmap();\par
15675   \}\par
15676   return result;\par
15677 \}\par
}
}
{\xe \v updateLayerIndices\:QCustomPlot}
{\xe \v QCustomPlot\:updateLayerIndices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::updateLayerIndices () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADVX}
{\bkmkend AAAAAAADVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15517 \{\par
15518   for (int i=0; i<mLayers.size(); ++i)\par
15519     mLayers.at(i)->mIndex = i;\par
15520 \}\par
}
}
{\xe \v updateLayout\:QCustomPlot}
{\xe \v QCustomPlot\:updateLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::updateLayout (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADVY}
{\bkmkend AAAAAAADVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14997 \{\par
14998   // run through layout phases:\par
14999   mPlotLayout->update(QCPLayoutElement::upPreparation);\par
15000   mPlotLayout->update(QCPLayoutElement::upMargins);\par
15001   mPlotLayout->update(QCPLayoutElement::upLayout);\par
15002 \}\par
}
}
{\xe \v viewport\:QCustomPlot}
{\xe \v QCustomPlot\:viewport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCustomPlot::viewport () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADVZ}
{\bkmkend AAAAAAADVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3624 \{ return mViewport; \}\par
}
}
{\xe \v wheelEvent\:QCustomPlot}
{\xe \v QCustomPlot\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCustomPlot::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADWA}
{\bkmkend AAAAAAADWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14941 \{\par
14942   emit mouseWheel(event);\par
14943   // forward event to layerable under cursor:\par
14944   QList<QCPLayerable*> candidates = layerableListAt(event->pos(), false);\par
14945   for (int i=0; i<candidates.size(); ++i)\par
14946   \{\par
14947     event->accept(); // default impl of QCPLayerable's mouse events ignore the event, in that case propagate to next candidate in list\par
14948     candidates.at(i)->wheelEvent(event);\par
14949     if (event->isAccepted())\par
14950       break;\par
14951   \}\par
14952   event->accept(); // in case QCPLayerable reimplementation manipulates event accepted state. In QWidget event system, QCustomPlot wants to accept the event.\par
14953 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v QCPAbstractItem\:QCustomPlot}
{\xe \v QCustomPlot\:QCPAbstractItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAbstractItem}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADWB}
{\bkmkend AAAAAAADWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPAbstractPlottable\:QCustomPlot}
{\xe \v QCustomPlot\:QCPAbstractPlottable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAbstractPlottable}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADWC}
{\bkmkend AAAAAAADWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPAxis\:QCustomPlot}
{\xe \v QCustomPlot\:QCPAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAxis}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADWD}
{\bkmkend AAAAAAADWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPAxisRect\:QCustomPlot}
{\xe \v QCustomPlot\:QCPAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAxisRect}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADWE}
{\bkmkend AAAAAAADWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPGraph\:QCustomPlot}
{\xe \v QCustomPlot\:QCPGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPGraph}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADWF}
{\bkmkend AAAAAAADWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPLayer\:QCustomPlot}
{\xe \v QCustomPlot\:QCPLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLayer}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADWG}
{\bkmkend AAAAAAADWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPLegend\:QCustomPlot}
{\xe \v QCustomPlot\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAADWH}
{\bkmkend AAAAAAADWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v legend\:QCustomPlot}
{\xe \v QCustomPlot\:legend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLegend} * QCustomPlot::legend}}
\par
{\bkmkstart AAAAAAADWI}
{\bkmkend AAAAAAADWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the default legend of the main axis rect. The legend is invisible by default. Use {\b QCPLegend::setVisible} to change this.\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple legends to the plot, use the layout system interface to access the new legend. For example, legends can be placed inside an axis rect's {\b inset layout}, and must then also be accessed via the inset layout. If the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointer becomes 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\xe \v mAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:mAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::mAntialiasedElements{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWJ}
{\bkmkend AAAAAAADWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAutoAddPlottableToLegend\:QCustomPlot}
{\xe \v QCustomPlot\:mAutoAddPlottableToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mAutoAddPlottableToLegend{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWK}
{\bkmkend AAAAAAADWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundBrush\:QCustomPlot}
{\xe \v QCustomPlot\:mBackgroundBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCustomPlot::mBackgroundBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWL}
{\bkmkend AAAAAAADWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundPixmap\:QCustomPlot}
{\xe \v QCustomPlot\:mBackgroundPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCustomPlot::mBackgroundPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWM}
{\bkmkend AAAAAAADWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundScaled\:QCustomPlot}
{\xe \v QCustomPlot\:mBackgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mBackgroundScaled{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWN}
{\bkmkend AAAAAAADWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundScaledMode\:QCustomPlot}
{\xe \v QCustomPlot\:mBackgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCustomPlot::mBackgroundScaledMode{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWO}
{\bkmkend AAAAAAADWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBufferDevicePixelRatio\:QCustomPlot}
{\xe \v QCustomPlot\:mBufferDevicePixelRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCustomPlot::mBufferDevicePixelRatio{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWP}
{\bkmkend AAAAAAADWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mCurrentLayer\:QCustomPlot}
{\xe \v QCustomPlot\:mCurrentLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCustomPlot::mCurrentLayer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWQ}
{\bkmkend AAAAAAADWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mGraphs\:QCustomPlot}
{\xe \v QCustomPlot\:mGraphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPGraph}*> QCustomPlot::mGraphs{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWR}
{\bkmkend AAAAAAADWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInteractions\:QCustomPlot}
{\xe \v QCustomPlot\:mInteractions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::Interactions QCustomPlot::mInteractions{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWS}
{\bkmkend AAAAAAADWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mItems\:QCustomPlot}
{\xe \v QCustomPlot\:mItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPAbstractItem}*> QCustomPlot::mItems{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWT}
{\bkmkend AAAAAAADWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLayers\:QCustomPlot}
{\xe \v QCustomPlot\:mLayers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPLayer}*> QCustomPlot::mLayers{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWU}
{\bkmkend AAAAAAADWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseEventLayerable\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseEventLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPLayerable}> QCustomPlot::mMouseEventLayerable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWV}
{\bkmkend AAAAAAADWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseEventLayerableDetails\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseEventLayerableDetails}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant QCustomPlot::mMouseEventLayerableDetails{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWW}
{\bkmkend AAAAAAADWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseHasMoved\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseHasMoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mMouseHasMoved{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWX}
{\bkmkend AAAAAAADWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMousePressPos\:QCustomPlot}
{\xe \v QCustomPlot\:mMousePressPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCustomPlot::mMousePressPos{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWY}
{\bkmkend AAAAAAADWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseSignalLayerable\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseSignalLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPLayerable}> QCustomPlot::mMouseSignalLayerable{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADWZ}
{\bkmkend AAAAAAADWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMouseSignalLayerableDetails\:QCustomPlot}
{\xe \v QCustomPlot\:mMouseSignalLayerableDetails}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant QCustomPlot::mMouseSignalLayerableDetails{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXA}
{\bkmkend AAAAAAADXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMultiSelectModifier\:QCustomPlot}
{\xe \v QCustomPlot\:mMultiSelectModifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::KeyboardModifier QCustomPlot::mMultiSelectModifier{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXB}
{\bkmkend AAAAAAADXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNoAntialiasingOnDrag\:QCustomPlot}
{\xe \v QCustomPlot\:mNoAntialiasingOnDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mNoAntialiasingOnDrag{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXC}
{\bkmkend AAAAAAADXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNotAntialiasedElements\:QCustomPlot}
{\xe \v QCustomPlot\:mNotAntialiasedElements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::mNotAntialiasedElements{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXD}
{\bkmkend AAAAAAADXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOpenGl\:QCustomPlot}
{\xe \v QCustomPlot\:mOpenGl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mOpenGl{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXE}
{\bkmkend AAAAAAADXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOpenGlAntialiasedElementsBackup\:QCustomPlot}
{\xe \v QCustomPlot\:mOpenGlAntialiasedElementsBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCustomPlot::mOpenGlAntialiasedElementsBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXF}
{\bkmkend AAAAAAADXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOpenGlCacheLabelsBackup\:QCustomPlot}
{\xe \v QCustomPlot\:mOpenGlCacheLabelsBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mOpenGlCacheLabelsBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXG}
{\bkmkend AAAAAAADXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOpenGlMultisamples\:QCustomPlot}
{\xe \v QCustomPlot\:mOpenGlMultisamples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::mOpenGlMultisamples{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXH}
{\bkmkend AAAAAAADXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPaintBuffers\:QCustomPlot}
{\xe \v QCustomPlot\:mPaintBuffers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QSharedPointer<{\b QCPAbstractPaintBuffer}> > QCustomPlot::mPaintBuffers{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXI}
{\bkmkend AAAAAAADXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPlotLayout\:QCustomPlot}
{\xe \v QCustomPlot\:mPlotLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutGrid}* QCustomPlot::mPlotLayout{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXJ}
{\bkmkend AAAAAAADXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPlottables\:QCustomPlot}
{\xe \v QCustomPlot\:mPlottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPAbstractPlottable}*> QCustomPlot::mPlottables{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXK}
{\bkmkend AAAAAAADXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPlottingHints\:QCustomPlot}
{\xe \v QCustomPlot\:mPlottingHints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::PlottingHints QCustomPlot::mPlottingHints{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXL}
{\bkmkend AAAAAAADXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mReplotQueued\:QCustomPlot}
{\xe \v QCustomPlot\:mReplotQueued}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mReplotQueued{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXM}
{\bkmkend AAAAAAADXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mReplotting\:QCustomPlot}
{\xe \v QCustomPlot\:mReplotting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCustomPlot::mReplotting{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXN}
{\bkmkend AAAAAAADXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScaledBackgroundPixmap\:QCustomPlot}
{\xe \v QCustomPlot\:mScaledBackgroundPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCustomPlot::mScaledBackgroundPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXO}
{\bkmkend AAAAAAADXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectionRect\:QCustomPlot}
{\xe \v QCustomPlot\:mSelectionRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionRect}* QCustomPlot::mSelectionRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXP}
{\bkmkend AAAAAAADXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectionRectMode\:QCustomPlot}
{\xe \v QCustomPlot\:mSelectionRectMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionRectMode} QCustomPlot::mSelectionRectMode{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXQ}
{\bkmkend AAAAAAADXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectionTolerance\:QCustomPlot}
{\xe \v QCustomPlot\:mSelectionTolerance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCustomPlot::mSelectionTolerance{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXR}
{\bkmkend AAAAAAADXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mViewport\:QCustomPlot}
{\xe \v QCustomPlot\:mViewport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCustomPlot::mViewport{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADXS}
{\bkmkend AAAAAAADXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xAxis\:QCustomPlot}
{\xe \v QCustomPlot\:xAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCustomPlot::xAxis}}
\par
{\bkmkstart AAAAAAADXT}
{\bkmkend AAAAAAADXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the primary x Axis (bottom) of the main axis rect of the plot.\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple axis rects or multiple axes to one side, use the {\b QCPAxisRect::axis} interface to access the new axes. If one of the four default axes or the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointers become 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\xe \v xAxis2\:QCustomPlot}
{\xe \v QCustomPlot\:xAxis2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCustomPlot::xAxis2}}
\par
{\bkmkstart AAAAAAADXU}
{\bkmkend AAAAAAADXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the secondary x Axis (top) of the main axis rect of the plot. Secondary axes are invisible by default. Use {\b QCPAxis::setVisible} to change this (or use {\b QCPAxisRect::setupFullAxesBox}).\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple axis rects or multiple axes to one side, use the {\b QCPAxisRect::axis} interface to access the new axes. If one of the four default axes or the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointers become 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\xe \v yAxis\:QCustomPlot}
{\xe \v QCustomPlot\:yAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCustomPlot::yAxis}}
\par
{\bkmkstart AAAAAAADXV}
{\bkmkend AAAAAAADXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the primary y Axis (left) of the main axis rect of the plot.\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple axis rects or multiple axes to one side, use the {\b QCPAxisRect::axis} interface to access the new axes. If one of the four default axes or the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointers become 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\xe \v yAxis2\:QCustomPlot}
{\xe \v QCustomPlot\:yAxis2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCustomPlot::yAxis2}}
\par
{\bkmkstart AAAAAAADXW}
{\bkmkend AAAAAAADXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the secondary y Axis (right) of the main axis rect of the plot. Secondary axes are invisible by default. Use {\b QCPAxis::setVisible} to change this (or use {\b QCPAxisRect::setupFullAxesBox}).\par
{\b QCustomPlot} offers convenient pointers to the axes ({\b xAxis}, {\b yAxis}, {\b xAxis2}, {\b yAxis2}) and the {\b legend}. They make it very easy working with plots that only have a single axis rect and at most one axis at each axis rect side. If you use {\b the layout system} to add multiple axis rects or multiple axes to one side, use the {\b QCPAxisRect::axis} interface to access the new axes. If one of the four default axes or the default legend is removed due to manipulation of the layout system (e.g. by removing the main axis rect), the corresponding pointers become 0.\par
If an axis convenience pointer is currently zero and a new axis rect or a corresponding axis is added in the place of the main axis rect, {\b QCustomPlot} resets the convenience pointers to the according new axes. Similarly the {\b legend} convenience pointer will be reset if a legend is added after the main legend was removed before. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Resistor Class Reference\par \pard\plain 
{\tc\tcl2 \v Resistor}
{\xe \v Resistor}
{\bkmkstart AAAAAAADXX}
{\bkmkend AAAAAAADXX}
\par
{
{\f2 #include <Classes_cirkt.h>}}\par
Collaboration diagram for Resistor:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_resistor__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Resistor} (float valor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_imp} (complex< double > s)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b get_resist} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
complex< double > {\b get_imp} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Resistor\:Resistor}
{\xe \v Resistor\:Resistor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Resistor::Resistor (float  {\i valor})}}
\par
{\bkmkstart AAAAAAADXY}
{\bkmkend AAAAAAADXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    18 \{resist = valor;\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_imp\:Resistor}
{\xe \v Resistor\:get_imp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
complex< double > Resistor::get_imp ()}}
\par
{\bkmkstart AAAAAAADXZ}
{\bkmkend AAAAAAADXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    21 \{ return imp; \}\par
}
}
{\xe \v get_resist\:Resistor}
{\xe \v Resistor\:get_resist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Resistor::get_resist ()}}
\par
{\bkmkstart AAAAAAADYA}
{\bkmkend AAAAAAADYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    20 \{return resist;\}\par
}
}
{\xe \v set_imp\:Resistor}
{\xe \v Resistor\:set_imp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Resistor::set_imp (complex< double >  {\i s})}}
\par
{\bkmkstart AAAAAAADYB}
{\bkmkend AAAAAAADYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    19 \{imp = complex<double>(resist, 0);\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Classes_cirkt.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Tensao Class Reference\par \pard\plain 
{\tc\tcl2 \v Tensao}
{\xe \v Tensao}
{\bkmkstart AAAAAAADYC}
{\bkmkend AAAAAAADYC}
\par
{
{\f2 #include <Classes_cirkt.h>}}\par
Collaboration diagram for Tensao:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_tensao__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Tensao} (complex< double > corrente, complex< double > impedance)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
complex< double > {\b get_valor} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Tensao\:Tensao}
{\xe \v Tensao\:Tensao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tensao::Tensao (complex< double >  {\i corrente}, complex< double >  {\i impedance})}}
\par
{\bkmkstart AAAAAAADYD}
{\bkmkend AAAAAAADYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    63 \{ valor = corrente * impedance; \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_valor\:Tensao}
{\xe \v Tensao\:get_valor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
complex< double > Tensao::get_valor ()}}
\par
{\bkmkstart AAAAAAADYE}
{\bkmkend AAAAAAADYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    64 \{ return valor; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Classes_cirkt.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
QCPAxisPainterPrivate::TickLabelData Struct Reference\par \pard\plain 
{\tc\tcl2 \v QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData}
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
\par
{
{\f2 #include <qcustomplot.h>}}\par
Collaboration diagram for QCPAxisPainterPrivate::TickLabelData:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_q_c_p_axis_painter_private_1_1_tick_label_data__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b basePart}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b expPart}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b suffixPart}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b baseBounds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b expBounds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b suffixBounds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b totalBounds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b rotatedTotalBounds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b baseFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b expFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v baseBounds\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:baseBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::TickLabelData::baseBounds}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v baseFont\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:baseFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxisPainterPrivate::TickLabelData::baseFont}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basePart\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:basePart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisPainterPrivate::TickLabelData::basePart}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v expBounds\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:expBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::TickLabelData::expBounds}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v expFont\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:expFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxisPainterPrivate::TickLabelData::expFont}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v expPart\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:expPart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisPainterPrivate::TickLabelData::expPart}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rotatedTotalBounds\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:rotatedTotalBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::TickLabelData::rotatedTotalBounds}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v suffixBounds\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:suffixBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::TickLabelData::suffixBounds}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v suffixPart\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:suffixPart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxisPainterPrivate::TickLabelData::suffixPart}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v totalBounds\:QCPAxisPainterPrivate::TickLabelData}
{\xe \v QCPAxisPainterPrivate::TickLabelData\:totalBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAxisPainterPrivate::TickLabelData::totalBounds}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
}
\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Classes_cirkt.h File Reference\par \pard\plain 
{\tc\tcl2 \v Classes_cirkt.h}
{\xe \v Classes_cirkt.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <complex>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Classes_cirkt.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_classes__cirkt_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_classes__cirkt_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Resistor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Capacitor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Indutor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Tensao}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
complex< double > {\b aux}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v aux\:Classes_cirkt.h}
{\xe \v Classes_cirkt.h\:aux}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
complex<double> aux}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v main.cpp}
{\xe \v main.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "mainwindow.h"}\par
{\f2 #include <QApplication>}\par
{\f2 #include <iostream>}\par
{\f2 #include <complex>}\par
{\f2 #include <vector>}\par
{\f2 #include <map>}\par
{\f2 #include <ctgmath>}\par
{\f2 #include "Classes_cirkt.h"}\par
{\f2 #include <QPixmap>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for main.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "main_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     QApplication a(argc, argv);\par
   14     MainWindow w;\par
   15     w.show();\par
   16     /*int esc, i,cont=0;\par
   17     char comp;\par
   18     float A, B, C, W, valor,periodo;\par
   19     double t = 0, saida;\par
   20     float real, img;\par
   21     complex<double> E1,s,I,fasor;\par
   22     vector<pair<double, double>> xy_pts_E1, xy_pts_Er, xy_pts_Ec, xy_pts_Ei;\par
   23     */\par
   24 \par
   25 \par
   26     return a.exec();\par
   27 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mainwindow.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v mainwindow.cpp}
{\xe \v mainwindow.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "mainwindow.h"}\par
{\f2 #include "ui_mainwindow.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for mainwindow.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "mainwindow_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mainwindow.h File Reference\par \pard\plain 
{\tc\tcl2 \v mainwindow.h}
{\xe \v mainwindow.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QMainWindow>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for mainwindow.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "mainwindow_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "mainwindow_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MainWindow}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b Ui}\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
qcustomplot.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v qcustomplot.cpp}
{\xe \v qcustomplot.cpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "qcustomplot.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for qcustomplot.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "qcustomplot_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
qcustomplot.h File Reference\par \pard\plain 
{\tc\tcl2 \v qcustomplot.h}
{\xe \v qcustomplot.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QtCore/qglobal.h>}\par
{\f2 #include <QtCore/QObject>}\par
{\f2 #include <QtCore/QPointer>}\par
{\f2 #include <QtCore/QSharedPointer>}\par
{\f2 #include <QtCore/QTimer>}\par
{\f2 #include <QtGui/QPainter>}\par
{\f2 #include <QtGui/QPaintEvent>}\par
{\f2 #include <QtGui/QMouseEvent>}\par
{\f2 #include <QtGui/QWheelEvent>}\par
{\f2 #include <QtGui/QPixmap>}\par
{\f2 #include <QtCore/QVector>}\par
{\f2 #include <QtCore/QString>}\par
{\f2 #include <QtCore/QDateTime>}\par
{\f2 #include <QtCore/QMultiMap>}\par
{\f2 #include <QtCore/QFlags>}\par
{\f2 #include <QtCore/QDebug>}\par
{\f2 #include <QtCore/QStack>}\par
{\f2 #include <QtCore/QCache>}\par
{\f2 #include <QtCore/QMargins>}\par
{\f2 #include <qmath.h>}\par
{\f2 #include <limits>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <QtNumeric>}\par
{\f2 #include <QtWidgets/QWidget>}\par
{\f2 #include <QtPrintSupport/QtPrintSupport>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for qcustomplot.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "qcustomplot_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "qcustomplot_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPVector2D}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents two doubles as a mathematical 2D vector. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPPainter}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QPainter subclass used internally. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractPaintBuffer}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for paint buffers, which define the rendering backend. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPPaintBufferPixmap}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A paint buffer based on QPixmap, using software raster rendering. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayer}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layer that may contain objects, to control the rendering order. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayerable}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for all drawable objects. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPRange}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the range an axis is encompassing. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPDataRange}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data range given by begin and end index. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPDataSelection}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a data set by holding multiple {\b QCPDataRange} instances. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPSelectionRect}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides rect/rubber-band data selection and range zoom interaction. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPMarginGroup}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A margin group allows synchronization of margin sides if working with multiple layout elements. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayoutElement}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all objects that form the layout system. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayout}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for layouts. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayoutGrid}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout that arranges child elements in a grid. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLayoutInset}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout that places child elements aligned to the border or arbitrarily positioned. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLineEnding}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handles the different ending decorations for line-like items. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisTicker}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The base class tick generator used by {\b QCPAxis} to create tick positions and tick labels. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisTickerDateTime}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker for calendar dates and times as axis ticks. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisTickerTime}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker for time spans in units of milliseconds to days. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisTickerFixed}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker with a fixed tick step. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisTickerText}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker which allows arbitrary labels at specified coordinates. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisTickerPi}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker to display ticks in units of an arbitrary constant, for example pi. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisTickerLog}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialized axis ticker suited for logarithmic axes. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPGrid}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Responsible for drawing the grid of a {\b QCPAxis}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxis}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a single axis inside a {\b QCustomPlot}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisPainterPrivate}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b QCPAxisPainterPrivate::CachedLabel}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b QCPAxisPainterPrivate::TickLabelData}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPScatterStyle}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the visual appearance of scatter points. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPDataContainer< DataType >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The generic data container for one-dimensional plottables. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPSelectionDecorator}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls how a plottable's data selection is drawn. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractPlottable}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all data representing objects in a plot. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemAnchor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An anchor of an item to which positions can be attached to. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemPosition}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages the position of an item. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractItem}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all items in a plot. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The central class of the library. This is the QWidget which displays the plot and interacts with the user. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPPlottableInterface1D}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines an abstract interface for one-dimensional plottables. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractPlottable1D< DataType >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A template base class for plottables with one-dimensional data. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPColorGradient}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines a color gradient for use with e.g. {\b QCPColorMap}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPSelectionDecoratorBracket}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A selection decorator which draws brackets around each selected data segment. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisRect}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds multiple axes and arranges them in a rectangular shape. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAbstractLegendItem}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The abstract base class for all entries in a {\b QCPLegend}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPPlottableLegendItem}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A legend item representing a plottable with an icon and the plottable name. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a legend inside a {\b QCustomPlot}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPTextElement}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A layout element displaying a text. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPColorScaleAxisRectPrivate}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPColorScale}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A color scale for use with color coding data such as {\b QCPColorMap}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPGraphData}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPGraph}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPGraph}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a graph in a plot. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPCurveData}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPCurve}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPCurve}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a parametric curve in a plot. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPBarsGroup}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Groups multiple {\b QCPBars} together so they appear side by side. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPBarsData}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point (one bar) for {\b QCPBars}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPBars}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a bar chart in a plot. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPStatisticalBoxData}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPStatisticalBox}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPStatisticalBox}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a single statistical box in a plot. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPColorMapData}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the two-dimensional data of a {\b QCPColorMap} plottable. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPColorMap}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a two-dimensional color map in a plot. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPFinancialData}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single data point for {\b QCPFinancial}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPFinancial}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a financial stock chart. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPErrorBarsData}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds the data of one single error bar for {\b QCPErrorBars}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPErrorBars}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable that adds a set of error bars to other plottables. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemStraightLine}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A straight line that spans infinitely in both directions. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemLine}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A line from one point to another. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemCurve}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A curved line from one point to another. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemRect}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A rectangle. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemText}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A text label. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemEllipse}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An ellipse. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemPixmap}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An arbitrary pixmap. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemTracer}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Item that sticks to {\b QCPGraph} data points. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPItemBracket}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bracket for referencing/highlighting certain parts in the plot. }\par}}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b QCP}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b QCP_DEVICEPIXELRATIO_SUPPORTED}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b QCP_DEVICEPIXELRATIO_FLOAT}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b QCP_LIB_DECL}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Q_DECL_OVERRIDE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b QCPDataContainer}< {\b QCPGraphData} > {\b QCPGraphDataContainer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b QCPDataContainer}< {\b QCPCurveData} > {\b QCPCurveDataContainer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b QCPDataContainer}< {\b QCPBarsData} > {\b QCPBarsDataContainer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b QCPDataContainer}< {\b QCPStatisticalBoxData} > {\b QCPStatisticalBoxDataContainer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b QCPDataContainer}< {\b QCPFinancialData} > {\b QCPFinancialDataContainer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef QVector< {\b QCPErrorBarsData} > {\b QCPErrorBarsDataContainer}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCP::ResolutionUnit} \{ {\b QCP::ruDotsPerMeter}, 
{\b QCP::ruDotsPerCentimeter}, 
{\b QCP::ruDotsPerInch}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCP::ExportPen} \{ {\b QCP::epNoCosmetic}, 
{\b QCP::epAllowCosmetic}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCP::SignDomain} \{ {\b QCP::sdNegative}, 
{\b QCP::sdBoth}, 
{\b QCP::sdPositive}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCP::MarginSide} \{ {\b QCP::msLeft} = 0x01, 
{\b QCP::msRight} = 0x02, 
{\b QCP::msTop} = 0x04, 
{\b QCP::msBottom} = 0x08, 
{\b QCP::msAll} = 0xFF, 
{\b QCP::msNone} = 0x00
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCP::AntialiasedElement} \{ {\b QCP::aeAxes} = 0x0001, 
{\b QCP::aeGrid} = 0x0002, 
{\b QCP::aeSubGrid} = 0x0004, 
{\b QCP::aeLegend} = 0x0008, 
{\b QCP::aeLegendItems} = 0x0010, 
{\b QCP::aePlottables} = 0x0020, 
{\b QCP::aeItems} = 0x0040, 
{\b QCP::aeScatters} = 0x0080, 
{\b QCP::aeFills} = 0x0100, 
{\b QCP::aeZeroLine} = 0x0200, 
{\b QCP::aeOther} = 0x8000, 
{\b QCP::aeAll} = 0xFFFF, 
{\b QCP::aeNone} = 0x0000
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCP::PlottingHint} \{ {\b QCP::phNone} = 0x000, 
{\b QCP::phFastPolylines} = 0x001, 
{\b QCP::phImmediateRefresh} = 0x002, 
{\b QCP::phCacheLabels} = 0x004
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCP::Interaction} \{ {\b QCP::iRangeDrag} = 0x001, 
{\b QCP::iRangeZoom} = 0x002, 
{\b QCP::iMultiSelect} = 0x004, 
{\b QCP::iSelectPlottables} = 0x008, 
{\b QCP::iSelectAxes} = 0x010, 
{\b QCP::iSelectLegend} = 0x020, 
{\b QCP::iSelectItems} = 0x040, 
{\b QCP::iSelectOther} = 0x080
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCP::SelectionRectMode} \{ {\b QCP::srmNone}, 
{\b QCP::srmZoom}, 
{\b QCP::srmSelect}, 
{\b QCP::srmCustom}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b QCP::SelectionType} \{ {\b QCP::stNone}, 
{\b QCP::stWhole}, 
{\b QCP::stSingleData}, 
{\b QCP::stDataRange}, 
{\b QCP::stMultipleDataRanges}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b QCP::isInvalidData} (double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b QCP::isInvalidData} (double value1, double value2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b QCP::setMarginValue} (QMargins &margins, {\b QCP::MarginSide} side, int value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b QCP::getMarginValue} (const QMargins &margins, {\b QCP::MarginSide} side)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPVector2D}, Q_MOVABLE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator*} (double factor, const {\b QCPVector2D} &vec)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator*} (const {\b QCPVector2D} &vec, double factor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator/} (const {\b QCPVector2D} &vec, double divisor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator+} (const {\b QCPVector2D} &vec1, const {\b QCPVector2D} &vec2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator-} (const {\b QCPVector2D} &vec1, const {\b QCPVector2D} &vec2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPVector2D} {\b operator-} (const {\b QCPVector2D} &vec)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPRange}, Q_MOVABLE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator+} (const {\b QCPRange} &range, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator+} (double value, const {\b QCPRange} &range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator-} (const {\b QCPRange} &range, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator*} (const {\b QCPRange} &range, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator*} (double value, const {\b QCPRange} &range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b operator/} (const {\b QCPRange} &range, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPDataRange}, Q_MOVABLE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataSelection} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataRange} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataSelection} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator+} (const {\b QCPDataRange} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataSelection} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataRange} &a, const {\b QCPDataSelection} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataSelection} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPDataSelection} {\b operator-} (const {\b QCPDataRange} &a, const {\b QCPDataRange} &b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPLineEnding}, Q_MOVABLE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPScatterStyle}, Q_MOVABLE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPGraphData}, Q_PRIMITIVE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPCurveData}, Q_PRIMITIVE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPBarsData}, Q_PRIMITIVE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPStatisticalBoxData}, Q_MOVABLE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPFinancialData}, Q_PRIMITIVE_TYPE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_TYPEINFO} ({\b QCPErrorBarsData}, Q_PRIMITIVE_TYPE)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QMetaObject {\b QCP::staticMetaObject}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v Q_DECL_OVERRIDE\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECL_OVERRIDE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Q_DECL_OVERRIDE}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCP_DEVICEPIXELRATIO_FLOAT\:qcustomplot.h}
{\xe \v qcustomplot.h\:QCP_DEVICEPIXELRATIO_FLOAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define QCP_DEVICEPIXELRATIO_FLOAT}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCP_DEVICEPIXELRATIO_SUPPORTED\:qcustomplot.h}
{\xe \v qcustomplot.h\:QCP_DEVICEPIXELRATIO_SUPPORTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define QCP_DEVICEPIXELRATIO_SUPPORTED}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCP_LIB_DECL\:qcustomplot.h}
{\xe \v qcustomplot.h\:QCP_LIB_DECL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define QCP_LIB_DECL}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v QCPBarsDataContainer\:qcustomplot.h}
{\xe \v qcustomplot.h\:QCPBarsDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPBarsDataContainer}}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Container for storing {\b QCPBarsData} points. The data is stored sorted by {\i key} .\par
This template instantiation is the container in which {\b QCPBars} holds its data. For details about the generic container, see the documentation of the class template {\b QCPDataContainer}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPBarsData}, {\b QCPBars::setData} \par
}}}
{\xe \v QCPCurveDataContainer\:qcustomplot.h}
{\xe \v qcustomplot.h\:QCPCurveDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPCurveDataContainer}}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Container for storing {\b QCPCurveData} points. The data is stored sorted by {\i t} , so the {\i sortKey()}  (returning {\i t} ) is different from {\i mainKey()}  (returning {\i key} ).\par
This template instantiation is the container in which {\b QCPCurve} holds its data. For details about the generic container, see the documentation of the class template {\b QCPDataContainer}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPCurveData}, {\b QCPCurve::setData} \par
}}}
{\xe \v QCPErrorBarsDataContainer\:qcustomplot.h}
{\xe \v qcustomplot.h\:QCPErrorBarsDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPErrorBarsDataContainer}}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Container for storing {\b QCPErrorBarsData} points. It is a typedef for {\f2 QVector<{\b QCPErrorBarsData}>} .\par
This is the container in which {\b QCPErrorBars} holds its data. Unlike most other data containers for plottables, it is not based on {\b QCPDataContainer}. This is because the error bars plottable is special in that it doesn't store its own key and value coordinate per error bar. It adopts the key and value from the plottable to which the error bars shall be applied ({\b QCPErrorBars::setDataPlottable}). So the stored {\b QCPErrorBarsData} doesn't need a sortable key, but merely an index (as {\f2 QVector}  provides), which maps one-to-one to the indices of the other plottable's data.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPErrorBarsData}, {\b QCPErrorBars::setData} \par
}}}
{\xe \v QCPFinancialDataContainer\:qcustomplot.h}
{\xe \v qcustomplot.h\:QCPFinancialDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPFinancialDataContainer}}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Container for storing {\b QCPFinancialData} points. The data is stored sorted by {\i key} .\par
This template instantiation is the container in which {\b QCPFinancial} holds its data. For details about the generic container, see the documentation of the class template {\b QCPDataContainer}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPFinancialData}, {\b QCPFinancial::setData} \par
}}}
{\xe \v QCPGraphDataContainer\:qcustomplot.h}
{\xe \v qcustomplot.h\:QCPGraphDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraphDataContainer}}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Container for storing {\b QCPGraphData} points. The data is stored sorted by {\i key} .\par
This template instantiation is the container in which {\b QCPGraph} holds its data. For details about the generic container, see the documentation of the class template {\b QCPDataContainer}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPGraphData}, {\b QCPGraph::setData} \par
}}}
{\xe \v QCPStatisticalBoxDataContainer\:qcustomplot.h}
{\xe \v qcustomplot.h\:QCPStatisticalBoxDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPStatisticalBoxDataContainer}}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Container for storing {\b QCPStatisticalBoxData} points. The data is stored sorted by {\i key} .\par
This template instantiation is the container in which {\b QCPStatisticalBox} holds its data. For details about the generic container, see the documentation of the class template {\b QCPDataContainer}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPStatisticalBoxData}, {\b QCPStatisticalBox::setData} \par
}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v operator*\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator* (double  {\i factor}, const {\b QCPVector2D} &  {\i vec}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   433 \{ return QCPVector2D(vec.mX*factor, vec.mY*factor); \}\par
}
}
{\xe \v operator*\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator* (const {\b QCPVector2D} &  {\i vec}, double  {\i factor}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   434 \{ return QCPVector2D(vec.mX*factor, vec.mY*factor); \}\par
}
}
{\xe \v operator*\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator* (const {\b QCPRange} &  {\i range}, double  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies both boundaries of the range by {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   858 \{\par
  859   QCPRange result(range);\par
  860   result *= value;\par
  861   return result;\par
  862 \}\par
}
}
{\xe \v operator*\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator* (double  {\i value}, const {\b QCPRange} &  {\i range}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplies both boundaries of the range by {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   868 \{\par
  869   QCPRange result(range);\par
  870   result *= value;\par
  871   return result;\par
  872 \}\par
}
}
{\xe \v operator+\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator+ (const {\b QCPVector2D} &  {\i vec1}, const {\b QCPVector2D} &  {\i vec2}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   436 \{ return QCPVector2D(vec1.mX+vec2.mX, vec1.mY+vec2.mY); \}\par
}
}
{\xe \v operator+\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator+ (const {\b QCPRange} &  {\i range}, double  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\i value}  to both boundaries of the range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   828 \{\par
  829   QCPRange result(range);\par
  830   result += value;\par
  831   return result;\par
  832 \}\par
}
}
{\xe \v operator+\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator+ (double  {\i value}, const {\b QCPRange} &  {\i range}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds {\i value}  to both boundaries of the range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   838 \{\par
  839   QCPRange result(range);\par
  840   result += value;\par
  841   return result;\par
  842 \}\par
}
}
{\xe \v operator+\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   980 \{\par
  981   QCPDataSelection result(a);\par
  982   result += b;\par
  983   return result;\par
  984 \}\par
}
}
{\xe \v operator+\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   991 \{\par
  992   QCPDataSelection result(a);\par
  993   result += b;\par
  994   return result;\par
  995 \}\par
}
}
{\xe \v operator+\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1002 \{\par
 1003   QCPDataSelection result(a);\par
 1004   result += b;\par
 1005   return result;\par
 1006 \}\par
}
}
{\xe \v operator+\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator+ (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points in {\i a}  joined with the data points in {\i b} . The resulting data selection is already simplified (see {\b QCPDataSelection::simplify}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1013 \{\par
 1014   QCPDataSelection result(a);\par
 1015   result += b;\par
 1016   return result;\par
 1017 \}\par
}
}
{\xe \v operator-\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator- (const {\b QCPVector2D} &  {\i vec1}, const {\b QCPVector2D} &  {\i vec2}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   437 \{ return QCPVector2D(vec1.mX-vec2.mX, vec1.mY-vec2.mY); \}\par
}
}
{\xe \v operator-\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator- (const {\b QCPVector2D} &  {\i vec}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   438 \{ return QCPVector2D(-vec.mX, -vec.mY); \}\par
}
}
{\xe \v operator-\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator- (const {\b QCPRange} &  {\i range}, double  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtracts {\i value}  from both boundaries of the range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   848 \{\par
  849   QCPRange result(range);\par
  850   result -= value;\par
  851   return result;\par
  852 \}\par
}
}
{\xe \v operator-\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1023 \{\par
 1024   QCPDataSelection result(a);\par
 1025   result -= b;\par
 1026   return result;\par
 1027 \}\par
}
}
{\xe \v operator-\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataSelection} &  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1033 \{\par
 1034   QCPDataSelection result(a);\par
 1035   result -= b;\par
 1036   return result;\par
 1037 \}\par
}
}
{\xe \v operator-\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataSelection} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1043 \{\par
 1044   QCPDataSelection result(a);\par
 1045   result -= b;\par
 1046   return result;\par
 1047 \}\par
}
}
{\xe \v operator-\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPDataSelection} operator- (const {\b QCPDataRange} &  {\i a}, const {\b QCPDataRange} &  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a {\b QCPDataSelection} with the data points which are in {\i a}  but not in {\i b} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1053 \{\par
 1054   QCPDataSelection result(a);\par
 1055   result -= b;\par
 1056   return result;\par
 1057 \}\par
}
}
{\xe \v operator/\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPVector2D} operator/ (const {\b QCPVector2D} &  {\i vec}, double  {\i divisor}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   435 \{ return QCPVector2D(vec.mX/divisor, vec.mY/divisor); \}\par
}
}
{\xe \v operator/\:qcustomplot.h}
{\xe \v qcustomplot.h\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} operator/ (const {\b QCPRange} &  {\i range}, double  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Divides both boundaries of the range by {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   878 \{\par
  879   QCPRange result(range);\par
  880   result /= value;\par
  881   return result;\par
  882 \}\par
}
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPVector2D} , Q_MOVABLE_TYPE )}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPRange} , Q_MOVABLE_TYPE )}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPDataRange} , Q_MOVABLE_TYPE )}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPLineEnding} , Q_MOVABLE_TYPE )}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPScatterStyle} , Q_MOVABLE_TYPE )}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPGraphData} , Q_PRIMITIVE_TYPE )}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPCurveData} , Q_PRIMITIVE_TYPE )}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPBarsData} , Q_PRIMITIVE_TYPE )}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPStatisticalBoxData} , Q_MOVABLE_TYPE )}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPFinancialData} , Q_PRIMITIVE_TYPE )}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_DECLARE_TYPEINFO\:qcustomplot.h}
{\xe \v qcustomplot.h\:Q_DECLARE_TYPEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_TYPEINFO ({\b QCPErrorBarsData} , Q_PRIMITIVE_TYPE )}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}