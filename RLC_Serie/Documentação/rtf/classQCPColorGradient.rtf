{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência da Classe QCPColorGradient\par \pard\plain 
{\tc\tcl2 \v QCPColorGradient}
{\xe \v QCPColorGradient}
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines a color gradient for use with e.g. {\b QCPColorMap}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ColorInterpolation} \{ {\b ciRGB}, 
{\b ciHSV}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b GradientPreset} \{ {\b gpGrayscale}, 
{\b gpHot}, 
{\b gpCold}, 
{\b gpNight}, 
{\b gpCandy}, 
{\b gpGeography}, 
{\b gpIon}, 
{\b gpThermal}, 
{\b gpPolar}, 
{\b gpSpectrum}, 
{\b gpJet}, 
{\b gpHues}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} ({\b GradientPreset} preset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b QCPColorGradient} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b QCPColorGradient} &other) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b levelCount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMap< double, QColor > {\b colorStops} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ColorInterpolation} {\b colorInterpolation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b periodic} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLevelCount} (int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColorStops} (const QMap< double, QColor > &{\b colorStops})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColorStopAt} (double position, const QColor &{\b color})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setColorInterpolation} ({\b ColorInterpolation} interpolation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPeriodic} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b colorize} (const double *data, const {\b QCPRange} &range, QRgb *scanLine, int n, int dataIndexFactor=1, bool logarithmic=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b colorize} (const double *data, const unsigned char *alpha, const {\b QCPRange} &range, QRgb *scanLine, int n, int dataIndexFactor=1, bool logarithmic=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRgb {\b color} (double position, const {\b QCPRange} &range, bool logarithmic=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loadPreset} ({\b GradientPreset} preset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearColorStops} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPColorGradient} {\b inverted} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b stopsUseAlpha} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateColorBuffer} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mLevelCount}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMap< double, QColor > {\b mColorStops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ColorInterpolation} {\b mColorInterpolation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mPeriodic}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QRgb > {\b mColorBuffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mColorBufferInvalidated}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines a color gradient for use with e.g. {\b QCPColorMap}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class describes a color gradient which can be used to encode data with color. For example, {\b QCPColorMap} and {\b QCPColorScale} have {\b setGradient} methods which take an instance of this class. Colors are set with {\b setColorStopAt(double position, const QColor &color)} with a {\i position}  from 0 to 1. In between these defined color positions, the color will be interpolated linearly either in RGB or HSV space, see {\b setColorInterpolation}.\par
Alternatively, load one of the preset color gradients shown in the image below, with {\b loadPreset}, or by directly specifying the preset in the constructor.\par
Apart from red, green and blue components, the gradient also interpolates the alpha values of the configured color stops. This allows to display some portions of the data range as transparent in the plot.\par
The {\b QCPColorGradient(GradientPreset preset)} constructor allows directly converting a {\b GradientPreset} to a {\b QCPColorGradient}. This means that you can directly pass {\b GradientPreset} to all the {\i setGradient}  methods, e.g.: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } The total number of levels used in the gradient can be set with {\b setLevelCount}. Whether the color gradient shall be applied periodically (wrapping around) to data values that lie outside the data range specified on the plottable instance can be controlled with {\b setPeriodic}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerações\par
\pard\plain 
{\xe \v ColorInterpolation\:QCPColorGradient}
{\xe \v QCPColorGradient\:ColorInterpolation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPColorGradient::ColorInterpolation}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the color spaces in which color interpolation between gradient stops can be performed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColorInterpolation} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ciRGB\:QCPColorGradient}
{\xe \v QCPColorGradient\:ciRGB}
{\qr ciRGB{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Color channels red, green and blue are linearly interpolated. \par
}\cell }{\row }
{\xe \v ciHSV\:QCPColorGradient}
{\xe \v QCPColorGradient\:ciHSV}
{\qr ciHSV{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Color channels hue, saturation and value are linearly interpolated (The hue is interpolated over the shortest angle distance) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4439                           \{ ciRGB  \par
 4440                             ,ciHSV \par
 4441                           \};\par
}
}
{\xe \v GradientPreset\:QCPColorGradient}
{\xe \v QCPColorGradient\:GradientPreset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPColorGradient::GradientPreset}}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the available presets that can be loaded with {\b loadPreset}. See the documentation there for an image of the presets. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v gpGrayscale\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpGrayscale}
{\qr gpGrayscale{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Continuous lightness from black to white (suited for non-biased data representation) \par
}\cell }{\row }
{\xe \v gpHot\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpHot}
{\qr gpHot{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Continuous lightness from black over firey colors to white (suited for non-biased data representation) \par
}\cell }{\row }
{\xe \v gpCold\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpCold}
{\qr gpCold{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Continuous lightness from black over icey colors to white (suited for non-biased data representation) \par
}\cell }{\row }
{\xe \v gpNight\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpNight}
{\qr gpNight{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Continuous lightness from black over weak blueish colors to white (suited for non-biased data representation) \par
}\cell }{\row }
{\xe \v gpCandy\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpCandy}
{\qr gpCandy{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blue over pink to white. \par
}\cell }{\row }
{\xe \v gpGeography\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpGeography}
{\qr gpGeography{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors suitable to represent different elevations on geographical maps. \par
}\cell }{\row }
{\xe \v gpIon\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpIon}
{\qr gpIon{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Half hue spectrum from black over purple to blue and finally green (creates banding illusion but allows more precise magnitude estimates) \par
}\cell }{\row }
{\xe \v gpThermal\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpThermal}
{\qr gpThermal{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors suitable for thermal imaging, ranging from dark blue over purple to orange, yellow and white. \par
}\cell }{\row }
{\xe \v gpPolar\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpPolar}
{\qr gpPolar{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors suitable to emphasize polarity around the center, with blue for negative, black in the middle and red for positive values. \par
}\cell }{\row }
{\xe \v gpSpectrum\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpSpectrum}
{\qr gpSpectrum{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An approximation of the visible light spectrum (creates banding illusion but allows more precise magnitude estimates) \par
}\cell }{\row }
{\xe \v gpJet\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpJet}
{\qr gpJet{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hue variation similar to a spectrum, often used in numerical visualization (creates banding illusion but allows more precise magnitude estimates) \par
}\cell }{\row }
{\xe \v gpHues\:QCPColorGradient}
{\xe \v QCPColorGradient\:gpHues}
{\qr gpHues{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Full hue cycle, with highest and lowest color red (suitable for periodic data, such as angles and phases, see {\b setPeriodic}) \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4448                       \{ gpGrayscale  \par
 4449                         ,gpHot       \par
 4450                         ,gpCold      \par
 4451                         ,gpNight     \par
 4452                         ,gpCandy     \par
 4453                         ,gpGeography \par
 4454                         ,gpIon       \par
 4455                         ,gpThermal   \par
 4456                         ,gpPolar     \par
 4457                         ,gpSpectrum  \par
 4458                         ,gpJet       \par
 4459                         ,gpHues      \par
 4460                       \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v QCPColorGradient\:QCPColorGradient}
{\xe \v QCPColorGradient\:QCPColorGradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorGradient::QCPColorGradient ()}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new, empty {\b QCPColorGradient} with no predefined color stops. You can add own color stops with {\b setColorStopAt}.\par
The color level count is initialized to 350. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15763                                    :\par
15764   mLevelCount(350),\par
15765   mColorInterpolation(ciRGB),\par
15766   mPeriodic(false),\par
15767   mColorBufferInvalidated(true)\par
15768 \{\par
15769   mColorBuffer.fill(qRgb(0, 0, 0), mLevelCount);\par
15770 \}\par
}
}
{\xe \v QCPColorGradient\:QCPColorGradient}
{\xe \v QCPColorGradient\:QCPColorGradient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPColorGradient::QCPColorGradient ({\b GradientPreset}  {\i preset})}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b QCPColorGradient} initialized with the colors and color interpolation according to {\i preset} .\par
The color level count is initialized to 350. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15778                                                         :\par
15779   mLevelCount(350),\par
15780   mColorInterpolation(ciRGB),\par
15781   mPeriodic(false),\par
15782   mColorBufferInvalidated(true)\par
15783 \{\par
15784   mColorBuffer.fill(qRgb(0, 0, 0), mLevelCount);\par
15785   loadPreset(preset);\par
15786 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções membros\par
\pard\plain 
{\xe \v clearColorStops\:QCPColorGradient}
{\xe \v QCPColorGradient\:clearColorStops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::clearColorStops ()}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all color stops.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColorStops}, {\b setColorStopAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16231 \{\par
16232   mColorStops.clear();\par
16233   mColorBufferInvalidated = true;\par
16234 \}\par
}
}
{\xe \v color\:QCPColorGradient}
{\xe \v QCPColorGradient\:color}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRgb QCPColorGradient::color (double  {\i position}, const {\b QCPRange} &  {\i range}, bool  {\i logarithmic} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16090 \{\par
16091   // If you change something here, make sure to also adapt ::colorize()\par
16092   if (mColorBufferInvalidated)\par
16093     updateColorBuffer();\par
16094   int index = 0;\par
16095   if (!logarithmic)\par
16096     index = (position-range.lower)*(mLevelCount-1)/range.size();\par
16097   else\par
16098     index = qLn(position/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);\par
16099   if (mPeriodic)\par
16100   \{\par
16101     index = index % mLevelCount;\par
16102     if (index < 0)\par
16103       index += mLevelCount;\par
16104   \} else\par
16105   \{\par
16106     if (index < 0)\par
16107       index = 0;\par
16108     else if (index >= mLevelCount)\par
16109       index = mLevelCount-1;\par
16110   \}\par
16111   return mColorBuffer.at(index);\par
16112 \}\par
}
}
{\xe \v colorInterpolation\:QCPColorGradient}
{\xe \v QCPColorGradient\:colorInterpolation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ColorInterpolation} QCPColorGradient::colorInterpolation () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4471 \{ return mColorInterpolation; \}\par
}
}
{\xe \v colorize\:QCPColorGradient}
{\xe \v QCPColorGradient\:colorize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::colorize (const double *  {\i data}, const {\b QCPRange} &  {\i range}, QRgb *  {\i scanLine}, int  {\i n}, int  {\i dataIndexFactor} = {\f2 1}, bool  {\i logarithmic} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
This method is used to quickly convert a {\i data}  array to colors. The colors will be output in the array {\i scanLine} . Both {\i data}  and {\i scanLine}  must have the length {\i n}  when passed to this function. The data range that shall be used for mapping the data value to the gradient is passed in {\i range} . {\i logarithmic}  indicates whether the data values shall be mapped to colors logarithmically.\par
if {\i data}  actually contains 2D-data linearized via {\f2 [row*columnCount + column]} , you can set {\i dataIndexFactor}  to {\f2 columnCount}  to convert a column instead of a row of the data array, in {\i scanLine} . {\i scanLine}  will remain a regular (1D) array. This works because {\i data}  is addressed {\f2 data[i*dataIndexFactor]} .\par
Use the overloaded method to additionally provide alpha map data.\par
The QRgb values that are placed in {\i scanLine}  have their r, g and b components premultiplied with alpha (see QImage::Format_ARGB32_Premultiplied). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15901 \{\par
15902   // If you change something here, make sure to also adapt color() and the other colorize() overload\par
15903   if (!data)\par
15904   \{\par
15905     qDebug() << Q_FUNC_INFO << "null pointer given as data";\par
15906     return;\par
15907   \}\par
15908   if (!scanLine)\par
15909   \{\par
15910     qDebug() << Q_FUNC_INFO << "null pointer given as scanLine";\par
15911     return;\par
15912   \}\par
15913   if (mColorBufferInvalidated)\par
15914     updateColorBuffer();\par
15915   \par
15916   if (!logarithmic)\par
15917   \{\par
15918     const double posToIndexFactor = (mLevelCount-1)/range.size();\par
15919     if (mPeriodic)\par
15920     \{\par
15921       for (int i=0; i<n; ++i)\par
15922       \{\par
15923         int index = (int)((data[dataIndexFactor*i]-range.lower)*posToIndexFactor) % mLevelCount;\par
15924         if (index < 0)\par
15925           index += mLevelCount;\par
15926         scanLine[i] = mColorBuffer.at(index);\par
15927       \}\par
15928     \} else\par
15929     \{\par
15930       for (int i=0; i<n; ++i)\par
15931       \{\par
15932         int index = (data[dataIndexFactor*i]-range.lower)*posToIndexFactor;\par
15933         if (index < 0)\par
15934           index = 0;\par
15935         else if (index >= mLevelCount)\par
15936           index = mLevelCount-1;\par
15937         scanLine[i] = mColorBuffer.at(index);\par
15938       \}\par
15939     \}\par
15940   \} else // logarithmic == true\par
15941   \{\par
15942     if (mPeriodic)\par
15943     \{\par
15944       for (int i=0; i<n; ++i)\par
15945       \{\par
15946         int index = (int)(qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1)) % mLevelCount;\par
15947         if (index < 0)\par
15948           index += mLevelCount;\par
15949         scanLine[i] = mColorBuffer.at(index);\par
15950       \}\par
15951     \} else\par
15952     \{\par
15953       for (int i=0; i<n; ++i)\par
15954       \{\par
15955         int index = qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);\par
15956         if (index < 0)\par
15957           index = 0;\par
15958         else if (index >= mLevelCount)\par
15959           index = mLevelCount-1;\par
15960         scanLine[i] = mColorBuffer.at(index);\par
15961       \}\par
15962     \}\par
15963   \}\par
15964 \}\par
}
}
{\xe \v colorize\:QCPColorGradient}
{\xe \v QCPColorGradient\:colorize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::colorize (const double *  {\i data}, const unsigned char *  {\i alpha}, const {\b QCPRange} &  {\i range}, QRgb *  {\i scanLine}, int  {\i n}, int  {\i dataIndexFactor} = {\f2 1}, bool  {\i logarithmic} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Additionally to the other overload of {\b colorize}, this method takes the array {\i alpha} , which has the same size and structure as {\i data}  and encodes the alpha information per data point.\par
The QRgb values that are placed in {\i scanLine}  have their r, g and b components premultiplied with alpha (see QImage::Format_ARGB32_Premultiplied). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15975 \{\par
15976   // If you change something here, make sure to also adapt color() and the other colorize() overload\par
15977   if (!data)\par
15978   \{\par
15979     qDebug() << Q_FUNC_INFO << "null pointer given as data";\par
15980     return;\par
15981   \}\par
15982   if (!alpha)\par
15983   \{\par
15984     qDebug() << Q_FUNC_INFO << "null pointer given as alpha";\par
15985     return;\par
15986   \}\par
15987   if (!scanLine)\par
15988   \{\par
15989     qDebug() << Q_FUNC_INFO << "null pointer given as scanLine";\par
15990     return;\par
15991   \}\par
15992   if (mColorBufferInvalidated)\par
15993     updateColorBuffer();\par
15994   \par
15995   if (!logarithmic)\par
15996   \{\par
15997     const double posToIndexFactor = (mLevelCount-1)/range.size();\par
15998     if (mPeriodic)\par
15999     \{\par
16000       for (int i=0; i<n; ++i)\par
16001       \{\par
16002         int index = (int)((data[dataIndexFactor*i]-range.lower)*posToIndexFactor) % mLevelCount;\par
16003         if (index < 0)\par
16004           index += mLevelCount;\par
16005         if (alpha[dataIndexFactor*i] == 255)\par
16006         \{\par
16007           scanLine[i] = mColorBuffer.at(index);\par
16008         \} else\par
16009         \{\par
16010           const QRgb rgb = mColorBuffer.at(index);\par
16011           const float alphaF = alpha[dataIndexFactor*i]/255.0f;\par
16012           scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);\par
16013         \}\par
16014       \}\par
16015     \} else\par
16016     \{\par
16017       for (int i=0; i<n; ++i)\par
16018       \{\par
16019         int index = (data[dataIndexFactor*i]-range.lower)*posToIndexFactor;\par
16020         if (index < 0)\par
16021           index = 0;\par
16022         else if (index >= mLevelCount)\par
16023           index = mLevelCount-1;\par
16024         if (alpha[dataIndexFactor*i] == 255)\par
16025         \{\par
16026           scanLine[i] = mColorBuffer.at(index);\par
16027         \} else\par
16028         \{\par
16029           const QRgb rgb = mColorBuffer.at(index);\par
16030           const float alphaF = alpha[dataIndexFactor*i]/255.0f;\par
16031           scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);\par
16032         \}\par
16033       \}\par
16034     \}\par
16035   \} else // logarithmic == true\par
16036   \{\par
16037     if (mPeriodic)\par
16038     \{\par
16039       for (int i=0; i<n; ++i)\par
16040       \{\par
16041         int index = (int)(qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1)) % mLevelCount;\par
16042         if (index < 0)\par
16043           index += mLevelCount;\par
16044         if (alpha[dataIndexFactor*i] == 255)\par
16045         \{\par
16046           scanLine[i] = mColorBuffer.at(index);\par
16047         \} else\par
16048         \{\par
16049           const QRgb rgb = mColorBuffer.at(index);\par
16050           const float alphaF = alpha[dataIndexFactor*i]/255.0f;\par
16051           scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);\par
16052         \}\par
16053       \}\par
16054     \} else\par
16055     \{\par
16056       for (int i=0; i<n; ++i)\par
16057       \{\par
16058         int index = qLn(data[dataIndexFactor*i]/range.lower)/qLn(range.upper/range.lower)*(mLevelCount-1);\par
16059         if (index < 0)\par
16060           index = 0;\par
16061         else if (index >= mLevelCount)\par
16062           index = mLevelCount-1;\par
16063         if (alpha[dataIndexFactor*i] == 255)\par
16064         \{\par
16065           scanLine[i] = mColorBuffer.at(index);\par
16066         \} else\par
16067         \{\par
16068           const QRgb rgb = mColorBuffer.at(index);\par
16069           const float alphaF = alpha[dataIndexFactor*i]/255.0f;\par
16070           scanLine[i] = qRgba(qRed(rgb)*alphaF, qGreen(rgb)*alphaF, qBlue(rgb)*alphaF, qAlpha(rgb)*alphaF);\par
16071         \}\par
16072       \}\par
16073     \}\par
16074   \}\par
16075 \}\par
}
}
{\xe \v colorStops\:QCPColorGradient}
{\xe \v QCPColorGradient\:colorStops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMap<double, QColor> QCPColorGradient::colorStops () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4470 \{ return mColorStops; \}\par
}
}
{\xe \v inverted\:QCPColorGradient}
{\xe \v QCPColorGradient\:inverted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPColorGradient} QCPColorGradient::inverted () const}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an inverted gradient. The inverted gradient has all properties as this {\b QCPColorGradient}, but the order of the color stops is inverted.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColorStops}, {\b setColorStopAt} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16243 \{\par
16244   QCPColorGradient result(*this);\par
16245   result.clearColorStops();\par
16246   for (QMap<double, QColor>::const_iterator it=mColorStops.constBegin(); it!=mColorStops.constEnd(); ++it)\par
16247     result.setColorStopAt(1.0-it.key(), it.value());\par
16248   return result;\par
16249 \}\par
}
}
{\xe \v levelCount\:QCPColorGradient}
{\xe \v QCPColorGradient\:levelCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorGradient::levelCount () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4469 \{ return mLevelCount; \}\par
}
}
{\xe \v loadPreset\:QCPColorGradient}
{\xe \v QCPColorGradient\:loadPreset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::loadPreset ({\b GradientPreset}  {\i preset})}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the current color stops and loads the specified {\i preset} . A preset consists of predefined color stops and the corresponding color interpolation method.\par
The available presets are:  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16122 \{\par
16123   clearColorStops();\par
16124   switch (preset)\par
16125   \{\par
16126     case gpGrayscale:\par
16127       setColorInterpolation(ciRGB);\par
16128       setColorStopAt(0, Qt::black);\par
16129       setColorStopAt(1, Qt::white);\par
16130       break;\par
16131     case gpHot:\par
16132       setColorInterpolation(ciRGB);\par
16133       setColorStopAt(0, QColor(50, 0, 0));\par
16134       setColorStopAt(0.2, QColor(180, 10, 0));\par
16135       setColorStopAt(0.4, QColor(245, 50, 0));\par
16136       setColorStopAt(0.6, QColor(255, 150, 10));\par
16137       setColorStopAt(0.8, QColor(255, 255, 50));\par
16138       setColorStopAt(1, QColor(255, 255, 255));\par
16139       break;\par
16140     case gpCold:\par
16141       setColorInterpolation(ciRGB);\par
16142       setColorStopAt(0, QColor(0, 0, 50));\par
16143       setColorStopAt(0.2, QColor(0, 10, 180));\par
16144       setColorStopAt(0.4, QColor(0, 50, 245));\par
16145       setColorStopAt(0.6, QColor(10, 150, 255));\par
16146       setColorStopAt(0.8, QColor(50, 255, 255));\par
16147       setColorStopAt(1, QColor(255, 255, 255));\par
16148       break;\par
16149     case gpNight:\par
16150       setColorInterpolation(ciHSV);\par
16151       setColorStopAt(0, QColor(10, 20, 30));\par
16152       setColorStopAt(1, QColor(250, 255, 250));\par
16153       break;\par
16154     case gpCandy:\par
16155       setColorInterpolation(ciHSV);\par
16156       setColorStopAt(0, QColor(0, 0, 255));\par
16157       setColorStopAt(1, QColor(255, 250, 250));\par
16158       break;\par
16159     case gpGeography:\par
16160       setColorInterpolation(ciRGB);\par
16161       setColorStopAt(0, QColor(70, 170, 210));\par
16162       setColorStopAt(0.20, QColor(90, 160, 180));\par
16163       setColorStopAt(0.25, QColor(45, 130, 175));\par
16164       setColorStopAt(0.30, QColor(100, 140, 125));\par
16165       setColorStopAt(0.5, QColor(100, 140, 100));\par
16166       setColorStopAt(0.6, QColor(130, 145, 120));\par
16167       setColorStopAt(0.7, QColor(140, 130, 120));\par
16168       setColorStopAt(0.9, QColor(180, 190, 190));\par
16169       setColorStopAt(1, QColor(210, 210, 230));\par
16170       break;\par
16171     case gpIon:\par
16172       setColorInterpolation(ciHSV);\par
16173       setColorStopAt(0, QColor(50, 10, 10));\par
16174       setColorStopAt(0.45, QColor(0, 0, 255));\par
16175       setColorStopAt(0.8, QColor(0, 255, 255));\par
16176       setColorStopAt(1, QColor(0, 255, 0));\par
16177       break;\par
16178     case gpThermal:\par
16179       setColorInterpolation(ciRGB);\par
16180       setColorStopAt(0, QColor(0, 0, 50));\par
16181       setColorStopAt(0.15, QColor(20, 0, 120));\par
16182       setColorStopAt(0.33, QColor(200, 30, 140));\par
16183       setColorStopAt(0.6, QColor(255, 100, 0));\par
16184       setColorStopAt(0.85, QColor(255, 255, 40));\par
16185       setColorStopAt(1, QColor(255, 255, 255));\par
16186       break;\par
16187     case gpPolar:\par
16188       setColorInterpolation(ciRGB);\par
16189       setColorStopAt(0, QColor(50, 255, 255));\par
16190       setColorStopAt(0.18, QColor(10, 70, 255));\par
16191       setColorStopAt(0.28, QColor(10, 10, 190));\par
16192       setColorStopAt(0.5, QColor(0, 0, 0));\par
16193       setColorStopAt(0.72, QColor(190, 10, 10));\par
16194       setColorStopAt(0.82, QColor(255, 70, 10));\par
16195       setColorStopAt(1, QColor(255, 255, 50));\par
16196       break;\par
16197     case gpSpectrum:\par
16198       setColorInterpolation(ciHSV);\par
16199       setColorStopAt(0, QColor(50, 0, 50));\par
16200       setColorStopAt(0.15, QColor(0, 0, 255));\par
16201       setColorStopAt(0.35, QColor(0, 255, 255));\par
16202       setColorStopAt(0.6, QColor(255, 255, 0));\par
16203       setColorStopAt(0.75, QColor(255, 30, 0));\par
16204       setColorStopAt(1, QColor(50, 0, 0));\par
16205       break;\par
16206     case gpJet:\par
16207       setColorInterpolation(ciRGB);\par
16208       setColorStopAt(0, QColor(0, 0, 100));\par
16209       setColorStopAt(0.15, QColor(0, 50, 255));\par
16210       setColorStopAt(0.35, QColor(0, 255, 255));\par
16211       setColorStopAt(0.65, QColor(255, 255, 0));\par
16212       setColorStopAt(0.85, QColor(255, 30, 0));\par
16213       setColorStopAt(1, QColor(100, 0, 0));\par
16214       break;\par
16215     case gpHues:\par
16216       setColorInterpolation(ciHSV);\par
16217       setColorStopAt(0, QColor(255, 0, 0));\par
16218       setColorStopAt(1.0/3.0, QColor(0, 0, 255));\par
16219       setColorStopAt(2.0/3.0, QColor(0, 255, 0));\par
16220       setColorStopAt(1, QColor(255, 0, 0));\par
16221       break;\par
16222   \}\par
16223 \}\par
}
}
{\xe \v operator!=\:QCPColorGradient}
{\xe \v QCPColorGradient\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::operator!= (const {\b QCPColorGradient} &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4466 \{ return !(*this == other); \}\par
}
}
{\xe \v operator==\:QCPColorGradient}
{\xe \v QCPColorGradient\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::operator== (const {\b QCPColorGradient} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15790 \{\par
15791   return ((other.mLevelCount == this->mLevelCount) &&\par
15792           (other.mColorInterpolation == this->mColorInterpolation) &&\par
15793           (other.mPeriodic == this->mPeriodic) &&\par
15794           (other.mColorStops == this->mColorStops));\par
15795 \}\par
}
}
{\xe \v periodic\:QCPColorGradient}
{\xe \v QCPColorGradient\:periodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::periodic () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4472 \{ return mPeriodic; \}\par
}
}
{\xe \v setColorInterpolation\:QCPColorGradient}
{\xe \v QCPColorGradient\:setColorInterpolation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setColorInterpolation ({\b QCPColorGradient::ColorInterpolation}  {\i interpolation})}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the colors in between the configured color stops (see {\b setColorStopAt}) shall be interpolated linearly in RGB or in HSV color space.\par
For example, a sweep in RGB space from red to green will have a muddy brown intermediate color, whereas in HSV space the intermediate color is yellow. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15854 \{\par
15855   if (interpolation != mColorInterpolation)\par
15856   \{\par
15857     mColorInterpolation = interpolation;\par
15858     mColorBufferInvalidated = true;\par
15859   \}\par
15860 \}\par
}
}
{\xe \v setColorStopAt\:QCPColorGradient}
{\xe \v QCPColorGradient\:setColorStopAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setColorStopAt (double  {\i position}, const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i color}  the gradient will have at the specified {\i position}  (from 0 to 1). In between these color stops, the color is interpolated according to {\b setColorInterpolation}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setColorStops}, {\b clearColorStops} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15841 \{\par
15842   mColorStops.insert(position, color);\par
15843   mColorBufferInvalidated = true;\par
15844 \}\par
}
}
{\xe \v setColorStops\:QCPColorGradient}
{\xe \v QCPColorGradient\:setColorStops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setColorStops (const QMap< double, QColor > &  {\i colorStops})}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets at which positions from 0 to 1 which color shall occur. The positions are the keys, the colors are the values of the passed QMap {\i colorStops} . In between these color stops, the color is interpolated according to {\b setColorInterpolation}.\par
A more convenient way to create a custom gradient may be to clear all color stops with {\b clearColorStops} (or creating a new, empty {\b QCPColorGradient}) and then adding them one by one with {\b setColorStopAt}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b clearColorStops} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15829 \{\par
15830   mColorStops = colorStops;\par
15831   mColorBufferInvalidated = true;\par
15832 \}\par
}
}
{\xe \v setLevelCount\:QCPColorGradient}
{\xe \v QCPColorGradient\:setLevelCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setLevelCount (int  {\i n})}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of discretization levels of the color gradient to {\i n} . The default is 350 which is typically enough to create a smooth appearance. The minimum number of levels is 2.\par
 \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15804 \{\par
15805   if (n < 2)\par
15806   \{\par
15807     qDebug() << Q_FUNC_INFO << "n must be greater or equal 2 but was" << n;\par
15808     n = 2;\par
15809   \}\par
15810   if (n != mLevelCount)\par
15811   \{\par
15812     mLevelCount = n;\par
15813     mColorBufferInvalidated = true;\par
15814   \}\par
15815 \}\par
}
}
{\xe \v setPeriodic\:QCPColorGradient}
{\xe \v QCPColorGradient\:setPeriodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::setPeriodic (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether data points that are outside the configured data range (e.g. {\b QCPColorMap::setDataRange}) are colored by periodically repeating the color gradient or whether they all have the same color, corresponding to the respective gradient boundary color.\par
As shown in the image above, gradients that have the same start and end color are especially suitable for a periodic gradient mapping, since they produce smooth color transitions throughout the color map. A preset that has this property is {\b gpHues}.\par
In practice, using periodic color gradients makes sense when the data corresponds to a periodic dimension, such as an angle or a phase. If this is not the case, the color encoding might become ambiguous, because multiple different data values are shown as the same color. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15878 \{\par
15879   mPeriodic = enabled;\par
15880 \}\par
}
}
{\xe \v stopsUseAlpha\:QCPColorGradient}
{\xe \v QCPColorGradient\:stopsUseAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::stopsUseAlpha () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16257 \{\par
16258   for (QMap<double, QColor>::const_iterator it=mColorStops.constBegin(); it!=mColorStops.constEnd(); ++it)\par
16259   \{\par
16260     if (it.value().alpha() < 255)\par
16261       return true;\par
16262   \}\par
16263   return false;\par
16264 \}\par
}
}
{\xe \v updateColorBuffer\:QCPColorGradient}
{\xe \v QCPColorGradient\:updateColorBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPColorGradient::updateColorBuffer (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16272 \{\par
16273   if (mColorBuffer.size() != mLevelCount)\par
16274     mColorBuffer.resize(mLevelCount);\par
16275   if (mColorStops.size() > 1)\par
16276   \{\par
16277     double indexToPosFactor = 1.0/(double)(mLevelCount-1);\par
16278     const bool useAlpha = stopsUseAlpha();\par
16279     for (int i=0; i<mLevelCount; ++i)\par
16280     \{\par
16281       double position = i*indexToPosFactor;\par
16282       QMap<double, QColor>::const_iterator it = mColorStops.lowerBound(position);\par
16283       if (it == mColorStops.constEnd()) // position is on or after last stop, use color of last stop\par
16284       \{\par
16285         mColorBuffer[i] = (it-1).value().rgba();\par
16286       \} else if (it == mColorStops.constBegin()) // position is on or before first stop, use color of first stop\par
16287       \{\par
16288         mColorBuffer[i] = it.value().rgba();\par
16289       \} else // position is in between stops (or on an intermediate stop), interpolate color\par
16290       \{\par
16291         QMap<double, QColor>::const_iterator high = it;\par
16292         QMap<double, QColor>::const_iterator low = it-1;\par
16293         double t = (position-low.key())/(high.key()-low.key()); // interpolation factor 0..1\par
16294         switch (mColorInterpolation)\par
16295         \{\par
16296           case ciRGB:\par
16297           \{\par
16298             if (useAlpha)\par
16299             \{\par
16300               const int alpha = (1-t)*low.value().alpha() + t*high.value().alpha();\par
16301               const float alphaPremultiplier = alpha/255.0f; // since we use QImage::Format_ARGB32_Premultiplied\par
16302               mColorBuffer[i] = qRgba(((1-t)*low.value().red() + t*high.value().red())*alphaPremultiplier,\par
16303                                       ((1-t)*low.value().green() + t*high.value().green())*alphaPremultiplier,\par
16304                                       ((1-t)*low.value().blue() + t*high.value().blue())*alphaPremultiplier,\par
16305                                       alpha);\par
16306             \} else\par
16307             \{\par
16308               mColorBuffer[i] = qRgb(((1-t)*low.value().red() + t*high.value().red()),\par
16309                                      ((1-t)*low.value().green() + t*high.value().green()),\par
16310                                      ((1-t)*low.value().blue() + t*high.value().blue()));\par
16311             \}\par
16312             break;\par
16313           \}\par
16314           case ciHSV:\par
16315           \{\par
16316             QColor lowHsv = low.value().toHsv();\par
16317             QColor highHsv = high.value().toHsv();\par
16318             double hue = 0;\par
16319             double hueDiff = highHsv.hueF()-lowHsv.hueF();\par
16320             if (hueDiff > 0.5)\par
16321               hue = lowHsv.hueF() - t*(1.0-hueDiff);\par
16322             else if (hueDiff < -0.5)\par
16323               hue = lowHsv.hueF() + t*(1.0+hueDiff);\par
16324             else\par
16325               hue = lowHsv.hueF() + t*hueDiff;\par
16326             if (hue < 0) hue += 1.0;\par
16327             else if (hue >= 1.0) hue -= 1.0;\par
16328             if (useAlpha)\par
16329             \{\par
16330               const QRgb rgb = QColor::fromHsvF(hue,\par
16331                                                 (1-t)*lowHsv.saturationF() + t*highHsv.saturationF(),\par
16332                                                 (1-t)*lowHsv.valueF() + t*highHsv.valueF()).rgb();\par
16333               const float alpha = (1-t)*lowHsv.alphaF() + t*highHsv.alphaF();\par
16334               mColorBuffer[i] = qRgba(qRed(rgb)*alpha, qGreen(rgb)*alpha, qBlue(rgb)*alpha, 255*alpha);\par
16335             \}\par
16336             else\par
16337             \{\par
16338               mColorBuffer[i] = QColor::fromHsvF(hue,\par
16339                                                  (1-t)*lowHsv.saturationF() + t*highHsv.saturationF(),\par
16340                                                  (1-t)*lowHsv.valueF() + t*highHsv.valueF()).rgb();\par
16341             \}\par
16342             break;\par
16343           \}\par
16344         \}\par
16345       \}\par
16346     \}\par
16347   \} else if (mColorStops.size() == 1)\par
16348   \{\par
16349     const QRgb rgb = mColorStops.constBegin().value().rgb();\par
16350     const float alpha = mColorStops.constBegin().value().alphaF();\par
16351     mColorBuffer.fill(qRgba(qRed(rgb)*alpha, qGreen(rgb)*alpha, qBlue(rgb)*alpha, 255*alpha));\par
16352   \} else // mColorStops is empty, fill color buffer with black\par
16353   \{\par
16354     mColorBuffer.fill(qRgb(0, 0, 0));\par
16355   \}\par
16356   mColorBufferInvalidated = false;\par
16357 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mColorBuffer\:QCPColorGradient}
{\xe \v QCPColorGradient\:mColorBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<QRgb> QCPColorGradient::mColorBuffer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mColorBufferInvalidated\:QCPColorGradient}
{\xe \v QCPColorGradient\:mColorBufferInvalidated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::mColorBufferInvalidated{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mColorInterpolation\:QCPColorGradient}
{\xe \v QCPColorGradient\:mColorInterpolation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ColorInterpolation} QCPColorGradient::mColorInterpolation{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mColorStops\:QCPColorGradient}
{\xe \v QCPColorGradient\:mColorStops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMap<double, QColor> QCPColorGradient::mColorStops{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLevelCount\:QCPColorGradient}
{\xe \v QCPColorGradient\:mLevelCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPColorGradient::mLevelCount{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPeriodic\:QCPColorGradient}
{\xe \v QCPColorGradient\:mPeriodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPColorGradient::mPeriodic{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documentação para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}}