{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência da Classe QCPAxisRect\par \pard\plain 
{\tc\tcl2 \v QCPAxisRect}
{\xe \v QCPAxisRect}
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds multiple axes and arranges them in a rectangular shape. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Diagrama de hierarquia para QCPAxisRect:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classQCPAxisRect__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b UpdatePhase} \{ {\b upPreparation}, 
{\b upMargins}, 
{\b upLayout}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SizeConstraintRect} \{ {\b scrInnerRect}, 
{\b scrOuterRect}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Sinais\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b layerChanged} ({\b QCPLayer} *newLayer)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} ({\b QCustomPlot} *{\b parentPlot}, bool setupDefaultAxes=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAxisRect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b background} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b backgroundBrush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b backgroundScaled} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b backgroundScaledMode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientations {\b rangeDrag} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientations {\b rangeZoom} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b rangeDragAxis} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b rangeZoomAxis} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b rangeDragAxes} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b rangeZoomAxes} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b rangeZoomFactor} (Qt::Orientation orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QPixmap &pm)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QPixmap &pm, bool scaled, Qt::AspectRatioMode mode=Qt::KeepAspectRatioByExpanding)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackground} (const QBrush &brush)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackgroundScaled} (bool scaled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBackgroundScaledMode} (Qt::AspectRatioMode mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeDrag} (Qt::Orientations orientations)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoom} (Qt::Orientations orientations)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeDragAxes} ({\b QCPAxis} *horizontal, {\b QCPAxis} *vertical)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeDragAxes} (QList< {\b QCPAxis} *> {\b axes})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeDragAxes} (QList< {\b QCPAxis} *> horizontal, QList< {\b QCPAxis} *> vertical)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomAxes} ({\b QCPAxis} *horizontal, {\b QCPAxis} *vertical)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomAxes} (QList< {\b QCPAxis} *> {\b axes})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomAxes} (QList< {\b QCPAxis} *> horizontal, QList< {\b QCPAxis} *> vertical)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomFactor} (double horizontalFactor, double verticalFactor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeZoomFactor} (double factor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b axisCount} ({\b QCPAxis::AxisType} type) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b axis} ({\b QCPAxis::AxisType} type, int index=0) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b axes} (QCPAxis::AxisTypes types) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b axes} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b addAxis} ({\b QCPAxis::AxisType} type, {\b QCPAxis} *{\b axis}=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAxis} * > {\b addAxes} (QCPAxis::AxisTypes types)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeAxis} ({\b QCPAxis} *{\b axis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutInset} * {\b insetLayout} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b zoom} (const QRectF &pixelRect)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b zoom} (const QRectF &pixelRect, const QList< {\b QCPAxis} *> &affectedAxes)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupFullAxesBox} (bool connectRanges=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractPlottable} * > {\b plottables} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPGraph} * > {\b graphs} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractItem} * > {\b items} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b left} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b right} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b top} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bottom} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b width} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b height} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b size} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b topLeft} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b topRight} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b bottomLeft} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b bottomRight} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPoint {\b center} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b update} ({\b UpdatePhase} phase) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QList< {\b QCPLayoutElement} * > {\b elements} (bool recursive) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayout} * {\b layout} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b rect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b outerRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b margins} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b minimumMargins} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::MarginSides {\b autoMargins} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b minimumSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b maximumSize} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SizeConstraintRect} {\b sizeConstraintRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPMarginGroup} * {\b marginGroup} ({\b QCP::MarginSide} side) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QHash< {\b QCP::MarginSide}, {\b QCPMarginGroup} * > {\b marginGroups} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOuterRect} (const QRect &{\b rect})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMargins} (const QMargins &{\b margins})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinimumMargins} (const QMargins &{\b margins})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAutoMargins} (QCP::MarginSides sides)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinimumSize} (const QSize &{\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMinimumSize} (int {\b width}, int {\b height})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMaximumSize} (const QSize &{\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMaximumSize} (int {\b width}, int {\b height})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSizeConstraintRect} ({\b SizeConstraintRect} constraintRect)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMarginGroup} (QCP::MarginSides sides, {\b QCPMarginGroup} *group)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b minimumOuterSizeHint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QSize {\b maximumOuterSizeHint} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b visible} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b parentPlot} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayerable} * {\b parentLayerable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b layer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiased} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVisible} (bool on)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT bool {\b setLayer} ({\b QCPLayer} *{\b layer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setLayer} (const QString &layerName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiased} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b realVisibility} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b calculateAutoMargin} ({\b QCP::MarginSide} side) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b layoutChanged} () {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event, const QPointF &startPos) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawBackground} ({\b QCPPainter} *painter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateAxesOffset} ({\b QCPAxis::AxisType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parentPlotInitialized} ({\b QCustomPlot} *{\b parentPlot}) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QRect {\b clipRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseDoubleClickEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initializeParentPlot} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setParentLayerable} ({\b QCPLayerable} *{\b parentLayerable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveToLayer} ({\b QCPLayer} *{\b layer}, bool prepend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyAntialiasingHint} ({\b QCPPainter} *painter, bool localAntialiased, {\b QCP::AntialiasedElement} overrideElement) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBackgroundBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mBackgroundPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPixmap {\b mScaledBackgroundPixmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mBackgroundScaled}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::AspectRatioMode {\b mBackgroundScaledMode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayoutInset} * {\b mInsetLayout}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientations {\b mRangeDrag}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientations {\b mRangeZoom}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QPointer< {\b QCPAxis} > > {\b mRangeDragHorzAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QPointer< {\b QCPAxis} > > {\b mRangeDragVertAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QPointer< {\b QCPAxis} > > {\b mRangeZoomHorzAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< QPointer< {\b QCPAxis} > > {\b mRangeZoomVertAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mRangeZoomFactorHorz}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mRangeZoomFactorVert}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPRange} > {\b mDragStartHorzRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPRange} > {\b mDragStartVertRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mAADragBackup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mNotAADragBackup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mDragging}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QHash< {\b QCPAxis::AxisType}, QList< {\b QCPAxis} * > > {\b mAxes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayout} * {\b mParentLayout}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b mMinimumSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b mMaximumSize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SizeConstraintRect} {\b mSizeConstraintRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QRect {\b mOuterRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b mMargins}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QMargins {\b mMinimumMargins}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::MarginSides {\b mAutoMargins}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QHash< {\b QCP::MarginSide}, {\b QCPMarginGroup} * > {\b mMarginGroups}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mVisible}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPLayerable} > {\b mParentLayerable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b mLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiased}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds multiple axes and arranges them in a rectangular shape. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class represents an axis rect, a rectangular area that is bounded on all sides with an arbitrary number of axes.\par
Initially {\b QCustomPlot} has one axis rect, accessible via {\b QCustomPlot::axisRect()}. However, the layout system allows to have multiple axis rects, e.g. arranged in a grid layout ({\b QCustomPlot::plotLayout}).\par
By default, {\b QCPAxisRect} comes with four axes, at bottom, top, left and right. They can be accessed via {\b axis} by providing the respective axis type ({\b QCPAxis::AxisType}) and index. If you need all axes in the axis rect, use {\b axes}. The top and right axes are set to be invisible initially ({\b QCPAxis::setVisible}). To add more axes to a side, use {\b addAxis} or {\b addAxes}. To remove an axis, use {\b removeAxis}.\par
The axis rect layerable itself only draws a background pixmap or color, if specified ({\b setBackground}). It is placed on the "background" layer initially (see {\b QCPLayer} for an explanation of the {\b QCustomPlot} layer system). The axes that are held by the axis rect can be placed on other layers, independently of the axis rect.\par
Every axis rect has a child layout of type {\b QCPLayoutInset}. It is accessible via {\b insetLayout} and can be used to have other layout elements (or even other layouts with multiple elements) hovering inside the axis rect.\par
If an axis rect is clicked and dragged, it processes this by moving certain axis ranges. The behaviour can be controlled with {\b setRangeDrag} and {\b setRangeDragAxes}. If the mouse wheel is scrolled while the cursor is on the axis rect, certain axes are scaled. This is controllable via {\b setRangeZoom}, {\b setRangeZoomAxes} and {\b setRangeZoomFactor}. These interactions are only enabled if {\b QCustomPlot::setInteractions} contains {\b QCP::iRangeDrag} and {\b QCP::iRangeZoom}.\par
 {\qc Overview of the spacings and paddings that define the geometry of an axis. The dashed line on the far left indicates the viewport/widget border.}  \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerações\par
\pard\plain 
{\xe \v SizeConstraintRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:SizeConstraintRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPLayoutElement::SizeConstraintRect}{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines to which rect of a layout element the size constraints that can be set via {\b setMinimumSize} and {\b setMaximumSize} apply. The outer rect ({\b outerRect}) includes the margins (e.g. in the case of a {\b QCPAxisRect} the axis labels), whereas the inner rect ({\b rect}) does not.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSizeConstraintRect} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v scrInnerRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:scrInnerRect}
{\qr scrInnerRect{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum/Maximum size constraints apply to inner rect. \par
}\cell }{\row }
{\xe \v scrOuterRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:scrOuterRect}
{\qr scrOuterRect{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1211                           \{ scrInnerRect \par
 1212                             , scrOuterRect \par
 1213                           \};\par
}
}
{\xe \v UpdatePhase\:QCPAxisRect}
{\xe \v QCPAxisRect\:UpdatePhase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPLayoutElement::UpdatePhase}{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the phases of the update process, that happens just before a replot. At each phase, {\b update} is called with the according UpdatePhase value. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v upPreparation\:QCPAxisRect}
{\xe \v QCPAxisRect\:upPreparation}
{\qr upPreparation{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Phase used for any type of preparation that needs to be done before margin calculation and layout. \par
}\cell }{\row }
{\xe \v upMargins\:QCPAxisRect}
{\xe \v QCPAxisRect\:upMargins}
{\qr upMargins{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Phase in which the margins are calculated and set. \par
}\cell }{\row }
{\xe \v upLayout\:QCPAxisRect}
{\xe \v QCPAxisRect\:upLayout}
{\qr upLayout{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Final phase in which the layout system places the rects of the elements. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1197                    \{ upPreparation \par
 1198                      ,upMargins    \par
 1199                      ,upLayout     \par
 1200                    \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v QCPAxisRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:QCPAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisRect::QCPAxisRect ({\b QCustomPlot} *  {\i parentPlot}, bool  {\i setupDefaultAxes} = {\f2 true}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b QCPAxisRect} instance and sets default values. An axis is added for each of the four sides, the top and right axes are set invisible initially. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16780                                                                        :\par
16781   QCPLayoutElement(parentPlot),\par
16782   mBackgroundBrush(Qt::NoBrush),\par
16783   mBackgroundScaled(true),\par
16784   mBackgroundScaledMode(Qt::KeepAspectRatioByExpanding),\par
16785   mInsetLayout(new QCPLayoutInset),\par
16786   mRangeDrag(Qt::Horizontal|Qt::Vertical),\par
16787   mRangeZoom(Qt::Horizontal|Qt::Vertical),\par
16788   mRangeZoomFactorHorz(0.85),\par
16789   mRangeZoomFactorVert(0.85),\par
16790   mDragging(false)\par
16791 \{\par
16792   mInsetLayout->initializeParentPlot(mParentPlot);\par
16793   mInsetLayout->setParentLayerable(this);\par
16794   mInsetLayout->setParent(this);\par
16795   \par
16796   setMinimumSize(50, 50);\par
16797   setMinimumMargins(QMargins(15, 15, 15, 15));\par
16798   mAxes.insert(QCPAxis::atLeft, QList<QCPAxis*>());\par
16799   mAxes.insert(QCPAxis::atRight, QList<QCPAxis*>());\par
16800   mAxes.insert(QCPAxis::atTop, QList<QCPAxis*>());\par
16801   mAxes.insert(QCPAxis::atBottom, QList<QCPAxis*>());\par
16802   \par
16803   if (setupDefaultAxes)\par
16804   \{\par
16805     QCPAxis *xAxis = addAxis(QCPAxis::atBottom);\par
16806     QCPAxis *yAxis = addAxis(QCPAxis::atLeft);\par
16807     QCPAxis *xAxis2 = addAxis(QCPAxis::atTop);\par
16808     QCPAxis *yAxis2 = addAxis(QCPAxis::atRight);\par
16809     setRangeDragAxes(xAxis, yAxis);\par
16810     setRangeZoomAxes(xAxis, yAxis);\par
16811     xAxis2->setVisible(false);\par
16812     yAxis2->setVisible(false);\par
16813     xAxis->grid()->setVisible(true);\par
16814     yAxis->grid()->setVisible(true);\par
16815     xAxis2->grid()->setVisible(false);\par
16816     yAxis2->grid()->setVisible(false);\par
16817     xAxis2->grid()->setZeroLinePen(Qt::NoPen);\par
16818     yAxis2->grid()->setZeroLinePen(Qt::NoPen);\par
16819     xAxis2->grid()->setVisible(false);\par
16820     yAxis2->grid()->setVisible(false);\par
16821   \}\par
16822 \}\par
}
}
{\xe \v ~QCPAxisRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:~QCPAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxisRect::~QCPAxisRect (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16825 \{\par
16826   delete mInsetLayout;\par
16827   mInsetLayout = 0;\par
16828   \par
16829   QList<QCPAxis*> axesList = axes();\par
16830   for (int i=0; i<axesList.size(); ++i)\par
16831     removeAxis(axesList.at(i));\par
16832 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções membros\par
\pard\plain 
{\xe \v addAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:addAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::addAxes (QCPAxis::AxisTypes  {\i types})}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new axis with {\b addAxis} to each axis rect side specified in {\i types} . This may be an {\f2 or} -combination of {\b QCPAxis::AxisType}, so axes can be added to multiple sides at once.\par
Returns a list of the added axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addAxis}, {\b setupFullAxesBox} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16976 \{\par
16977   QList<QCPAxis*> result;\par
16978   if (types.testFlag(QCPAxis::atLeft))\par
16979     result << addAxis(QCPAxis::atLeft);\par
16980   if (types.testFlag(QCPAxis::atRight))\par
16981     result << addAxis(QCPAxis::atRight);\par
16982   if (types.testFlag(QCPAxis::atTop))\par
16983     result << addAxis(QCPAxis::atTop);\par
16984   if (types.testFlag(QCPAxis::atBottom))\par
16985     result << addAxis(QCPAxis::atBottom);\par
16986   return result;\par
16987 \}\par
}
}
{\xe \v addAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:addAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCPAxisRect::addAxis ({\b QCPAxis::AxisType}  {\i type}, {\b QCPAxis} *  {\i axis} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new axis to the axis rect side specified with {\i type} , and returns it. If {\i axis}  is 0, a new {\b QCPAxis} instance is created internally. {\b QCustomPlot} owns the returned axis, so if you want to remove an axis, use {\b removeAxis} instead of deleting it manually.\par
You may inject {\b QCPAxis} instances (or subclasses of {\b QCPAxis}) by setting {\i axis}  to an axis that was previously created outside {\b QCustomPlot}. It is important to note that {\b QCustomPlot} takes ownership of the axis, so you may not delete it afterwards. Further, the {\i axis}  must have been created with this axis rect as parent and with the same axis type as specified in {\i type} . If this is not the case, a debug output is generated, the axis is not added, and the method returns 0.\par
This method can not be used to move {\i axis}  between axis rects. The same {\i axis}  instance must not be added multiple times to the same or different axis rects.\par
If an axis rect side already contains one or more axes, the lower and upper endings of the new axis ({\b QCPAxis::setLowerEnding}, {\b QCPAxis::setUpperEnding}) are set to {\b QCPLineEnding::esHalfBar}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addAxes}, {\b setupFullAxesBox} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16921 \{\par
16922   QCPAxis *newAxis = axis;\par
16923   if (!newAxis)\par
16924   \{\par
16925     newAxis = new QCPAxis(this, type);\par
16926   \} else // user provided existing axis instance, do some sanity checks\par
16927   \{\par
16928     if (newAxis->axisType() != type)\par
16929     \{\par
16930       qDebug() << Q_FUNC_INFO << "passed axis has different axis type than specified in type parameter";\par
16931       return 0;\par
16932     \}\par
16933     if (newAxis->axisRect() != this)\par
16934     \{\par
16935       qDebug() << Q_FUNC_INFO << "passed axis doesn't have this axis rect as parent axis rect";\par
16936       return 0;\par
16937     \}\par
16938     if (axes().contains(newAxis))\par
16939     \{\par
16940       qDebug() << Q_FUNC_INFO << "passed axis is already owned by this axis rect";\par
16941       return 0;\par
16942     \}\par
16943   \}\par
16944   if (mAxes[type].size() > 0) // multiple axes on one side, add half-bar axis ending to additional axes with offset\par
16945   \{\par
16946     bool invert = (type == QCPAxis::atRight) || (type == QCPAxis::atBottom);\par
16947     newAxis->setLowerEnding(QCPLineEnding(QCPLineEnding::esHalfBar, 6, 10, !invert));\par
16948     newAxis->setUpperEnding(QCPLineEnding(QCPLineEnding::esHalfBar, 6, 10, invert));\par
16949   \}\par
16950   mAxes[type].append(newAxis);\par
16951   \par
16952   // reset convenience axis pointers on parent QCustomPlot if they are unset:\par
16953   if (mParentPlot && mParentPlot->axisRectCount() > 0 && mParentPlot->axisRect(0) == this)\par
16954   \{\par
16955     switch (type)\par
16956     \{\par
16957       case QCPAxis::atBottom: \{ if (!mParentPlot->xAxis) mParentPlot->xAxis = newAxis; break; \}\par
16958       case QCPAxis::atLeft: \{ if (!mParentPlot->yAxis) mParentPlot->yAxis = newAxis; break; \}\par
16959       case QCPAxis::atTop: \{ if (!mParentPlot->xAxis2) mParentPlot->xAxis2 = newAxis; break; \}\par
16960       case QCPAxis::atRight: \{ if (!mParentPlot->yAxis2) mParentPlot->yAxis2 = newAxis; break; \}\par
16961     \}\par
16962   \}\par
16963   \par
16964   return newAxis;\par
16965 \}\par
}
}
{\xe \v antialiased\:QCPAxisRect}
{\xe \v QCPAxisRect\:antialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::antialiased () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   711 \{ return mAntialiased; \}\par
}
}
{\xe \v applyAntialiasingHint\:QCPAxisRect}
{\xe \v QCPAxisRect\:applyAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::applyAntialiasingHint ({\b QCPPainter} *  {\i painter}, bool  {\i localAntialiased}, {\b QCP::AntialiasedElement}  {\i overrideElement}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1567 \{\par
 1568   if (mParentPlot && mParentPlot->notAntialiasedElements().testFlag(overrideElement))\par
 1569     painter->setAntialiasing(false);\par
 1570   else if (mParentPlot && mParentPlot->antialiasedElements().testFlag(overrideElement))\par
 1571     painter->setAntialiasing(true);\par
 1572   else\par
 1573     painter->setAntialiasing(localAntialiased);\par
 1574 \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPAxisRect}
{\xe \v QCPAxisRect\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17258 \{\par
17259   painter->setAntialiasing(false);\par
17260 \}\par
}
}
{\xe \v autoMargins\:QCPAxisRect}
{\xe \v QCPAxisRect\:autoMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::MarginSides QCPLayoutElement::autoMargins () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1225 \{ return mAutoMargins; \}\par
}
}
{\xe \v axes\:QCPAxisRect}
{\xe \v QCPAxisRect\:axes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::axes (QCPAxis::AxisTypes  {\i types}) const}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all axes on the axis rect sides specified with {\i types} .\par
{\i types}  may be a single {\b QCPAxis::AxisType} or an {\f2 or} -combination, to get the axes of multiple sides.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16871 \{\par
16872   QList<QCPAxis*> result;\par
16873   if (types.testFlag(QCPAxis::atLeft))\par
16874     result << mAxes.value(QCPAxis::atLeft);\par
16875   if (types.testFlag(QCPAxis::atRight))\par
16876     result << mAxes.value(QCPAxis::atRight);\par
16877   if (types.testFlag(QCPAxis::atTop))\par
16878     result << mAxes.value(QCPAxis::atTop);\par
16879   if (types.testFlag(QCPAxis::atBottom))\par
16880     result << mAxes.value(QCPAxis::atBottom);\par
16881   return result;\par
16882 \}\par
}
}
{\xe \v axes\:QCPAxisRect}
{\xe \v QCPAxisRect\:axes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::axes () const}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Returns all axes of this axis rect. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16889 \{\par
16890   QList<QCPAxis*> result;\par
16891   QHashIterator<QCPAxis::AxisType, QList<QCPAxis*> > it(mAxes);\par
16892   while (it.hasNext())\par
16893   \{\par
16894     it.next();\par
16895     result << it.value();\par
16896   \}\par
16897   return result;\par
16898 \}\par
}
}
{\xe \v axis\:QCPAxisRect}
{\xe \v QCPAxisRect\:axis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCPAxisRect::axis ({\b QCPAxis::AxisType}  {\i type}, int  {\i index} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the axis with the given {\i index}  on the axis rect side specified with {\i type} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axisCount}, {\b axes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16850 \{\par
16851   QList<QCPAxis*> ax(mAxes.value(type));\par
16852   if (index >= 0 && index < ax.size())\par
16853   \{\par
16854     return ax.at(index);\par
16855   \} else\par
16856   \{\par
16857     qDebug() << Q_FUNC_INFO << "Axis index out of bounds:" << index;\par
16858     return 0;\par
16859   \}\par
16860 \}\par
}
}
{\xe \v axisCount\:QCPAxisRect}
{\xe \v QCPAxisRect\:axisCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::axisCount ({\b QCPAxis::AxisType}  {\i type}) const}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of axes on the axis rect side specified with {\i type} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b axis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16840 \{\par
16841   return mAxes.value(type).size();\par
16842 \}\par
}
}
{\xe \v background\:QCPAxisRect}
{\xe \v QCPAxisRect\:background}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPAxisRect::background () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4597 \{ return mBackgroundPixmap; \}\par
}
}
{\xe \v backgroundBrush\:QCPAxisRect}
{\xe \v QCPAxisRect\:backgroundBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAxisRect::backgroundBrush () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4598 \{ return mBackgroundBrush; \}\par
}
}
{\xe \v backgroundScaled\:QCPAxisRect}
{\xe \v QCPAxisRect\:backgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisRect::backgroundScaled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4599 \{ return mBackgroundScaled; \}\par
}
}
{\xe \v backgroundScaledMode\:QCPAxisRect}
{\xe \v QCPAxisRect\:backgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCPAxisRect::backgroundScaledMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4600 \{ return mBackgroundScaledMode; \}\par
}
}
{\xe \v bottom\:QCPAxisRect}
{\xe \v QCPAxisRect\:bottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::bottom () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position of the bottom border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4647 \{ return mRect.bottom(); \}\par
}
}
{\xe \v bottomLeft\:QCPAxisRect}
{\xe \v QCPAxisRect\:bottomLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::bottomLeft () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the bottom left corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4653 \{ return mRect.bottomLeft(); \}\par
}
}
{\xe \v bottomRight\:QCPAxisRect}
{\xe \v QCPAxisRect\:bottomRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::bottomRight () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the bottom right corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4654 \{ return mRect.bottomRight(); \}\par
}
}
{\xe \v calculateAutoMargin\:QCPAxisRect}
{\xe \v QCPAxisRect\:calculateAutoMargin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::calculateAutoMargin ({\b QCP::MarginSide}  {\i side}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17720 \{\par
17721   if (!mAutoMargins.testFlag(side))\par
17722     qDebug() << Q_FUNC_INFO << "Called with side that isn't specified as auto margin";\par
17723   \par
17724   updateAxesOffset(QCPAxis::marginSideToAxisType(side));\par
17725   \par
17726   // note: only need to look at the last (outer most) axis to determine the total margin, due to updateAxisOffset call\par
17727   const QList<QCPAxis*> axesList = mAxes.value(QCPAxis::marginSideToAxisType(side));\par
17728   if (axesList.size() > 0)\par
17729     return axesList.last()->offset() + axesList.last()->calculateMargin();\par
17730   else\par
17731     return 0;\par
17732 \}\par
}
}
{\xe \v center\:QCPAxisRect}
{\xe \v QCPAxisRect\:center}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::center () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the center of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4655 \{ return mRect.center(); \}\par
}
}
{\xe \v clipRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:clipRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayerable::clipRect () const{\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1623 \{\par
 1624   if (mParentPlot)\par
 1625     return mParentPlot->viewport();\par
 1626   else\par
 1627     return QRect();\par
 1628 \}\par
}
}
{\xe \v deselectEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABCX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABCY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOA \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAATN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1679 \{\par
 1680   Q_UNUSED(selectionStateChanged)\par
 1681 \}\par
}
}
{\xe \v draw\:QCPAxisRect}
{\xe \v QCPAxisRect\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplementado por {\b QCPColorScaleAxisRectPrivate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17264 \{\par
17265   drawBackground(painter);\par
17266 \}\par
}
}
{\xe \v drawBackground\:QCPAxisRect}
{\xe \v QCPAxisRect\:drawBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::drawBackground ({\b QCPPainter} *  {\i painter}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17665 \{\par
17666   // draw background fill:\par
17667   if (mBackgroundBrush != Qt::NoBrush)\par
17668     painter->fillRect(mRect, mBackgroundBrush);\par
17669   \par
17670   // draw background pixmap (on top of fill, if brush specified):\par
17671   if (!mBackgroundPixmap.isNull())\par
17672   \{\par
17673     if (mBackgroundScaled)\par
17674     \{\par
17675       // check whether mScaledBackground needs to be updated:\par
17676       QSize scaledSize(mBackgroundPixmap.size());\par
17677       scaledSize.scale(mRect.size(), mBackgroundScaledMode);\par
17678       if (mScaledBackgroundPixmap.size() != scaledSize)\par
17679         mScaledBackgroundPixmap = mBackgroundPixmap.scaled(mRect.size(), mBackgroundScaledMode, Qt::SmoothTransformation);\par
17680       painter->drawPixmap(mRect.topLeft()+QPoint(0, -1), mScaledBackgroundPixmap, QRect(0, 0, mRect.width(), mRect.height()) & mScaledBackgroundPixmap.rect());\par
17681     \} else\par
17682     \{\par
17683       painter->drawPixmap(mRect.topLeft()+QPoint(0, -1), mBackgroundPixmap, QRect(0, 0, mRect.width(), mRect.height()));\par
17684     \}\par
17685   \}\par
17686 \}\par
}
}
{\xe \v elements\:QCPAxisRect}
{\xe \v QCPAxisRect\:elements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPLayoutElement} * > QCPAxisRect::elements (bool  {\i recursive}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all child elements in this layout element. If {\i recursive}  is true, all sub-child elements are included in the list, too.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Aviso:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid There may be entries with value 0 in the returned list. (For example, {\b QCPLayoutGrid} may have empty cells which yield 0 at the respective index.) \par
}}{
Reimplementa {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17245 \{\par
17246   QList<QCPLayoutElement*> result;\par
17247   if (mInsetLayout)\par
17248   \{\par
17249     result << mInsetLayout;\par
17250     if (recursive)\par
17251       result << mInsetLayout->elements(recursive);\par
17252   \}\par
17253   return result;\par
17254 \}\par
}
}
{\xe \v graphs\:QCPAxisRect}
{\xe \v QCPAxisRect\:graphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPGraph} * > QCPAxisRect::graphs () const}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the graphs that are associated with this axis rect.\par
A graph is considered associated with an axis rect if its key or value axis (or both) is in this axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottables}, {\b items} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17160 \{\par
17161   // Note: don't append all QCPAxis::graphs() into a list, because we might get duplicate entries\par
17162   QList<QCPGraph*> result;\par
17163   for (int i=0; i<mParentPlot->mGraphs.size(); ++i)\par
17164   \{\par
17165     if (mParentPlot->mGraphs.at(i)->keyAxis()->axisRect() == this || mParentPlot->mGraphs.at(i)->valueAxis()->axisRect() == this)\par
17166       result.append(mParentPlot->mGraphs.at(i));\par
17167   \}\par
17168   return result;\par
17169 \}\par
}
}
{\xe \v height\:QCPAxisRect}
{\xe \v QCPAxisRect\:height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::height () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel height of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4649 \{ return mRect.height(); \}\par
}
}
{\xe \v initializeParentPlot\:QCPAxisRect}
{\xe \v QCPAxisRect\:initializeParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::initializeParentPlot ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1497 \{\par
 1498   if (mParentPlot)\par
 1499   \{\par
 1500     qDebug() << Q_FUNC_INFO << "called with mParentPlot already initialized";\par
 1501     return;\par
 1502   \}\par
 1503   \par
 1504   if (!parentPlot)\par
 1505     qDebug() << Q_FUNC_INFO << "called with parentPlot zero";\par
 1506   \par
 1507   mParentPlot = parentPlot;\par
 1508   parentPlotInitialized(mParentPlot);\par
 1509 \}\par
}
}
{\xe \v insetLayout\:QCPAxisRect}
{\xe \v QCPAxisRect\:insetLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutInset} * QCPAxisRect::insetLayout () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the inset layout of this axis rect. It can be used to place other layout elements (or even layouts with multiple other elements) inside/on top of an axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPLayoutInset} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4634 \{ return mInsetLayout; \}\par
}
}
{\xe \v items\:QCPAxisRect}
{\xe \v QCPAxisRect\:items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractItem} * > QCPAxisRect::items () const}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the items that are associated with this axis rect.\par
An item is considered associated with an axis rect if any of its positions has key or value axis set to an axis that is in this axis rect, or if any of its positions has {\b QCPItemPosition::setAxisRect} set to the axis rect, or if the clip axis rect ({\b QCPAbstractItem::setClipAxisRect}) is set to this axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottables}, {\b graphs} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17182 \{\par
17183   // Note: don't just append all QCPAxis::items() into a list, because we might get duplicate entries\par
17184   //       and miss those items that have this axis rect as clipAxisRect.\par
17185   QList<QCPAbstractItem*> result;\par
17186   for (int itemId=0; itemId<mParentPlot->mItems.size(); ++itemId)\par
17187   \{\par
17188     if (mParentPlot->mItems.at(itemId)->clipAxisRect() == this)\par
17189     \{\par
17190       result.append(mParentPlot->mItems.at(itemId));\par
17191       continue;\par
17192     \}\par
17193     QList<QCPItemPosition*> positions = mParentPlot->mItems.at(itemId)->positions();\par
17194     for (int posId=0; posId<positions.size(); ++posId)\par
17195     \{\par
17196       if (positions.at(posId)->axisRect() == this ||\par
17197           positions.at(posId)->keyAxis()->axisRect() == this ||\par
17198           positions.at(posId)->valueAxis()->axisRect() == this)\par
17199       \{\par
17200         result.append(mParentPlot->mItems.at(itemId));\par
17201         break;\par
17202       \}\par
17203     \}\par
17204   \}\par
17205   return result;\par
17206 \}\par
}
}
{\xe \v layer\:QCPAxisRect}
{\xe \v QCPAxisRect\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::layer () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   710 \{ return mLayer; \}\par
}
}
{\xe \v layerChanged\:QCPAxisRect}
{\xe \v QCPAxisRect\:layerChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::layerChanged ({\b QCPLayer} *  {\i newLayer}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLayer} \par
}}}
{\xe \v layout\:QCPAxisRect}
{\xe \v QCPAxisRect\:layout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayout} * QCPLayoutElement::layout () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parent layout of this layout element. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1220 \{ return mParentLayout; \}\par
}
}
{\xe \v layoutChanged\:QCPAxisRect}
{\xe \v QCPAxisRect\:layoutChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::layoutChanged (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17745 \{\par
17746   if (mParentPlot && mParentPlot->axisRectCount() > 0 && mParentPlot->axisRect(0) == this)\par
17747   \{\par
17748     if (axisCount(QCPAxis::atBottom) > 0 && !mParentPlot->xAxis)\par
17749       mParentPlot->xAxis = axis(QCPAxis::atBottom);\par
17750     if (axisCount(QCPAxis::atLeft) > 0 && !mParentPlot->yAxis)\par
17751       mParentPlot->yAxis = axis(QCPAxis::atLeft);\par
17752     if (axisCount(QCPAxis::atTop) > 0 && !mParentPlot->xAxis2)\par
17753       mParentPlot->xAxis2 = axis(QCPAxis::atTop);\par
17754     if (axisCount(QCPAxis::atRight) > 0 && !mParentPlot->yAxis2)\par
17755       mParentPlot->yAxis2 = axis(QCPAxis::atRight);\par
17756   \}\par
17757 \}\par
}
}
{\xe \v left\:QCPAxisRect}
{\xe \v QCPAxisRect\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::left () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position of the left border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4644 \{ return mRect.left(); \}\par
}
}
{\xe \v marginGroup\:QCPAxisRect}
{\xe \v QCPAxisRect\:marginGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPMarginGroup}* QCPLayoutElement::marginGroup ({\b QCP::MarginSide}  {\i side}) const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1229 \{ return mMarginGroups.value(side, (QCPMarginGroup*)0); \}\par
}
}
{\xe \v marginGroups\:QCPAxisRect}
{\xe \v QCPAxisRect\:marginGroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QHash<{\b QCP::MarginSide}, {\b QCPMarginGroup}*> QCPLayoutElement::marginGroups () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1230 \{ return mMarginGroups; \}\par
}
}
{\xe \v margins\:QCPAxisRect}
{\xe \v QCPAxisRect\:margins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPLayoutElement::margins () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1223 \{ return mMargins; \}\par
}
}
{\xe \v maximumOuterSizeHint\:QCPAxisRect}
{\xe \v QCPAxisRect\:maximumOuterSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::maximumOuterSizeHint () const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the suggested maximum size this layout element (the {\b outerRect}) may be expanded to, if no manual maximum size is set.\par
if a maximum size ({\b setMaximumSize}) was not set manually, parent layouts use the returned size (usually indirectly through {\b QCPLayout::getFinalMaximumOuterSize}) to determine the maximum allowed size of this layout element.\par
A manual maximum size is considered set if it is smaller than Qt's {\f2 QWIDGETSIZE_MAX} .\par
The default implementation simply returns {\f2 QWIDGETSIZE_MAX}  for both width and height, implying no suggested maximum size. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints. \par
}{
Reimplementado por {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKG \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3466 \{\par
 3467   return QSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);\par
 3468 \}\par
}
}
{\xe \v maximumSize\:QCPAxisRect}
{\xe \v QCPAxisRect\:maximumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::maximumSize () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1227 \{ return mMaximumSize; \}\par
}
}
{\xe \v minimumMargins\:QCPAxisRect}
{\xe \v QCPAxisRect\:minimumMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPLayoutElement::minimumMargins () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1224 \{ return mMinimumMargins; \}\par
}
}
{\xe \v minimumOuterSizeHint\:QCPAxisRect}
{\xe \v QCPAxisRect\:minimumOuterSizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::minimumOuterSizeHint () const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the suggested minimum size this layout element (the {\b outerRect}) may be compressed to, if no manual minimum size is set.\par
if a minimum size ({\b setMinimumSize}) was not set manually, parent layouts use the returned size (usually indirectly through {\b QCPLayout::getFinalMinimumOuterSize}) to determine the minimum allowed size of this layout element.\par
A manual minimum size is considered set if it is non-zero.\par
The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints. \par
}{
Reimplementado por {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPPlottableLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPLayoutGrid} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3447 \{\par
 3448   return QSize(mMargins.left()+mMargins.right(), mMargins.top()+mMargins.bottom());\par
 3449 \}\par
}
}
{\xe \v minimumSize\:QCPAxisRect}
{\xe \v QCPAxisRect\:minimumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::minimumSize () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1226 \{ return mMinimumSize; \}\par
}
}
{\xe \v mouseDoubleClickEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:mouseDoubleClickEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseDoubleClickEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The {\b mouseDoubleClickEvent} is called instead of the second {\b mousePressEvent}. So in the case of a double-click, the event succession is {\i pressEvent \'96 releaseEvent \'96 doubleClickEvent \'96 releaseEvent} .\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
Similarly to {\b mousePressEvent}, once a layerable has accepted the {\b mouseDoubleClickEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} and {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1777 \{\par
 1778   Q_UNUSED(details)\par
 1779   event->ignore();\par
 1780 \}\par
}
}
{\xe \v mouseMoveEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::mouseMoveEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17803 \{\par
17804   Q_UNUSED(startPos)\par
17805   // Mouse range dragging interaction:\par
17806   if (mDragging && mParentPlot->interactions().testFlag(QCP::iRangeDrag))\par
17807   \{\par
17808     \par
17809     if (mRangeDrag.testFlag(Qt::Horizontal))\par
17810     \{\par
17811       for (int i=0; i<mRangeDragHorzAxis.size(); ++i)\par
17812       \{\par
17813         QCPAxis *ax = mRangeDragHorzAxis.at(i).data();\par
17814         if (!ax)\par
17815           continue;\par
17816         if (i >= mDragStartHorzRange.size())\par
17817           break;\par
17818         if (ax->mScaleType == QCPAxis::stLinear)\par
17819         \{\par
17820           double diff = ax->pixelToCoord(startPos.x()) - ax->pixelToCoord(event->pos().x());\par
17821           ax->setRange(mDragStartHorzRange.at(i).lower+diff, mDragStartHorzRange.at(i).upper+diff);\par
17822         \} else if (ax->mScaleType == QCPAxis::stLogarithmic)\par
17823         \{\par
17824           double diff = ax->pixelToCoord(startPos.x()) / ax->pixelToCoord(event->pos().x());\par
17825           ax->setRange(mDragStartHorzRange.at(i).lower*diff, mDragStartHorzRange.at(i).upper*diff);\par
17826         \}\par
17827       \}\par
17828     \}\par
17829     \par
17830     if (mRangeDrag.testFlag(Qt::Vertical))\par
17831     \{\par
17832       for (int i=0; i<mRangeDragVertAxis.size(); ++i)\par
17833       \{\par
17834         QCPAxis *ax = mRangeDragVertAxis.at(i).data();\par
17835         if (!ax)\par
17836           continue;\par
17837         if (i >= mDragStartVertRange.size())\par
17838           break;\par
17839         if (ax->mScaleType == QCPAxis::stLinear)\par
17840         \{\par
17841           double diff = ax->pixelToCoord(startPos.y()) - ax->pixelToCoord(event->pos().y());\par
17842           ax->setRange(mDragStartVertRange.at(i).lower+diff, mDragStartVertRange.at(i).upper+diff);\par
17843         \} else if (ax->mScaleType == QCPAxis::stLogarithmic)\par
17844         \{\par
17845           double diff = ax->pixelToCoord(startPos.y()) / ax->pixelToCoord(event->pos().y());\par
17846           ax->setRange(mDragStartVertRange.at(i).lower*diff, mDragStartVertRange.at(i).upper*diff);\par
17847         \}\par
17848       \}\par
17849     \}\par
17850     \par
17851     if (mRangeDrag != 0) // if either vertical or horizontal drag was enabled, do a replot\par
17852     \{\par
17853       if (mParentPlot->noAntialiasingOnDrag())\par
17854         mParentPlot->setNotAntialiasedElements(QCP::aeAll);\par
17855       mParentPlot->replot(QCustomPlot::rpQueuedReplot);\par
17856     \}\par
17857     \par
17858   \}\par
17859 \}\par
}
}
{\xe \v mousePressEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::mousePressEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
{\b QCustomPlot} uses an event propagation system that works the same as Qt's system. If your layerable doesn't reimplement the {\b mousePressEvent} or explicitly calls {\f2 event->ignore()}  in its reimplementation, the event will be propagated to the next layerable in the stacking order.\par
Once a layerable has accepted the {\b mousePressEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} or {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17771 \{\par
17772   Q_UNUSED(details)\par
17773   if (event->buttons() & Qt::LeftButton)\par
17774   \{\par
17775     mDragging = true;\par
17776     // initialize antialiasing backup in case we start dragging:\par
17777     if (mParentPlot->noAntialiasingOnDrag())\par
17778     \{\par
17779       mAADragBackup = mParentPlot->antialiasedElements();\par
17780       mNotAADragBackup = mParentPlot->notAntialiasedElements();\par
17781     \}\par
17782     // Mouse range dragging interaction:\par
17783     if (mParentPlot->interactions().testFlag(QCP::iRangeDrag))\par
17784     \{\par
17785       mDragStartHorzRange.clear();\par
17786       for (int i=0; i<mRangeDragHorzAxis.size(); ++i)\par
17787         mDragStartHorzRange.append(mRangeDragHorzAxis.at(i).isNull() ? QCPRange() : mRangeDragHorzAxis.at(i)->range());\par
17788       mDragStartVertRange.clear();\par
17789       for (int i=0; i<mRangeDragVertAxis.size(); ++i)\par
17790         mDragStartVertRange.append(mRangeDragVertAxis.at(i).isNull() ? QCPRange() : mRangeDragVertAxis.at(i)->range());\par
17791     \}\par
17792   \}\par
17793 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::mouseReleaseEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17863 \{\par
17864   Q_UNUSED(event)\par
17865   Q_UNUSED(startPos)\par
17866   mDragging = false;\par
17867   if (mParentPlot->noAntialiasingOnDrag())\par
17868   \{\par
17869     mParentPlot->setAntialiasedElements(mAADragBackup);\par
17870     mParentPlot->setNotAntialiasedElements(mNotAADragBackup);\par
17871   \}\par
17872 \}\par
}
}
{\xe \v moveToLayer\:QCPAxisRect}
{\xe \v QCPAxisRect\:moveToLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::moveToLayer ({\b QCPLayer} *  {\i layer}, bool  {\i prepend}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1536 \{\par
 1537   if (layer && !mParentPlot)\par
 1538   \{\par
 1539     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1540     return false;\par
 1541   \}\par
 1542   if (layer && layer->parentPlot() != mParentPlot)\par
 1543   \{\par
 1544     qDebug() << Q_FUNC_INFO << "layer" << layer->name() << "is not in same QCustomPlot as this layerable";\par
 1545     return false;\par
 1546   \}\par
 1547   \par
 1548   QCPLayer *oldLayer = mLayer;\par
 1549   if (mLayer)\par
 1550     mLayer->removeChild(this);\par
 1551   mLayer = layer;\par
 1552   if (mLayer)\par
 1553     mLayer->addChild(this, prepend);\par
 1554   if (mLayer != oldLayer)\par
 1555     emit layerChanged(mLayer);\par
 1556   return true;\par
 1557 \}\par
}
}
{\xe \v outerRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:outerRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayoutElement::outerRect () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the outer rect of this layout element. The outer rect is the inner rect expanded by the margins ({\b setMargins}, {\b setAutoMargins}). The outer rect is used (and set via {\b setOuterRect}) by the parent {\b QCPLayout} to control the size of this layout element.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1222 \{ return mOuterRect; \}\par
}
}
{\xe \v parentLayerable\:QCPAxisRect}
{\xe \v QCPAxisRect\:parentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayerable} * QCPLayerable::parentLayerable () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method {\b realVisibility}. This way, layerables only get drawn if their parent layerables are visible, too.\par
Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn't always have a parent layerable, so this function may return 0.\par
A parent layerable is set implicitly when placed inside layout elements and doesn't need to be set manually by the user. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   709 \{ return mParentLayerable.data(); \}\par
}
}
{\xe \v parentPlot\:QCPAxisRect}
{\xe \v QCPAxisRect\:parentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::parentPlot () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   708 \{ return mParentPlot; \}\par
}
}
{\xe \v parentPlotInitialized\:QCPAxisRect}
{\xe \v QCPAxisRect\:parentPlotInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::parentPlotInitialized ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplementado por {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3520 \{\par
 3521   foreach (QCPLayoutElement* el, elements(false))\par
 3522   \{\par
 3523     if (!el->parentPlot())\par
 3524       el->initializeParentPlot(parentPlot);\par
 3525   \}\par
 3526 \}\par
}
}
{\xe \v plottables\:QCPAxisRect}
{\xe \v QCPAxisRect\:plottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractPlottable} * > QCPAxisRect::plottables () const}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the plottables that are associated with this axis rect.\par
A plottable is considered associated with an axis rect if its key or value axis (or both) is in this axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graphs}, {\b items} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17140 \{\par
17141   // Note: don't append all QCPAxis::plottables() into a list, because we might get duplicate entries\par
17142   QList<QCPAbstractPlottable*> result;\par
17143   for (int i=0; i<mParentPlot->mPlottables.size(); ++i)\par
17144   \{\par
17145     if (mParentPlot->mPlottables.at(i)->keyAxis()->axisRect() == this || mParentPlot->mPlottables.at(i)->valueAxis()->axisRect() == this)\par
17146       result.append(mParentPlot->mPlottables.at(i));\par
17147   \}\par
17148   return result;\par
17149 \}\par
}
}
{\xe \v rangeDrag\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientations QCPAxisRect::rangeDrag () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4601 \{ return mRangeDrag; \}\par
}
}
{\xe \v rangeDragAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeDragAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::rangeDragAxes (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all range drag axes of the {\i orientation}  provided.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rangeZoomAxis}, {\b setRangeZoomAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17381 \{\par
17382   QList<QCPAxis*> result;\par
17383   if (orientation == Qt::Horizontal)\par
17384   \{\par
17385     for (int i=0; i<mRangeDragHorzAxis.size(); ++i)\par
17386     \{\par
17387       if (!mRangeDragHorzAxis.at(i).isNull())\par
17388         result.append(mRangeDragHorzAxis.at(i).data());\par
17389     \}\par
17390   \} else\par
17391   \{\par
17392     for (int i=0; i<mRangeDragVertAxis.size(); ++i)\par
17393     \{\par
17394       if (!mRangeDragVertAxis.at(i).isNull())\par
17395         result.append(mRangeDragVertAxis.at(i).data());\par
17396     \}\par
17397   \}\par
17398   return result;\par
17399 \}\par
}
}
{\xe \v rangeDragAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeDragAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCPAxisRect::rangeDragAxis (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range drag axis of the {\i orientation}  provided. If multiple axes were set, returns the first one (use {\b rangeDragAxes} to retrieve a list with all set axes).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeDragAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17354 \{\par
17355   if (orientation == Qt::Horizontal)\par
17356     return mRangeDragHorzAxis.isEmpty() ? 0 : mRangeDragHorzAxis.first().data();\par
17357   else\par
17358     return mRangeDragVertAxis.isEmpty() ? 0 : mRangeDragVertAxis.first().data();\par
17359 \}\par
}
}
{\xe \v rangeZoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientations QCPAxisRect::rangeZoom () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4602 \{ return mRangeZoom; \}\par
}
}
{\xe \v rangeZoomAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeZoomAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAxis} * > QCPAxisRect::rangeZoomAxes (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all range zoom axes of the {\i orientation}  provided.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rangeDragAxis}, {\b setRangeDragAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17407 \{\par
17408   QList<QCPAxis*> result;\par
17409   if (orientation == Qt::Horizontal)\par
17410   \{\par
17411     for (int i=0; i<mRangeZoomHorzAxis.size(); ++i)\par
17412     \{\par
17413       if (!mRangeZoomHorzAxis.at(i).isNull())\par
17414         result.append(mRangeZoomHorzAxis.at(i).data());\par
17415     \}\par
17416   \} else\par
17417   \{\par
17418     for (int i=0; i<mRangeZoomVertAxis.size(); ++i)\par
17419     \{\par
17420       if (!mRangeZoomVertAxis.at(i).isNull())\par
17421         result.append(mRangeZoomVertAxis.at(i).data());\par
17422     \}\par
17423   \}\par
17424   return result;\par
17425 \}\par
}
}
{\xe \v rangeZoomAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeZoomAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis} * QCPAxisRect::rangeZoomAxis (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range zoom axis of the {\i orientation}  provided. If multiple axes were set, returns the first one (use {\b rangeZoomAxes} to retrieve a list with all set axes).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoomAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17368 \{\par
17369   if (orientation == Qt::Horizontal)\par
17370     return mRangeZoomHorzAxis.isEmpty() ? 0 : mRangeZoomHorzAxis.first().data();\par
17371   else\par
17372     return mRangeZoomVertAxis.isEmpty() ? 0 : mRangeZoomVertAxis.first().data();\par
17373 \}\par
}
}
{\xe \v rangeZoomFactor\:QCPAxisRect}
{\xe \v QCPAxisRect\:rangeZoomFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisRect::rangeZoomFactor (Qt::Orientation  {\i orientation})}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the range zoom factor of the {\i orientation}  provided.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoomFactor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17433 \{\par
17434   return (orientation == Qt::Horizontal ? mRangeZoomFactorHorz : mRangeZoomFactorVert);\par
17435 \}\par
}
}
{\xe \v realVisibility\:QCPAxisRect}
{\xe \v QCPAxisRect\:realVisibility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::realVisibility () const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable's layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.\par
If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of {\b QCPLayoutElement}), this function returns true only if this layerable has its visibility set to true and the parent layerable's {\b realVisibility} returns true. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1433 \{\par
 1434   return mVisible && (!mLayer || mLayer->visible()) && (!mParentLayerable || mParentLayerable.data()->realVisibility());\par
 1435 \}\par
}
}
{\xe \v rect\:QCPAxisRect}
{\xe \v QCPAxisRect\:rect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayoutElement::rect () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the inner rect of this layout element. The inner rect is the outer rect ({\b outerRect}, {\b setOuterRect}) shrinked by the margins ({\b setMargins}, {\b setAutoMargins}).\par
In some cases, the area between outer and inner rect is left blank. In other cases the margin area is used to display peripheral graphics while the main content is in the inner rect. This is where automatic margin calculation becomes interesting because it allows the layout element to adapt the margins to the peripheral graphics it wants to draw. For example, {\b QCPAxisRect} draws the axis labels and tick labels in the margin area, thus needs to adjust the margins (if {\b setAutoMargins} is enabled) according to the space required by the labels of the axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b outerRect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1221 \{ return mRect; \}\par
}
}
{\xe \v removeAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:removeAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisRect::removeAxis ({\b QCPAxis} *  {\i axis})}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the specified {\i axis}  from the axis rect and deletes it.\par
Returns true on success, i.e. if {\i axis}  was a valid axis in this axis rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addAxis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16997 \{\par
16998   // don't access axis->axisType() to provide safety when axis is an invalid pointer, rather go through all axis containers:\par
16999   QHashIterator<QCPAxis::AxisType, QList<QCPAxis*> > it(mAxes);\par
17000   while (it.hasNext())\par
17001   \{\par
17002     it.next();\par
17003     if (it.value().contains(axis))\par
17004     \{\par
17005       if (it.value().first() == axis && it.value().size() > 1) // if removing first axis, transfer axis offset to the new first axis (which at this point is the second axis, if it exists)\par
17006         it.value()[1]->setOffset(axis->offset());\par
17007       mAxes[it.key()].removeOne(axis);\par
17008       if (qobject_cast<QCustomPlot*>(parentPlot())) // make sure this isn't called from QObject dtor when QCustomPlot is already destructed (happens when the axis rect is not in any layout and thus QObject-child of QCustomPlot)\par
17009         parentPlot()->axisRemoved(axis);\par
17010       delete axis;\par
17011       return true;\par
17012     \}\par
17013   \}\par
17014   qDebug() << Q_FUNC_INFO << "Axis isn't in axis rect:" << reinterpret_cast<quintptr>(axis);\par
17015   return false;\par
17016 \}\par
}
}
{\xe \v right\:QCPAxisRect}
{\xe \v QCPAxisRect\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::right () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position of the right border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4645 \{ return mRect.right(); \}\par
}
}
{\xe \v selectEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPX \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1659 \{\par
 1660   Q_UNUSED(event)\par
 1661   Q_UNUSED(additive)\par
 1662   Q_UNUSED(details)\par
 1663   Q_UNUSED(selectionStateChanged)\par
 1664 \}\par
}
}
{\xe \v selectionCategory\:QCPAxisRect}
{\xe \v QCPAxisRect\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPLayerable::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPZ \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1609 \{\par
 1610   return QCP::iSelectOther;\par
 1611 \}\par
}
}
{\xe \v selectTest\:QCPAxisRect}
{\xe \v QCPAxisRect\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPLayoutElement::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Layout elements are sensitive to events inside their outer rect. If {\i pos}  is within the outer rect, this method returns a value corresponding to 0.99 times the parent plot's selection tolerance. However, layout elements are not selectable by default. So if {\i onlySelectable}  is true, -1.0 is returned.\par
See {\b QCPLayerable::selectTest} for a general explanation of this virtual method.\par
{\b QCPLayoutElement} subclasses may reimplement this method to provide more specific selection test behaviour. \par
}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplementado por {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALA \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPLayoutInset} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABDW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3495 \{\par
 3496   Q_UNUSED(details)\par
 3497   \par
 3498   if (onlySelectable)\par
 3499     return -1;\par
 3500   \par
 3501   if (QRectF(mOuterRect).contains(pos))\par
 3502   \{\par
 3503     if (mParentPlot)\par
 3504       return mParentPlot->selectionTolerance()*0.99;\par
 3505     else\par
 3506     \{\par
 3507       qDebug() << Q_FUNC_INFO << "parent plot not defined";\par
 3508       return -1;\par
 3509     \}\par
 3510   \} else\par
 3511     return -1;\par
 3512 \}\par
}
}
{\xe \v setAntialiased\:QCPAxisRect}
{\xe \v QCPAxisRect\:setAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setAntialiased (bool  {\i enabled}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this object will be drawn antialiased or not.\par
Note that antialiasing settings may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1418 \{\par
 1419   mAntialiased = enabled;\par
 1420 \}\par
}
}
{\xe \v setAutoMargins\:QCPAxisRect}
{\xe \v QCPAxisRect\:setAutoMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setAutoMargins (QCP::MarginSides  {\i sides}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets on which sides the margin shall be calculated automatically. If a side is calculated automatically, a minimum margin value may be provided with {\b setMinimumMargins}. If a side is set to be controlled manually, the value may be specified with {\b setMargins}.\par
Margin sides that are under automatic control may participate in a {\b QCPMarginGroup} (see {\b setMarginGroup}), to synchronize (align) it with other layout elements in the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setMinimumMargins}, {\b setMargins}, {\b QCP::MarginSide} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3265 \{\par
 3266   mAutoMargins = sides;\par
 3267 \}\par
}
}
{\xe \v setBackground\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackground (const QPixmap &  {\i pm})}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets {\i pm}  as the axis background pixmap. The axis background pixmap will be drawn inside the axis rect. Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds are usually drawn below everything else.\par
For cases where the provided pixmap doesn't have the same size as the axis rect, scaling can be enabled with {\b setBackgroundScaled} and the scaling mode (i.e. whether and how the aspect ratio is preserved) can be set with {\b setBackgroundScaledMode}. To set all these options in one call, consider using the overloaded version of this function.\par
Below the pixmap, the axis rect may be optionally filled with a brush, if specified with {\b setBackground(const QBrush &brush)}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackgroundScaled}, {\b setBackgroundScaledMode}, {\b setBackground(const QBrush &brush)} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17284 \{\par
17285   mBackgroundPixmap = pm;\par
17286   mScaledBackgroundPixmap = QPixmap();\par
17287 \}\par
}
}
{\xe \v setBackground\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackground (const QPixmap &  {\i pm}, bool  {\i scaled}, Qt::AspectRatioMode  {\i mode} = {\f2 Qt::KeepAspectRatioByExpanding})}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Allows setting the background pixmap of the axis rect, whether it shall be scaled and how it shall be scaled in one call.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground(const QPixmap &pm)}, {\b setBackgroundScaled}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17315 \{\par
17316   mBackgroundPixmap = pm;\par
17317   mScaledBackgroundPixmap = QPixmap();\par
17318   mBackgroundScaled = scaled;\par
17319   mBackgroundScaledMode = mode;\par
17320 \}\par
}
}
{\xe \v setBackground\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackground}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackground (const QBrush &  {\i brush})}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Sets {\i brush}  as the background brush. The axis rect background will be filled with this brush. Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds are usually drawn below everything else.\par
The brush will be drawn before (under) any background pixmap, which may be specified with {\b setBackground(const QPixmap &pm)}.\par
To disable drawing of a background brush, set {\i brush}  to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground(const QPixmap &pm)} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17303 \{\par
17304   mBackgroundBrush = brush;\par
17305 \}\par
}
}
{\xe \v setBackgroundScaled\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackgroundScaled (bool  {\i scaled})}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the axis background pixmap shall be scaled to fit the axis rect or not. If {\i scaled}  is set to true, you may control whether and how the aspect ratio of the original pixmap is preserved with {\b setBackgroundScaledMode}.\par
Note that the scaled version of the original pixmap is buffered, so there is no performance penalty on replots. (Except when the axis rect dimensions are changed continuously.)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground}, {\b setBackgroundScaledMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17333 \{\par
17334   mBackgroundScaled = scaled;\par
17335 \}\par
}
}
{\xe \v setBackgroundScaledMode\:QCPAxisRect}
{\xe \v QCPAxisRect\:setBackgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setBackgroundScaledMode (Qt::AspectRatioMode  {\i mode})}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If scaling of the axis background pixmap is enabled ({\b setBackgroundScaled}), use this function to define whether and how the aspect ratio of the original pixmap passed to {\b setBackground} is preserved. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBackground}, {\b setBackgroundScaled} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17343 \{\par
17344   mBackgroundScaledMode = mode;\par
17345 \}\par
}
}
{\xe \v setLayer\:QCPAxisRect}
{\xe \v QCPAxisRect\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer ({\b QCPLayer} *  {\i layer}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i layer}  of this layerable object. The object will be placed on top of the other objects already on {\i layer} .\par
If {\i layer}  is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).\par
Returns true if the layer of this layerable was successfully changed to {\i layer} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1385 \{\par
 1386   return moveToLayer(layer, false);\par
 1387 \}\par
}
}
{\xe \v setLayer\:QCPAxisRect}
{\xe \v QCPAxisRect\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer (const QString &  {\i layerName}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name\par
Returns true on success, i.e. if {\i layerName}  is a valid layer name. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1395 \{\par
 1396   if (!mParentPlot)\par
 1397   \{\par
 1398     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1399     return false;\par
 1400   \}\par
 1401   if (QCPLayer *layer = mParentPlot->layer(layerName))\par
 1402   \{\par
 1403     return setLayer(layer);\par
 1404   \} else\par
 1405   \{\par
 1406     qDebug() << Q_FUNC_INFO << "there is no layer with name" << layerName;\par
 1407     return false;\par
 1408   \}\par
 1409 \}\par
}
}
{\xe \v setMarginGroup\:QCPAxisRect}
{\xe \v QCPAxisRect\:setMarginGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMarginGroup (QCP::MarginSides  {\i sides}, {\b QCPMarginGroup} *  {\i group}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the margin {\i group}  of the specified margin {\i sides} .\par
Margin groups allow synchronizing specified margins across layout elements, see the documentation of {\b QCPMarginGroup}.\par
To unset the margin group of {\i sides} , set {\i group}  to 0.\par
Note that margin groups only work for margin sides that are set to automatic ({\b setAutoMargins}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCP::MarginSide} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3365 \{\par
 3366   QVector<QCP::MarginSide> sideVector;\par
 3367   if (sides.testFlag(QCP::msLeft)) sideVector.append(QCP::msLeft);\par
 3368   if (sides.testFlag(QCP::msRight)) sideVector.append(QCP::msRight);\par
 3369   if (sides.testFlag(QCP::msTop)) sideVector.append(QCP::msTop);\par
 3370   if (sides.testFlag(QCP::msBottom)) sideVector.append(QCP::msBottom);\par
 3371   \par
 3372   for (int i=0; i<sideVector.size(); ++i)\par
 3373   \{\par
 3374     QCP::MarginSide side = sideVector.at(i);\par
 3375     if (marginGroup(side) != group)\par
 3376     \{\par
 3377       QCPMarginGroup *oldGroup = marginGroup(side);\par
 3378       if (oldGroup) // unregister at old group\par
 3379         oldGroup->removeChild(side, this);\par
 3380       \par
 3381       if (!group) // if setting to 0, remove hash entry. Else set hash entry to new group and register there\par
 3382       \{\par
 3383         mMarginGroups.remove(side);\par
 3384       \} else // setting to a new group\par
 3385       \{\par
 3386         mMarginGroups[side] = group;\par
 3387         group->addChild(side, this);\par
 3388       \}\par
 3389     \}\par
 3390   \}\par
 3391 \}\par
}
}
{\xe \v setMargins\:QCPAxisRect}
{\xe \v QCPAxisRect\:setMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMargins (const QMargins &  {\i margins}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the margins of this layout element. If {\b setAutoMargins} is disabled for some or all sides, this function is used to manually set the margin on those sides. Sides that are still set to be handled automatically are ignored and may have any value in {\i margins} .\par
The margin is the distance between the outer rect (controlled by the parent layout via {\b setOuterRect}) and the inner {\b rect} (which usually contains the main content of this layout element).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAutoMargins} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3229 \{\par
 3230   if (mMargins != margins)\par
 3231   \{\par
 3232     mMargins = margins;\par
 3233     mRect = mOuterRect.adjusted(mMargins.left(), mMargins.top(), -mMargins.right(), -mMargins.bottom());\par
 3234   \}\par
 3235 \}\par
}
}
{\xe \v setMaximumSize\:QCPAxisRect}
{\xe \v QCPAxisRect\:setMaximumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMaximumSize (const QSize &  {\i size}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the maximum size of this layout element. A parent layout tries to respect the {\i size}  here by changing row/column sizes in the layout accordingly.\par
Whether this constraint applies to the inner or the outer rect can be specified with {\b setSizeConstraintRect} (see {\b rect} and {\b outerRect}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3311 \{\par
 3312   if (mMaximumSize != size)\par
 3313   \{\par
 3314     mMaximumSize = size;\par
 3315     if (mParentLayout)\par
 3316       mParentLayout->sizeConstraintsChanged();\par
 3317   \}\par
 3318 \}\par
}
}
{\xe \v setMaximumSize\:QCPAxisRect}
{\xe \v QCPAxisRect\:setMaximumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMaximumSize (int  {\i width}, int  {\i height}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Sets the maximum size of this layout element.\par
Whether this constraint applies to the inner or the outer rect can be specified with {\b setSizeConstraintRect} (see {\b rect} and {\b outerRect}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3328 \{\par
 3329   setMaximumSize(QSize(width, height));\par
 3330 \}\par
}
}
{\xe \v setMinimumMargins\:QCPAxisRect}
{\xe \v QCPAxisRect\:setMinimumMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMinimumMargins (const QMargins &  {\i margins}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If {\b setAutoMargins} is enabled on some or all margins, this function is used to provide minimum values for those margins.\par
The minimum values are not enforced on margin sides that were set to be under manual control via {\b setAutoMargins}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setAutoMargins} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3247 \{\par
 3248   if (mMinimumMargins != margins)\par
 3249   \{\par
 3250     mMinimumMargins = margins;\par
 3251   \}\par
 3252 \}\par
}
}
{\xe \v setMinimumSize\:QCPAxisRect}
{\xe \v QCPAxisRect\:setMinimumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMinimumSize (const QSize &  {\i size}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the minimum size of this layout element. A parent layout tries to respect the {\i size}  here by changing row/column sizes in the layout accordingly.\par
If the parent layout size is not sufficient to satisfy all minimum size constraints of its child layout elements, the layout may set a size that is actually smaller than {\i size} . {\b QCustomPlot} propagates the layout's size constraints to the outside by setting its own minimum QWidget size accordingly, so violations of {\i size}  should be exceptions.\par
Whether this constraint applies to the inner or the outer rect can be specified with {\b setSizeConstraintRect} (see {\b rect} and {\b outerRect}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3282 \{\par
 3283   if (mMinimumSize != size)\par
 3284   \{\par
 3285     mMinimumSize = size;\par
 3286     if (mParentLayout)\par
 3287       mParentLayout->sizeConstraintsChanged();\par
 3288   \}\par
 3289 \}\par
}
}
{\xe \v setMinimumSize\:QCPAxisRect}
{\xe \v QCPAxisRect\:setMinimumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setMinimumSize (int  {\i width}, int  {\i height}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Sets the minimum size of this layout element.\par
Whether this constraint applies to the inner or the outer rect can be specified with {\b setSizeConstraintRect} (see {\b rect} and {\b outerRect}). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3299 \{\par
 3300   setMinimumSize(QSize(width, height));\par
 3301 \}\par
}
}
{\xe \v setOuterRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:setOuterRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setOuterRect (const QRect &  {\i rect}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the outer rect of this layout element. If the layout element is inside a layout, the layout sets the position and size of this layout element using this function.\par
Calling this function externally has no effect, since the layout will overwrite any changes to the outer rect upon the next replot.\par
The layout element will adapt its inner {\b rect} by applying the margins inward to the outer rect.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rect} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3209 \{\par
 3210   if (mOuterRect != rect)\par
 3211   \{\par
 3212     mOuterRect = rect;\par
 3213     mRect = mOuterRect.adjusted(mMargins.left(), mMargins.top(), -mMargins.right(), -mMargins.bottom());\par
 3214   \}\par
 3215 \}\par
}
}
{\xe \v setParentLayerable\:QCPAxisRect}
{\xe \v QCPAxisRect\:setParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setParentLayerable ({\b QCPLayerable} *  {\i parentLayerable}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1523 \{\par
 1524   mParentLayerable = parentLayerable;\par
 1525 \}\par
}
}
{\xe \v setRangeDrag\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeDrag (Qt::Orientations  {\i orientations})}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which axis orientation may be range dragged by the user with mouse interaction. What orientation corresponds to which specific axis can be set with {\b setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical)}. By default, the horizontal axis is the bottom axis (xAxis) and the vertical axis is the left axis (yAxis).\par
To disable range dragging entirely, pass 0 as {\i orientations}  or remove {\b QCP::iRangeDrag} from {\b QCustomPlot::setInteractions}. To enable range dragging for both directions, pass {\f2 Qt::Horizontal | Qt::Vertical}  as {\i orientations} .\par
In addition to setting {\i orientations}  to a non-zero value, make sure {\b QCustomPlot::setInteractions} contains {\b QCP::iRangeDrag} to enable the range dragging interaction.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoom}, {\b setRangeDragAxes}, {\b QCustomPlot::setNoAntialiasingOnDrag} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17454 \{\par
17455   mRangeDrag = orientations;\par
17456 \}\par
}
}
{\xe \v setRangeDragAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeDragAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeDragAxes ({\b QCPAxis} *  {\i horizontal}, {\b QCPAxis} *  {\i vertical})}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Sets the axes whose range will be dragged when {\b setRangeDrag} enables mouse range dragging on the {\b QCustomPlot} widget. Pass 0 if no axis shall be dragged in the respective orientation.\par
Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall react to dragging interactions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoomAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17489 \{\par
17490   QList<QCPAxis*> horz, vert;\par
17491   if (horizontal)\par
17492     horz.append(horizontal);\par
17493   if (vertical)\par
17494     vert.append(vertical);\par
17495   setRangeDragAxes(horz, vert);\par
17496 \}\par
}
}
{\xe \v setRangeDragAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeDragAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeDragAxes (QList< {\b QCPAxis} *>  {\i axes})}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
This method allows to set up multiple axes to react to horizontal and vertical dragging. The drag orientation that the respective axis will react to is deduced from its orientation ({\b QCPAxis::orientation}).\par
In the unusual case that you wish to e.g. drag a vertically oriented axis with a horizontal drag motion, use the overload taking two separate lists for horizontal and vertical dragging. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17508 \{\par
17509   QList<QCPAxis*> horz, vert;\par
17510   foreach (QCPAxis *ax, axes)\par
17511   \{\par
17512     if (ax->orientation() == Qt::Horizontal)\par
17513       horz.append(ax);\par
17514     else\par
17515       vert.append(ax);\par
17516   \}\par
17517   setRangeDragAxes(horz, vert);\par
17518 \}\par
}
}
{\xe \v setRangeDragAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeDragAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeDragAxes (QList< {\b QCPAxis} *>  {\i horizontal}, QList< {\b QCPAxis} *>  {\i vertical})}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
This method allows to set multiple axes up to react to horizontal and vertical dragging, and define specifically which axis reacts to which drag orientation (irrespective of the axis orientation). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17527 \{\par
17528   mRangeDragHorzAxis.clear();\par
17529   foreach (QCPAxis *ax, horizontal)\par
17530   \{\par
17531     QPointer<QCPAxis> axPointer(ax);\par
17532     if (!axPointer.isNull())\par
17533       mRangeDragHorzAxis.append(axPointer);\par
17534     else\par
17535       qDebug() << Q_FUNC_INFO << "invalid axis passed in horizontal list:" << reinterpret_cast<quintptr>(ax);\par
17536   \}\par
17537   mRangeDragVertAxis.clear();\par
17538   foreach (QCPAxis *ax, vertical)\par
17539   \{\par
17540     QPointer<QCPAxis> axPointer(ax);\par
17541     if (!axPointer.isNull())\par
17542       mRangeDragVertAxis.append(axPointer);\par
17543     else\par
17544       qDebug() << Q_FUNC_INFO << "invalid axis passed in vertical list:" << reinterpret_cast<quintptr>(ax);\par
17545   \}\par
17546 \}\par
}
}
{\xe \v setRangeZoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoom (Qt::Orientations  {\i orientations})}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which axis orientation may be zoomed by the user with the mouse wheel. What orientation corresponds to which specific axis can be set with {\b setRangeZoomAxes}({\b QCPAxis} *horizontal, {\b QCPAxis} *vertical). By default, the horizontal axis is the bottom axis (xAxis) and the vertical axis is the left axis (yAxis).\par
To disable range zooming entirely, pass 0 as {\i orientations}  or remove {\b QCP::iRangeZoom} from {\b QCustomPlot::setInteractions}. To enable range zooming for both directions, pass {\f2 Qt::Horizontal | Qt::Vertical}  as {\i orientations} .\par
In addition to setting {\i orientations}  to a non-zero value, make sure {\b QCustomPlot::setInteractions} contains {\b QCP::iRangeZoom} to enable the range zooming interaction.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeZoomFactor}, {\b setRangeZoomAxes}, {\b setRangeDrag} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17474 \{\par
17475   mRangeZoom = orientations;\par
17476 \}\par
}
}
{\xe \v setRangeZoomAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomAxes ({\b QCPAxis} *  {\i horizontal}, {\b QCPAxis} *  {\i vertical})}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the axes whose range will be zoomed when {\b setRangeZoom} enables mouse wheel zooming on the {\b QCustomPlot} widget. Pass 0 if no axis shall be zoomed in the respective orientation.\par
The two axes can be zoomed with different strengths, when different factors are passed to {\b setRangeZoomFactor(double horizontalFactor, double verticalFactor)}.\par
Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall react to zooming interactions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRangeDragAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17561 \{\par
17562   QList<QCPAxis*> horz, vert;\par
17563   if (horizontal)\par
17564     horz.append(horizontal);\par
17565   if (vertical)\par
17566     vert.append(vertical);\par
17567   setRangeZoomAxes(horz, vert);\par
17568 \}\par
}
}
{\xe \v setRangeZoomAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomAxes (QList< {\b QCPAxis} *>  {\i axes})}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
This method allows to set up multiple axes to react to horizontal and vertical range zooming. The zoom orientation that the respective axis will react to is deduced from its orientation ({\b QCPAxis::orientation}).\par
In the unusual case that you wish to e.g. zoom a vertically oriented axis with a horizontal zoom interaction, use the overload taking two separate lists for horizontal and vertical zooming. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17580 \{\par
17581   QList<QCPAxis*> horz, vert;\par
17582   foreach (QCPAxis *ax, axes)\par
17583   \{\par
17584     if (ax->orientation() == Qt::Horizontal)\par
17585       horz.append(ax);\par
17586     else\par
17587       vert.append(ax);\par
17588   \}\par
17589   setRangeZoomAxes(horz, vert);\par
17590 \}\par
}
}
{\xe \v setRangeZoomAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomAxes (QList< {\b QCPAxis} *>  {\i horizontal}, QList< {\b QCPAxis} *>  {\i vertical})}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
This method allows to set multiple axes up to react to horizontal and vertical zooming, and define specifically which axis reacts to which zoom orientation (irrespective of the axis orientation). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17599 \{\par
17600   mRangeZoomHorzAxis.clear();\par
17601   foreach (QCPAxis *ax, horizontal)\par
17602   \{\par
17603     QPointer<QCPAxis> axPointer(ax);\par
17604     if (!axPointer.isNull())\par
17605       mRangeZoomHorzAxis.append(axPointer);\par
17606     else\par
17607       qDebug() << Q_FUNC_INFO << "invalid axis passed in horizontal list:" << reinterpret_cast<quintptr>(ax);\par
17608   \}\par
17609   mRangeZoomVertAxis.clear();\par
17610   foreach (QCPAxis *ax, vertical)\par
17611   \{\par
17612     QPointer<QCPAxis> axPointer(ax);\par
17613     if (!axPointer.isNull())\par
17614       mRangeZoomVertAxis.append(axPointer);\par
17615     else\par
17616       qDebug() << Q_FUNC_INFO << "invalid axis passed in vertical list:" << reinterpret_cast<quintptr>(ax);\par
17617   \}\par
17618 \}\par
}
}
{\xe \v setRangeZoomFactor\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomFactor (double  {\i horizontalFactor}, double  {\i verticalFactor})}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how strong one rotation step of the mouse wheel zooms, when range zoom was activated with {\b setRangeZoom}. The two parameters {\i horizontalFactor}  and {\i verticalFactor}  provide a way to let the horizontal axis zoom at different rates than the vertical axis. Which axis is horizontal and which is vertical, can be set with {\b setRangeZoomAxes}.\par
When the zoom factor is greater than one, scrolling the mouse wheel backwards (towards the user) will zoom in (make the currently visible range smaller). For zoom factors smaller than one, the same scrolling direction will zoom out. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17631 \{\par
17632   mRangeZoomFactorHorz = horizontalFactor;\par
17633   mRangeZoomFactorVert = verticalFactor;\par
17634 \}\par
}
}
{\xe \v setRangeZoomFactor\:QCPAxisRect}
{\xe \v QCPAxisRect\:setRangeZoomFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setRangeZoomFactor (double  {\i factor})}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Sets both the horizontal and vertical zoom {\i factor} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17641 \{\par
17642   mRangeZoomFactorHorz = factor;\par
17643   mRangeZoomFactorVert = factor;\par
17644 \}\par
}
}
{\xe \v setSizeConstraintRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:setSizeConstraintRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayoutElement::setSizeConstraintRect ({\b SizeConstraintRect}  {\i constraintRect}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets to which rect of a layout element the size constraints apply. Size constraints can be set via {\b setMinimumSize} and {\b setMaximumSize}.\par
The outer rect ({\b outerRect}) includes the margins (e.g. in the case of a {\b QCPAxisRect} the axis labels), whereas the inner rect ({\b rect}) does not.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setMinimumSize}, {\b setMaximumSize} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3342 \{\par
 3343   if (mSizeConstraintRect != constraintRect)\par
 3344   \{\par
 3345     mSizeConstraintRect = constraintRect;\par
 3346     if (mParentLayout)\par
 3347       mParentLayout->sizeConstraintsChanged();\par
 3348   \}\par
 3349 \}\par
}
}
{\xe \v setupFullAxesBox\:QCPAxisRect}
{\xe \v QCPAxisRect\:setupFullAxesBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::setupFullAxesBox (bool  {\i connectRanges} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function to create an axis on each side that doesn't have any axes yet and set their visibility to true. Further, the top/right axes are assigned the following properties of the bottom/left axes:\par
{
\par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range ({\b QCPAxis::setRange}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
range reversed ({\b QCPAxis::setRangeReversed}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
scale type ({\b QCPAxis::setScaleType}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tick visibility ({\b QCPAxis::setTicks}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
number format ({\b QCPAxis::setNumberFormat}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
number precision ({\b QCPAxis::setNumberPrecision}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tick count of ticker ({\b QCPAxisTicker::setTickCount}) \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
tick origin of ticker ({\b QCPAxisTicker::setTickOrigin})\par
}
Tick label visibility ({\b QCPAxis::setTickLabels}) of the right and top axes are set to false.\par
If {\i connectRanges}  is true, the {\b rangeChanged} signals of the bottom and left axes are connected to the {\b QCPAxis::setRange} slots of the top and right axes. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17077 \{\par
17078   QCPAxis *xAxis, *yAxis, *xAxis2, *yAxis2;\par
17079   if (axisCount(QCPAxis::atBottom) == 0)\par
17080     xAxis = addAxis(QCPAxis::atBottom);\par
17081   else\par
17082     xAxis = axis(QCPAxis::atBottom);\par
17083   \par
17084   if (axisCount(QCPAxis::atLeft) == 0)\par
17085     yAxis = addAxis(QCPAxis::atLeft);\par
17086   else\par
17087     yAxis = axis(QCPAxis::atLeft);\par
17088   \par
17089   if (axisCount(QCPAxis::atTop) == 0)\par
17090     xAxis2 = addAxis(QCPAxis::atTop);\par
17091   else\par
17092     xAxis2 = axis(QCPAxis::atTop);\par
17093   \par
17094   if (axisCount(QCPAxis::atRight) == 0)\par
17095     yAxis2 = addAxis(QCPAxis::atRight);\par
17096   else\par
17097     yAxis2 = axis(QCPAxis::atRight);\par
17098   \par
17099   xAxis->setVisible(true);\par
17100   yAxis->setVisible(true);\par
17101   xAxis2->setVisible(true);\par
17102   yAxis2->setVisible(true);\par
17103   xAxis2->setTickLabels(false);\par
17104   yAxis2->setTickLabels(false);\par
17105   \par
17106   xAxis2->setRange(xAxis->range());\par
17107   xAxis2->setRangeReversed(xAxis->rangeReversed());\par
17108   xAxis2->setScaleType(xAxis->scaleType());\par
17109   xAxis2->setTicks(xAxis->ticks());\par
17110   xAxis2->setNumberFormat(xAxis->numberFormat());\par
17111   xAxis2->setNumberPrecision(xAxis->numberPrecision());\par
17112   xAxis2->ticker()->setTickCount(xAxis->ticker()->tickCount());\par
17113   xAxis2->ticker()->setTickOrigin(xAxis->ticker()->tickOrigin());\par
17114   \par
17115   yAxis2->setRange(yAxis->range());\par
17116   yAxis2->setRangeReversed(yAxis->rangeReversed());\par
17117   yAxis2->setScaleType(yAxis->scaleType());\par
17118   yAxis2->setTicks(yAxis->ticks());\par
17119   yAxis2->setNumberFormat(yAxis->numberFormat());\par
17120   yAxis2->setNumberPrecision(yAxis->numberPrecision());\par
17121   yAxis2->ticker()->setTickCount(yAxis->ticker()->tickCount());\par
17122   yAxis2->ticker()->setTickOrigin(yAxis->ticker()->tickOrigin());\par
17123   \par
17124   if (connectRanges)\par
17125   \{\par
17126     connect(xAxis, SIGNAL(rangeChanged(QCPRange)), xAxis2, SLOT(setRange(QCPRange)));\par
17127     connect(yAxis, SIGNAL(rangeChanged(QCPRange)), yAxis2, SLOT(setRange(QCPRange)));\par
17128   \}\par
17129 \}\par
}
}
{\xe \v setVisible\:QCPAxisRect}
{\xe \v QCPAxisRect\:setVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setVisible (bool  {\i on}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the {\b QCustomPlot} surface, and user interaction with it (e.g. click and selection) is not possible. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1371 \{\par
 1372   mVisible = on;\par
 1373 \}\par
}
}
{\xe \v size\:QCPAxisRect}
{\xe \v QCPAxisRect\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPAxisRect::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel size of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4650 \{ return mRect.size(); \}\par
}
}
{\xe \v sizeConstraintRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:sizeConstraintRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SizeConstraintRect} QCPLayoutElement::sizeConstraintRect () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1228 \{ return mSizeConstraintRect; \}\par
}
}
{\xe \v top\:QCPAxisRect}
{\xe \v QCPAxisRect\:top}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::top () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position of the top border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4646 \{ return mRect.top(); \}\par
}
}
{\xe \v topLeft\:QCPAxisRect}
{\xe \v QCPAxisRect\:topLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::topLeft () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the top left corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4651 \{ return mRect.topLeft(); \}\par
}
}
{\xe \v topRight\:QCPAxisRect}
{\xe \v QCPAxisRect\:topRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPoint QCPAxisRect::topRight () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the top right corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4652 \{ return mRect.topRight(); \}\par
}
}
{\xe \v update\:QCPAxisRect}
{\xe \v QCPAxisRect\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::update ({\b UpdatePhase}  {\i phase}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is called automatically upon replot and doesn't need to be called by users of {\b QCPAxisRect}.\par
Calls the base class implementation to update the margins (see {\b QCPLayoutElement::update}), and finally passes the {\b rect} to the inset layout ({\b insetLayout}) and calls its QCPInsetLayout::update function.\par
}{
Reimplementa {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17219 \{\par
17220   QCPLayoutElement::update(phase);\par
17221   \par
17222   switch (phase)\par
17223   \{\par
17224     case upPreparation:\par
17225     \{\par
17226       QList<QCPAxis*> allAxes = axes();\par
17227       for (int i=0; i<allAxes.size(); ++i)\par
17228         allAxes.at(i)->setupTickVectors();\par
17229       break;\par
17230     \}\par
17231     case upLayout:\par
17232     \{\par
17233       mInsetLayout->setOuterRect(rect());\par
17234       break;\par
17235     \}\par
17236     default: break;\par
17237   \}\par
17238   \par
17239   // pass update call on to inset layout (doesn't happen automatically, because QCPAxisRect doesn't derive from QCPLayout):\par
17240   mInsetLayout->update(phase);\par
17241 \}\par
}
}
{\xe \v updateAxesOffset\:QCPAxisRect}
{\xe \v QCPAxisRect\:updateAxesOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::updateAxesOffset ({\b QCPAxis::AxisType}  {\i type}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17699 \{\par
17700   const QList<QCPAxis*> axesList = mAxes.value(type);\par
17701   if (axesList.isEmpty())\par
17702     return;\par
17703   \par
17704   bool isFirstVisible = !axesList.first()->visible(); // if the first axis is visible, the second axis (which is where the loop starts) isn't the first visible axis, so initialize with false\par
17705   for (int i=1; i<axesList.size(); ++i)\par
17706   \{\par
17707     int offset = axesList.at(i-1)->offset() + axesList.at(i-1)->calculateMargin();\par
17708     if (axesList.at(i)->visible()) // only add inner tick length to offset if this axis is visible and it's not the first visible one (might happen if true first axis is invisible)\par
17709     \{\par
17710       if (!isFirstVisible)\par
17711         offset += axesList.at(i)->tickLengthIn();\par
17712       isFirstVisible = false;\par
17713     \}\par
17714     axesList.at(i)->setOffset(offset);\par
17715   \}\par
17716 \}\par
}
}
{\xe \v visible\:QCPAxisRect}
{\xe \v QCPAxisRect\:visible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::visible () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   707 \{ return mVisible; \}\par
}
}
{\xe \v wheelEvent\:QCPAxisRect}
{\xe \v QCPAxisRect\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} .\par
The {\f2 event->delta()}  indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making {\f2 event->delta()}  larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent} \par
}}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17889 \{\par
17890   // Mouse range zooming interaction:\par
17891   if (mParentPlot->interactions().testFlag(QCP::iRangeZoom))\par
17892   \{\par
17893     if (mRangeZoom != 0)\par
17894     \{\par
17895       double factor;\par
17896       double wheelSteps = event->delta()/120.0; // a single step delta is +/-120 usually\par
17897       if (mRangeZoom.testFlag(Qt::Horizontal))\par
17898       \{\par
17899         factor = qPow(mRangeZoomFactorHorz, wheelSteps);\par
17900         for (int i=0; i<mRangeZoomHorzAxis.size(); ++i)\par
17901         \{\par
17902           if (!mRangeZoomHorzAxis.at(i).isNull())\par
17903             mRangeZoomHorzAxis.at(i)->scaleRange(factor, mRangeZoomHorzAxis.at(i)->pixelToCoord(event->pos().x()));\par
17904         \}\par
17905       \}\par
17906       if (mRangeZoom.testFlag(Qt::Vertical))\par
17907       \{\par
17908         factor = qPow(mRangeZoomFactorVert, wheelSteps);\par
17909         for (int i=0; i<mRangeZoomVertAxis.size(); ++i)\par
17910         \{\par
17911           if (!mRangeZoomVertAxis.at(i).isNull())\par
17912             mRangeZoomVertAxis.at(i)->scaleRange(factor, mRangeZoomVertAxis.at(i)->pixelToCoord(event->pos().y()));\par
17913         \}\par
17914       \}\par
17915       mParentPlot->replot();\par
17916     \}\par
17917   \}\par
17918 \}\par
}
}
{\xe \v width\:QCPAxisRect}
{\xe \v QCPAxisRect\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxisRect::width () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel width of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner {\b rect}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4648 \{ return mRect.width(); \}\par
}
}
{\xe \v zoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:zoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::zoom (const QRectF &  {\i pixelRect})}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zooms in (or out) to the passed rectangular region {\i pixelRect} , given in pixel coordinates.\par
All axes of this axis rect will have their range zoomed accordingly. If you only wish to zoom specific axes, use the overloaded version of this method.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::setSelectionRectMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17027 \{\par
17028   zoom(pixelRect, axes());\par
17029 \}\par
}
}
{\xe \v zoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:zoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxisRect::zoom (const QRectF &  {\i pixelRect}, const QList< {\b QCPAxis} *> &  {\i affectedAxes})}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Zooms in (or out) to the passed rectangular region {\i pixelRect} , given in pixel coordinates.\par
Only the axes passed in {\i affectedAxes}  will have their ranges zoomed accordingly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::setSelectionRectMode} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17040 \{\par
17041   foreach (QCPAxis *axis, affectedAxes)\par
17042   \{\par
17043     if (!axis)\par
17044     \{\par
17045       qDebug() << Q_FUNC_INFO << "a passed axis was zero";\par
17046       continue;\par
17047     \}\par
17048     QCPRange pixelRange;\par
17049     if (axis->orientation() == Qt::Horizontal)\par
17050       pixelRange = QCPRange(pixelRect.left(), pixelRect.right());\par
17051     else\par
17052       pixelRange = QCPRange(pixelRect.top(), pixelRect.bottom());\par
17053     axis->setRange(axis->pixelToCoord(pixelRange.lower), axis->pixelToCoord(pixelRange.upper));\par
17054   \}\par
17055 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas e Funções Relacionadas\par
\pard\plain 
{\xe \v QCustomPlot\:QCPAxisRect}
{\xe \v QCPAxisRect\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mAADragBackup\:QCPAxisRect}
{\xe \v QCPAxisRect\:mAADragBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCPAxisRect::mAADragBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAntialiased\:QCPAxisRect}
{\xe \v QCPAxisRect\:mAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mAntialiased{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAutoMargins\:QCPAxisRect}
{\xe \v QCPAxisRect\:mAutoMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::MarginSides QCPLayoutElement::mAutoMargins{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAxes\:QCPAxisRect}
{\xe \v QCPAxisRect\:mAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QHash<{\b QCPAxis::AxisType}, QList<{\b QCPAxis}*> > QCPAxisRect::mAxes{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundBrush\:QCPAxisRect}
{\xe \v QCPAxisRect\:mBackgroundBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAxisRect::mBackgroundBrush{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundPixmap\:QCPAxisRect}
{\xe \v QCPAxisRect\:mBackgroundPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPAxisRect::mBackgroundPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundScaled\:QCPAxisRect}
{\xe \v QCPAxisRect\:mBackgroundScaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisRect::mBackgroundScaled{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBackgroundScaledMode\:QCPAxisRect}
{\xe \v QCPAxisRect\:mBackgroundScaledMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::AspectRatioMode QCPAxisRect::mBackgroundScaledMode{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragging\:QCPAxisRect}
{\xe \v QCPAxisRect\:mDragging}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxisRect::mDragging{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragStartHorzRange\:QCPAxisRect}
{\xe \v QCPAxisRect\:mDragStartHorzRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPRange}> QCPAxisRect::mDragStartHorzRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragStartVertRange\:QCPAxisRect}
{\xe \v QCPAxisRect\:mDragStartVertRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<{\b QCPRange}> QCPAxisRect::mDragStartVertRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mInsetLayout\:QCPAxisRect}
{\xe \v QCPAxisRect\:mInsetLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayoutInset}* QCPAxisRect::mInsetLayout{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLayer\:QCPAxisRect}
{\xe \v QCPAxisRect\:mLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::mLayer{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMarginGroups\:QCPAxisRect}
{\xe \v QCPAxisRect\:mMarginGroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QHash<{\b QCP::MarginSide}, {\b QCPMarginGroup}*> QCPLayoutElement::mMarginGroups{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMargins\:QCPAxisRect}
{\xe \v QCPAxisRect\:mMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPLayoutElement::mMargins{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMaximumSize\:QCPAxisRect}
{\xe \v QCPAxisRect\:mMaximumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::mMaximumSize{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMinimumMargins\:QCPAxisRect}
{\xe \v QCPAxisRect\:mMinimumMargins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QMargins QCPLayoutElement::mMinimumMargins{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mMinimumSize\:QCPAxisRect}
{\xe \v QCPAxisRect\:mMinimumSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize QCPLayoutElement::mMinimumSize{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNotAADragBackup\:QCPAxisRect}
{\xe \v QCPAxisRect\:mNotAADragBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCPAxisRect::mNotAADragBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOuterRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:mOuterRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayoutElement::mOuterRect{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentLayerable\:QCPAxisRect}
{\xe \v QCPAxisRect\:mParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPLayerable}> QCPLayerable::mParentLayerable{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentLayout\:QCPAxisRect}
{\xe \v QCPAxisRect\:mParentLayout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayout}* QCPLayoutElement::mParentLayout{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPAxisRect}
{\xe \v QCPAxisRect\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::mParentPlot{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeDrag\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeDrag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientations QCPAxisRect::mRangeDrag{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeDragHorzAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeDragHorzAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QPointer<{\b QCPAxis}> > QCPAxisRect::mRangeDragHorzAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeDragVertAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeDragVertAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QPointer<{\b QCPAxis}> > QCPAxisRect::mRangeDragVertAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoom\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientations QCPAxisRect::mRangeZoom{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoomFactorHorz\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoomFactorHorz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisRect::mRangeZoomFactorHorz{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoomFactorVert\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoomFactorVert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxisRect::mRangeZoomFactorVert{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoomHorzAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoomHorzAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QPointer<{\b QCPAxis}> > QCPAxisRect::mRangeZoomHorzAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeZoomVertAxis\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRangeZoomVertAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<QPointer<{\b QCPAxis}> > QCPAxisRect::mRangeZoomVertAxis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:mRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayoutElement::mRect{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScaledBackgroundPixmap\:QCPAxisRect}
{\xe \v QCPAxisRect\:mScaledBackgroundPixmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPixmap QCPAxisRect::mScaledBackgroundPixmap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSizeConstraintRect\:QCPAxisRect}
{\xe \v QCPAxisRect\:mSizeConstraintRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SizeConstraintRect} QCPLayoutElement::mSizeConstraintRect{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mVisible\:QCPAxisRect}
{\xe \v QCPAxisRect\:mVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mVisible{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documentação para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}}