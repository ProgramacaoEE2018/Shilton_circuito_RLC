{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência da Classe QCPAxis\par \pard\plain 
{\tc\tcl2 \v QCPAxis}
{\xe \v QCPAxis}
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a single axis inside a {\b QCustomPlot}. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Diagrama de hierarquia para QCPAxis:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classQCPAxis__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AxisType} \{ {\b atLeft} = 0x01, 
{\b atRight} = 0x02, 
{\b atTop} = 0x04, 
{\b atBottom} = 0x08
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LabelSide} \{ {\b lsInside}, 
{\b lsOutside}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ScaleType} \{ {\b stLinear}, 
{\b stLogarithmic}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SelectablePart} \{ {\b spNone} = 0, 
{\b spAxis} = 0x001, 
{\b spTickLabels} = 0x002, 
{\b spAxisLabel} = 0x004
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Sinais\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rangeChanged} (const {\b QCPRange} &newRange)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rangeChanged} (const {\b QCPRange} &newRange, const {\b QCPRange} &oldRange)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scaleTypeChanged} ({\b QCPAxis::ScaleType} {\b scaleType})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (const QCPAxis::SelectableParts &parts)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectableChanged} (const QCPAxis::SelectableParts &parts)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b layerChanged} ({\b QCPLayer} *newLayer)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} ({\b QCPAxisRect} *parent, {\b AxisType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAxis} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AxisType} {\b axisType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b axisRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScaleType} {\b scaleType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b QCPRange} {\b range} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rangeReversed} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPAxisTicker} > {\b ticker} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ticks} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b tickLabels} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickLabelPadding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b tickLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b tickLabelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b tickLabelRotation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LabelSide} {\b tickLabelSide} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b numberFormat} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numberPrecision} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< double > {\b tickVector} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QString > {\b tickVectorLabels} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickLengthIn} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tickLengthOut} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b subTicks} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b subTickLengthIn} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b subTickLengthOut} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b basePen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b tickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b subTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b labelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b labelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b label} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b labelPadding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b padding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b offset} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b selectedParts} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b selectableParts} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b selectedTickLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b selectedLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b selectedTickLabelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b selectedLabelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedBasePen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b selectedSubTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b lowerEnding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLineEnding} {\b upperEnding} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGrid} * {\b grid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setScaleType} ({\b QCPAxis::ScaleType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setRange} (const {\b QCPRange} &{\b range})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRange} (double lower, double upper)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRange} (double position, double size, Qt::AlignmentFlag alignment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeLower} (double lower)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeUpper} (double upper)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRangeReversed} (bool reversed)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTicker} (QSharedPointer< {\b QCPAxisTicker} > {\b ticker})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTicks} (bool show)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabels} (bool show)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelPadding} (int {\b padding})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelFont} (const QFont &font)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelRotation} (double degrees)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLabelSide} ({\b LabelSide} side)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNumberFormat} (const QString &formatCode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNumberPrecision} (int precision)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLength} (int inside, int outside=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLengthIn} (int inside)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickLengthOut} (int outside)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTicks} (bool show)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickLength} (int inside, int outside=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickLengthIn} (int inside)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickLengthOut} (int outside)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBasePen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTickPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSubTickPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLabelFont} (const QFont &font)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLabelColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLabel} (const QString &str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLabelPadding} (int {\b padding})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPadding} (int {\b padding})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOffset} (int {\b offset})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedTickLabelFont} (const QFont &font)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedLabelFont} (const QFont &font)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedTickLabelColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedLabelColor} (const QColor &color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedBasePen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedTickPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectedSubTickPen} (const QPen &pen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectableParts} (const QCPAxis::SelectableParts &{\b selectableParts})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectedParts} (const QCPAxis::SelectableParts &{\b selectedParts})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLowerEnding} (const {\b QCPLineEnding} &ending)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setUpperEnding} (const {\b QCPLineEnding} &ending)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientation {\b orientation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pixelOrientation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveRange} (double diff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scaleRange} (double factor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b scaleRange} (double factor, double center)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScaleRatio} (const {\b QCPAxis} *otherAxis, double ratio=1.0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescale} (bool onlyVisiblePlottables=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b pixelToCoord} (double value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b coordToPixel} (double value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SelectablePart} {\b getPartAt} (const QPointF &pos) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractPlottable} * > {\b plottables} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPGraph} * > {\b graphs} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b QCPAbstractItem} * > {\b items} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b visible} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b parentPlot} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayerable} * {\b parentLayerable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b layer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiased} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVisible} (bool on)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT bool {\b setLayer} ({\b QCPLayer} *{\b layer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setLayer} (const QString &layerName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiased} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b realVisibility} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos Estáticos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AxisType} {\b marginSideToAxisType} ({\b QCP::MarginSide} side)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static Qt::Orientation {\b orientation} ({\b AxisType} type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AxisType} {\b opposite} ({\b AxisType} type)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b calculateMargin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupTickVectors} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b getBasePen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b getTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b getSubTickPen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b getTickLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b getLabelFont} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b getTickLabelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b getLabelColor} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parentPlotInitialized} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QRect {\b clipRect} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseDoubleClickEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initializeParentPlot} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setParentLayerable} ({\b QCPLayerable} *{\b parentLayerable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveToLayer} ({\b QCPLayer} *{\b layer}, bool prepend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyAntialiasingHint} ({\b QCPPainter} *painter, bool localAntialiased, {\b QCP::AntialiasedElement} overrideElement) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AxisType} {\b mAxisType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisRect} * {\b mAxisRect}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mPadding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::Orientation {\b mOrientation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b mSelectableParts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SelectableParts {\b mSelectedParts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mBasePen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedBasePen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mLabel}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mLabelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mSelectedLabelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mLabelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mSelectedLabelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mTickLabels}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mTickLabelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QFont {\b mSelectedTickLabelFont}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mTickLabelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QColor {\b mSelectedTickLabelColor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mNumberPrecision}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLatin1Char {\b mNumberFormatChar}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mNumberBeautifulPowers}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mTicks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mSubTicks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mTickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedTickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSubTickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mSelectedSubTickPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mRangeReversed}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScaleType} {\b mScaleType}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGrid} * {\b mGrid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxisPainterPrivate} * {\b mAxisPainter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPAxisTicker} > {\b mTicker}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< double > {\b mTickVector}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QString > {\b mTickVectorLabels}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< double > {\b mSubTickVector}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mCachedMarginValid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mCachedMargin}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mDragging}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPRange} {\b mDragStartRange}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mAADragBackup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCP::AntialiasedElements {\b mNotAADragBackup}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mVisible}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPLayerable} > {\b mParentLayerable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b mLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiased}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPGrid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPAxisRect}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a single axis inside a {\b QCustomPlot}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Usually doesn't need to be instantiated externally. Access QCustomPlot's default four axes via {\b QCustomPlot::xAxis} (bottom), {\b QCustomPlot::yAxis} (left), {\b QCustomPlot::xAxis2} (top) and {\b QCustomPlot::yAxis2} (right).\par
Axes are always part of an axis rect, see {\b QCPAxisRect}.  {\qc Naming convention of axis parts}  \par
  {\qc Overview of the spacings and paddings that define the geometry of an axis. The dashed gray line on the left represents the {\b QCustomPlot} widget border.} \par
Each axis holds an instance of {\b QCPAxisTicker} which is used to generate the tick coordinates and tick labels. You can access the currently installed {\b ticker} or set a new one (possibly one of the specialized subclasses, or your own subclass) via {\b setTicker}. For details, see the documentation of {\b QCPAxisTicker}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerações\par
\pard\plain 
{\xe \v AxisType\:QCPAxis}
{\xe \v QCPAxis\:AxisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxis::AxisType}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines at which side of the axis rect the axis will appear. This also affects how the tick marks are drawn, on which side the labels are placed etc. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v atLeft\:QCPAxis}
{\xe \v QCPAxis\:atLeft}
{\qr atLeft{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x01}  Axis is vertical and on the left side of the axis rect \par
}\cell }{\row }
{\xe \v atRight\:QCPAxis}
{\xe \v QCPAxis\:atRight}
{\qr atRight{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x02}  Axis is vertical and on the right side of the axis rect \par
}\cell }{\row }
{\xe \v atTop\:QCPAxis}
{\xe \v QCPAxis\:atTop}
{\qr atTop{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x04}  Axis is horizontal and on the top side of the axis rect \par
}\cell }{\row }
{\xe \v atBottom\:QCPAxis}
{\xe \v QCPAxis\:atBottom}
{\qr atBottom{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 0x08}  Axis is horizontal and on the bottom side of the axis rect \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1964                 \{ atLeft    = 0x01  \par
 1965                   ,atRight  = 0x02  \par
 1966                   ,atTop    = 0x04  \par
 1967                   ,atBottom = 0x08  \par
 1968                 \};\par
}
}
{\xe \v LabelSide\:QCPAxis}
{\xe \v QCPAxis\:LabelSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxis::LabelSide}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines on which side of the axis the tick labels (numbers) shall appear.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabelSide} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v lsInside\:QCPAxis}
{\xe \v QCPAxis\:lsInside}
{\qr lsInside{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tick labels will be displayed inside the axis rect and clipped to the inner axis rect. \par
}\cell }{\row }
{\xe \v lsOutside\:QCPAxis}
{\xe \v QCPAxis\:lsOutside}
{\qr lsOutside{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tick labels will be displayed outside the axis rect. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1977                  \{ lsInside    \par
 1978                    ,lsOutside  \par
 1979                  \};\par
}
}
{\xe \v ScaleType\:QCPAxis}
{\xe \v QCPAxis\:ScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxis::ScaleType}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the scale of an axis. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setScaleType} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v stLinear\:QCPAxis}
{\xe \v QCPAxis\:stLinear}
{\qr stLinear{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Linear scaling. \par
}\cell }{\row }
{\xe \v stLogarithmic\:QCPAxis}
{\xe \v QCPAxis\:stLogarithmic}
{\qr stLogarithmic{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logarithmic scaling with correspondingly transformed axis coordinates (possibly also {\b setTicker} to a {\b QCPAxisTickerLog} instance). \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1985                  \{ stLinear       \par
 1986                    ,stLogarithmic \par
 1987                  \};\par
}
}
{\xe \v SelectablePart\:QCPAxis}
{\xe \v QCPAxis\:SelectablePart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPAxis::SelectablePart}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the selectable parts of an axis. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectableParts}, {\b setSelectedParts} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v spNone\:QCPAxis}
{\xe \v QCPAxis\:spNone}
{\qr spNone{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
None of the selectable parts. \par
}\cell }{\row }
{\xe \v spAxis\:QCPAxis}
{\xe \v QCPAxis\:spAxis}
{\qr spAxis{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The axis backbone and tick marks. \par
}\cell }{\row }
{\xe \v spTickLabels\:QCPAxis}
{\xe \v QCPAxis\:spTickLabels}
{\qr spTickLabels{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tick labels (numbers) of this axis (as a whole, not individually) \par
}\cell }{\row }
{\xe \v spAxisLabel\:QCPAxis}
{\xe \v QCPAxis\:spAxisLabel}
{\qr spAxisLabel{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The axis label. \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1993                       \{ spNone        = 0      \par
 1994                         ,spAxis       = 0x001  \par
 1995                         ,spTickLabels = 0x002  \par
 1996                         ,spAxisLabel  = 0x004  \par
 1997                       \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v QCPAxis\:QCPAxis}
{\xe \v QCPAxis\:QCPAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxis::QCPAxis ({\b QCPAxisRect} *  {\i parent}, {\b AxisType}  {\i type}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an Axis instance of Type {\i type}  for the axis rect {\i parent} .\par
Usually it isn't necessary to instantiate axes directly, because you can let {\b QCustomPlot} create them for you with {\b QCPAxisRect::addAxis}. If you want to use own QCPAxis-subclasses however, create them manually and then inject them also via {\b QCPAxisRect::addAxis}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7499                                                    :\par
 7500   QCPLayerable(parent->parentPlot(), QString(), parent),\par
 7501   // axis base:\par
 7502   mAxisType(type),\par
 7503   mAxisRect(parent),\par
 7504   mPadding(5),\par
 7505   mOrientation(orientation(type)),\par
 7506   mSelectableParts(spAxis | spTickLabels | spAxisLabel),\par
 7507   mSelectedParts(spNone),\par
 7508   mBasePen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),\par
 7509   mSelectedBasePen(QPen(Qt::blue, 2)),\par
 7510   // axis label:\par
 7511   mLabel(),\par
 7512   mLabelFont(mParentPlot->font()),\par
 7513   mSelectedLabelFont(QFont(mLabelFont.family(), mLabelFont.pointSize(), QFont::Bold)),\par
 7514   mLabelColor(Qt::black),\par
 7515   mSelectedLabelColor(Qt::blue),\par
 7516   // tick labels:\par
 7517   mTickLabels(true),\par
 7518   mTickLabelFont(mParentPlot->font()),\par
 7519   mSelectedTickLabelFont(QFont(mTickLabelFont.family(), mTickLabelFont.pointSize(), QFont::Bold)),\par
 7520   mTickLabelColor(Qt::black),\par
 7521   mSelectedTickLabelColor(Qt::blue),\par
 7522   mNumberPrecision(6),\par
 7523   mNumberFormatChar('g'),\par
 7524   mNumberBeautifulPowers(true),\par
 7525   // ticks and subticks:\par
 7526   mTicks(true),\par
 7527   mSubTicks(true),\par
 7528   mTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),\par
 7529   mSelectedTickPen(QPen(Qt::blue, 2)),\par
 7530   mSubTickPen(QPen(Qt::black, 0, Qt::SolidLine, Qt::SquareCap)),\par
 7531   mSelectedSubTickPen(QPen(Qt::blue, 2)),\par
 7532   // scale and range:\par
 7533   mRange(0, 5),\par
 7534   mRangeReversed(false),\par
 7535   mScaleType(stLinear),\par
 7536   // internal members:\par
 7537   mGrid(new QCPGrid(this)),\par
 7538   mAxisPainter(new QCPAxisPainterPrivate(parent->parentPlot())),\par
 7539   mTicker(new QCPAxisTicker),\par
 7540   mCachedMarginValid(false),\par
 7541   mCachedMargin(0)\par
 7542 \{\par
 7543   setParent(parent);\par
 7544   mGrid->setVisible(false);\par
 7545   setAntialiased(false);\par
 7546   setLayer(mParentPlot->currentLayer()); // it's actually on that layer already, but we want it in front of the grid, so we place it on there again\par
 7547   \par
 7548   if (type == atTop)\par
 7549   \{\par
 7550     setTickLabelPadding(3);\par
 7551     setLabelPadding(6);\par
 7552   \} else if (type == atRight)\par
 7553   \{\par
 7554     setTickLabelPadding(7);\par
 7555     setLabelPadding(12);\par
 7556   \} else if (type == atBottom)\par
 7557   \{\par
 7558     setTickLabelPadding(3);\par
 7559     setLabelPadding(3);\par
 7560   \} else if (type == atLeft)\par
 7561   \{\par
 7562     setTickLabelPadding(5);\par
 7563     setLabelPadding(10);\par
 7564   \}\par
 7565 \}\par
}
}
{\xe \v ~QCPAxis\:QCPAxis}
{\xe \v QCPAxis\:~QCPAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPAxis::~QCPAxis (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7568 \{\par
 7569   delete mAxisPainter;\par
 7570   delete mGrid; // delete grid here instead of via parent ~QObject for better defined deletion order\par
 7571 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções membros\par
\pard\plain 
{\xe \v antialiased\:QCPAxis}
{\xe \v QCPAxis\:antialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::antialiased () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   711 \{ return mAntialiased; \}\par
}
}
{\xe \v applyAntialiasingHint\:QCPAxis}
{\xe \v QCPAxis\:applyAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::applyAntialiasingHint ({\b QCPPainter} *  {\i painter}, bool  {\i localAntialiased}, {\b QCP::AntialiasedElement}  {\i overrideElement}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1567 \{\par
 1568   if (mParentPlot && mParentPlot->notAntialiasedElements().testFlag(overrideElement))\par
 1569     painter->setAntialiasing(false);\par
 1570   else if (mParentPlot && mParentPlot->antialiasedElements().testFlag(overrideElement))\par
 1571     painter->setAntialiasing(true);\par
 1572   else\par
 1573     painter->setAntialiasing(localAntialiased);\par
 1574 \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPAxis}
{\xe \v QCPAxis\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8946 \{\par
 8947   applyAntialiasingHint(painter, mAntialiased, QCP::aeAxes);\par
 8948 \}\par
}
}
{\xe \v axisRect\:QCPAxis}
{\xe \v QCPAxis\:axisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect}* QCPAxis::axisRect () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2007 \{ return mAxisRect; \}\par
}
}
{\xe \v axisType\:QCPAxis}
{\xe \v QCPAxis\:axisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AxisType} QCPAxis::axisType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2006 \{ return mAxisType; \}\par
}
}
{\xe \v basePen\:QCPAxis}
{\xe \v QCPAxis\:basePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::basePen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2028 \{ return mBasePen; \}\par
}
}
{\xe \v calculateMargin\:QCPAxis}
{\xe \v QCPAxis\:calculateMargin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::calculateMargin (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9107 \{\par
 9108   if (!mVisible) // if not visible, directly return 0, don't cache 0 because we can't react to setVisible in QCPAxis\par
 9109     return 0;\par
 9110   \par
 9111   if (mCachedMarginValid)\par
 9112     return mCachedMargin;\par
 9113   \par
 9114   // run through similar steps as QCPAxis::draw, and calculate margin needed to fit axis and its labels\par
 9115   int margin = 0;\par
 9116   \par
 9117   QVector<double> tickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter\par
 9118   QVector<QString> tickLabels; // the final vector passed to QCPAxisPainter\par
 9119   tickPositions.reserve(mTickVector.size());\par
 9120   tickLabels.reserve(mTickVector.size());\par
 9121   \par
 9122   if (mTicks)\par
 9123   \{\par
 9124     for (int i=0; i<mTickVector.size(); ++i)\par
 9125     \{\par
 9126       tickPositions.append(coordToPixel(mTickVector.at(i)));\par
 9127       if (mTickLabels)\par
 9128         tickLabels.append(mTickVectorLabels.at(i));\par
 9129     \}\par
 9130   \}\par
 9131   // transfer all properties of this axis to QCPAxisPainterPrivate which it needs to calculate the size.\par
 9132   // Note that some axis painter properties are already set by direct feed-through with QCPAxis setters\par
 9133   mAxisPainter->type = mAxisType;\par
 9134   mAxisPainter->labelFont = getLabelFont();\par
 9135   mAxisPainter->label = mLabel;\par
 9136   mAxisPainter->tickLabelFont = mTickLabelFont;\par
 9137   mAxisPainter->axisRect = mAxisRect->rect();\par
 9138   mAxisPainter->viewportRect = mParentPlot->viewport();\par
 9139   mAxisPainter->tickPositions = tickPositions;\par
 9140   mAxisPainter->tickLabels = tickLabels;\par
 9141   margin += mAxisPainter->size();\par
 9142   margin += mPadding;\par
 9143 \par
 9144   mCachedMargin = margin;\par
 9145   mCachedMarginValid = true;\par
 9146   return margin;\par
 9147 \}\par
}
}
{\xe \v clipRect\:QCPAxis}
{\xe \v QCPAxis\:clipRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPLayerable::clipRect () const{\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b QCPAbstractLegendItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAbstractItem} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1623 \{\par
 1624   if (mParentPlot)\par
 1625     return mParentPlot->viewport();\par
 1626   else\par
 1627     return QRect();\par
 1628 \}\par
}
}
{\xe \v coordToPixel\:QCPAxis}
{\xe \v QCPAxis\:coordToPixel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxis::coordToPixel (double  {\i value}) const}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms {\i value} , in coordinates of the axis, to pixel coordinates of the {\b QCustomPlot} widget. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8594 \{\par
 8595   if (orientation() == Qt::Horizontal)\par
 8596   \{\par
 8597     if (mScaleType == stLinear)\par
 8598     \{\par
 8599       if (!mRangeReversed)\par
 8600         return (value-mRange.lower)/mRange.size()*mAxisRect->width()+mAxisRect->left();\par
 8601       else\par
 8602         return (mRange.upper-value)/mRange.size()*mAxisRect->width()+mAxisRect->left();\par
 8603     \} else // mScaleType == stLogarithmic\par
 8604     \{\par
 8605       if (value >= 0.0 && mRange.upper < 0.0) // invalid value for logarithmic scale, just draw it outside visible range\par
 8606         return !mRangeReversed ? mAxisRect->right()+200 : mAxisRect->left()-200;\par
 8607       else if (value <= 0.0 && mRange.upper >= 0.0) // invalid value for logarithmic scale, just draw it outside visible range\par
 8608         return !mRangeReversed ? mAxisRect->left()-200 : mAxisRect->right()+200;\par
 8609       else\par
 8610       \{\par
 8611         if (!mRangeReversed)\par
 8612           return qLn(value/mRange.lower)/qLn(mRange.upper/mRange.lower)*mAxisRect->width()+mAxisRect->left();\par
 8613         else\par
 8614           return qLn(mRange.upper/value)/qLn(mRange.upper/mRange.lower)*mAxisRect->width()+mAxisRect->left();\par
 8615       \}\par
 8616     \}\par
 8617   \} else // orientation() == Qt::Vertical\par
 8618   \{\par
 8619     if (mScaleType == stLinear)\par
 8620     \{\par
 8621       if (!mRangeReversed)\par
 8622         return mAxisRect->bottom()-(value-mRange.lower)/mRange.size()*mAxisRect->height();\par
 8623       else\par
 8624         return mAxisRect->bottom()-(mRange.upper-value)/mRange.size()*mAxisRect->height();\par
 8625     \} else // mScaleType == stLogarithmic\par
 8626     \{\par
 8627       if (value >= 0.0 && mRange.upper < 0.0) // invalid value for logarithmic scale, just draw it outside visible range\par
 8628         return !mRangeReversed ? mAxisRect->top()-200 : mAxisRect->bottom()+200;\par
 8629       else if (value <= 0.0 && mRange.upper >= 0.0) // invalid value for logarithmic scale, just draw it outside visible range\par
 8630         return !mRangeReversed ? mAxisRect->bottom()+200 : mAxisRect->top()-200;\par
 8631       else\par
 8632       \{\par
 8633         if (!mRangeReversed)\par
 8634           return mAxisRect->bottom()-qLn(value/mRange.lower)/qLn(mRange.upper/mRange.lower)*mAxisRect->height();\par
 8635         else\par
 8636           return mAxisRect->bottom()-qLn(mRange.upper/value)/qLn(mRange.upper/mRange.lower)*mAxisRect->height();\par
 8637       \}\par
 8638     \}\par
 8639   \}\par
 8640 \}\par
}
}
{\xe \v deselectEvent\:QCPAxis}
{\xe \v QCPAxis\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8792 \{\par
 8793   SelectableParts selBefore = mSelectedParts;\par
 8794   setSelectedParts(mSelectedParts & ~mSelectableParts);\par
 8795   if (selectionStateChanged)\par
 8796     *selectionStateChanged = mSelectedParts != selBefore;\par
 8797 \}\par
}
}
{\xe \v draw\:QCPAxis}
{\xe \v QCPAxis\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8957 \{\par
 8958   QVector<double> subTickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter\par
 8959   QVector<double> tickPositions; // the final coordToPixel transformed vector passed to QCPAxisPainter\par
 8960   QVector<QString> tickLabels; // the final vector passed to QCPAxisPainter\par
 8961   tickPositions.reserve(mTickVector.size());\par
 8962   tickLabels.reserve(mTickVector.size());\par
 8963   subTickPositions.reserve(mSubTickVector.size());\par
 8964   \par
 8965   if (mTicks)\par
 8966   \{\par
 8967     for (int i=0; i<mTickVector.size(); ++i)\par
 8968     \{\par
 8969       tickPositions.append(coordToPixel(mTickVector.at(i)));\par
 8970       if (mTickLabels)\par
 8971         tickLabels.append(mTickVectorLabels.at(i));\par
 8972     \}\par
 8973 \par
 8974     if (mSubTicks)\par
 8975     \{\par
 8976       const int subTickCount = mSubTickVector.size();\par
 8977       for (int i=0; i<subTickCount; ++i)\par
 8978         subTickPositions.append(coordToPixel(mSubTickVector.at(i)));\par
 8979     \}\par
 8980   \}\par
 8981   \par
 8982   // transfer all properties of this axis to QCPAxisPainterPrivate which it needs to draw the axis.\par
 8983   // Note that some axis painter properties are already set by direct feed-through with QCPAxis setters\par
 8984   mAxisPainter->type = mAxisType;\par
 8985   mAxisPainter->basePen = getBasePen();\par
 8986   mAxisPainter->labelFont = getLabelFont();\par
 8987   mAxisPainter->labelColor = getLabelColor();\par
 8988   mAxisPainter->label = mLabel;\par
 8989   mAxisPainter->substituteExponent = mNumberBeautifulPowers;\par
 8990   mAxisPainter->tickPen = getTickPen();\par
 8991   mAxisPainter->subTickPen = getSubTickPen();\par
 8992   mAxisPainter->tickLabelFont = getTickLabelFont();\par
 8993   mAxisPainter->tickLabelColor = getTickLabelColor();\par
 8994   mAxisPainter->axisRect = mAxisRect->rect();\par
 8995   mAxisPainter->viewportRect = mParentPlot->viewport();\par
 8996   mAxisPainter->abbreviateDecimalPowers = mScaleType == stLogarithmic;\par
 8997   mAxisPainter->reversedEndings = mRangeReversed;\par
 8998   mAxisPainter->tickPositions = tickPositions;\par
 8999   mAxisPainter->tickLabels = tickLabels;\par
 9000   mAxisPainter->subTickPositions = subTickPositions;\par
 9001   mAxisPainter->draw(painter);\par
 9002 \}\par
}
}
{\xe \v getBasePen\:QCPAxis}
{\xe \v QCPAxis\:getBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::getBasePen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9028 \{\par
 9029   return mSelectedParts.testFlag(spAxis) ? mSelectedBasePen : mBasePen;\par
 9030 \}\par
}
}
{\xe \v getLabelColor\:QCPAxis}
{\xe \v QCPAxis\:getLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::getLabelColor () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9088 \{\par
 9089   return mSelectedParts.testFlag(spAxisLabel) ? mSelectedLabelColor : mLabelColor;\par
 9090 \}\par
}
}
{\xe \v getLabelFont\:QCPAxis}
{\xe \v QCPAxis\:getLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::getLabelFont () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9068 \{\par
 9069   return mSelectedParts.testFlag(spAxisLabel) ? mSelectedLabelFont : mLabelFont;\par
 9070 \}\par
}
}
{\xe \v getPartAt\:QCPAxis}
{\xe \v QCPAxis\:getPartAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::SelectablePart} QCPAxis::getPartAt (const QPointF &  {\i pos}) const}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the part of the axis that is hit by {\i pos}  (in pixels). The return value of this function is independent of the user-selectable parts defined with {\b setSelectableParts}. Further, this function does not change the current selection state of the axis.\par
If the axis is not visible ({\b setVisible}), this function always returns {\b spNone}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectedParts}, {\b setSelectableParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8652 \{\par
 8653   if (!mVisible)\par
 8654     return spNone;\par
 8655   \par
 8656   if (mAxisPainter->axisSelectionBox().contains(pos.toPoint()))\par
 8657     return spAxis;\par
 8658   else if (mAxisPainter->tickLabelsSelectionBox().contains(pos.toPoint()))\par
 8659     return spTickLabels;\par
 8660   else if (mAxisPainter->labelSelectionBox().contains(pos.toPoint()))\par
 8661     return spAxisLabel;\par
 8662   else\par
 8663     return spNone;\par
 8664 \}\par
}
}
{\xe \v getSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:getSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::getSubTickPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9048 \{\par
 9049   return mSelectedParts.testFlag(spAxis) ? mSelectedSubTickPen : mSubTickPen;\par
 9050 \}\par
}
}
{\xe \v getTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:getTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::getTickLabelColor () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9078 \{\par
 9079   return mSelectedParts.testFlag(spTickLabels) ? mSelectedTickLabelColor : mTickLabelColor;\par
 9080 \}\par
}
}
{\xe \v getTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:getTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::getTickLabelFont () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9058 \{\par
 9059   return mSelectedParts.testFlag(spTickLabels) ? mSelectedTickLabelFont : mTickLabelFont;\par
 9060 \}\par
}
}
{\xe \v getTickPen\:QCPAxis}
{\xe \v QCPAxis\:getTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::getTickPen () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9038 \{\par
 9039   return mSelectedParts.testFlag(spAxis) ? mSelectedTickPen : mTickPen;\par
 9040 \}\par
}
}
{\xe \v graphs\:QCPAxis}
{\xe \v QCPAxis\:graphs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPGraph} * > QCPAxis::graphs () const}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the graphs that have this axis as key or value axis.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottables}, {\b items} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8705 \{\par
 8706   QList<QCPGraph*> result;\par
 8707   if (!mParentPlot) return result;\par
 8708   \par
 8709   for (int i=0; i<mParentPlot->mGraphs.size(); ++i)\par
 8710   \{\par
 8711     if (mParentPlot->mGraphs.at(i)->keyAxis() == this || mParentPlot->mGraphs.at(i)->valueAxis() == this)\par
 8712       result.append(mParentPlot->mGraphs.at(i));\par
 8713   \}\par
 8714   return result;\par
 8715 \}\par
}
}
{\xe \v grid\:QCPAxis}
{\xe \v QCPAxis\:grid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGrid} * QCPAxis::grid () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b QCPGrid} instance belonging to this axis. Access it to set details about the way the grid is displayed. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2048 \{ return mGrid; \}\par
}
}
{\xe \v initializeParentPlot\:QCPAxis}
{\xe \v QCPAxis\:initializeParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::initializeParentPlot ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1497 \{\par
 1498   if (mParentPlot)\par
 1499   \{\par
 1500     qDebug() << Q_FUNC_INFO << "called with mParentPlot already initialized";\par
 1501     return;\par
 1502   \}\par
 1503   \par
 1504   if (!parentPlot)\par
 1505     qDebug() << Q_FUNC_INFO << "called with parentPlot zero";\par
 1506   \par
 1507   mParentPlot = parentPlot;\par
 1508   parentPlotInitialized(mParentPlot);\par
 1509 \}\par
}
}
{\xe \v items\:QCPAxis}
{\xe \v QCPAxis\:items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractItem} * > QCPAxis::items () const}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the items that are associated with this axis. An item is considered associated with an axis if at least one of its positions uses the axis as key or value axis.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b plottables}, {\b graphs} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8724 \{\par
 8725   QList<QCPAbstractItem*> result;\par
 8726   if (!mParentPlot) return result;\par
 8727   \par
 8728   for (int itemId=0; itemId<mParentPlot->mItems.size(); ++itemId)\par
 8729   \{\par
 8730     QList<QCPItemPosition*> positions = mParentPlot->mItems.at(itemId)->positions();\par
 8731     for (int posId=0; posId<positions.size(); ++posId)\par
 8732     \{\par
 8733       if (positions.at(posId)->keyAxis() == this || positions.at(posId)->valueAxis() == this)\par
 8734       \{\par
 8735         result.append(mParentPlot->mItems.at(itemId));\par
 8736         break;\par
 8737       \}\par
 8738     \}\par
 8739   \}\par
 8740   return result;\par
 8741 \}\par
}
}
{\xe \v label\:QCPAxis}
{\xe \v QCPAxis\:label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxis::label () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2033 \{ return mLabel; \}\par
}
}
{\xe \v labelColor\:QCPAxis}
{\xe \v QCPAxis\:labelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::labelColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2032 \{ return mLabelColor; \}\par
}
}
{\xe \v labelFont\:QCPAxis}
{\xe \v QCPAxis\:labelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::labelFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2031 \{ return mLabelFont; \}\par
}
}
{\xe \v labelPadding\:QCPAxis}
{\xe \v QCPAxis\:labelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::labelPadding () const}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7631 \{\par
 7632   return mAxisPainter->labelPadding;\par
 7633 \}\par
}
}
{\xe \v layer\:QCPAxis}
{\xe \v QCPAxis\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::layer () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   710 \{ return mLayer; \}\par
}
}
{\xe \v layerChanged\:QCPAxis}
{\xe \v QCPAxis\:layerChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::layerChanged ({\b QCPLayer} *  {\i newLayer}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLayer} \par
}}}
{\xe \v lowerEnding\:QCPAxis}
{\xe \v QCPAxis\:lowerEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPAxis::lowerEnding () const}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7643 \{\par
 7644   return mAxisPainter->lowerEnding;\par
 7645 \}\par
}
}
{\xe \v marginSideToAxisType\:QCPAxis}
{\xe \v QCPAxis\:marginSideToAxisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::AxisType} QCPAxis::marginSideToAxisType ({\b QCP::MarginSide}  {\i side}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms a margin side to the logically corresponding axis type. ({\b QCP::msLeft} to {\b QCPAxis::atLeft}, {\b QCP::msRight} to {\b QCPAxis::atRight}, etc.) \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8748 \{\par
 8749   switch (side)\par
 8750   \{\par
 8751     case QCP::msLeft: return atLeft;\par
 8752     case QCP::msRight: return atRight;\par
 8753     case QCP::msTop: return atTop;\par
 8754     case QCP::msBottom: return atBottom;\par
 8755     default: break;\par
 8756   \}\par
 8757   qDebug() << Q_FUNC_INFO << "Invalid margin side passed:" << (int)side;\par
 8758   return atLeft;\par
 8759 \}\par
}
}
{\xe \v mouseDoubleClickEvent\:QCPAxis}
{\xe \v QCPAxis\:mouseDoubleClickEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseDoubleClickEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The {\b mouseDoubleClickEvent} is called instead of the second {\b mousePressEvent}. So in the case of a double-click, the event succession is {\i pressEvent \'96 releaseEvent \'96 doubleClickEvent \'96 releaseEvent} .\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
Similarly to {\b mousePressEvent}, once a layerable has accepted the {\b mouseDoubleClickEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} and {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1777 \{\par
 1778   Q_UNUSED(details)\par
 1779   event->ignore();\par
 1780 \}\par
}
}
{\xe \v mouseMoveEvent\:QCPAxis}
{\xe \v QCPAxis\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::mouseMoveEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8853 \{\par
 8854   if (mDragging)\par
 8855   \{\par
 8856     const double startPixel = orientation() == Qt::Horizontal ? startPos.x() : startPos.y();\par
 8857     const double currentPixel = orientation() == Qt::Horizontal ? event->pos().x() : event->pos().y();\par
 8858     if (mScaleType == QCPAxis::stLinear)\par
 8859     \{\par
 8860       const double diff = pixelToCoord(startPixel) - pixelToCoord(currentPixel);\par
 8861       setRange(mDragStartRange.lower+diff, mDragStartRange.upper+diff);\par
 8862     \} else if (mScaleType == QCPAxis::stLogarithmic)\par
 8863     \{\par
 8864       const double diff = pixelToCoord(startPixel) / pixelToCoord(currentPixel);\par
 8865       setRange(mDragStartRange.lower*diff, mDragStartRange.upper*diff);\par
 8866     \}\par
 8867     \par
 8868     if (mParentPlot->noAntialiasingOnDrag())\par
 8869       mParentPlot->setNotAntialiasedElements(QCP::aeAll);\par
 8870     mParentPlot->replot(QCustomPlot::rpQueuedReplot);\par
 8871   \}\par
 8872 \}\par
}
}
{\xe \v mousePressEvent\:QCPAxis}
{\xe \v QCPAxis\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::mousePressEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
{\b QCustomPlot} uses an event propagation system that works the same as Qt's system. If your layerable doesn't reimplement the {\b mousePressEvent} or explicitly calls {\f2 event->ignore()}  in its reimplementation, the event will be propagated to the next layerable in the stacking order.\par
Once a layerable has accepted the {\b mousePressEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} or {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8815 \{\par
 8816   Q_UNUSED(details)\par
 8817   if (!mParentPlot->interactions().testFlag(QCP::iRangeDrag) ||\par
 8818       !mAxisRect->rangeDrag().testFlag(orientation()) ||\par
 8819       !mAxisRect->rangeDragAxes(orientation()).contains(this))\par
 8820   \{\par
 8821     event->ignore();\par
 8822     return;\par
 8823   \}\par
 8824   \par
 8825   if (event->buttons() & Qt::LeftButton)\par
 8826   \{\par
 8827     mDragging = true;\par
 8828     // initialize antialiasing backup in case we start dragging:\par
 8829     if (mParentPlot->noAntialiasingOnDrag())\par
 8830     \{\par
 8831       mAADragBackup = mParentPlot->antialiasedElements();\par
 8832       mNotAADragBackup = mParentPlot->notAntialiasedElements();\par
 8833     \}\par
 8834     // Mouse range dragging interaction:\par
 8835     if (mParentPlot->interactions().testFlag(QCP::iRangeDrag))\par
 8836       mDragStartRange = mRange;\par
 8837   \}\par
 8838 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPAxis}
{\xe \v QCPAxis\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::mouseReleaseEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8887 \{\par
 8888   Q_UNUSED(event)\par
 8889   Q_UNUSED(startPos)\par
 8890   mDragging = false;\par
 8891   if (mParentPlot->noAntialiasingOnDrag())\par
 8892   \{\par
 8893     mParentPlot->setAntialiasedElements(mAADragBackup);\par
 8894     mParentPlot->setNotAntialiasedElements(mNotAADragBackup);\par
 8895   \}\par
 8896 \}\par
}
}
{\xe \v moveRange\:QCPAxis}
{\xe \v QCPAxis\:moveRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::moveRange (double  {\i diff})}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the scale type ({\b setScaleType}) is {\b stLinear}, {\i diff}  is added to the lower and upper bounds of the range. The range is simply moved by {\i diff} .\par
If the scale type is {\b stLogarithmic}, the range bounds are multiplied by {\i diff} . This corresponds to an apparent "linear" move in logarithmic scaling by a distance of log(diff). \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8405 \{\par
 8406   QCPRange oldRange = mRange;\par
 8407   if (mScaleType == stLinear)\par
 8408   \{\par
 8409     mRange.lower += diff;\par
 8410     mRange.upper += diff;\par
 8411   \} else // mScaleType == stLogarithmic\par
 8412   \{\par
 8413     mRange.lower *= diff;\par
 8414     mRange.upper *= diff;\par
 8415   \}\par
 8416   emit rangeChanged(mRange);\par
 8417   emit rangeChanged(mRange, oldRange);\par
 8418 \}\par
}
}
{\xe \v moveToLayer\:QCPAxis}
{\xe \v QCPAxis\:moveToLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::moveToLayer ({\b QCPLayer} *  {\i layer}, bool  {\i prepend}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1536 \{\par
 1537   if (layer && !mParentPlot)\par
 1538   \{\par
 1539     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1540     return false;\par
 1541   \}\par
 1542   if (layer && layer->parentPlot() != mParentPlot)\par
 1543   \{\par
 1544     qDebug() << Q_FUNC_INFO << "layer" << layer->name() << "is not in same QCustomPlot as this layerable";\par
 1545     return false;\par
 1546   \}\par
 1547   \par
 1548   QCPLayer *oldLayer = mLayer;\par
 1549   if (mLayer)\par
 1550     mLayer->removeChild(this);\par
 1551   mLayer = layer;\par
 1552   if (mLayer)\par
 1553     mLayer->addChild(this, prepend);\par
 1554   if (mLayer != oldLayer)\par
 1555     emit layerChanged(mLayer);\par
 1556   return true;\par
 1557 \}\par
}
}
{\xe \v numberFormat\:QCPAxis}
{\xe \v QCPAxis\:numberFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxis::numberFormat () const}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7593 \{\par
 7594   QString result;\par
 7595   result.append(mNumberFormatChar);\par
 7596   if (mNumberBeautifulPowers)\par
 7597   \{\par
 7598     result.append(QLatin1Char('b'));\par
 7599     if (mAxisPainter->numberMultiplyCross)\par
 7600       result.append(QLatin1Char('c'));\par
 7601   \}\par
 7602   return result;\par
 7603 \}\par
}
}
{\xe \v numberPrecision\:QCPAxis}
{\xe \v QCPAxis\:numberPrecision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::numberPrecision () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2020 \{ return mNumberPrecision; \}\par
}
}
{\xe \v offset\:QCPAxis}
{\xe \v QCPAxis\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::offset () const}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7637 \{\par
 7638   return mAxisPainter->offset;\par
 7639 \}\par
}
}
{\xe \v opposite\:QCPAxis}
{\xe \v QCPAxis\:opposite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::AxisType} QCPAxis::opposite ({\b QCPAxis::AxisType}  {\i type}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the axis type that describes the opposite axis of an axis with the specified {\i type} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8765 \{\par
 8766   switch (type)\par
 8767   \{\par
 8768     case atLeft: return atRight; break;\par
 8769     case atRight: return atLeft; break;\par
 8770     case atBottom: return atTop; break;\par
 8771     case atTop: return atBottom; break;\par
 8772     default: qDebug() << Q_FUNC_INFO << "invalid axis type"; return atLeft; break;\par
 8773   \}\par
 8774 \}\par
}
}
{\xe \v orientation\:QCPAxis}
{\xe \v QCPAxis\:orientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientation QCPAxis::orientation () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orientation of this axis. The axis orientation (horizontal or vertical) is deduced from the axis type (left, top, right or bottom).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b orientation(AxisType type)}, {\b pixelOrientation} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2100 \{ return mOrientation; \}\par
}
}
{\xe \v orientation\:QCPAxis}
{\xe \v QCPAxis\:orientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static Qt::Orientation QCPAxis::orientation ({\b AxisType}  {\i type}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orientation of the specified axis type\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b orientation()}, {\b pixelOrientation} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2115 \{ return type==atBottom||type==atTop ? Qt::Horizontal : Qt::Vertical; \}\par
}
}
{\xe \v padding\:QCPAxis}
{\xe \v QCPAxis\:padding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::padding () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2035 \{ return mPadding; \}\par
}
}
{\xe \v parentLayerable\:QCPAxis}
{\xe \v QCPAxis\:parentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayerable} * QCPLayerable::parentLayerable () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method {\b realVisibility}. This way, layerables only get drawn if their parent layerables are visible, too.\par
Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn't always have a parent layerable, so this function may return 0.\par
A parent layerable is set implicitly when placed inside layout elements and doesn't need to be set manually by the user. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   709 \{ return mParentLayerable.data(); \}\par
}
}
{\xe \v parentPlot\:QCPAxis}
{\xe \v QCPAxis\:parentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::parentPlot () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   708 \{ return mParentPlot; \}\par
}
}
{\xe \v parentPlotInitialized\:QCPAxis}
{\xe \v QCPAxis\:parentPlotInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::parentPlotInitialized ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1593 \{\par
 1594    Q_UNUSED(parentPlot)\par
 1595 \}\par
}
}
{\xe \v pixelOrientation\:QCPAxis}
{\xe \v QCPAxis\:pixelOrientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::pixelOrientation () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns which direction points towards higher coordinate values/keys, in pixel space.\par
This method returns either 1 or -1. If it returns 1, then going in the positive direction along the orientation of the axis in pixels corresponds to going from lower to higher axis coordinates. On the other hand, if this method returns -1, going to smaller pixel values corresponds to going from lower to higher axis coordinates.\par
For example, this is useful to easily shift axis coordinates by a certain amount given in pixels, without having to care about reversed or vertically aligned axes:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid double newKey = keyAxis->pixelToCoord(keyAxis->coordToPixel(oldKey)+10*keyAxis->pixelOrientation());\par
}
\par
{\i newKey}  will then contain a key that is ten pixels towards higher keys, starting from {\i oldKey} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2101 \{ return rangeReversed() != (orientation()==Qt::Vertical) ? -1 : 1; \}\par
}
}
{\xe \v pixelToCoord\:QCPAxis}
{\xe \v QCPAxis\:pixelToCoord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxis::pixelToCoord (double  {\i value}) const}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transforms {\i value} , in pixel coordinates of the {\b QCustomPlot} widget, to axis coordinates. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8556 \{\par
 8557   if (orientation() == Qt::Horizontal)\par
 8558   \{\par
 8559     if (mScaleType == stLinear)\par
 8560     \{\par
 8561       if (!mRangeReversed)\par
 8562         return (value-mAxisRect->left())/(double)mAxisRect->width()*mRange.size()+mRange.lower;\par
 8563       else\par
 8564         return -(value-mAxisRect->left())/(double)mAxisRect->width()*mRange.size()+mRange.upper;\par
 8565     \} else // mScaleType == stLogarithmic\par
 8566     \{\par
 8567       if (!mRangeReversed)\par
 8568         return qPow(mRange.upper/mRange.lower, (value-mAxisRect->left())/(double)mAxisRect->width())*mRange.lower;\par
 8569       else\par
 8570         return qPow(mRange.upper/mRange.lower, (mAxisRect->left()-value)/(double)mAxisRect->width())*mRange.upper;\par
 8571     \}\par
 8572   \} else // orientation() == Qt::Vertical\par
 8573   \{\par
 8574     if (mScaleType == stLinear)\par
 8575     \{\par
 8576       if (!mRangeReversed)\par
 8577         return (mAxisRect->bottom()-value)/(double)mAxisRect->height()*mRange.size()+mRange.lower;\par
 8578       else\par
 8579         return -(mAxisRect->bottom()-value)/(double)mAxisRect->height()*mRange.size()+mRange.upper;\par
 8580     \} else // mScaleType == stLogarithmic\par
 8581     \{\par
 8582       if (!mRangeReversed)\par
 8583         return qPow(mRange.upper/mRange.lower, (mAxisRect->bottom()-value)/(double)mAxisRect->height())*mRange.lower;\par
 8584       else\par
 8585         return qPow(mRange.upper/mRange.lower, (value-mAxisRect->bottom())/(double)mAxisRect->height())*mRange.upper;\par
 8586     \}\par
 8587   \}\par
 8588 \}\par
}
}
{\xe \v plottables\:QCPAxis}
{\xe \v QCPAxis\:plottables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b QCPAbstractPlottable} * > QCPAxis::plottables () const}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a list of all the plottables that have this axis as key or value axis.\par
If you are only interested in plottables of type {\b QCPGraph}, see {\b graphs}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b graphs}, {\b items} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8687 \{\par
 8688   QList<QCPAbstractPlottable*> result;\par
 8689   if (!mParentPlot) return result;\par
 8690   \par
 8691   for (int i=0; i<mParentPlot->mPlottables.size(); ++i)\par
 8692   \{\par
 8693     if (mParentPlot->mPlottables.at(i)->keyAxis() == this ||mParentPlot->mPlottables.at(i)->valueAxis() == this)\par
 8694       result.append(mParentPlot->mPlottables.at(i));\par
 8695   \}\par
 8696   return result;\par
 8697 \}\par
}
}
{\xe \v range\:QCPAxis}
{\xe \v QCPAxis\:range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b QCPRange} QCPAxis::range () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2009 \{ return mRange; \}\par
}
}
{\xe \v rangeChanged\:QCPAxis}
{\xe \v QCPAxis\:rangeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::rangeChanged (const {\b QCPRange} &  {\i newRange}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the range of this axis has changed. You can connect it to the {\b setRange} slot of another axis to communicate the new range to the other axis, in order for it to be synchronized.\par
You may also manipulate/correct the range with {\b setRange} in a slot connected to this signal. This is useful if for example a maximum range span shall not be exceeded, or if the lower/upper range shouldn't go beyond certain values (see {\b QCPRange::bounded}). For example, the following slot would limit the x axis to ranges between 0 and 10: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid customPlot->xAxis->setRange(newRange.bounded(0, 10))\par
}
 \par
}}
{\xe \v rangeChanged\:QCPAxis}
{\xe \v QCPAxis\:rangeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::rangeChanged (const {\b QCPRange} &  {\i newRange}, const {\b QCPRange} &  {\i oldRange}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Additionally to the new range, this signal also provides the previous range held by the axis as {\i oldRange} . \par
}}
{\xe \v rangeReversed\:QCPAxis}
{\xe \v QCPAxis\:rangeReversed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::rangeReversed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2010 \{ return mRangeReversed; \}\par
}
}
{\xe \v realVisibility\:QCPAxis}
{\xe \v QCPAxis\:realVisibility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::realVisibility () const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable's layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.\par
If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of {\b QCPLayoutElement}), this function returns true only if this layerable has its visibility set to true and the parent layerable's {\b realVisibility} returns true. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1433 \{\par
 1434   return mVisible && (!mLayer || mLayer->visible()) && (!mParentLayerable || mParentLayerable.data()->realVisibility());\par
 1435 \}\par
}
}
{\xe \v rescale\:QCPAxis}
{\xe \v QCPAxis\:rescale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::rescale (bool  {\i onlyVisiblePlottables} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Changes the axis range such that all plottables associated with this axis are fully visible in that dimension.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPAbstractPlottable::rescaleAxes}, {\b QCustomPlot::rescaleAxes} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8507 \{\par
 8508   QList<QCPAbstractPlottable*> p = plottables();\par
 8509   QCPRange newRange;\par
 8510   bool haveRange = false;\par
 8511   for (int i=0; i<p.size(); ++i)\par
 8512   \{\par
 8513     if (!p.at(i)->realVisibility() && onlyVisiblePlottables)\par
 8514       continue;\par
 8515     QCPRange plottableRange;\par
 8516     bool currentFoundRange;\par
 8517     QCP::SignDomain signDomain = QCP::sdBoth;\par
 8518     if (mScaleType == stLogarithmic)\par
 8519       signDomain = (mRange.upper < 0 ? QCP::sdNegative : QCP::sdPositive);\par
 8520     if (p.at(i)->keyAxis() == this)\par
 8521       plottableRange = p.at(i)->getKeyRange(currentFoundRange, signDomain);\par
 8522     else\par
 8523       plottableRange = p.at(i)->getValueRange(currentFoundRange, signDomain);\par
 8524     if (currentFoundRange)\par
 8525     \{\par
 8526       if (!haveRange)\par
 8527         newRange = plottableRange;\par
 8528       else\par
 8529         newRange.expand(plottableRange);\par
 8530       haveRange = true;\par
 8531     \}\par
 8532   \}\par
 8533   if (haveRange)\par
 8534   \{\par
 8535     if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable\par
 8536     \{\par
 8537       double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason\par
 8538       if (mScaleType == stLinear)\par
 8539       \{\par
 8540         newRange.lower = center-mRange.size()/2.0;\par
 8541         newRange.upper = center+mRange.size()/2.0;\par
 8542       \} else // mScaleType == stLogarithmic\par
 8543       \{\par
 8544         newRange.lower = center/qSqrt(mRange.upper/mRange.lower);\par
 8545         newRange.upper = center*qSqrt(mRange.upper/mRange.lower);\par
 8546       \}\par
 8547     \}\par
 8548     setRange(newRange);\par
 8549   \}\par
 8550 \}\par
}
}
{\xe \v scaleRange\:QCPAxis}
{\xe \v QCPAxis\:scaleRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::scaleRange (double  {\i factor})}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scales the range of this axis by {\i factor}  around the center of the current axis range. For example, if {\i factor}  is 2.0, then the axis range will double its size, and the point at the axis range center won't have changed its position in the {\b QCustomPlot} widget (i.e. coordinates around the center will have moved symmetrically closer).\par
If you wish to scale around a different coordinate than the current axis range center, use the overload {\b scaleRange(double factor, double center)}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8430 \{\par
 8431   scaleRange(factor, range().center());\par
 8432 \}\par
}
}
{\xe \v scaleRange\:QCPAxis}
{\xe \v QCPAxis\:scaleRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::scaleRange (double  {\i factor}, double  {\i center})}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Scales the range of this axis by {\i factor}  around the coordinate {\i center} . For example, if {\i factor}  is 2.0, {\i center}  is 1.0, then the axis range will double its size, and the point at coordinate 1.0 won't have changed its position in the {\b QCustomPlot} widget (i.e. coordinates around 1.0 will have moved symmetrically closer to 1.0).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b scaleRange(double factor)} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8444 \{\par
 8445   QCPRange oldRange = mRange;\par
 8446   if (mScaleType == stLinear)\par
 8447   \{\par
 8448     QCPRange newRange;\par
 8449     newRange.lower = (mRange.lower-center)*factor + center;\par
 8450     newRange.upper = (mRange.upper-center)*factor + center;\par
 8451     if (QCPRange::validRange(newRange))\par
 8452       mRange = newRange.sanitizedForLinScale();\par
 8453   \} else // mScaleType == stLogarithmic\par
 8454   \{\par
 8455     if ((mRange.upper < 0 && center < 0) || (mRange.upper > 0 && center > 0)) // make sure center has same sign as range\par
 8456     \{\par
 8457       QCPRange newRange;\par
 8458       newRange.lower = qPow(mRange.lower/center, factor)*center;\par
 8459       newRange.upper = qPow(mRange.upper/center, factor)*center;\par
 8460       if (QCPRange::validRange(newRange))\par
 8461         mRange = newRange.sanitizedForLogScale();\par
 8462     \} else\par
 8463       qDebug() << Q_FUNC_INFO << "Center of scaling operation doesn't lie in same logarithmic sign domain as range:" << center;\par
 8464   \}\par
 8465   emit rangeChanged(mRange);\par
 8466   emit rangeChanged(mRange, oldRange);\par
 8467 \}\par
}
}
{\xe \v scaleType\:QCPAxis}
{\xe \v QCPAxis\:scaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScaleType} QCPAxis::scaleType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2008 \{ return mScaleType; \}\par
}
}
{\xe \v scaleTypeChanged\:QCPAxis}
{\xe \v QCPAxis\:scaleTypeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::scaleTypeChanged ({\b QCPAxis::ScaleType}  {\i scaleType}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the scale type changes, by calls to {\b setScaleType} \par
}}
{\xe \v selectableChanged\:QCPAxis}
{\xe \v QCPAxis\:selectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::selectableChanged (const QCPAxis::SelectableParts &  {\i parts}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selectability changes, by calls to {\b setSelectableParts} \par
}}
{\xe \v selectableParts\:QCPAxis}
{\xe \v QCPAxis\:selectableParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPAxis::selectableParts () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2038 \{ return mSelectableParts; \}\par
}
}
{\xe \v selectedBasePen\:QCPAxis}
{\xe \v QCPAxis\:selectedBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::selectedBasePen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2043 \{ return mSelectedBasePen; \}\par
}
}
{\xe \v selectedLabelColor\:QCPAxis}
{\xe \v QCPAxis\:selectedLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::selectedLabelColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2042 \{ return mSelectedLabelColor; \}\par
}
}
{\xe \v selectedLabelFont\:QCPAxis}
{\xe \v QCPAxis\:selectedLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::selectedLabelFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2040 \{ return mSelectedLabelFont; \}\par
}
}
{\xe \v selectedParts\:QCPAxis}
{\xe \v QCPAxis\:selectedParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPAxis::selectedParts () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2037 \{ return mSelectedParts; \}\par
}
}
{\xe \v selectedSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:selectedSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::selectedSubTickPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2045 \{ return mSelectedSubTickPen; \}\par
}
}
{\xe \v selectedTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:selectedTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::selectedTickLabelColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2041 \{ return mSelectedTickLabelColor; \}\par
}
}
{\xe \v selectedTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:selectedTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::selectedTickLabelFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2039 \{ return mSelectedTickLabelFont; \}\par
}
}
{\xe \v selectedTickPen\:QCPAxis}
{\xe \v QCPAxis\:selectedTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::selectedTickPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2044 \{ return mSelectedTickPen; \}\par
}
}
{\xe \v selectEvent\:QCPAxis}
{\xe \v QCPAxis\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8778 \{\par
 8779   Q_UNUSED(event)\par
 8780   SelectablePart part = details.value<SelectablePart>();\par
 8781   if (mSelectableParts.testFlag(part))\par
 8782   \{\par
 8783     SelectableParts selBefore = mSelectedParts;\par
 8784     setSelectedParts(additive ? mSelectedParts^part : part);\par
 8785     if (selectionStateChanged)\par
 8786       *selectionStateChanged = mSelectedParts != selBefore;\par
 8787   \}\par
 8788 \}\par
}
}
{\xe \v selectionCategory\:QCPAxis}
{\xe \v QCPAxis\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPAxis::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9151 \{\par
 9152   return QCP::iSelectAxes;\par
 9153 \}\par
}
}
{\xe \v selectionChanged\:QCPAxis}
{\xe \v QCPAxis\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::selectionChanged (const QCPAxis::SelectableParts &  {\i parts}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this axis has changed, either by user interaction or by a direct call to {\b setSelectedParts}. \par
}}
{\xe \v selectTest\:QCPAxis}
{\xe \v QCPAxis\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxis::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to decide whether a click hits a layerable object or not.\par
{\i pos}  is a point in pixel coordinates on the {\b QCustomPlot} surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if {\i onlySelectable}  is true and the object is not selectable, -1.0 is returned, too.\par
If the object is represented not by single lines but by an area like a {\b QCPItemText} or the bars of a {\b QCPBars} plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).\par
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).\par
The actual setting of the selection state is not done by this function. This is handled by the parent {\b QCustomPlot} when the mouseReleaseEvent occurs, and the finally selected object is notified via the {\b selectEvent}/{\b deselectEvent} methods.\par
{\i details}  is an optional output parameter. Every layerable subclass may place any information in {\i details} . This information will be passed to {\b selectEvent} when the parent {\b QCustomPlot} decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to {\b selectEvent} will carry the {\i details} . This is useful for multi-part objects (like {\b QCPAxis}). This way, a possibly complex calculation to decide which part was clicked is only done once in {\b selectTest}. The result (i.e. the actually clicked part) can then be placed in {\i details} . So in the subsequent {\b selectEvent}, the decision which part was selected doesn't have to be done a second time for a single selection operation.\par
You may pass 0 as {\i details}  to indicate that you are not interested in those selection details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectEvent}, {\b deselectEvent}, {\b mousePressEvent}, {\b wheelEvent}, {\b QCustomPlot::setInteractions} \par
}}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8668 \{\par
 8669   if (!mParentPlot) return -1;\par
 8670   SelectablePart part = getPartAt(pos);\par
 8671   if ((onlySelectable && !mSelectableParts.testFlag(part)) || part == spNone)\par
 8672     return -1;\par
 8673   \par
 8674   if (details)\par
 8675     details->setValue(part);\par
 8676   return mParentPlot->selectionTolerance()*0.99;\par
 8677 \}\par
}
}
{\xe \v setAntialiased\:QCPAxis}
{\xe \v QCPAxis\:setAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setAntialiased (bool  {\i enabled}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this object will be drawn antialiased or not.\par
Note that antialiasing settings may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1418 \{\par
 1419   mAntialiased = enabled;\par
 1420 \}\par
}
}
{\xe \v setBasePen\:QCPAxis}
{\xe \v QCPAxis\:setBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setBasePen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen, the axis base line is drawn with.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickPen}, {\b setSubTickPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8182 \{\par
 8183   mBasePen = pen;\par
 8184 \}\par
}
}
{\xe \v setLabel\:QCPAxis}
{\xe \v QCPAxis\:setLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLabel (const QString &  {\i str})}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the text of the axis label that will be shown below/above or next to the axis, depending on its orientation. To disable axis labels, pass an empty string as {\i str} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8235 \{\par
 8236   if (mLabel != str)\par
 8237   \{\par
 8238     mLabel = str;\par
 8239     mCachedMarginValid = false;\par
 8240   \}\par
 8241 \}\par
}
}
{\xe \v setLabelColor\:QCPAxis}
{\xe \v QCPAxis\:setLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLabelColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color of the axis label.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8226 \{\par
 8227   mLabelColor = color;\par
 8228 \}\par
}
}
{\xe \v setLabelFont\:QCPAxis}
{\xe \v QCPAxis\:setLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLabelFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font of the axis label.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8212 \{\par
 8213   if (mLabelFont != font)\par
 8214   \{\par
 8215     mLabelFont = font;\par
 8216     mCachedMarginValid = false;\par
 8217   \}\par
 8218 \}\par
}
}
{\xe \v setLabelPadding\:QCPAxis}
{\xe \v QCPAxis\:setLabelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLabelPadding (int  {\i padding})}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the distance between the tick labels and the axis label.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabelPadding}, {\b setPadding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8249 \{\par
 8250   if (mAxisPainter->labelPadding != padding)\par
 8251   \{\par
 8252     mAxisPainter->labelPadding = padding;\par
 8253     mCachedMarginValid = false;\par
 8254   \}\par
 8255 \}\par
}
}
{\xe \v setLayer\:QCPAxis}
{\xe \v QCPAxis\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer ({\b QCPLayer} *  {\i layer}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i layer}  of this layerable object. The object will be placed on top of the other objects already on {\i layer} .\par
If {\i layer}  is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).\par
Returns true if the layer of this layerable was successfully changed to {\i layer} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1385 \{\par
 1386   return moveToLayer(layer, false);\par
 1387 \}\par
}
}
{\xe \v setLayer\:QCPAxis}
{\xe \v QCPAxis\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer (const QString &  {\i layerName}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name\par
Returns true on success, i.e. if {\i layerName}  is a valid layer name. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1395 \{\par
 1396   if (!mParentPlot)\par
 1397   \{\par
 1398     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1399     return false;\par
 1400   \}\par
 1401   if (QCPLayer *layer = mParentPlot->layer(layerName))\par
 1402   \{\par
 1403     return setLayer(layer);\par
 1404   \} else\par
 1405   \{\par
 1406     qDebug() << Q_FUNC_INFO << "there is no layer with name" << layerName;\par
 1407     return false;\par
 1408   \}\par
 1409 \}\par
}
}
{\xe \v setLowerEnding\:QCPAxis}
{\xe \v QCPAxis\:setLowerEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setLowerEnding (const {\b QCPLineEnding} &  {\i ending})}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the style for the lower axis ending. See the documentation of {\b QCPLineEnding} for available styles.\par
For horizontal axes, this method refers to the left ending, for vertical axes the bottom ending. Note that this meaning does not change when the axis range is reversed with {\b setRangeReversed}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setUpperEnding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8378 \{\par
 8379   mAxisPainter->lowerEnding = ending;\par
 8380 \}\par
}
}
{\xe \v setNumberFormat\:QCPAxis}
{\xe \v QCPAxis\:setNumberFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setNumberFormat (const QString &  {\i formatCode})}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number format for the numbers in tick labels. This {\i formatCode}  is an extended version of the format code used e.g. by QString::number() and QLocale::toString(). For reference about that, see the "Argument Formats" section in the detailed description of the QString class.\par
{\i formatCode}  is a string of one, two or three characters. The first character is identical to the normal format code used by Qt. In short, this means: 'e'/'E' scientific format, 'f' fixed format, 'g'/'G' scientific or fixed, whichever is shorter.\par
The second and third characters are optional and specific to {\b QCustomPlot}:\par
If the first char was 'e' or 'g', numbers are/might be displayed in the scientific format, e.g. "5.5e9", which is ugly in a plot. So when the second char of {\i formatCode}  is set to 'b' (for "beautiful"), those exponential numbers are formatted in a more natural way, i.e. "5.5
[multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot. If instead a cross should be shown (as is usual in the USA), the third char of {\i formatCode}  can be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the cross and 183 (0xB7) for the dot.\par
Examples for {\i formatCode:}  {
\par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 g}  normal format code behaviour. If number is small, fixed format is used, if number is large, normal scientific format is used \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 gb}  If number is small, fixed format is used, if number is large, scientific format is used with beautifully typeset decimal powers and a dot as multiplication sign \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 ebc}  All numbers are in scientific format with beautifully typeset decimal power and a cross as multiplication sign \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 fb}  illegal format code, since fixed format doesn't support (or need) beautifully typeset decimal powers. Format code will be reduced to 'f'. \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\f2 hello}  illegal format code, since first char is not 'e', 'E', 'f', 'g' or 'G'. Current format code will not be changed. \par
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8004 \{\par
 8005   if (formatCode.isEmpty())\par
 8006   \{\par
 8007     qDebug() << Q_FUNC_INFO << "Passed formatCode is empty";\par
 8008     return;\par
 8009   \}\par
 8010   mCachedMarginValid = false;\par
 8011   \par
 8012   // interpret first char as number format char:\par
 8013   QString allowedFormatChars(QLatin1String("eEfgG"));\par
 8014   if (allowedFormatChars.contains(formatCode.at(0)))\par
 8015   \{\par
 8016     mNumberFormatChar = QLatin1Char(formatCode.at(0).toLatin1());\par
 8017   \} else\par
 8018   \{\par
 8019     qDebug() << Q_FUNC_INFO << "Invalid number format code (first char not in 'eEfgG'):" << formatCode;\par
 8020     return;\par
 8021   \}\par
 8022   if (formatCode.length() < 2)\par
 8023   \{\par
 8024     mNumberBeautifulPowers = false;\par
 8025     mAxisPainter->numberMultiplyCross = false;\par
 8026     return;\par
 8027   \}\par
 8028   \par
 8029   // interpret second char as indicator for beautiful decimal powers:\par
 8030   if (formatCode.at(1) == QLatin1Char('b') && (mNumberFormatChar == QLatin1Char('e') || mNumberFormatChar == QLatin1Char('g')))\par
 8031   \{\par
 8032     mNumberBeautifulPowers = true;\par
 8033   \} else\par
 8034   \{\par
 8035     qDebug() << Q_FUNC_INFO << "Invalid number format code (second char not 'b' or first char neither 'e' nor 'g'):" << formatCode;\par
 8036     return;\par
 8037   \}\par
 8038   if (formatCode.length() < 3)\par
 8039   \{\par
 8040     mAxisPainter->numberMultiplyCross = false;\par
 8041     return;\par
 8042   \}\par
 8043   \par
 8044   // interpret third char as indicator for dot or cross multiplication symbol:\par
 8045   if (formatCode.at(2) == QLatin1Char('c'))\par
 8046   \{\par
 8047     mAxisPainter->numberMultiplyCross = true;\par
 8048   \} else if (formatCode.at(2) == QLatin1Char('d'))\par
 8049   \{\par
 8050     mAxisPainter->numberMultiplyCross = false;\par
 8051   \} else\par
 8052   \{\par
 8053     qDebug() << Q_FUNC_INFO << "Invalid number format code (third char neither 'c' nor 'd'):" << formatCode;\par
 8054     return;\par
 8055   \}\par
 8056 \}\par
}
}
{\xe \v setNumberPrecision\:QCPAxis}
{\xe \v QCPAxis\:setNumberPrecision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setNumberPrecision (int  {\i precision})}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the precision of the tick label numbers. See QLocale::toString(double i, char f, int prec) for details. The effect of precisions are most notably for number Formats starting with 'e', see {\b setNumberFormat} \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8064 \{\par
 8065   if (mNumberPrecision != precision)\par
 8066   \{\par
 8067     mNumberPrecision = precision;\par
 8068     mCachedMarginValid = false;\par
 8069   \}\par
 8070 \}\par
}
}
{\xe \v setOffset\:QCPAxis}
{\xe \v QCPAxis\:setOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setOffset (int  {\i offset})}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the offset the axis has to its axis rect side.\par
If an axis rect side has multiple axes and automatic margin calculation is enabled for that side, only the offset of the inner most axis has meaning (even if it is set to be invisible). The offset of the other, outer axes is controlled automatically, to place them at appropriate positions. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8285 \{\par
 8286   mAxisPainter->offset = offset;\par
 8287 \}\par
}
}
{\xe \v setPadding\:QCPAxis}
{\xe \v QCPAxis\:setPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setPadding (int  {\i padding})}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the padding of the axis.\par
When {\b QCPAxisRect::setAutoMargins} is enabled, the padding is the additional outer most space, that is left blank.\par
The axis padding has no meaning if {\b QCPAxisRect::setAutoMargins} is disabled.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelPadding}, {\b setTickLabelPadding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8268 \{\par
 8269   if (mPadding != padding)\par
 8270   \{\par
 8271     mPadding = padding;\par
 8272     mCachedMarginValid = false;\par
 8273   \}\par
 8274 \}\par
}
}
{\xe \v setParentLayerable\:QCPAxis}
{\xe \v QCPAxis\:setParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setParentLayerable ({\b QCPLayerable} *  {\i parentLayerable}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1523 \{\par
 1524   mParentLayerable = parentLayerable;\par
 1525 \}\par
}
}
{\xe \v setRange\:QCPAxis}
{\xe \v QCPAxis\:setRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRange (const {\b QCPRange} &  {\i range})}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the range of the axis.\par
This slot may be connected with the {\b rangeChanged} signal of another axis so this axis is always synchronized with the other axis range, when it changes.\par
To invert the direction of an axis, use {\b setRangeReversed}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7684 \{\par
 7685   if (range.lower == mRange.lower && range.upper == mRange.upper)\par
 7686     return;\par
 7687   \par
 7688   if (!QCPRange::validRange(range)) return;\par
 7689   QCPRange oldRange = mRange;\par
 7690   if (mScaleType == stLogarithmic)\par
 7691   \{\par
 7692     mRange = range.sanitizedForLogScale();\par
 7693   \} else\par
 7694   \{\par
 7695     mRange = range.sanitizedForLinScale();\par
 7696   \}\par
 7697   emit rangeChanged(mRange);\par
 7698   emit rangeChanged(mRange, oldRange);\par
 7699 \}\par
}
}
{\xe \v setRange\:QCPAxis}
{\xe \v QCPAxis\:setRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRange (double  {\i lower}, double  {\i upper})}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Sets the lower and upper bound of the axis range.\par
To invert the direction of an axis, use {\b setRangeReversed}.\par
There is also a slot to set a range, see {\b setRange(const QCPRange &range)}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7754 \{\par
 7755   if (lower == mRange.lower && upper == mRange.upper)\par
 7756     return;\par
 7757   \par
 7758   if (!QCPRange::validRange(lower, upper)) return;\par
 7759   QCPRange oldRange = mRange;\par
 7760   mRange.lower = lower;\par
 7761   mRange.upper = upper;\par
 7762   if (mScaleType == stLogarithmic)\par
 7763   \{\par
 7764     mRange = mRange.sanitizedForLogScale();\par
 7765   \} else\par
 7766   \{\par
 7767     mRange = mRange.sanitizedForLinScale();\par
 7768   \}\par
 7769   emit rangeChanged(mRange);\par
 7770   emit rangeChanged(mRange, oldRange);\par
 7771 \}\par
}
}
{\xe \v setRange\:QCPAxis}
{\xe \v QCPAxis\:setRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRange (double  {\i position}, double  {\i size}, Qt::AlignmentFlag  {\i alignment})}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Sets the range of the axis.\par
The {\i position}  coordinate indicates together with the {\i alignment}  parameter, where the new range will be positioned. {\i size}  defines the size of the new axis range. {\i alignment}  may be Qt::AlignLeft, Qt::AlignRight or Qt::AlignCenter. This will cause the left border, right border, or center of the range to be aligned with {\i position} . Any other values of {\i alignment}  will default to Qt::AlignCenter. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7785 \{\par
 7786   if (alignment == Qt::AlignLeft)\par
 7787     setRange(position, position+size);\par
 7788   else if (alignment == Qt::AlignRight)\par
 7789     setRange(position-size, position);\par
 7790   else // alignment == Qt::AlignCenter\par
 7791     setRange(position-size/2.0, position+size/2.0);\par
 7792 \}\par
}
}
{\xe \v setRangeLower\:QCPAxis}
{\xe \v QCPAxis\:setRangeLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRangeLower (double  {\i lower})}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the lower bound of the axis range. The upper bound is not changed. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7799 \{\par
 7800   if (mRange.lower == lower)\par
 7801     return;\par
 7802   \par
 7803   QCPRange oldRange = mRange;\par
 7804   mRange.lower = lower;\par
 7805   if (mScaleType == stLogarithmic)\par
 7806   \{\par
 7807     mRange = mRange.sanitizedForLogScale();\par
 7808   \} else\par
 7809   \{\par
 7810     mRange = mRange.sanitizedForLinScale();\par
 7811   \}\par
 7812   emit rangeChanged(mRange);\par
 7813   emit rangeChanged(mRange, oldRange);\par
 7814 \}\par
}
}
{\xe \v setRangeReversed\:QCPAxis}
{\xe \v QCPAxis\:setRangeReversed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRangeReversed (bool  {\i reversed})}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the axis range (direction) is displayed reversed. Normally, the values on horizontal axes increase left to right, on vertical axes bottom to top. When {\i reversed}  is set to true, the direction of increasing values is inverted.\par
Note that the range and data interface stays the same for reversed axes, e.g. the {\i lower}  part of the {\b setRange} interface will still reference the mathematically smaller number than the {\i upper}  part. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7848 \{\par
 7849   mRangeReversed = reversed;\par
 7850 \}\par
}
}
{\xe \v setRangeUpper\:QCPAxis}
{\xe \v QCPAxis\:setRangeUpper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setRangeUpper (double  {\i upper})}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the upper bound of the axis range. The lower bound is not changed. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setRange} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7821 \{\par
 7822   if (mRange.upper == upper)\par
 7823     return;\par
 7824   \par
 7825   QCPRange oldRange = mRange;\par
 7826   mRange.upper = upper;\par
 7827   if (mScaleType == stLogarithmic)\par
 7828   \{\par
 7829     mRange = mRange.sanitizedForLogScale();\par
 7830   \} else\par
 7831   \{\par
 7832     mRange = mRange.sanitizedForLinScale();\par
 7833   \}\par
 7834   emit rangeChanged(mRange);\par
 7835   emit rangeChanged(mRange, oldRange);\par
 7836 \}\par
}
}
{\xe \v setScaleRatio\:QCPAxis}
{\xe \v QCPAxis\:setScaleRatio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setScaleRatio (const {\b QCPAxis} *  {\i otherAxis}, double  {\i ratio} = {\f2 1.0})}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scales the range of this axis to have a certain scale {\i ratio}  to {\i otherAxis} . The scaling will be done around the center of the current axis range.\par
For example, if {\i ratio}  is 1, this axis is the {\i yAxis}  and {\i otherAxis}  is {\i xAxis} , graphs plotted with those axes will appear in a 1:1 aspect ratio, independent of the aspect ratio the axis rect has.\par
This is an operation that changes the range of this axis once, it doesn't fix the scale ratio indefinitely. Note that calling this function in the constructor of the {\b QCustomPlot}'s parent won't have the desired effect, since the widget dimensions aren't defined yet, and a resizeEvent will follow. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8483 \{\par
 8484   int otherPixelSize, ownPixelSize;\par
 8485   \par
 8486   if (otherAxis->orientation() == Qt::Horizontal)\par
 8487     otherPixelSize = otherAxis->axisRect()->width();\par
 8488   else\par
 8489     otherPixelSize = otherAxis->axisRect()->height();\par
 8490   \par
 8491   if (orientation() == Qt::Horizontal)\par
 8492     ownPixelSize = axisRect()->width();\par
 8493   else\par
 8494     ownPixelSize = axisRect()->height();\par
 8495   \par
 8496   double newRangeSize = ratio*otherAxis->range().size()*ownPixelSize/(double)otherPixelSize;\par
 8497   setRange(range().center(), newRangeSize, Qt::AlignCenter);\par
 8498 \}\par
}
}
{\xe \v setScaleType\:QCPAxis}
{\xe \v QCPAxis\:setScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setScaleType ({\b QCPAxis::ScaleType}  {\i type})}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the axis uses a linear scale or a logarithmic scale.\par
Note that this method controls the coordinate transformation. You will likely also want to use a logarithmic tick spacing and labeling, which can be achieved by setting an instance of {\b QCPAxisTickerLog} via {\b setTicker}. See the documentation of {\b QCPAxisTickerLog} about the details of logarithmic axis tick creation.\par
{\b setNumberPrecision} \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7664 \{\par
 7665   if (mScaleType != type)\par
 7666   \{\par
 7667     mScaleType = type;\par
 7668     if (mScaleType == stLogarithmic)\par
 7669       setRange(mRange.sanitizedForLogScale());\par
 7670     mCachedMarginValid = false;\par
 7671     emit scaleTypeChanged(mScaleType);\par
 7672   \}\par
 7673 \}\par
}
}
{\xe \v setSelectableParts\:QCPAxis}
{\xe \v QCPAxis\:setSelectableParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectableParts (const QCPAxis::SelectableParts &  {\i selectableParts})}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the user can (de-)select the parts in {\i selectable}  by clicking on the {\b QCustomPlot} surface. (When {\b QCustomPlot::setInteractions} contains iSelectAxes.)\par
However, even when {\i selectable}  is set to a value not allowing the selection of a specific part, it is still possible to set the selection of this part manually, by calling {\b setSelectedParts} directly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SelectablePart}, {\b setSelectedParts} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7712 \{\par
 7713   if (mSelectableParts != selectable)\par
 7714   \{\par
 7715     mSelectableParts = selectable;\par
 7716     emit selectableChanged(mSelectableParts);\par
 7717   \}\par
 7718 \}\par
}
}
{\xe \v setSelectedBasePen\:QCPAxis}
{\xe \v QCPAxis\:setSelectedBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedBasePen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that is used to draw the axis base line when selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBasePen}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8343 \{\par
 8344   mSelectedBasePen = pen;\par
 8345 \}\par
}
}
{\xe \v setSelectedLabelColor\:QCPAxis}
{\xe \v QCPAxis\:setSelectedLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedLabelColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color that is used for the axis label when it is selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelColor}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8333 \{\par
 8334   mSelectedLabelColor = color;\par
 8335 \}\par
}
}
{\xe \v setSelectedLabelFont\:QCPAxis}
{\xe \v QCPAxis\:setSelectedLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedLabelFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font that is used for the axis label when it is selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelFont}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8309 \{\par
 8310   mSelectedLabelFont = font;\par
 8311   // don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts\par
 8312 \}\par
}
}
{\xe \v setSelectedParts\:QCPAxis}
{\xe \v QCPAxis\:setSelectedParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedParts (const QCPAxis::SelectableParts &  {\i selectedParts})}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the selected state of the respective axis parts described by {\b SelectablePart}. When a part is selected, it uses a different pen/font.\par
The entire selection mechanism for axes is handled automatically when {\b QCustomPlot::setInteractions} contains iSelectAxes. You only need to call this function when you wish to change the selection state manually.\par
This function can change the selection state of a part, independent of the {\b setSelectableParts} setting.\par
emits the {\b selectionChanged} signal when {\i selected}  is different from the previous selection state.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SelectablePart}, {\b setSelectableParts}, {\b selectTest}, {\b setSelectedBasePen}, {\b setSelectedTickPen}, {\b setSelectedSubTickPen}, {\b setSelectedTickLabelFont}, {\b setSelectedLabelFont}, {\b setSelectedTickLabelColor}, {\b setSelectedLabelColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7736 \{\par
 7737   if (mSelectedParts != selected)\par
 7738   \{\par
 7739     mSelectedParts = selected;\par
 7740     emit selectionChanged(mSelectedParts);\par
 7741   \}\par
 7742 \}\par
}
}
{\xe \v setSelectedSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:setSelectedSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedSubTickPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that is used to draw the subticks when selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTickPen}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8363 \{\par
 8364   mSelectedSubTickPen = pen;\par
 8365 \}\par
}
}
{\xe \v setSelectedTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:setSelectedTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedTickLabelColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color that is used for tick labels when they are selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabelColor}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8320 \{\par
 8321   if (color != mSelectedTickLabelColor)\par
 8322   \{\par
 8323     mSelectedTickLabelColor = color;\par
 8324   \}\par
 8325 \}\par
}
}
{\xe \v setSelectedTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:setSelectedTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedTickLabelFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font that is used for tick labels when they are selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabelFont}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8295 \{\par
 8296   if (font != mSelectedTickLabelFont)\par
 8297   \{\par
 8298     mSelectedTickLabelFont = font;\par
 8299     // don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts\par
 8300   \}\par
 8301 \}\par
}
}
{\xe \v setSelectedTickPen\:QCPAxis}
{\xe \v QCPAxis\:setSelectedTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSelectedTickPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen that is used to draw the (major) ticks when selected.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickPen}, {\b setSelectableParts}, {\b setSelectedParts}, {\b QCustomPlot::setInteractions} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8353 \{\par
 8354   mSelectedTickPen = pen;\par
 8355 \}\par
}
}
{\xe \v setSubTickLength\:QCPAxis}
{\xe \v QCPAxis\:setSubTickLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTickLength (int  {\i inside}, int  {\i outside} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the subticks in pixels. {\i inside}  is the length the subticks will reach inside the plot and {\i outside}  is the length they will reach outside the plot. If {\i outside}  is greater than zero, the tick labels and axis label will increase their distance to the axis accordingly, so they won't collide with the ticks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLength}, {\b setSubTickLengthIn}, {\b setSubTickLengthOut} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8141 \{\par
 8142   setSubTickLengthIn(inside);\par
 8143   setSubTickLengthOut(outside);\par
 8144 \}\par
}
}
{\xe \v setSubTickLengthIn\:QCPAxis}
{\xe \v QCPAxis\:setSubTickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTickLengthIn (int  {\i inside})}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the inward subticks in pixels. {\i inside}  is the length the subticks will reach inside the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTickLengthOut}, {\b setSubTickLength}, {\b setTickLength} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8153 \{\par
 8154   if (mAxisPainter->subTickLengthIn != inside)\par
 8155   \{\par
 8156     mAxisPainter->subTickLengthIn = inside;\par
 8157   \}\par
 8158 \}\par
}
}
{\xe \v setSubTickLengthOut\:QCPAxis}
{\xe \v QCPAxis\:setSubTickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTickLengthOut (int  {\i outside})}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the outward subticks in pixels. {\i outside}  is the length the subticks will reach outside the plot. If {\i outside}  is greater than zero, the tick labels will increase their distance to the axis accordingly, so they won't collide with the ticks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTickLengthIn}, {\b setSubTickLength}, {\b setTickLength} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8168 \{\par
 8169   if (mAxisPainter->subTickLengthOut != outside)\par
 8170   \{\par
 8171     mAxisPainter->subTickLengthOut = outside;\par
 8172     mCachedMarginValid = false; // only outside tick length can change margin\par
 8173   \}\par
 8174 \}\par
}
}
{\xe \v setSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:setSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTickPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen, subtick marks will be drawn with.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid setSubTickCount, {\b setSubTickLength}, {\b setBasePen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8202 \{\par
 8203   mSubTickPen = pen;\par
 8204 \}\par
}
}
{\xe \v setSubTicks\:QCPAxis}
{\xe \v QCPAxis\:setSubTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setSubTicks (bool  {\i show})}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether sub tick marks are displayed.\par
Sub ticks are only potentially visible if (major) ticks are also visible (see {\b setTicks})\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTicks} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8124 \{\par
 8125   if (mSubTicks != show)\par
 8126   \{\par
 8127     mSubTicks = show;\par
 8128     mCachedMarginValid = false;\par
 8129   \}\par
 8130 \}\par
}
}
{\xe \v setTicker\:QCPAxis}
{\xe \v QCPAxis\:setTicker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTicker (QSharedPointer< {\b QCPAxisTicker} >  {\i ticker})}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The axis ticker is responsible for generating the tick positions and tick labels. See the documentation of {\b QCPAxisTicker} for details on how to work with axis tickers.\par
You can change the tick positioning/labeling behaviour of this axis by setting a different {\b QCPAxisTicker} subclass using this method. If you only wish to modify the currently installed axis ticker, access it via {\b ticker}.\par
Since the ticker is stored in the axis as a shared pointer, multiple axes may share the same axis ticker simply by passing the same shared pointer to multiple axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b ticker} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7866 \{\par
 7867   if (ticker)\par
 7868     mTicker = ticker;\par
 7869   else\par
 7870     qDebug() << Q_FUNC_INFO << "can not set 0 as axis ticker";\par
 7871   // no need to invalidate margin cache here because produced tick labels are checked for changes in setupTickVector\par
 7872 \}\par
}
}
{\xe \v setTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelColor (const QColor &  {\i color})}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the color of the tick labels.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabels}, {\b setTickLabelFont} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7938 \{\par
 7939   mTickLabelColor = color;\par
 7940 \}\par
}
}
{\xe \v setTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelFont (const QFont &  {\i font})}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the font of the tick labels.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLabels}, {\b setTickLabelColor} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7924 \{\par
 7925   if (font != mTickLabelFont)\par
 7926   \{\par
 7927     mTickLabelFont = font;\par
 7928     mCachedMarginValid = false;\par
 7929   \}\par
 7930 \}\par
}
}
{\xe \v setTickLabelPadding\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelPadding (int  {\i padding})}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the distance between the axis base line (including any outward ticks) and the tick labels. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLabelPadding}, {\b setPadding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7910 \{\par
 7911   if (mAxisPainter->tickLabelPadding != padding)\par
 7912   \{\par
 7913     mAxisPainter->tickLabelPadding = padding;\par
 7914     mCachedMarginValid = false;\par
 7915   \}\par
 7916 \}\par
}
}
{\xe \v setTickLabelRotation\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelRotation (double  {\i degrees})}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the rotation of the tick labels. If {\i degrees}  is zero, the labels are drawn normally. Else, the tick labels are drawn rotated by {\i degrees}  clockwise. The specified angle is bound to values from -90 to 90 degrees.\par
If {\i degrees}  is exactly -90, 0 or 90, the tick labels are centered on the tick coordinate. For other angles, the label is drawn with an offset such that it seems to point toward or away from the tick mark. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7952 \{\par
 7953   if (!qFuzzyIsNull(degrees-mAxisPainter->tickLabelRotation))\par
 7954   \{\par
 7955     mAxisPainter->tickLabelRotation = qBound(-90.0, degrees, 90.0);\par
 7956     mCachedMarginValid = false;\par
 7957   \}\par
 7958 \}\par
}
}
{\xe \v setTickLabels\:QCPAxis}
{\xe \v QCPAxis\:setTickLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabels (bool  {\i show})}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether tick labels are displayed. Tick labels are the numbers drawn next to tick marks. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7895 \{\par
 7896   if (mTickLabels != show)\par
 7897   \{\par
 7898     mTickLabels = show;\par
 7899     mCachedMarginValid = false;\par
 7900     if (!mTickLabels)\par
 7901       mTickVectorLabels.clear();\par
 7902   \}\par
 7903 \}\par
}
}
{\xe \v setTickLabelSide\:QCPAxis}
{\xe \v QCPAxis\:setTickLabelSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLabelSide ({\b LabelSide}  {\i side})}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the tick labels (numbers) shall appear inside or outside the axis rect.\par
The usual and default setting is {\b lsOutside}. Very compact plots sometimes require tick labels to be inside the axis rect, to save space. If {\i side}  is set to {\b lsInside}, the tick labels appear on the inside are additionally clipped to the axis rect. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7968 \{\par
 7969   mAxisPainter->tickLabelSide = side;\par
 7970   mCachedMarginValid = false;\par
 7971 \}\par
}
}
{\xe \v setTickLength\:QCPAxis}
{\xe \v QCPAxis\:setTickLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLength (int  {\i inside}, int  {\i outside} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the ticks in pixels. {\i inside}  is the length the ticks will reach inside the plot and {\i outside}  is the length they will reach outside the plot. If {\i outside}  is greater than zero, the tick labels and axis label will increase their distance to the axis accordingly, so they won't collide with the ticks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTickLength}, {\b setTickLengthIn}, {\b setTickLengthOut} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8081 \{\par
 8082   setTickLengthIn(inside);\par
 8083   setTickLengthOut(outside);\par
 8084 \}\par
}
}
{\xe \v setTickLengthIn\:QCPAxis}
{\xe \v QCPAxis\:setTickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLengthIn (int  {\i inside})}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the inward ticks in pixels. {\i inside}  is the length the ticks will reach inside the plot.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLengthOut}, {\b setTickLength}, {\b setSubTickLength} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8093 \{\par
 8094   if (mAxisPainter->tickLengthIn != inside)\par
 8095   \{\par
 8096     mAxisPainter->tickLengthIn = inside;\par
 8097   \}\par
 8098 \}\par
}
}
{\xe \v setTickLengthOut\:QCPAxis}
{\xe \v QCPAxis\:setTickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickLengthOut (int  {\i outside})}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the length of the outward ticks in pixels. {\i outside}  is the length the ticks will reach outside the plot. If {\i outside}  is greater than zero, the tick labels and axis label will increase their distance to the axis accordingly, so they won't collide with the ticks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLengthIn}, {\b setTickLength}, {\b setSubTickLength} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8108 \{\par
 8109   if (mAxisPainter->tickLengthOut != outside)\par
 8110   \{\par
 8111     mAxisPainter->tickLengthOut = outside;\par
 8112     mCachedMarginValid = false; // only outside tick length can change margin\par
 8113   \}\par
 8114 \}\par
}
}
{\xe \v setTickPen\:QCPAxis}
{\xe \v QCPAxis\:setTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTickPen (const QPen &  {\i pen})}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the pen, tick marks will be drawn with.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTickLength}, {\b setBasePen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8192 \{\par
 8193   mTickPen = pen;\par
 8194 \}\par
}
}
{\xe \v setTicks\:QCPAxis}
{\xe \v QCPAxis\:setTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setTicks (bool  {\i show})}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether tick marks are displayed.\par
Note that setting {\i show}  to false does not imply that tick labels are invisible, too. To achieve that, see {\b setTickLabels}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSubTicks} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7883 \{\par
 7884   if (mTicks != show)\par
 7885   \{\par
 7886     mTicks = show;\par
 7887     mCachedMarginValid = false;\par
 7888   \}\par
 7889 \}\par
}
}
{\xe \v setUpperEnding\:QCPAxis}
{\xe \v QCPAxis\:setUpperEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setUpperEnding (const {\b QCPLineEnding} &  {\i ending})}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the style for the upper axis ending. See the documentation of {\b QCPLineEnding} for available styles.\par
For horizontal axes, this method refers to the right ending, for vertical axes the top ending. Note that this meaning does not change when the axis range is reversed with {\b setRangeReversed}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLowerEnding} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8393 \{\par
 8394   mAxisPainter->upperEnding = ending;\par
 8395 \}\par
}
}
{\xe \v setupTickVectors\:QCPAxis}
{\xe \v QCPAxis\:setupTickVectors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::setupTickVectors (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9013 \{\par
 9014   if (!mParentPlot) return;\par
 9015   if ((!mTicks && !mTickLabels && !mGrid->visible()) || mRange.size() <= 0) return;\par
 9016   \par
 9017   QVector<QString> oldLabels = mTickVectorLabels;\par
 9018   mTicker->generate(mRange, mParentPlot->locale(), mNumberFormatChar, mNumberPrecision, mTickVector, mSubTicks ? &mSubTickVector : 0, mTickLabels ? &mTickVectorLabels : 0);\par
 9019   mCachedMarginValid &= mTickVectorLabels == oldLabels; // if labels have changed, margin might have changed, too\par
 9020 \}\par
}
}
{\xe \v setVisible\:QCPAxis}
{\xe \v QCPAxis\:setVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setVisible (bool  {\i on}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the {\b QCustomPlot} surface, and user interaction with it (e.g. click and selection) is not possible. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1371 \{\par
 1372   mVisible = on;\par
 1373 \}\par
}
}
{\xe \v subTickLengthIn\:QCPAxis}
{\xe \v QCPAxis\:subTickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::subTickLengthIn () const}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7619 \{\par
 7620   return mAxisPainter->subTickLengthIn;\par
 7621 \}\par
}
}
{\xe \v subTickLengthOut\:QCPAxis}
{\xe \v QCPAxis\:subTickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::subTickLengthOut () const}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7625 \{\par
 7626   return mAxisPainter->subTickLengthOut;\par
 7627 \}\par
}
}
{\xe \v subTickPen\:QCPAxis}
{\xe \v QCPAxis\:subTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::subTickPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2030 \{ return mSubTickPen; \}\par
}
}
{\xe \v subTicks\:QCPAxis}
{\xe \v QCPAxis\:subTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::subTicks () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2025 \{ return mSubTicks; \}\par
}
}
{\xe \v ticker\:QCPAxis}
{\xe \v QCPAxis\:ticker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer< {\b QCPAxisTicker} > QCPAxis::ticker () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a modifiable shared pointer to the currently installed axis ticker. The axis ticker is responsible for generating the tick positions and tick labels of this axis. You can access the {\b QCPAxisTicker} with this method and modify basic properties such as the approximate tick count ({\b QCPAxisTicker::setTickCount}).\par
You can gain more control over the axis ticks by setting a different {\b QCPAxisTicker} subclass, see the documentation there. A new axis ticker can be set with {\b setTicker}.\par
Since the ticker is stored in the axis as a shared pointer, multiple axes may share the same axis ticker simply by passing the same shared pointer to multiple axes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setTicker} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2011 \{ return mTicker; \}\par
}
}
{\xe \v tickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:tickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::tickLabelColor () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2016 \{ return mTickLabelColor; \}\par
}
}
{\xe \v tickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:tickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::tickLabelFont () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2015 \{ return mTickLabelFont; \}\par
}
}
{\xe \v tickLabelPadding\:QCPAxis}
{\xe \v QCPAxis\:tickLabelPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::tickLabelPadding () const}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7575 \{\par
 7576   return mAxisPainter->tickLabelPadding;\par
 7577 \}\par
}
}
{\xe \v tickLabelRotation\:QCPAxis}
{\xe \v QCPAxis\:tickLabelRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPAxis::tickLabelRotation () const}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7581 \{\par
 7582   return mAxisPainter->tickLabelRotation;\par
 7583 \}\par
}
}
{\xe \v tickLabels\:QCPAxis}
{\xe \v QCPAxis\:tickLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::tickLabels () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2013 \{ return mTickLabels; \}\par
}
}
{\xe \v tickLabelSide\:QCPAxis}
{\xe \v QCPAxis\:tickLabelSide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis::LabelSide} QCPAxis::tickLabelSide () const}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7587 \{\par
 7588   return mAxisPainter->tickLabelSide;\par
 7589 \}\par
}
}
{\xe \v tickLengthIn\:QCPAxis}
{\xe \v QCPAxis\:tickLengthIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::tickLengthIn () const}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7607 \{\par
 7608   return mAxisPainter->tickLengthIn;\par
 7609 \}\par
}
}
{\xe \v tickLengthOut\:QCPAxis}
{\xe \v QCPAxis\:tickLengthOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::tickLengthOut () const}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7613 \{\par
 7614   return mAxisPainter->tickLengthOut;\par
 7615 \}\par
}
}
{\xe \v tickPen\:QCPAxis}
{\xe \v QCPAxis\:tickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::tickPen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2029 \{ return mTickPen; \}\par
}
}
{\xe \v ticks\:QCPAxis}
{\xe \v QCPAxis\:ticks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::ticks () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2012 \{ return mTicks; \}\par
}
}
{\xe \v tickVector\:QCPAxis}
{\xe \v QCPAxis\:tickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<double> QCPAxis::tickVector () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2021 \{ return mTickVector; \}\par
}
}
{\xe \v tickVectorLabels\:QCPAxis}
{\xe \v QCPAxis\:tickVectorLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<QString> QCPAxis::tickVectorLabels () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2022 \{ return mTickVectorLabels; \}\par
}
}
{\xe \v upperEnding\:QCPAxis}
{\xe \v QCPAxis\:upperEnding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLineEnding} QCPAxis::upperEnding () const}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7649 \{\par
 7650   return mAxisPainter->upperEnding;\par
 7651 \}\par
}
}
{\xe \v visible\:QCPAxis}
{\xe \v QCPAxis\:visible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::visible () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   707 \{ return mVisible; \}\par
}
}
{\xe \v wheelEvent\:QCPAxis}
{\xe \v QCPAxis\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAxis::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} .\par
The {\f2 event->delta()}  indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making {\f2 event->delta()}  larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent} \par
}}{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8914 \{\par
 8915   // Mouse range zooming interaction:\par
 8916   if (!mParentPlot->interactions().testFlag(QCP::iRangeZoom) ||\par
 8917       !mAxisRect->rangeZoom().testFlag(orientation()) ||\par
 8918       !mAxisRect->rangeZoomAxes(orientation()).contains(this))\par
 8919   \{\par
 8920     event->ignore();\par
 8921     return;\par
 8922   \}\par
 8923   \par
 8924   const double wheelSteps = event->delta()/120.0; // a single step delta is +/-120 usually\par
 8925   const double factor = qPow(mAxisRect->rangeZoomFactor(orientation()), wheelSteps);\par
 8926   scaleRange(factor, pixelToCoord(orientation() == Qt::Horizontal ? event->pos().x() : event->pos().y()));\par
 8927   mParentPlot->replot();\par
 8928 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas e Funções Relacionadas\par
\pard\plain 
{\xe \v QCPAxisRect\:QCPAxis}
{\xe \v QCPAxis\:QCPAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPAxisRect}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCPGrid\:QCPAxis}
{\xe \v QCPAxis\:QCPGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPGrid}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPAxis}
{\xe \v QCPAxis\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mAADragBackup\:QCPAxis}
{\xe \v QCPAxis\:mAADragBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCPAxis::mAADragBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAntialiased\:QCPAxis}
{\xe \v QCPAxis\:mAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mAntialiased{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAxisPainter\:QCPAxis}
{\xe \v QCPAxis\:mAxisPainter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisPainterPrivate}* QCPAxis::mAxisPainter{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAxisRect\:QCPAxis}
{\xe \v QCPAxis\:mAxisRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxisRect}* QCPAxis::mAxisRect{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAxisType\:QCPAxis}
{\xe \v QCPAxis\:mAxisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AxisType} QCPAxis::mAxisType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBasePen\:QCPAxis}
{\xe \v QCPAxis\:mBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mBasePen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mCachedMargin\:QCPAxis}
{\xe \v QCPAxis\:mCachedMargin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::mCachedMargin{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mCachedMarginValid\:QCPAxis}
{\xe \v QCPAxis\:mCachedMarginValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mCachedMarginValid{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragging\:QCPAxis}
{\xe \v QCPAxis\:mDragging}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mDragging{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDragStartRange\:QCPAxis}
{\xe \v QCPAxis\:mDragStartRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPAxis::mDragStartRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mGrid\:QCPAxis}
{\xe \v QCPAxis\:mGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGrid}* QCPAxis::mGrid{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLabel\:QCPAxis}
{\xe \v QCPAxis\:mLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAxis::mLabel{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLabelColor\:QCPAxis}
{\xe \v QCPAxis\:mLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::mLabelColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLabelFont\:QCPAxis}
{\xe \v QCPAxis\:mLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::mLabelFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLayer\:QCPAxis}
{\xe \v QCPAxis\:mLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::mLayer{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNotAADragBackup\:QCPAxis}
{\xe \v QCPAxis\:mNotAADragBackup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCP::AntialiasedElements QCPAxis::mNotAADragBackup{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNumberBeautifulPowers\:QCPAxis}
{\xe \v QCPAxis\:mNumberBeautifulPowers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mNumberBeautifulPowers{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNumberFormatChar\:QCPAxis}
{\xe \v QCPAxis\:mNumberFormatChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLatin1Char QCPAxis::mNumberFormatChar{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mNumberPrecision\:QCPAxis}
{\xe \v QCPAxis\:mNumberPrecision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::mNumberPrecision{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mOrientation\:QCPAxis}
{\xe \v QCPAxis\:mOrientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::Orientation QCPAxis::mOrientation{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPadding\:QCPAxis}
{\xe \v QCPAxis\:mPadding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPAxis::mPadding{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentLayerable\:QCPAxis}
{\xe \v QCPAxis\:mParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPLayerable}> QCPLayerable::mParentLayerable{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPAxis}
{\xe \v QCPAxis\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::mParentPlot{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRange\:QCPAxis}
{\xe \v QCPAxis\:mRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPAxis::mRange{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mRangeReversed\:QCPAxis}
{\xe \v QCPAxis\:mRangeReversed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mRangeReversed{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScaleType\:QCPAxis}
{\xe \v QCPAxis\:mScaleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ScaleType} QCPAxis::mScaleType{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectableParts\:QCPAxis}
{\xe \v QCPAxis\:mSelectableParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPAxis::mSelectableParts{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedBasePen\:QCPAxis}
{\xe \v QCPAxis\:mSelectedBasePen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mSelectedBasePen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedLabelColor\:QCPAxis}
{\xe \v QCPAxis\:mSelectedLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::mSelectedLabelColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedLabelFont\:QCPAxis}
{\xe \v QCPAxis\:mSelectedLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::mSelectedLabelFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedParts\:QCPAxis}
{\xe \v QCPAxis\:mSelectedParts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SelectableParts QCPAxis::mSelectedParts{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:mSelectedSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mSelectedSubTickPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:mSelectedTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::mSelectedTickLabelColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:mSelectedTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::mSelectedTickLabelFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectedTickPen\:QCPAxis}
{\xe \v QCPAxis\:mSelectedTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mSelectedTickPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSubTickPen\:QCPAxis}
{\xe \v QCPAxis\:mSubTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mSubTickPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSubTicks\:QCPAxis}
{\xe \v QCPAxis\:mSubTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mSubTicks{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSubTickVector\:QCPAxis}
{\xe \v QCPAxis\:mSubTickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<double> QCPAxis::mSubTickVector{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTicker\:QCPAxis}
{\xe \v QCPAxis\:mTicker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer<{\b QCPAxisTicker}> QCPAxis::mTicker{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickLabelColor\:QCPAxis}
{\xe \v QCPAxis\:mTickLabelColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QColor QCPAxis::mTickLabelColor{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickLabelFont\:QCPAxis}
{\xe \v QCPAxis\:mTickLabelFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QFont QCPAxis::mTickLabelFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickLabels\:QCPAxis}
{\xe \v QCPAxis\:mTickLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mTickLabels{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickPen\:QCPAxis}
{\xe \v QCPAxis\:mTickPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAxis::mTickPen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTicks\:QCPAxis}
{\xe \v QCPAxis\:mTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAxis::mTicks{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickVector\:QCPAxis}
{\xe \v QCPAxis\:mTickVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<double> QCPAxis::mTickVector{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mTickVectorLabels\:QCPAxis}
{\xe \v QCPAxis\:mTickVectorLabels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector<QString> QCPAxis::mTickVectorLabels{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mVisible\:QCPAxis}
{\xe \v QCPAxis\:mVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mVisible{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documentação para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}}