{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência da Classe QCPGraph\par \pard\plain 
{\tc\tcl2 \v QCPGraph}
{\xe \v QCPGraph}
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a graph in a plot. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Diagrama de hierarquia para QCPGraph:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classQCPGraph__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LineStyle} \{ {\b lsNone}, 
{\b lsLine}, 
{\b lsStepLeft}, 
{\b lsStepRight}, 
{\b lsStepCenter}, 
{\b lsImpulse}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Sinais\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (bool {\b selected})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (const {\b QCPDataSelection} &{\b selection})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectableChanged} ({\b QCP::SelectionType} {\b selectable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b layerChanged} ({\b QCPLayer} *newLayer)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPGraph} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPGraphDataContainer} > {\b data} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LineStyle} {\b lineStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b scatterStyle} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b scatterSkip} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPGraph} * {\b channelFillGraph} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b adaptiveSampling} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (QSharedPointer< {\b QCPGraphDataContainer} > {\b data})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLineStyle} ({\b LineStyle} ls)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScatterStyle} (const {\b QCPScatterStyle} &style)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScatterSkip} (int skip)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setChannelFillGraph} ({\b QCPGraph} *targetGraph)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAdaptiveSampling} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addData} (double key, double value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b dataCount} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainKey} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataSortKey} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainValue} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b dataValueRange} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b dataPixelPosition} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b sortKeyIsMainKey} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPDataSelection} {\b selectTestRect} (const QRectF &rect, bool onlySelectable) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findBegin} (double sortKey, bool expandedRange=true) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findEnd} (double sortKey, bool expandedRange=true) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPPlottableInterface1D} * {\b interface1D} () {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b name} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiasedFill} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiasedScatters} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b keyAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b valueAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionType} {\b selectable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b selected} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b selection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionDecorator} * {\b selectionDecorator} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (const QString &{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedFill} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedScatters} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setKeyAxis} ({\b QCPAxis} *axis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValueAxis} ({\b QCPAxis} *axis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectable} ({\b QCP::SelectionType} {\b selectable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelection} ({\b QCPDataSelection} {\b selection})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectionDecorator} ({\b QCPSelectionDecorator} *decorator)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b coordsToPixels} (double key, double value, double &x, double &y) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QPointF {\b coordsToPixels} (double key, double value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsToCoords} (double x, double y, double &key, double &value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsToCoords} (const QPointF &pixelPos, double &key, double &value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleAxes} (bool onlyEnlarge=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleKeyAxis} (bool onlyEnlarge=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleValueAxis} (bool onlyEnlarge=false, bool inKeyRange=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addToLegend} ({\b QCPLegend} *legend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addToLegend} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeFromLegend} ({\b QCPLegend} *legend) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeFromLegend} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b visible} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b parentPlot} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayerable} * {\b parentLayerable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b layer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiased} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVisible} (bool on)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT bool {\b setLayer} ({\b QCPLayer} *{\b layer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setLayer} (const QString &layerName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiased} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b realVisibility} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawFill} ({\b QCPPainter} *painter, QVector< QPointF > *lines) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawScatterPlot} ({\b QCPPainter} *painter, const QVector< QPointF > &scatters, const {\b QCPScatterStyle} &style) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLinePlot} ({\b QCPPainter} *painter, const QVector< QPointF > &lines) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawImpulsePlot} ({\b QCPPainter} *painter, const QVector< QPointF > &lines) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getOptimizedLineData} (QVector< {\b QCPGraphData} > *lineData, const {\b QCPGraphDataContainer::const_iterator} &begin, const {\b QCPGraphDataContainer::const_iterator} &end) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getOptimizedScatterData} (QVector< {\b QCPGraphData} > *scatterData, {\b QCPGraphDataContainer::const_iterator} begin, {\b QCPGraphDataContainer::const_iterator} end) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getVisibleDataBounds} ({\b QCPGraphDataContainer::const_iterator} &begin, {\b QCPGraphDataContainer::const_iterator} &end, const {\b QCPDataRange} &rangeRestriction) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getLines} (QVector< QPointF > *lines, const {\b QCPDataRange} &dataRange) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getScatters} (QVector< QPointF > *scatters, const {\b QCPDataRange} &dataRange) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToStepLeftLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToStepRightLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToStepCenterLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPointF > {\b dataToImpulseLines} (const QVector< {\b QCPGraphData} > &{\b data}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< {\b QCPDataRange} > {\b getNonNanSegments} (const QVector< QPointF > *lineData, Qt::Orientation keyOrientation) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVector< QPair< {\b QCPDataRange}, {\b QCPDataRange} > > {\b getOverlappingSegments} (QVector< {\b QCPDataRange} > thisSegments, const QVector< QPointF > *thisData, QVector< {\b QCPDataRange} > otherSegments, const QVector< QPointF > *otherData) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b segmentsIntersect} (double aLower, double aUpper, double bLower, double bUpper, int &bPrecedence) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointF {\b getFillBasePoint} (QPointF matchingDataPoint) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QPolygonF {\b getFillPolygon} (const QVector< QPointF > *lineData, {\b QCPDataRange} segment) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QPolygonF {\b getChannelFillPolygon} (const QVector< QPointF > *lineData, {\b QCPDataRange} thisSegment, const QVector< QPointF > *otherData, {\b QCPDataRange} otherSegment) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIndexBelowX} (const QVector< QPointF > *{\b data}, double x) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIndexAboveX} (const QVector< QPointF > *{\b data}, double x) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIndexBelowY} (const QVector< QPointF > *{\b data}, double y) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIndexAboveY} (const QVector< QPointF > *{\b data}, double y) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b pointDistance} (const QPointF &pixelPoint, {\b QCPGraphDataContainer::const_iterator} &closestData) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getDataSegments} (QList< {\b QCPDataRange} > &selectedSegments, QList< {\b QCPDataRange} > &unselectedSegments) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawPolyline} ({\b QCPPainter} *painter, const QVector< QPointF > &lineData) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QRect {\b clipRect} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyFillAntialiasingHint} ({\b QCPPainter} *painter) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyScattersAntialiasingHint} ({\b QCPPainter} *painter) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parentPlotInitialized} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseDoubleClickEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initializeParentPlot} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setParentLayerable} ({\b QCPLayerable} *{\b parentLayerable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveToLayer} ({\b QCPLayer} *{\b layer}, bool prepend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyAntialiasingHint} ({\b QCPPainter} *painter, bool localAntialiased, {\b QCP::AntialiasedElement} overrideElement) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LineStyle} {\b mLineStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPScatterStyle} {\b mScatterStyle}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mScatterSkip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPGraph} > {\b mChannelFillGraph}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAdaptiveSampling}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPDataContainer}< {\b QCPGraphData} > > {\b mDataContainer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiasedFill}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiasedScatters}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxis} > {\b mKeyAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxis} > {\b mValueAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionType} {\b mSelectable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b mSelection}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionDecorator} * {\b mSelectionDecorator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mVisible}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPLayerable} > {\b mParentLayerable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b mLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiased}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCustomPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b QCPLegend}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A plottable representing a graph in a plot. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
Usually you create new graphs by calling {\b QCustomPlot::addGraph}. The resulting instance can be accessed via {\b QCustomPlot::graph}.\par
To plot data, assign it with the {\b setData} or {\b addData} functions. Alternatively, you can also access and modify the data via the {\b data} method, which returns a pointer to the internal {\b QCPGraphDataContainer}.\par
Graphs are used to display single-valued data. Single-valued means that there should only be one data point per unique key coordinate. In other words, the graph can't have {\i loops} . If you do want to plot non-single-valued curves, rather use the {\b QCPCurve} plottable.\par
Gaps in the graph line can be created by adding data points with NaN as value ({\f2 qQNaN()}  or {\f2 std::numeric_limits<double>::quiet_NaN()} ) in between the two data points that shall be separated.\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Changing the appearance
\par}
{\tc\tcl2 \v Changing the appearance}
The appearance of the graph is mainly determined by the line style, scatter style, brush and pen of the graph ({\b setLineStyle}, {\b setScatterStyle}, {\b setBrush}, {\b setPen}).\par
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Filling under or between graphs
\par}
{\tc\tcl3 \v Filling under or between graphs}
{\b QCPGraph} knows two types of fills: Normal graph fills towards the zero-value-line parallel to the key axis of the graph, and fills between two graphs, called channel fills. To enable a fill, just set a brush with {\b setBrush} which is neither Qt::NoBrush nor fully transparent.\par
By default, a normal fill towards the zero-value-line will be drawn. To set up a channel fill between this graph and another one, call {\b setChannelFillGraph} with the other graph as parameter.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b QCustomPlot::addGraph}, {\b QCustomPlot::graph} \par
}\par}
\par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerações\par
\pard\plain 
{\xe \v LineStyle\:QCPGraph}
{\xe \v QCPGraph\:LineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b QCPGraph::LineStyle}}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines how the graph's line is represented visually in the plot. The line is drawn with the current pen of the graph ({\b setPen}). \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLineStyle} \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v lsNone\:QCPGraph}
{\xe \v QCPGraph\:lsNone}
{\qr lsNone{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data points are not connected with any lines (e.g. data only represented with symbols according to the scatter style, see {\b setScatterStyle}) \par
}\cell }{\row }
{\xe \v lsLine\:QCPGraph}
{\xe \v QCPGraph\:lsLine}
{\qr lsLine{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
data points are connected by a straight line \par
}\cell }{\row }
{\xe \v lsStepLeft\:QCPGraph}
{\xe \v QCPGraph\:lsStepLeft}
{\qr lsStepLeft{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
line is drawn as steps where the step height is the value of the left data point \par
}\cell }{\row }
{\xe \v lsStepRight\:QCPGraph}
{\xe \v QCPGraph\:lsStepRight}
{\qr lsStepRight{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
line is drawn as steps where the step height is the value of the right data point \par
}\cell }{\row }
{\xe \v lsStepCenter\:QCPGraph}
{\xe \v QCPGraph\:lsStepCenter}
{\qr lsStepCenter{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
line is drawn as steps where the step is in between two data points \par
}\cell }{\row }
{\xe \v lsImpulse\:QCPGraph}
{\xe \v QCPGraph\:lsImpulse}
{\qr lsImpulse{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
each data point is represented by a line parallel to the value axis, which reaches from the data point to the zero-value-line \par
}\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5168                  \{ lsNone        \par
 5169                    ,lsLine       \par
 5171                    ,lsStepLeft   \par
 5172                    ,lsStepRight  \par
 5173                    ,lsStepCenter \par
 5174                    ,lsImpulse    \par
 5175                  \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v QCPGraph\:QCPGraph}
{\xe \v QCPGraph\:QCPGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPGraph::QCPGraph ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a graph which uses {\i keyAxis}  as its key axis ("x") and {\i valueAxis}  as its value axis ("y"). {\i keyAxis}  and {\i valueAxis}  must reside in the same {\b QCustomPlot} instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.\par
The created {\b QCPGraph} is automatically registered with the {\b QCustomPlot} instance inferred from {\i keyAxis} . This {\b QCustomPlot} instance takes ownership of the {\b QCPGraph}, so do not delete it manually but use {\b QCustomPlot::removePlottable()} instead.\par
To directly create a graph inside a plot, you can also use the simpler {\b QCustomPlot::addGraph} function. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20060                                                        :\par
20061   QCPAbstractPlottable1D<QCPGraphData>(keyAxis, valueAxis)\par
20062 \{\par
20063   // special handling for QCPGraphs to maintain the simple graph interface:\par
20064   mParentPlot->registerGraph(this);\par
20065 \par
20066   setPen(QPen(Qt::blue, 0));\par
20067   setBrush(Qt::NoBrush);\par
20068   \par
20069   setLineStyle(lsLine);\par
20070   setScatterSkip(0);\par
20071   setChannelFillGraph(0);\par
20072   setAdaptiveSampling(true);\par
20073 \}\par
}
}
{\xe \v ~QCPGraph\:QCPGraph}
{\xe \v QCPGraph\:~QCPGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCPGraph::~QCPGraph (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20076 \{\par
20077 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções membros\par
\pard\plain 
{\xe \v adaptiveSampling\:QCPGraph}
{\xe \v QCPGraph\:adaptiveSampling}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGraph::adaptiveSampling () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5187 \{ return mAdaptiveSampling; \}\par
}
}
{\xe \v addData\:QCPGraph}
{\xe \v QCPGraph\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::addData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i values}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Adds the provided points in {\i keys}  and {\i values}  to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20232 \{\par
20233   if (keys.size() != values.size())\par
20234     qDebug() << Q_FUNC_INFO << "keys and values have different sizes:" << keys.size() << values.size();\par
20235   const int n = qMin(keys.size(), values.size());\par
20236   QVector<QCPGraphData> tempData(n);\par
20237   QVector<QCPGraphData>::iterator it = tempData.begin();\par
20238   const QVector<QCPGraphData>::iterator itEnd = tempData.end();\par
20239   int i = 0;\par
20240   while (it != itEnd)\par
20241   \{\par
20242     it->key = keys[i];\par
20243     it->value = values[i];\par
20244     ++it;\par
20245     ++i;\par
20246   \}\par
20247   mDataContainer->add(tempData, alreadySorted); // don't modify tempData beyond this to prevent copy on write\par
20248 \}\par
}
}
{\xe \v addData\:QCPGraph}
{\xe \v QCPGraph\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::addData (double  {\i key}, double  {\i value})}}
\par
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Adds the provided data point as {\i key}  and {\i value}  to the current data.\par
Alternatively, you can also access and modify the data directly via the {\b data} method, which returns a pointer to the internal data container. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20258 \{\par
20259   mDataContainer->add(QCPGraphData(key, value));\par
20260 \}\par
}
}
{\xe \v addToLegend\:QCPGraph}
{\xe \v QCPGraph\:addToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::addToLegend ({\b QCPLegend} *  {\i legend}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Adds this plottable to the specified {\i legend} .\par
Creates a {\b QCPPlottableLegendItem} which is inserted into the legend. Returns true on success, i.e. when the legend exists and a legend item associated with this plottable isn't already in the legend.\par
If the plottable needs a more specialized representation in the legend, you can create a corresponding subclass of {\b QCPPlottableLegendItem} and add it to the legend manually instead of calling this method.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeFromLegend}, {\b QCPLegend::addItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11084 \{\par
11085   if (!legend)\par
11086   \{\par
11087     qDebug() << Q_FUNC_INFO << "passed legend is null";\par
11088     return false;\par
11089   \}\par
11090   if (legend->parentPlot() != mParentPlot)\par
11091   \{\par
11092     qDebug() << Q_FUNC_INFO << "passed legend isn't in the same QCustomPlot as this plottable";\par
11093     return false;\par
11094   \}\par
11095   \par
11096   if (!legend->hasItemWithPlottable(this))\par
11097   \{\par
11098     legend->addItem(new QCPPlottableLegendItem(legend, this));\par
11099     return true;\par
11100   \} else\par
11101     return false;\par
11102 \}\par
}
}
{\xe \v addToLegend\:QCPGraph}
{\xe \v QCPGraph\:addToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::addToLegend (){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Adds this plottable to the legend of the parent {\b QCustomPlot} ({\b QCustomPlot::legend}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeFromLegend} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11111 \{\par
11112   if (!mParentPlot || !mParentPlot->legend)\par
11113     return false;\par
11114   else\par
11115     return addToLegend(mParentPlot->legend);\par
11116 \}\par
}
}
{\xe \v antialiased\:QCPGraph}
{\xe \v QCPGraph\:antialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::antialiased () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   711 \{ return mAntialiased; \}\par
}
}
{\xe \v antialiasedFill\:QCPGraph}
{\xe \v QCPGraph\:antialiasedFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::antialiasedFill () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3308 \{ return mAntialiasedFill; \}\par
}
}
{\xe \v antialiasedScatters\:QCPGraph}
{\xe \v QCPGraph\:antialiasedScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::antialiasedScatters () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3309 \{ return mAntialiasedScatters; \}\par
}
}
{\xe \v applyAntialiasingHint\:QCPGraph}
{\xe \v QCPGraph\:applyAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::applyAntialiasingHint ({\b QCPPainter} *  {\i painter}, bool  {\i localAntialiased}, {\b QCP::AntialiasedElement}  {\i overrideElement}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1567 \{\par
 1568   if (mParentPlot && mParentPlot->notAntialiasedElements().testFlag(overrideElement))\par
 1569     painter->setAntialiasing(false);\par
 1570   else if (mParentPlot && mParentPlot->antialiasedElements().testFlag(overrideElement))\par
 1571     painter->setAntialiasing(true);\par
 1572   else\par
 1573     painter->setAntialiasing(localAntialiased);\par
 1574 \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPGraph}
{\xe \v QCPGraph\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11187 \{\par
11188   applyAntialiasingHint(painter, mAntialiased, QCP::aePlottables);\par
11189 \}\par
}
}
{\xe \v applyFillAntialiasingHint\:QCPGraph}
{\xe \v QCPGraph\:applyFillAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::applyFillAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11203 \{\par
11204   applyAntialiasingHint(painter, mAntialiasedFill, QCP::aeFills);\par
11205 \}\par
}
}
{\xe \v applyScattersAntialiasingHint\:QCPGraph}
{\xe \v QCPGraph\:applyScattersAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::applyScattersAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11219 \{\par
11220   applyAntialiasingHint(painter, mAntialiasedScatters, QCP::aeScatters);\par
11221 \}\par
}
}
{\xe \v brush\:QCPGraph}
{\xe \v QCPGraph\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAbstractPlottable::brush () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3311 \{ return mBrush; \}\par
}
}
{\xe \v channelFillGraph\:QCPGraph}
{\xe \v QCPGraph\:channelFillGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPGraph}* QCPGraph::channelFillGraph () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5186 \{ return mChannelFillGraph.data(); \}\par
}
}
{\xe \v clipRect\:QCPGraph}
{\xe \v QCPGraph\:clipRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAbstractPlottable::clipRect () const{\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11158 \{\par
11159   if (mKeyAxis && mValueAxis)\par
11160     return mKeyAxis.data()->axisRect()->rect() & mValueAxis.data()->axisRect()->rect();\par
11161   else\par
11162     return QRect();\par
11163 \}\par
}
}
{\xe \v coordsToPixels\:QCPGraph}
{\xe \v QCPGraph\:coordsToPixels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::coordsToPixels (double  {\i key}, double  {\i value}, double &  {\i x}, double &  {\i y}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function for transforming a key/value pair to pixels on the {\b QCustomPlot} surface, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).\par
{\i key}  and {\i value}  are transformed to the coodinates in pixels and are written to {\i x}  and {\i y} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b pixelsToCoords}, {\b QCPAxis::coordToPixel} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10903 \{\par
10904   QCPAxis *keyAxis = mKeyAxis.data();\par
10905   QCPAxis *valueAxis = mValueAxis.data();\par
10906   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
10907   \par
10908   if (keyAxis->orientation() == Qt::Horizontal)\par
10909   \{\par
10910     x = keyAxis->coordToPixel(key);\par
10911     y = valueAxis->coordToPixel(value);\par
10912   \} else\par
10913   \{\par
10914     y = keyAxis->coordToPixel(key);\par
10915     x = valueAxis->coordToPixel(value);\par
10916   \}\par
10917 \}\par
}
}
{\xe \v coordsToPixels\:QCPGraph}
{\xe \v QCPGraph\:coordsToPixels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QPointF QCPAbstractPlottable::coordsToPixels (double  {\i key}, double  {\i value}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Transforms the given {\i key}  and {\i value}  to pixel coordinates and returns them in a QPointF. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10924 \{\par
10925   QCPAxis *keyAxis = mKeyAxis.data();\par
10926   QCPAxis *valueAxis = mValueAxis.data();\par
10927   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); \}\par
10928   \par
10929   if (keyAxis->orientation() == Qt::Horizontal)\par
10930     return QPointF(keyAxis->coordToPixel(key), valueAxis->coordToPixel(value));\par
10931   else\par
10932     return QPointF(valueAxis->coordToPixel(value), keyAxis->coordToPixel(key));\par
10933 \}\par
}
}
{\xe \v data\:QCPGraph}
{\xe \v QCPGraph\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer< {\b QCPGraphDataContainer} > QCPGraph::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a shared pointer to the internal data storage of type {\b QCPGraphDataContainer}. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular {\b setData} or {\b addData} methods. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5182 \{ return mDataContainer; \}\par
}
}
{\xe \v dataCount\:QCPGraph}
{\xe \v QCPGraph\:dataCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::dataCount () const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data points of the plottable. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4112 \{\par
 4113   return mDataContainer->size();\par
 4114 \}\par
}
}
{\xe \v dataMainKey\:QCPGraph}
{\xe \v QCPGraph\:dataMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::dataMainKey (int  {\i index}) const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main key of the data point at the given {\i index} .\par
What the main key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4121 \{\par
 4122   if (index >= 0 && index < mDataContainer->size())\par
 4123   \{\par
 4124     return (mDataContainer->constBegin()+index)->mainKey();\par
 4125   \} else\par
 4126   \{\par
 4127     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4128     return 0;\par
 4129   \}\par
 4130 \}\par
}
}
{\xe \v dataMainValue\:QCPGraph}
{\xe \v QCPGraph\:dataMainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::dataMainValue (int  {\i index}) const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main value of the data point at the given {\i index} .\par
What the main value is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4153 \{\par
 4154   if (index >= 0 && index < mDataContainer->size())\par
 4155   \{\par
 4156     return (mDataContainer->constBegin()+index)->mainValue();\par
 4157   \} else\par
 4158   \{\par
 4159     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4160     return 0;\par
 4161   \}\par
 4162 \}\par
}
}
{\xe \v dataPixelPosition\:QCPGraph}
{\xe \v QCPGraph\:dataPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::dataPixelPosition (int  {\i index}) const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position on the widget surface at which the data point at the given {\i index}  appears.\par
Usually this corresponds to the point of {\b dataMainKey}/{\b dataMainValue}, in pixel coordinates. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values. For example, {\b QCPBars} apparent data values can be shifted depending on their stacking, bar grouping or configured base value. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4185 \{\par
 4186   if (index >= 0 && index < mDataContainer->size())\par
 4187   \{\par
 4188     const typename QCPDataContainer<DataType>::const_iterator it = mDataContainer->constBegin()+index;\par
 4189     return coordsToPixels(it->mainKey(), it->mainValue());\par
 4190   \} else\par
 4191   \{\par
 4192     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4193     return QPointF();\par
 4194   \}\par
 4195 \}\par
}
}
{\xe \v dataSortKey\:QCPGraph}
{\xe \v QCPGraph\:dataSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::dataSortKey (int  {\i index}) const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the sort key of the data point at the given {\i index} .\par
What the sort key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4137 \{\par
 4138   if (index >= 0 && index < mDataContainer->size())\par
 4139   \{\par
 4140     return (mDataContainer->constBegin()+index)->sortKey();\par
 4141   \} else\par
 4142   \{\par
 4143     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4144     return 0;\par
 4145   \}\par
 4146 \}\par
}
}
{\xe \v dataToImpulseLines\:QCPGraph}
{\xe \v QCPGraph\:dataToImpulseLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToImpulseLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20710 \{\par
20711   QVector<QPointF> result;\par
20712   QCPAxis *keyAxis = mKeyAxis.data();\par
20713   QCPAxis *valueAxis = mValueAxis.data();\par
20714   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20715   \par
20716   result.resize(data.size()*2);\par
20717   \par
20718   // transform data points to pixels:\par
20719   if (keyAxis->orientation() == Qt::Vertical)\par
20720   \{\par
20721     for (int i=0; i<data.size(); ++i)\par
20722     \{\par
20723       const double key = keyAxis->coordToPixel(data.at(i).key);\par
20724       result[i*2+0].setX(valueAxis->coordToPixel(0));\par
20725       result[i*2+0].setY(key);\par
20726       result[i*2+1].setX(valueAxis->coordToPixel(data.at(i).value));\par
20727       result[i*2+1].setY(key);\par
20728     \}\par
20729   \} else // key axis is horizontal\par
20730   \{\par
20731     for (int i=0; i<data.size(); ++i)\par
20732     \{\par
20733       const double key = keyAxis->coordToPixel(data.at(i).key);\par
20734       result[i*2+0].setX(key);\par
20735       result[i*2+0].setY(valueAxis->coordToPixel(0));\par
20736       result[i*2+1].setX(key);\par
20737       result[i*2+1].setY(valueAxis->coordToPixel(data.at(i).value));\par
20738     \}\par
20739   \}\par
20740   return result;\par
20741 \}\par
}
}
{\xe \v dataToLines\:QCPGraph}
{\xe \v QCPGraph\:dataToLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20516 \{\par
20517   QVector<QPointF> result;\par
20518   QCPAxis *keyAxis = mKeyAxis.data();\par
20519   QCPAxis *valueAxis = mValueAxis.data();\par
20520   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20521 \par
20522   result.resize(data.size());\par
20523   \par
20524   // transform data points to pixels:\par
20525   if (keyAxis->orientation() == Qt::Vertical)\par
20526   \{\par
20527     for (int i=0; i<data.size(); ++i)\par
20528     \{\par
20529       result[i].setX(valueAxis->coordToPixel(data.at(i).value));\par
20530       result[i].setY(keyAxis->coordToPixel(data.at(i).key));\par
20531     \}\par
20532   \} else // key axis is horizontal\par
20533   \{\par
20534     for (int i=0; i<data.size(); ++i)\par
20535     \{\par
20536       result[i].setX(keyAxis->coordToPixel(data.at(i).key));\par
20537       result[i].setY(valueAxis->coordToPixel(data.at(i).value));\par
20538     \}\par
20539   \}\par
20540   return result;\par
20541 \}\par
}
}
{\xe \v dataToStepCenterLines\:QCPGraph}
{\xe \v QCPGraph\:dataToStepCenterLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToStepCenterLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20650 \{\par
20651   QVector<QPointF> result;\par
20652   QCPAxis *keyAxis = mKeyAxis.data();\par
20653   QCPAxis *valueAxis = mValueAxis.data();\par
20654   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20655   \par
20656   result.resize(data.size()*2);\par
20657   \par
20658   // calculate steps from data and transform to pixel coordinates:\par
20659   if (keyAxis->orientation() == Qt::Vertical)\par
20660   \{\par
20661     double lastKey = keyAxis->coordToPixel(data.first().key);\par
20662     double lastValue = valueAxis->coordToPixel(data.first().value);\par
20663     result[0].setX(lastValue);\par
20664     result[0].setY(lastKey);\par
20665     for (int i=1; i<data.size(); ++i)\par
20666     \{\par
20667       const double key = (keyAxis->coordToPixel(data.at(i).key)+lastKey)*0.5;\par
20668       result[i*2-1].setX(lastValue);\par
20669       result[i*2-1].setY(key);\par
20670       lastValue = valueAxis->coordToPixel(data.at(i).value);\par
20671       lastKey = keyAxis->coordToPixel(data.at(i).key);\par
20672       result[i*2+0].setX(lastValue);\par
20673       result[i*2+0].setY(key);\par
20674     \}\par
20675     result[data.size()*2-1].setX(lastValue);\par
20676     result[data.size()*2-1].setY(lastKey);\par
20677   \} else // key axis is horizontal\par
20678   \{\par
20679     double lastKey = keyAxis->coordToPixel(data.first().key);\par
20680     double lastValue = valueAxis->coordToPixel(data.first().value);\par
20681     result[0].setX(lastKey);\par
20682     result[0].setY(lastValue);\par
20683     for (int i=1; i<data.size(); ++i)\par
20684     \{\par
20685       const double key = (keyAxis->coordToPixel(data.at(i).key)+lastKey)*0.5;\par
20686       result[i*2-1].setX(key);\par
20687       result[i*2-1].setY(lastValue);\par
20688       lastValue = valueAxis->coordToPixel(data.at(i).value);\par
20689       lastKey = keyAxis->coordToPixel(data.at(i).key);\par
20690       result[i*2+0].setX(key);\par
20691       result[i*2+0].setY(lastValue);\par
20692     \}\par
20693     result[data.size()*2-1].setX(lastKey);\par
20694     result[data.size()*2-1].setY(lastValue);\par
20695   \}\par
20696   return result;\par
20697 \}\par
}
}
{\xe \v dataToStepLeftLines\:QCPGraph}
{\xe \v QCPGraph\:dataToStepLeftLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToStepLeftLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20554 \{\par
20555   QVector<QPointF> result;\par
20556   QCPAxis *keyAxis = mKeyAxis.data();\par
20557   QCPAxis *valueAxis = mValueAxis.data();\par
20558   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20559   \par
20560   result.resize(data.size()*2);\par
20561   \par
20562   // calculate steps from data and transform to pixel coordinates:\par
20563   if (keyAxis->orientation() == Qt::Vertical)\par
20564   \{\par
20565     double lastValue = valueAxis->coordToPixel(data.first().value);\par
20566     for (int i=0; i<data.size(); ++i)\par
20567     \{\par
20568       const double key = keyAxis->coordToPixel(data.at(i).key);\par
20569       result[i*2+0].setX(lastValue);\par
20570       result[i*2+0].setY(key);\par
20571       lastValue = valueAxis->coordToPixel(data.at(i).value);\par
20572       result[i*2+1].setX(lastValue);\par
20573       result[i*2+1].setY(key);\par
20574     \}\par
20575   \} else // key axis is horizontal\par
20576   \{\par
20577     double lastValue = valueAxis->coordToPixel(data.first().value);\par
20578     for (int i=0; i<data.size(); ++i)\par
20579     \{\par
20580       const double key = keyAxis->coordToPixel(data.at(i).key);\par
20581       result[i*2+0].setX(key);\par
20582       result[i*2+0].setY(lastValue);\par
20583       lastValue = valueAxis->coordToPixel(data.at(i).value);\par
20584       result[i*2+1].setX(key);\par
20585       result[i*2+1].setY(lastValue);\par
20586     \}\par
20587   \}\par
20588   return result;\par
20589 \}\par
}
}
{\xe \v dataToStepRightLines\:QCPGraph}
{\xe \v QCPGraph\:dataToStepRightLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPointF > QCPGraph::dataToStepRightLines (const QVector< {\b QCPGraphData} > &  {\i data}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20602 \{\par
20603   QVector<QPointF> result;\par
20604   QCPAxis *keyAxis = mKeyAxis.data();\par
20605   QCPAxis *valueAxis = mValueAxis.data();\par
20606   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return result; \}\par
20607   \par
20608   result.resize(data.size()*2);\par
20609   \par
20610   // calculate steps from data and transform to pixel coordinates:\par
20611   if (keyAxis->orientation() == Qt::Vertical)\par
20612   \{\par
20613     double lastKey = keyAxis->coordToPixel(data.first().key);\par
20614     for (int i=0; i<data.size(); ++i)\par
20615     \{\par
20616       const double value = valueAxis->coordToPixel(data.at(i).value);\par
20617       result[i*2+0].setX(value);\par
20618       result[i*2+0].setY(lastKey);\par
20619       lastKey = keyAxis->coordToPixel(data.at(i).key);\par
20620       result[i*2+1].setX(value);\par
20621       result[i*2+1].setY(lastKey);\par
20622     \}\par
20623   \} else // key axis is horizontal\par
20624   \{\par
20625     double lastKey = keyAxis->coordToPixel(data.first().key);\par
20626     for (int i=0; i<data.size(); ++i)\par
20627     \{\par
20628       const double value = valueAxis->coordToPixel(data.at(i).value);\par
20629       result[i*2+0].setX(lastKey);\par
20630       result[i*2+0].setY(value);\par
20631       lastKey = keyAxis->coordToPixel(data.at(i).key);\par
20632       result[i*2+1].setX(lastKey);\par
20633       result[i*2+1].setY(value);\par
20634     \}\par
20635   \}\par
20636   return result;\par
20637 \}\par
}
}
{\xe \v dataValueRange\:QCPGraph}
{\xe \v QCPGraph\:dataValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::dataValueRange (int  {\i index}) const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the value range of the data point at the given {\i index} .\par
What the value range is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4169 \{\par
 4170   if (index >= 0 && index < mDataContainer->size())\par
 4171   \{\par
 4172     return (mDataContainer->constBegin()+index)->valueRange();\par
 4173   \} else\par
 4174   \{\par
 4175     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4176     return QCPRange(0, 0);\par
 4177   \}\par
 4178 \}\par
}
}
{\xe \v deselectEvent\:QCPGraph}
{\xe \v QCPGraph\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11256 \{\par
11257   if (mSelectable != QCP::stNone)\par
11258   \{\par
11259     QCPDataSelection selectionBefore = mSelection;\par
11260     setSelection(QCPDataSelection());\par
11261     if (selectionStateChanged)\par
11262       *selectionStateChanged = mSelection != selectionBefore;\par
11263   \}\par
11264 \}\par
}
}
{\xe \v draw\:QCPGraph}
{\xe \v QCPGraph\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20298 \{\par
20299   if (!mKeyAxis || !mValueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
20300   if (mKeyAxis.data()->range().size() <= 0 || mDataContainer->isEmpty()) return;\par
20301   if (mLineStyle == lsNone && mScatterStyle.isNone()) return;\par
20302   \par
20303   QVector<QPointF> lines, scatters; // line and (if necessary) scatter pixel coordinates will be stored here while iterating over segments\par
20304   \par
20305   // loop over and draw segments of unselected/selected data:\par
20306   QList<QCPDataRange> selectedSegments, unselectedSegments, allSegments;\par
20307   getDataSegments(selectedSegments, unselectedSegments);\par
20308   allSegments << unselectedSegments << selectedSegments;\par
20309   for (int i=0; i<allSegments.size(); ++i)\par
20310   \{\par
20311     bool isSelectedSegment = i >= unselectedSegments.size();\par
20312     // get line pixel points appropriate to line style:\par
20313     QCPDataRange lineDataRange = isSelectedSegment ? allSegments.at(i) : allSegments.at(i).adjusted(-1, 1); // unselected segments extend lines to bordering selected data point (safe to exceed total data bounds in first/last segment, getLines takes care)\par
20314     getLines(&lines, lineDataRange);\par
20315     \par
20316     // check data validity if flag set:\par
20317 #ifdef QCUSTOMPLOT_CHECK_DATA\par
20318     QCPGraphDataContainer::const_iterator it;\par
20319     for (it = mDataContainer->constBegin(); it != mDataContainer->constEnd(); ++it)\par
20320     \{\par
20321       if (QCP::isInvalidData(it->key, it->value))\par
20322         qDebug() << Q_FUNC_INFO << "Data point at" << it->key << "invalid." << "Plottable name:" << name();\par
20323     \}\par
20324 #endif\par
20325     \par
20326     // draw fill of graph:\par
20327     if (isSelectedSegment && mSelectionDecorator)\par
20328       mSelectionDecorator->applyBrush(painter);\par
20329     else\par
20330       painter->setBrush(mBrush);\par
20331     painter->setPen(Qt::NoPen);\par
20332     drawFill(painter, &lines);\par
20333     \par
20334     // draw line:\par
20335     if (mLineStyle != lsNone)\par
20336     \{\par
20337       if (isSelectedSegment && mSelectionDecorator)\par
20338         mSelectionDecorator->applyPen(painter);\par
20339       else\par
20340         painter->setPen(mPen);\par
20341       painter->setBrush(Qt::NoBrush);\par
20342       if (mLineStyle == lsImpulse)\par
20343         drawImpulsePlot(painter, lines);\par
20344       else\par
20345         drawLinePlot(painter, lines); // also step plots can be drawn as a line plot\par
20346     \}\par
20347     \par
20348     // draw scatters:\par
20349     QCPScatterStyle finalScatterStyle = mScatterStyle;\par
20350     if (isSelectedSegment && mSelectionDecorator)\par
20351       finalScatterStyle = mSelectionDecorator->getFinalScatterStyle(mScatterStyle);\par
20352     if (!finalScatterStyle.isNone())\par
20353     \{\par
20354       getScatters(&scatters, allSegments.at(i));\par
20355       drawScatterPlot(painter, scatters, finalScatterStyle);\par
20356     \}\par
20357   \}\par
20358   \par
20359   // draw other selection decoration that isn't just line/scatter pens and brushes:\par
20360   if (mSelectionDecorator)\par
20361     mSelectionDecorator->drawDecoration(painter, selection());\par
20362 \}\par
}
}
{\xe \v drawFill\:QCPGraph}
{\xe \v QCPGraph\:drawFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawFill ({\b QCPPainter} *  {\i painter}, QVector< QPointF > *  {\i lines}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20761 \{\par
20762   if (mLineStyle == lsImpulse) return; // fill doesn't make sense for impulse plot\par
20763   if (painter->brush().style() == Qt::NoBrush || painter->brush().color().alpha() == 0) return;\par
20764   \par
20765   applyFillAntialiasingHint(painter);\par
20766   QVector<QCPDataRange> segments = getNonNanSegments(lines, keyAxis()->orientation());\par
20767   if (!mChannelFillGraph)\par
20768   \{\par
20769     // draw base fill under graph, fill goes all the way to the zero-value-line:\par
20770     for (int i=0; i<segments.size(); ++i)\par
20771       painter->drawPolygon(getFillPolygon(lines, segments.at(i)));\par
20772   \} else\par
20773   \{\par
20774     // draw fill between this graph and mChannelFillGraph:\par
20775     QVector<QPointF> otherLines;\par
20776     mChannelFillGraph->getLines(&otherLines, QCPDataRange(0, mChannelFillGraph->dataCount()));\par
20777     if (!otherLines.isEmpty())\par
20778     \{\par
20779       QVector<QCPDataRange> otherSegments = getNonNanSegments(&otherLines, mChannelFillGraph->keyAxis()->orientation());\par
20780       QVector<QPair<QCPDataRange, QCPDataRange> > segmentPairs = getOverlappingSegments(segments, lines, otherSegments, &otherLines);\par
20781       for (int i=0; i<segmentPairs.size(); ++i)\par
20782         painter->drawPolygon(getChannelFillPolygon(lines, segmentPairs.at(i).first, &otherLines, segmentPairs.at(i).second));\par
20783     \}\par
20784   \}\par
20785 \}\par
}
}
{\xe \v drawImpulsePlot\:QCPGraph}
{\xe \v QCPGraph\:drawImpulsePlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawImpulsePlot ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i lines}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20826 \{\par
20827   if (painter->pen().style() != Qt::NoPen && painter->pen().color().alpha() != 0)\par
20828   \{\par
20829     applyDefaultAntialiasingHint(painter);\par
20830     QPen oldPen = painter->pen();\par
20831     QPen newPen = painter->pen();\par
20832     newPen.setCapStyle(Qt::FlatCap); // so impulse line doesn't reach beyond zero-line\par
20833     painter->setPen(newPen);\par
20834     painter->drawLines(lines);\par
20835     painter->setPen(oldPen);\par
20836   \}\par
20837 \}\par
}
}
{\xe \v drawLegendIcon\:QCPGraph}
{\xe \v QCPGraph\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20366 \{\par
20367   // draw fill:\par
20368   if (mBrush.style() != Qt::NoBrush)\par
20369   \{\par
20370     applyFillAntialiasingHint(painter);\par
20371     painter->fillRect(QRectF(rect.left(), rect.top()+rect.height()/2.0, rect.width(), rect.height()/3.0), mBrush);\par
20372   \}\par
20373   // draw line vertically centered:\par
20374   if (mLineStyle != lsNone)\par
20375   \{\par
20376     applyDefaultAntialiasingHint(painter);\par
20377     painter->setPen(mPen);\par
20378     painter->drawLine(QLineF(rect.left(), rect.top()+rect.height()/2.0, rect.right()+5, rect.top()+rect.height()/2.0)); // +5 on x2 else last segment is missing from dashed/dotted pens\par
20379   \}\par
20380   // draw scatter symbol:\par
20381   if (!mScatterStyle.isNone())\par
20382   \{\par
20383     applyScattersAntialiasingHint(painter);\par
20384     // scale scatter pixmap if it's too large to fit in legend icon rect:\par
20385     if (mScatterStyle.shape() == QCPScatterStyle::ssPixmap && (mScatterStyle.pixmap().size().width() > rect.width() || mScatterStyle.pixmap().size().height() > rect.height()))\par
20386     \{\par
20387       QCPScatterStyle scaledStyle(mScatterStyle);\par
20388       scaledStyle.setPixmap(scaledStyle.pixmap().scaled(rect.size().toSize(), Qt::KeepAspectRatio, Qt::SmoothTransformation));\par
20389       scaledStyle.applyTo(painter, mPen);\par
20390       scaledStyle.drawShape(painter, QRectF(rect).center());\par
20391     \} else\par
20392     \{\par
20393       mScatterStyle.applyTo(painter, mPen);\par
20394       mScatterStyle.drawShape(painter, QRectF(rect).center());\par
20395     \}\par
20396   \}\par
20397 \}\par
}
}
{\xe \v drawLinePlot\:QCPGraph}
{\xe \v QCPGraph\:drawLinePlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawLinePlot ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i lines}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20809 \{\par
20810   if (painter->pen().style() != Qt::NoPen && painter->pen().color().alpha() != 0)\par
20811   \{\par
20812     applyDefaultAntialiasingHint(painter);\par
20813     drawPolyline(painter, lines);\par
20814   \}\par
20815 \}\par
}
}
{\xe \v drawPolyline\:QCPGraph}
{\xe \v QCPGraph\:drawPolyline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::drawPolyline ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i lineData}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A helper method which draws a line with the passed {\i painter} , according to the pixel data in {\i lineData} . NaN points create gaps in the line, as expected from {\b QCustomPlot}'s plottables (this is the main difference to QPainter's regular drawPolyline, which handles NaNs by lagging or crashing).\par
Further it uses a faster line drawing technique based on {\b QCPPainter::drawLine} rather than {\f2 QPainter::drawPolyline}  if the configured {\b QCustomPlot::setPlottingHints()} and {\i painter}  style allows. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4378 \{\par
 4379   // if drawing solid line and not in PDF, use much faster line drawing instead of polyline:\par
 4380   if (mParentPlot->plottingHints().testFlag(QCP::phFastPolylines) &&\par
 4381       painter->pen().style() == Qt::SolidLine &&\par
 4382       !painter->modes().testFlag(QCPPainter::pmVectorized) &&\par
 4383       !painter->modes().testFlag(QCPPainter::pmNoCaching))\par
 4384   \{\par
 4385     int i = 0;\par
 4386     bool lastIsNan = false;\par
 4387     const int lineDataSize = lineData.size();\par
 4388     while (i < lineDataSize && (qIsNaN(lineData.at(i).y()) || qIsNaN(lineData.at(i).x()))) // make sure first point is not NaN\par
 4389       ++i;\par
 4390     ++i; // because drawing works in 1 point retrospect\par
 4391     while (i < lineDataSize)\par
 4392     \{\par
 4393       if (!qIsNaN(lineData.at(i).y()) && !qIsNaN(lineData.at(i).x())) // NaNs create a gap in the line\par
 4394       \{\par
 4395         if (!lastIsNan)\par
 4396           painter->drawLine(lineData.at(i-1), lineData.at(i));\par
 4397         else\par
 4398           lastIsNan = false;\par
 4399       \} else\par
 4400         lastIsNan = true;\par
 4401       ++i;\par
 4402     \}\par
 4403   \} else\par
 4404   \{\par
 4405     int segmentStart = 0;\par
 4406     int i = 0;\par
 4407     const int lineDataSize = lineData.size();\par
 4408     while (i < lineDataSize)\par
 4409     \{\par
 4410       if (qIsNaN(lineData.at(i).y()) || qIsNaN(lineData.at(i).x()) || qIsInf(lineData.at(i).y())) // NaNs create a gap in the line. Also filter Infs which make drawPolyline block\par
 4411       \{\par
 4412         painter->drawPolyline(lineData.constData()+segmentStart, i-segmentStart); // i, because we don't want to include the current NaN point\par
 4413         segmentStart = i+1;\par
 4414       \}\par
 4415       ++i;\par
 4416     \}\par
 4417     // draw last segment:\par
 4418     painter->drawPolyline(lineData.constData()+segmentStart, lineDataSize-segmentStart);\par
 4419   \}\par
 4420 \}\par
}
}
{\xe \v drawScatterPlot\:QCPGraph}
{\xe \v QCPGraph\:drawScatterPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::drawScatterPlot ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i scatters}, const {\b QCPScatterStyle} &  {\i style}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20795 \{\par
20796   applyScattersAntialiasingHint(painter);\par
20797   style.applyTo(painter, mPen);\par
20798   for (int i=0; i<scatters.size(); ++i)\par
20799     style.drawShape(painter, scatters.at(i).x(), scatters.at(i).y());\par
20800 \}\par
}
}
{\xe \v findBegin\:QCPGraph}
{\xe \v QCPGraph\:findBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::findBegin (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index of the data point with a (sort-)key that is equal to, just below, or just above {\i sortKey} . If {\i expandedRange}  is true, the data point just below {\i sortKey}  will be considered, otherwise the one just above.\par
This can be used in conjunction with {\b findEnd} to iterate over data points within a given key range, including or excluding the bounding data points that are just beyond the specified range.\par
If {\i expandedRange}  is true but there are no data points below {\i sortKey} , 0 is returned.\par
If the container is empty, returns 0 (in that case, {\b findEnd} will also return 0, so a loop using these methods will not iterate over the index 0).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findEnd}, {\b QCPDataContainer::findBegin} \par
}}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4264 \{\par
 4265   return mDataContainer->findBegin(sortKey, expandedRange)-mDataContainer->constBegin();\par
 4266 \}\par
}
}
{\xe \v findEnd\:QCPGraph}
{\xe \v QCPGraph\:findEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::findEnd (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index one after the data point with a (sort-)key that is equal to, just above, or just below {\i sortKey} . If {\i expandedRange}  is true, the data point just above {\i sortKey}  will be considered, otherwise the one just below.\par
This can be used in conjunction with {\b findBegin} to iterate over data points within a given key range, including the bounding data points that are just below and above the specified range.\par
If {\i expandedRange}  is true but there are no data points above {\i sortKey} , the index just above the highest data point is returned.\par
If the container is empty, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findBegin}, {\b QCPDataContainer::findEnd} \par
}}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4273 \{\par
 4274   return mDataContainer->findEnd(sortKey, expandedRange)-mDataContainer->constBegin();\par
 4275 \}\par
}
}
{\xe \v findIndexAboveX\:QCPGraph}
{\xe \v QCPGraph\:findIndexAboveX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::findIndexAboveX (const QVector< QPointF > *  {\i data}, double  {\i x}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21506 \{\par
21507   for (int i=data->size()-1; i>=0; --i)\par
21508   \{\par
21509     if (data->at(i).x() < x)\par
21510     \{\par
21511       if (i<data->size()-1)\par
21512         return i+1;\par
21513       else\par
21514         return data->size()-1;\par
21515     \}\par
21516   \}\par
21517   return -1;\par
21518 \}\par
}
}
{\xe \v findIndexAboveY\:QCPGraph}
{\xe \v QCPGraph\:findIndexAboveY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::findIndexAboveY (const QVector< QPointF > *  {\i data}, double  {\i y}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21552 \{\par
21553   for (int i=data->size()-1; i>=0; --i)\par
21554   \{\par
21555     if (data->at(i).y() < y)\par
21556     \{\par
21557       if (i<data->size()-1)\par
21558         return i+1;\par
21559       else\par
21560         return data->size()-1;\par
21561     \}\par
21562   \}\par
21563   return -1;\par
21564 \}\par
}
}
{\xe \v findIndexBelowX\:QCPGraph}
{\xe \v QCPGraph\:findIndexBelowX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::findIndexBelowX (const QVector< QPointF > *  {\i data}, double  {\i x}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21529 \{\par
21530   for (int i=0; i<data->size(); ++i)\par
21531   \{\par
21532     if (data->at(i).x() > x)\par
21533     \{\par
21534       if (i>0)\par
21535         return i-1;\par
21536       else\par
21537         return 0;\par
21538     \}\par
21539   \}\par
21540   return -1;\par
21541 \}\par
}
}
{\xe \v findIndexBelowY\:QCPGraph}
{\xe \v QCPGraph\:findIndexBelowY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::findIndexBelowY (const QVector< QPointF > *  {\i data}, double  {\i y}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21634 \{\par
21635   for (int i=0; i<data->size(); ++i)\par
21636   \{\par
21637     if (data->at(i).y() > y)\par
21638     \{\par
21639       if (i>0)\par
21640         return i-1;\par
21641       else\par
21642         return 0;\par
21643     \}\par
21644   \}\par
21645   return -1;\par
21646 \}\par
}
}
{\xe \v getChannelFillPolygon\:QCPGraph}
{\xe \v QCPGraph\:getChannelFillPolygon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QPolygonF QCPGraph::getChannelFillPolygon (const QVector< QPointF > *  {\i lineData}, {\b QCPDataRange}  {\i thisSegment}, const QVector< QPointF > *  {\i otherData}, {\b QCPDataRange}  {\i otherSegment}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21399 \{\par
21400   if (!mChannelFillGraph)\par
21401     return QPolygonF();\par
21402   \par
21403   QCPAxis *keyAxis = mKeyAxis.data();\par
21404   QCPAxis *valueAxis = mValueAxis.data();\par
21405   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPolygonF(); \}\par
21406   if (!mChannelFillGraph.data()->mKeyAxis) \{ qDebug() << Q_FUNC_INFO << "channel fill target key axis invalid"; return QPolygonF(); \}\par
21407   \par
21408   if (mChannelFillGraph.data()->mKeyAxis.data()->orientation() != keyAxis->orientation())\par
21409     return QPolygonF(); // don't have same axis orientation, can't fill that (Note: if keyAxis fits, valueAxis will fit too, because it's always orthogonal to keyAxis)\par
21410   \par
21411   if (thisData->isEmpty()) return QPolygonF();\par
21412   QVector<QPointF> thisSegmentData(thisSegment.size());\par
21413   QVector<QPointF> otherSegmentData(otherSegment.size());\par
21414   std::copy(thisData->constBegin()+thisSegment.begin(), thisData->constBegin()+thisSegment.end(), thisSegmentData.begin());\par
21415   std::copy(otherData->constBegin()+otherSegment.begin(), otherData->constBegin()+otherSegment.end(), otherSegmentData.begin());\par
21416   // pointers to be able to swap them, depending which data range needs cropping:\par
21417   QVector<QPointF> *staticData = &thisSegmentData;\par
21418   QVector<QPointF> *croppedData = &otherSegmentData;\par
21419   \par
21420   // crop both vectors to ranges in which the keys overlap (which coord is key, depends on axisType):\par
21421   if (keyAxis->orientation() == Qt::Horizontal)\par
21422   \{\par
21423     // x is key\par
21424     // crop lower bound:\par
21425     if (staticData->first().x() < croppedData->first().x()) // other one must be cropped\par
21426       qSwap(staticData, croppedData);\par
21427     const int lowBound = findIndexBelowX(croppedData, staticData->first().x());\par
21428     if (lowBound == -1) return QPolygonF(); // key ranges have no overlap\par
21429     croppedData->remove(0, lowBound);\par
21430     // set lowest point of cropped data to fit exactly key position of first static data point via linear interpolation:\par
21431     if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation\par
21432     double slope;\par
21433     if (!qFuzzyCompare(croppedData->at(1).x(), croppedData->at(0).x()))\par
21434       slope = (croppedData->at(1).y()-croppedData->at(0).y())/(croppedData->at(1).x()-croppedData->at(0).x());\par
21435     else\par
21436       slope = 0;\par
21437     (*croppedData)[0].setY(croppedData->at(0).y()+slope*(staticData->first().x()-croppedData->at(0).x()));\par
21438     (*croppedData)[0].setX(staticData->first().x());\par
21439     \par
21440     // crop upper bound:\par
21441     if (staticData->last().x() > croppedData->last().x()) // other one must be cropped\par
21442       qSwap(staticData, croppedData);\par
21443     int highBound = findIndexAboveX(croppedData, staticData->last().x());\par
21444     if (highBound == -1) return QPolygonF(); // key ranges have no overlap\par
21445     croppedData->remove(highBound+1, croppedData->size()-(highBound+1));\par
21446     // set highest point of cropped data to fit exactly key position of last static data point via linear interpolation:\par
21447     if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation\par
21448     const int li = croppedData->size()-1; // last index\par
21449     if (!qFuzzyCompare(croppedData->at(li).x(), croppedData->at(li-1).x()))\par
21450       slope = (croppedData->at(li).y()-croppedData->at(li-1).y())/(croppedData->at(li).x()-croppedData->at(li-1).x());\par
21451     else\par
21452       slope = 0;\par
21453     (*croppedData)[li].setY(croppedData->at(li-1).y()+slope*(staticData->last().x()-croppedData->at(li-1).x()));\par
21454     (*croppedData)[li].setX(staticData->last().x());\par
21455   \} else // mKeyAxis->orientation() == Qt::Vertical\par
21456   \{\par
21457     // y is key\par
21458     // crop lower bound:\par
21459     if (staticData->first().y() < croppedData->first().y()) // other one must be cropped\par
21460       qSwap(staticData, croppedData);\par
21461     int lowBound = findIndexBelowY(croppedData, staticData->first().y());\par
21462     if (lowBound == -1) return QPolygonF(); // key ranges have no overlap\par
21463     croppedData->remove(0, lowBound);\par
21464     // set lowest point of cropped data to fit exactly key position of first static data point via linear interpolation:\par
21465     if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation\par
21466     double slope;\par
21467     if (!qFuzzyCompare(croppedData->at(1).y(), croppedData->at(0).y())) // avoid division by zero in step plots\par
21468       slope = (croppedData->at(1).x()-croppedData->at(0).x())/(croppedData->at(1).y()-croppedData->at(0).y());\par
21469     else\par
21470       slope = 0;\par
21471     (*croppedData)[0].setX(croppedData->at(0).x()+slope*(staticData->first().y()-croppedData->at(0).y()));\par
21472     (*croppedData)[0].setY(staticData->first().y());\par
21473     \par
21474     // crop upper bound:\par
21475     if (staticData->last().y() > croppedData->last().y()) // other one must be cropped\par
21476       qSwap(staticData, croppedData);\par
21477     int highBound = findIndexAboveY(croppedData, staticData->last().y());\par
21478     if (highBound == -1) return QPolygonF(); // key ranges have no overlap\par
21479     croppedData->remove(highBound+1, croppedData->size()-(highBound+1));\par
21480     // set highest point of cropped data to fit exactly key position of last static data point via linear interpolation:\par
21481     if (croppedData->size() < 2) return QPolygonF(); // need at least two points for interpolation\par
21482     int li = croppedData->size()-1; // last index\par
21483     if (!qFuzzyCompare(croppedData->at(li).y(), croppedData->at(li-1).y())) // avoid division by zero in step plots\par
21484       slope = (croppedData->at(li).x()-croppedData->at(li-1).x())/(croppedData->at(li).y()-croppedData->at(li-1).y());\par
21485     else\par
21486       slope = 0;\par
21487     (*croppedData)[li].setX(croppedData->at(li-1).x()+slope*(staticData->last().y()-croppedData->at(li-1).y()));\par
21488     (*croppedData)[li].setY(staticData->last().y());\par
21489   \}\par
21490   \par
21491   // return joined:\par
21492   for (int i=otherSegmentData.size()-1; i>=0; --i) // insert reversed, otherwise the polygon will be twisted\par
21493     thisSegmentData << otherSegmentData.at(i);\par
21494   return QPolygonF(thisSegmentData);\par
21495 \}\par
}
}
{\xe \v getDataSegments\:QCPGraph}
{\xe \v QCPGraph\:getDataSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::getDataSegments (QList< {\b QCPDataRange} > &  {\i selectedSegments}, QList< {\b QCPDataRange} > &  {\i unselectedSegments}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits all data into selected and unselected segments and outputs them via {\i selectedSegments}  and {\i unselectedSegments} , respectively.\par
This is useful when subclasses implement their {\b draw} method and need to draw selected segments with a different pen/brush than unselected segments (also see {\b QCPSelectionDecorator}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelection} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4348 \{\par
 4349   selectedSegments.clear();\par
 4350   unselectedSegments.clear();\par
 4351   if (mSelectable == QCP::stWhole) // stWhole selection type draws the entire plottable with selected style if mSelection isn't empty\par
 4352   \{\par
 4353     if (selected())\par
 4354       selectedSegments << QCPDataRange(0, dataCount());\par
 4355     else\par
 4356       unselectedSegments << QCPDataRange(0, dataCount());\par
 4357   \} else\par
 4358   \{\par
 4359     QCPDataSelection sel(selection());\par
 4360     sel.simplify();\par
 4361     selectedSegments = sel.dataRanges();\par
 4362     unselectedSegments = sel.inverse(QCPDataRange(0, dataCount())).dataRanges();\par
 4363   \}\par
 4364 \}\par
}
}
{\xe \v getFillBasePoint\:QCPGraph}
{\xe \v QCPGraph\:getFillBasePoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointF QCPGraph::getFillBasePoint (QPointF  {\i matchingDataPoint}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21309 \{\par
21310   QCPAxis *keyAxis = mKeyAxis.data();\par
21311   QCPAxis *valueAxis = mValueAxis.data();\par
21312   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); \}\par
21313   \par
21314   QPointF result;\par
21315   if (valueAxis->scaleType() == QCPAxis::stLinear)\par
21316   \{\par
21317     if (keyAxis->orientation() == Qt::Horizontal)\par
21318     \{\par
21319       result.setX(matchingDataPoint.x());\par
21320       result.setY(valueAxis->coordToPixel(0));\par
21321     \} else // keyAxis->orientation() == Qt::Vertical\par
21322     \{\par
21323       result.setX(valueAxis->coordToPixel(0));\par
21324       result.setY(matchingDataPoint.y());\par
21325     \}\par
21326   \} else // valueAxis->mScaleType == QCPAxis::stLogarithmic\par
21327   \{\par
21328     // In logarithmic scaling we can't just draw to value 0 so we just fill all the way\par
21329     // to the axis which is in the direction towards 0\par
21330     if (keyAxis->orientation() == Qt::Vertical)\par
21331     \{\par
21332       if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||\par
21333           (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) // if range is negative, zero is on opposite side of key axis\par
21334         result.setX(keyAxis->axisRect()->right());\par
21335       else\par
21336         result.setX(keyAxis->axisRect()->left());\par
21337       result.setY(matchingDataPoint.y());\par
21338     \} else if (keyAxis->axisType() == QCPAxis::atTop || keyAxis->axisType() == QCPAxis::atBottom)\par
21339     \{\par
21340       result.setX(matchingDataPoint.x());\par
21341       if ((valueAxis->range().upper < 0 && !valueAxis->rangeReversed()) ||\par
21342           (valueAxis->range().upper > 0 && valueAxis->rangeReversed())) // if range is negative, zero is on opposite side of key axis\par
21343         result.setY(keyAxis->axisRect()->top());\par
21344       else\par
21345         result.setY(keyAxis->axisRect()->bottom());\par
21346     \}\par
21347   \}\par
21348   return result;\par
21349 \}\par
}
}
{\xe \v getFillPolygon\:QCPGraph}
{\xe \v QCPGraph\:getFillPolygon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QPolygonF QCPGraph::getFillPolygon (const QVector< QPointF > *  {\i lineData}, {\b QCPDataRange}  {\i segment}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21368 \{\par
21369   if (segment.size() < 2)\par
21370     return QPolygonF();\par
21371   QPolygonF result(segment.size()+2);\par
21372   \par
21373   result[0] = getFillBasePoint(lineData->at(segment.begin()));\par
21374   std::copy(lineData->constBegin()+segment.begin(), lineData->constBegin()+segment.end(), result.begin()+1);\par
21375   result[result.size()-1] = getFillBasePoint(lineData->at(segment.end()-1));\par
21376   \par
21377   return result;\par
21378 \}\par
}
}
{\xe \v getKeyRange\:QCPGraph}
{\xe \v QCPGraph\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPGraph::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implementa {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20286 \{\par
20287   return mDataContainer->keyRange(foundRange, inSignDomain);\par
20288 \}\par
}
}
{\xe \v getLines\:QCPGraph}
{\xe \v QCPGraph\:getLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getLines (QVector< QPointF > *  {\i lines}, const {\b QCPDataRange} &  {\i dataRange}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20420 \{\par
20421   if (!lines) return;\par
20422   QCPGraphDataContainer::const_iterator begin, end;\par
20423   getVisibleDataBounds(begin, end, dataRange);\par
20424   if (begin == end)\par
20425   \{\par
20426     lines->clear();\par
20427     return;\par
20428   \}\par
20429   \par
20430   QVector<QCPGraphData> lineData;\par
20431   if (mLineStyle != lsNone)\par
20432     getOptimizedLineData(&lineData, begin, end);\par
20433   \par
20434   if (mKeyAxis->rangeReversed() != (mKeyAxis->orientation() == Qt::Vertical)) // make sure key pixels are sorted ascending in lineData (significantly simplifies following processing)\par
20435     std::reverse(lineData.begin(), lineData.end());\par
20436 \par
20437   switch (mLineStyle)\par
20438   \{\par
20439     case lsNone: lines->clear(); break;\par
20440     case lsLine: *lines = dataToLines(lineData); break;\par
20441     case lsStepLeft: *lines = dataToStepLeftLines(lineData); break;\par
20442     case lsStepRight: *lines = dataToStepRightLines(lineData); break;\par
20443     case lsStepCenter: *lines = dataToStepCenterLines(lineData); break;\par
20444     case lsImpulse: *lines = dataToImpulseLines(lineData); break;\par
20445   \}\par
20446 \}\par
}
}
{\xe \v getNonNanSegments\:QCPGraph}
{\xe \v QCPGraph\:getNonNanSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< {\b QCPDataRange} > QCPGraph::getNonNanSegments (const QVector< QPointF > *  {\i lineData}, Qt::Orientation  {\i keyOrientation}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21155 \{\par
21156   QVector<QCPDataRange> result;\par
21157   const int n = lineData->size();\par
21158   \par
21159   QCPDataRange currentSegment(-1, -1);\par
21160   int i = 0;\par
21161   \par
21162   if (keyOrientation == Qt::Horizontal)\par
21163   \{\par
21164     while (i < n)\par
21165     \{\par
21166       while (i < n && qIsNaN(lineData->at(i).y())) // seek next non-NaN data point\par
21167         ++i;\par
21168       if (i == n)\par
21169         break;\par
21170       currentSegment.setBegin(i++);\par
21171       while (i < n && !qIsNaN(lineData->at(i).y())) // seek next NaN data point or end of data\par
21172         ++i;\par
21173       currentSegment.setEnd(i++);\par
21174       result.append(currentSegment);\par
21175     \}\par
21176   \} else // keyOrientation == Qt::Vertical\par
21177   \{\par
21178     while (i < n)\par
21179     \{\par
21180       while (i < n && qIsNaN(lineData->at(i).x())) // seek next non-NaN data point\par
21181         ++i;\par
21182       if (i == n)\par
21183         break;\par
21184       currentSegment.setBegin(i++);\par
21185       while (i < n && !qIsNaN(lineData->at(i).x())) // seek next NaN data point or end of data\par
21186         ++i;\par
21187       currentSegment.setEnd(i++);\par
21188       result.append(currentSegment);\par
21189     \}\par
21190   \}\par
21191   return result;\par
21192 \}\par
}
}
{\xe \v getOptimizedLineData\:QCPGraph}
{\xe \v QCPGraph\:getOptimizedLineData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getOptimizedLineData (QVector< {\b QCPGraphData} > *  {\i lineData}, const {\b QCPGraphDataContainer::const_iterator} &  {\i begin}, const {\b QCPGraphDataContainer::const_iterator} &  {\i end}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20852 \{\par
20853   if (!lineData) return;\par
20854   QCPAxis *keyAxis = mKeyAxis.data();\par
20855   QCPAxis *valueAxis = mValueAxis.data();\par
20856   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
20857   if (begin == end) return;\par
20858   \par
20859   int dataCount = end-begin;\par
20860   int maxCount = std::numeric_limits<int>::max();\par
20861   if (mAdaptiveSampling)\par
20862   \{\par
20863     double keyPixelSpan = qAbs(keyAxis->coordToPixel(begin->key)-keyAxis->coordToPixel((end-1)->key));\par
20864     if (2*keyPixelSpan+2 < (double)std::numeric_limits<int>::max())\par
20865       maxCount = 2*keyPixelSpan+2;\par
20866   \}\par
20867   \par
20868   if (mAdaptiveSampling && dataCount >= maxCount) // use adaptive sampling only if there are at least two points per pixel on average\par
20869   \{\par
20870     QCPGraphDataContainer::const_iterator it = begin;\par
20871     double minValue = it->value;\par
20872     double maxValue = it->value;\par
20873     QCPGraphDataContainer::const_iterator currentIntervalFirstPoint = it;\par
20874     int reversedFactor = keyAxis->pixelOrientation(); // is used to calculate keyEpsilon pixel into the correct direction\par
20875     int reversedRound = reversedFactor==-1 ? 1 : 0; // is used to switch between floor (normal) and ceil (reversed) rounding of currentIntervalStartKey\par
20876     double currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(begin->key)+reversedRound));\par
20877     double lastIntervalEndKey = currentIntervalStartKey;\par
20878     double keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor)); // interval of one pixel on screen when mapped to plot key coordinates\par
20879     bool keyEpsilonVariable = keyAxis->scaleType() == QCPAxis::stLogarithmic; // indicates whether keyEpsilon needs to be updated after every interval (for log axes)\par
20880     int intervalDataCount = 1;\par
20881     ++it; // advance iterator to second data point because adaptive sampling works in 1 point retrospect\par
20882     while (it != end)\par
20883     \{\par
20884       if (it->key < currentIntervalStartKey+keyEpsilon) // data point is still within same pixel, so skip it and expand value span of this cluster if necessary\par
20885       \{\par
20886         if (it->value < minValue)\par
20887           minValue = it->value;\par
20888         else if (it->value > maxValue)\par
20889           maxValue = it->value;\par
20890         ++intervalDataCount;\par
20891       \} else // new pixel interval started\par
20892       \{\par
20893         if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them to a cluster\par
20894         \{\par
20895           if (lastIntervalEndKey < currentIntervalStartKey-keyEpsilon) // last point is further away, so first point of this cluster must be at a real data point\par
20896             lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.2, currentIntervalFirstPoint->value));\par
20897           lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.25, minValue));\par
20898           lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.75, maxValue));\par
20899           if (it->key > currentIntervalStartKey+keyEpsilon*2) // new pixel started further away from previous cluster, so make sure the last point of the cluster is at a real data point\par
20900             lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.8, (it-1)->value));\par
20901         \} else\par
20902           lineData->append(QCPGraphData(currentIntervalFirstPoint->key, currentIntervalFirstPoint->value));\par
20903         lastIntervalEndKey = (it-1)->key;\par
20904         minValue = it->value;\par
20905         maxValue = it->value;\par
20906         currentIntervalFirstPoint = it;\par
20907         currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(it->key)+reversedRound));\par
20908         if (keyEpsilonVariable)\par
20909           keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor));\par
20910         intervalDataCount = 1;\par
20911       \}\par
20912       ++it;\par
20913     \}\par
20914     // handle last interval:\par
20915     if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them to a cluster\par
20916     \{\par
20917       if (lastIntervalEndKey < currentIntervalStartKey-keyEpsilon) // last point wasn't a cluster, so first point of this cluster must be at a real data point\par
20918         lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.2, currentIntervalFirstPoint->value));\par
20919       lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.25, minValue));\par
20920       lineData->append(QCPGraphData(currentIntervalStartKey+keyEpsilon*0.75, maxValue));\par
20921     \} else\par
20922       lineData->append(QCPGraphData(currentIntervalFirstPoint->key, currentIntervalFirstPoint->value));\par
20923     \par
20924   \} else // don't use adaptive sampling algorithm, transfer points one-to-one from the data container into the output\par
20925   \{\par
20926     lineData->resize(dataCount);\par
20927     std::copy(begin, end, lineData->begin());\par
20928   \}\par
20929 \}\par
}
}
{\xe \v getOptimizedScatterData\:QCPGraph}
{\xe \v QCPGraph\:getOptimizedScatterData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getOptimizedScatterData (QVector< {\b QCPGraphData} > *  {\i scatterData}, {\b QCPGraphDataContainer::const_iterator}  {\i begin}, {\b QCPGraphDataContainer::const_iterator}  {\i end}) const{\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20944 \{\par
20945   if (!scatterData) return;\par
20946   QCPAxis *keyAxis = mKeyAxis.data();\par
20947   QCPAxis *valueAxis = mValueAxis.data();\par
20948   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
20949   \par
20950   const int scatterModulo = mScatterSkip+1;\par
20951   const bool doScatterSkip = mScatterSkip > 0;\par
20952   int beginIndex = begin-mDataContainer->constBegin();\par
20953   int endIndex = end-mDataContainer->constBegin();\par
20954   while (doScatterSkip && begin != end && beginIndex % scatterModulo != 0) // advance begin iterator to first non-skipped scatter\par
20955   \{\par
20956     ++beginIndex;\par
20957     ++begin;\par
20958   \}\par
20959   if (begin == end) return;\par
20960   int dataCount = end-begin;\par
20961   int maxCount = std::numeric_limits<int>::max();\par
20962   if (mAdaptiveSampling)\par
20963   \{\par
20964     int keyPixelSpan = qAbs(keyAxis->coordToPixel(begin->key)-keyAxis->coordToPixel((end-1)->key));\par
20965     maxCount = 2*keyPixelSpan+2;\par
20966   \}\par
20967   \par
20968   if (mAdaptiveSampling && dataCount >= maxCount) // use adaptive sampling only if there are at least two points per pixel on average\par
20969   \{\par
20970     double valueMaxRange = valueAxis->range().upper;\par
20971     double valueMinRange = valueAxis->range().lower;\par
20972     QCPGraphDataContainer::const_iterator it = begin;\par
20973     int itIndex = beginIndex;\par
20974     double minValue = it->value;\par
20975     double maxValue = it->value;\par
20976     QCPGraphDataContainer::const_iterator minValueIt = it;\par
20977     QCPGraphDataContainer::const_iterator maxValueIt = it;\par
20978     QCPGraphDataContainer::const_iterator currentIntervalStart = it;\par
20979     int reversedFactor = keyAxis->pixelOrientation(); // is used to calculate keyEpsilon pixel into the correct direction\par
20980     int reversedRound = reversedFactor==-1 ? 1 : 0; // is used to switch between floor (normal) and ceil (reversed) rounding of currentIntervalStartKey\par
20981     double currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(begin->key)+reversedRound));\par
20982     double keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor)); // interval of one pixel on screen when mapped to plot key coordinates\par
20983     bool keyEpsilonVariable = keyAxis->scaleType() == QCPAxis::stLogarithmic; // indicates whether keyEpsilon needs to be updated after every interval (for log axes)\par
20984     int intervalDataCount = 1;\par
20985     // advance iterator to second (non-skipped) data point because adaptive sampling works in 1 point retrospect:\par
20986     if (!doScatterSkip)\par
20987       ++it;\par
20988     else\par
20989     \{\par
20990       itIndex += scatterModulo;\par
20991       if (itIndex < endIndex) // make sure we didn't jump over end\par
20992         it += scatterModulo;\par
20993       else\par
20994       \{\par
20995         it = end;\par
20996         itIndex = endIndex;\par
20997       \}\par
20998     \}\par
20999     // main loop over data points:\par
21000     while (it != end)\par
21001     \{\par
21002       if (it->key < currentIntervalStartKey+keyEpsilon) // data point is still within same pixel, so skip it and expand value span of this pixel if necessary\par
21003       \{\par
21004         if (it->value < minValue && it->value > valueMinRange && it->value < valueMaxRange)\par
21005         \{\par
21006           minValue = it->value;\par
21007           minValueIt = it;\par
21008         \} else if (it->value > maxValue && it->value > valueMinRange && it->value < valueMaxRange)\par
21009         \{\par
21010           maxValue = it->value;\par
21011           maxValueIt = it;\par
21012         \}\par
21013         ++intervalDataCount;\par
21014       \} else // new pixel started\par
21015       \{\par
21016         if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them\par
21017         \{\par
21018           // determine value pixel span and add as many points in interval to maintain certain vertical data density (this is specific to scatter plot):\par
21019           double valuePixelSpan = qAbs(valueAxis->coordToPixel(minValue)-valueAxis->coordToPixel(maxValue));\par
21020           int dataModulo = qMax(1, qRound(intervalDataCount/(valuePixelSpan/4.0))); // approximately every 4 value pixels one data point on average\par
21021           QCPGraphDataContainer::const_iterator intervalIt = currentIntervalStart;\par
21022           int c = 0;\par
21023           while (intervalIt != it)\par
21024           \{\par
21025             if ((c % dataModulo == 0 || intervalIt == minValueIt || intervalIt == maxValueIt) && intervalIt->value > valueMinRange && intervalIt->value < valueMaxRange)\par
21026               scatterData->append(*intervalIt);\par
21027             ++c;\par
21028             if (!doScatterSkip)\par
21029               ++intervalIt;\par
21030             else\par
21031               intervalIt += scatterModulo; // since we know indices of "currentIntervalStart", "intervalIt" and "it" are multiples of scatterModulo, we can't accidentally jump over "it" here\par
21032           \}\par
21033         \} else if (currentIntervalStart->value > valueMinRange && currentIntervalStart->value < valueMaxRange)\par
21034           scatterData->append(*currentIntervalStart);\par
21035         minValue = it->value;\par
21036         maxValue = it->value;\par
21037         currentIntervalStart = it;\par
21038         currentIntervalStartKey = keyAxis->pixelToCoord((int)(keyAxis->coordToPixel(it->key)+reversedRound));\par
21039         if (keyEpsilonVariable)\par
21040           keyEpsilon = qAbs(currentIntervalStartKey-keyAxis->pixelToCoord(keyAxis->coordToPixel(currentIntervalStartKey)+1.0*reversedFactor));\par
21041         intervalDataCount = 1;\par
21042       \}\par
21043       // advance to next data point:\par
21044       if (!doScatterSkip)\par
21045         ++it;\par
21046       else\par
21047       \{\par
21048         itIndex += scatterModulo;\par
21049         if (itIndex < endIndex) // make sure we didn't jump over end\par
21050           it += scatterModulo;\par
21051         else\par
21052         \{\par
21053           it = end;\par
21054           itIndex = endIndex;\par
21055         \}\par
21056       \}\par
21057     \}\par
21058     // handle last interval:\par
21059     if (intervalDataCount >= 2) // last pixel had multiple data points, consolidate them\par
21060     \{\par
21061       // determine value pixel span and add as many points in interval to maintain certain vertical data density (this is specific to scatter plot):\par
21062       double valuePixelSpan = qAbs(valueAxis->coordToPixel(minValue)-valueAxis->coordToPixel(maxValue));\par
21063       int dataModulo = qMax(1, qRound(intervalDataCount/(valuePixelSpan/4.0))); // approximately every 4 value pixels one data point on average\par
21064       QCPGraphDataContainer::const_iterator intervalIt = currentIntervalStart;\par
21065       int intervalItIndex = intervalIt-mDataContainer->constBegin();\par
21066       int c = 0;\par
21067       while (intervalIt != it)\par
21068       \{\par
21069         if ((c % dataModulo == 0 || intervalIt == minValueIt || intervalIt == maxValueIt) && intervalIt->value > valueMinRange && intervalIt->value < valueMaxRange)\par
21070           scatterData->append(*intervalIt);\par
21071         ++c;\par
21072         if (!doScatterSkip)\par
21073           ++intervalIt;\par
21074         else // here we can't guarantee that adding scatterModulo doesn't exceed "it" (because "it" is equal to "end" here, and "end" isn't scatterModulo-aligned), so check via index comparison:\par
21075         \{\par
21076           intervalItIndex += scatterModulo;\par
21077           if (intervalItIndex < itIndex)\par
21078             intervalIt += scatterModulo;\par
21079           else\par
21080           \{\par
21081             intervalIt = it;\par
21082             intervalItIndex = itIndex;\par
21083           \}\par
21084         \}\par
21085       \}\par
21086     \} else if (currentIntervalStart->value > valueMinRange && currentIntervalStart->value < valueMaxRange)\par
21087       scatterData->append(*currentIntervalStart);\par
21088     \par
21089   \} else // don't use adaptive sampling algorithm, transfer points one-to-one from the data container into the output\par
21090   \{\par
21091     QCPGraphDataContainer::const_iterator it = begin;\par
21092     int itIndex = beginIndex;\par
21093     scatterData->reserve(dataCount);\par
21094     while (it != end)\par
21095     \{\par
21096       scatterData->append(*it);\par
21097       // advance to next data point:\par
21098       if (!doScatterSkip)\par
21099         ++it;\par
21100       else\par
21101       \{\par
21102         itIndex += scatterModulo;\par
21103         if (itIndex < endIndex)\par
21104           it += scatterModulo;\par
21105         else\par
21106         \{\par
21107           it = end;\par
21108           itIndex = endIndex;\par
21109         \}\par
21110       \}\par
21111     \}\par
21112   \}\par
21113 \}\par
}
}
{\xe \v getOverlappingSegments\:QCPGraph}
{\xe \v QCPGraph\:getOverlappingSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVector< QPair< {\b QCPDataRange}, {\b QCPDataRange} > > QCPGraph::getOverlappingSegments (QVector< {\b QCPDataRange} >  {\i thisSegments}, const QVector< QPointF > *  {\i thisData}, QVector< {\b QCPDataRange} >  {\i otherSegments}, const QVector< QPointF > *  {\i otherData}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21213 \{\par
21214   QVector<QPair<QCPDataRange, QCPDataRange> > result;\par
21215   if (thisData->isEmpty() || otherData->isEmpty() || thisSegments.isEmpty() || otherSegments.isEmpty())\par
21216     return result;\par
21217   \par
21218   int thisIndex = 0;\par
21219   int otherIndex = 0;\par
21220   const bool verticalKey = mKeyAxis->orientation() == Qt::Vertical;\par
21221   while (thisIndex < thisSegments.size() && otherIndex < otherSegments.size())\par
21222   \{\par
21223     if (thisSegments.at(thisIndex).size() < 2) // segments with fewer than two points won't have a fill anyhow\par
21224     \{\par
21225       ++thisIndex;\par
21226       continue;\par
21227     \}\par
21228     if (otherSegments.at(otherIndex).size() < 2) // segments with fewer than two points won't have a fill anyhow\par
21229     \{\par
21230       ++otherIndex;\par
21231       continue;\par
21232     \}\par
21233     double thisLower, thisUpper, otherLower, otherUpper;\par
21234     if (!verticalKey)\par
21235     \{\par
21236       thisLower = thisData->at(thisSegments.at(thisIndex).begin()).x();\par
21237       thisUpper = thisData->at(thisSegments.at(thisIndex).end()-1).x();\par
21238       otherLower = otherData->at(otherSegments.at(otherIndex).begin()).x();\par
21239       otherUpper = otherData->at(otherSegments.at(otherIndex).end()-1).x();\par
21240     \} else\par
21241     \{\par
21242       thisLower = thisData->at(thisSegments.at(thisIndex).begin()).y();\par
21243       thisUpper = thisData->at(thisSegments.at(thisIndex).end()-1).y();\par
21244       otherLower = otherData->at(otherSegments.at(otherIndex).begin()).y();\par
21245       otherUpper = otherData->at(otherSegments.at(otherIndex).end()-1).y();\par
21246     \}\par
21247     \par
21248     int bPrecedence;\par
21249     if (segmentsIntersect(thisLower, thisUpper, otherLower, otherUpper, bPrecedence))\par
21250       result.append(QPair<QCPDataRange, QCPDataRange>(thisSegments.at(thisIndex), otherSegments.at(otherIndex)));\par
21251     \par
21252     if (bPrecedence <= 0) // otherSegment doesn't reach as far as thisSegment, so continue with next otherSegment, keeping current thisSegment\par
21253       ++otherIndex;\par
21254     else // otherSegment reaches further than thisSegment, so continue with next thisSegment, keeping current otherSegment\par
21255       ++thisIndex;\par
21256   \}\par
21257   \par
21258   return result;\par
21259 \}\par
}
}
{\xe \v getScatters\:QCPGraph}
{\xe \v QCPGraph\:getScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getScatters (QVector< QPointF > *  {\i scatters}, const {\b QCPDataRange} &  {\i dataRange}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20461 \{\par
20462   if (!scatters) return;\par
20463   QCPAxis *keyAxis = mKeyAxis.data();\par
20464   QCPAxis *valueAxis = mValueAxis.data();\par
20465   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; scatters->clear(); return; \}\par
20466   \par
20467   QCPGraphDataContainer::const_iterator begin, end;\par
20468   getVisibleDataBounds(begin, end, dataRange);\par
20469   if (begin == end)\par
20470   \{\par
20471     scatters->clear();\par
20472     return;\par
20473   \}\par
20474   \par
20475   QVector<QCPGraphData> data;\par
20476   getOptimizedScatterData(&data, begin, end);\par
20477   \par
20478   if (mKeyAxis->rangeReversed() != (mKeyAxis->orientation() == Qt::Vertical)) // make sure key pixels are sorted ascending in data (significantly simplifies following processing)\par
20479     std::reverse(data.begin(), data.end());\par
20480   \par
20481   scatters->resize(data.size());\par
20482   if (keyAxis->orientation() == Qt::Vertical)\par
20483   \{\par
20484     for (int i=0; i<data.size(); ++i)\par
20485     \{\par
20486       if (!qIsNaN(data.at(i).value))\par
20487       \{\par
20488         (*scatters)[i].setX(valueAxis->coordToPixel(data.at(i).value));\par
20489         (*scatters)[i].setY(keyAxis->coordToPixel(data.at(i).key));\par
20490       \}\par
20491     \}\par
20492   \} else\par
20493   \{\par
20494     for (int i=0; i<data.size(); ++i)\par
20495     \{\par
20496       if (!qIsNaN(data.at(i).value))\par
20497       \{\par
20498         (*scatters)[i].setX(keyAxis->coordToPixel(data.at(i).key));\par
20499         (*scatters)[i].setY(valueAxis->coordToPixel(data.at(i).value));\par
20500       \}\par
20501     \}\par
20502   \}\par
20503 \}\par
}
}
{\xe \v getValueRange\:QCPGraph}
{\xe \v QCPGraph\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPGraph::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implementa {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20292 \{\par
20293   return mDataContainer->valueRange(foundRange, inSignDomain, inKeyRange);\par
20294 \}\par
}
}
{\xe \v getVisibleDataBounds\:QCPGraph}
{\xe \v QCPGraph\:getVisibleDataBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::getVisibleDataBounds ({\b QCPGraphDataContainer::const_iterator} &  {\i begin}, {\b QCPGraphDataContainer::const_iterator} &  {\i end}, const {\b QCPDataRange} &  {\i rangeRestriction}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method outputs the currently visible data range via {\i begin}  and {\i end} . The returned range will also never exceed {\i rangeRestriction} .\par
This method takes into account that the drawing of data lines at the axis rect border always requires the points just outside the visible axis range. So {\i begin}  and {\i end}  may actually indicate a range that contains one additional data point to the left and right of the visible axis range. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21125 \{\par
21126   if (rangeRestriction.isEmpty())\par
21127   \{\par
21128     end = mDataContainer->constEnd();\par
21129     begin = end;\par
21130   \} else\par
21131   \{\par
21132     QCPAxis *keyAxis = mKeyAxis.data();\par
21133     QCPAxis *valueAxis = mValueAxis.data();\par
21134     if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
21135     // get visible data range:\par
21136     begin = mDataContainer->findBegin(keyAxis->range().lower);\par
21137     end = mDataContainer->findEnd(keyAxis->range().upper);\par
21138     // limit lower/upperEnd to rangeRestriction:\par
21139     mDataContainer->limitIteratorsToDataRange(begin, end, rangeRestriction); // this also ensures rangeRestriction outside data bounds doesn't break anything\par
21140   \}\par
21141 \}\par
}
}
{\xe \v initializeParentPlot\:QCPGraph}
{\xe \v QCPGraph\:initializeParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::initializeParentPlot ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1497 \{\par
 1498   if (mParentPlot)\par
 1499   \{\par
 1500     qDebug() << Q_FUNC_INFO << "called with mParentPlot already initialized";\par
 1501     return;\par
 1502   \}\par
 1503   \par
 1504   if (!parentPlot)\par
 1505     qDebug() << Q_FUNC_INFO << "called with parentPlot zero";\par
 1506   \par
 1507   mParentPlot = parentPlot;\par
 1508   parentPlotInitialized(mParentPlot);\par
 1509 \}\par
}
}
{\xe \v interface1D\:QCPGraph}
{\xe \v QCPGraph\:interface1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPPlottableInterface1D} * {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::interface1D (){\f2 [inline]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPPlottableInterface1D} pointer to this plottable, providing access to its 1D interface.\par
}{
Reimplementa {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3890 \{ return this; \}\par
}
}
{\xe \v keyAxis\:QCPGraph}
{\xe \v QCPGraph\:keyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis}* QCPAbstractPlottable::keyAxis () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3312 \{ return mKeyAxis.data(); \}\par
}
}
{\xe \v layer\:QCPGraph}
{\xe \v QCPGraph\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::layer () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   710 \{ return mLayer; \}\par
}
}
{\xe \v layerChanged\:QCPGraph}
{\xe \v QCPGraph\:layerChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::layerChanged ({\b QCPLayer} *  {\i newLayer}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLayer} \par
}}}
{\xe \v lineStyle\:QCPGraph}
{\xe \v QCPGraph\:lineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LineStyle} QCPGraph::lineStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5183 \{ return mLineStyle; \}\par
}
}
{\xe \v mouseDoubleClickEvent\:QCPGraph}
{\xe \v QCPGraph\:mouseDoubleClickEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseDoubleClickEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The {\b mouseDoubleClickEvent} is called instead of the second {\b mousePressEvent}. So in the case of a double-click, the event succession is {\i pressEvent \'96 releaseEvent \'96 doubleClickEvent \'96 releaseEvent} .\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
Similarly to {\b mousePressEvent}, once a layerable has accepted the {\b mouseDoubleClickEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} and {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1777 \{\par
 1778   Q_UNUSED(details)\par
 1779   event->ignore();\par
 1780 \}\par
}
}
{\xe \v mouseMoveEvent\:QCPGraph}
{\xe \v QCPGraph\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseMoveEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1727 \{\par
 1728   Q_UNUSED(startPos)\par
 1729   event->ignore();\par
 1730 \}\par
}
}
{\xe \v mousePressEvent\:QCPGraph}
{\xe \v QCPGraph\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mousePressEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
{\b QCustomPlot} uses an event propagation system that works the same as Qt's system. If your layerable doesn't reimplement the {\b mousePressEvent} or explicitly calls {\f2 event->ignore()}  in its reimplementation, the event will be propagated to the next layerable in the stacking order.\par
Once a layerable has accepted the {\b mousePressEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} or {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGQ \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1709 \{\par
 1710   Q_UNUSED(details)\par
 1711   event->ignore();\par
 1712 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPGraph}
{\xe \v QCPGraph\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseReleaseEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGV \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1745 \{\par
 1746   Q_UNUSED(startPos)\par
 1747   event->ignore();\par
 1748 \}\par
}
}
{\xe \v moveToLayer\:QCPGraph}
{\xe \v QCPGraph\:moveToLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::moveToLayer ({\b QCPLayer} *  {\i layer}, bool  {\i prepend}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1536 \{\par
 1537   if (layer && !mParentPlot)\par
 1538   \{\par
 1539     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1540     return false;\par
 1541   \}\par
 1542   if (layer && layer->parentPlot() != mParentPlot)\par
 1543   \{\par
 1544     qDebug() << Q_FUNC_INFO << "layer" << layer->name() << "is not in same QCustomPlot as this layerable";\par
 1545     return false;\par
 1546   \}\par
 1547   \par
 1548   QCPLayer *oldLayer = mLayer;\par
 1549   if (mLayer)\par
 1550     mLayer->removeChild(this);\par
 1551   mLayer = layer;\par
 1552   if (mLayer)\par
 1553     mLayer->addChild(this, prepend);\par
 1554   if (mLayer != oldLayer)\par
 1555     emit layerChanged(mLayer);\par
 1556   return true;\par
 1557 \}\par
}
}
{\xe \v name\:QCPGraph}
{\xe \v QCPGraph\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAbstractPlottable::name () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3307 \{ return mName; \}\par
}
}
{\xe \v parentLayerable\:QCPGraph}
{\xe \v QCPGraph\:parentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayerable} * QCPLayerable::parentLayerable () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method {\b realVisibility}. This way, layerables only get drawn if their parent layerables are visible, too.\par
Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn't always have a parent layerable, so this function may return 0.\par
A parent layerable is set implicitly when placed inside layout elements and doesn't need to be set manually by the user. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   709 \{ return mParentLayerable.data(); \}\par
}
}
{\xe \v parentPlot\:QCPGraph}
{\xe \v QCPGraph\:parentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::parentPlot () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   708 \{ return mParentPlot; \}\par
}
}
{\xe \v parentPlotInitialized\:QCPGraph}
{\xe \v QCPGraph\:parentPlotInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::parentPlotInitialized ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1593 \{\par
 1594    Q_UNUSED(parentPlot)\par
 1595 \}\par
}
}
{\xe \v pen\:QCPGraph}
{\xe \v QCPGraph\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAbstractPlottable::pen () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3310 \{ return mPen; \}\par
}
}
{\xe \v pixelsToCoords\:QCPGraph}
{\xe \v QCPGraph\:pixelsToCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::pixelsToCoords (double  {\i x}, double  {\i y}, double &  {\i key}, double &  {\i value}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function for transforming a x/y pixel pair on the {\b QCustomPlot} surface to plot coordinates, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).\par
{\i x}  and {\i y}  are transformed to the plot coodinates and are written to {\i key}  and {\i value} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b coordsToPixels}, {\b QCPAxis::coordToPixel} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10945 \{\par
10946   QCPAxis *keyAxis = mKeyAxis.data();\par
10947   QCPAxis *valueAxis = mValueAxis.data();\par
10948   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
10949   \par
10950   if (keyAxis->orientation() == Qt::Horizontal)\par
10951   \{\par
10952     key = keyAxis->pixelToCoord(x);\par
10953     value = valueAxis->pixelToCoord(y);\par
10954   \} else\par
10955   \{\par
10956     key = keyAxis->pixelToCoord(y);\par
10957     value = valueAxis->pixelToCoord(x);\par
10958   \}\par
10959 \}\par
}
}
{\xe \v pixelsToCoords\:QCPGraph}
{\xe \v QCPGraph\:pixelsToCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::pixelsToCoords (const QPointF &  {\i pixelPos}, double &  {\i key}, double &  {\i value}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Returns the pixel input {\i pixelPos}  as plot coordinates {\i key}  and {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10966 \{\par
10967   pixelsToCoords(pixelPos.x(), pixelPos.y(), key, value);\par
10968 \}\par
}
}
{\xe \v pointDistance\:QCPGraph}
{\xe \v QCPGraph\:pointDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPGraph::pointDistance (const QPointF &  {\i pixelPoint}, {\b QCPGraphDataContainer::const_iterator} &  {\i closestData}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21578 \{\par
21579   closestData = mDataContainer->constEnd();\par
21580   if (mDataContainer->isEmpty())\par
21581     return -1.0;\par
21582   if (mLineStyle == lsNone && mScatterStyle.isNone())\par
21583     return -1.0;\par
21584   \par
21585   // calculate minimum distances to graph data points and find closestData iterator:\par
21586   double minDistSqr = std::numeric_limits<double>::max();\par
21587   // determine which key range comes into question, taking selection tolerance around pos into account:\par
21588   double posKeyMin, posKeyMax, dummy;\par
21589   pixelsToCoords(pixelPoint-QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMin, dummy);\par
21590   pixelsToCoords(pixelPoint+QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMax, dummy);\par
21591   if (posKeyMin > posKeyMax)\par
21592     qSwap(posKeyMin, posKeyMax);\par
21593   // iterate over found data points and then choose the one with the shortest distance to pos:\par
21594   QCPGraphDataContainer::const_iterator begin = mDataContainer->findBegin(posKeyMin, true);\par
21595   QCPGraphDataContainer::const_iterator end = mDataContainer->findEnd(posKeyMax, true);\par
21596   for (QCPGraphDataContainer::const_iterator it=begin; it!=end; ++it)\par
21597   \{\par
21598     const double currentDistSqr = QCPVector2D(coordsToPixels(it->key, it->value)-pixelPoint).lengthSquared();\par
21599     if (currentDistSqr < minDistSqr)\par
21600     \{\par
21601       minDistSqr = currentDistSqr;\par
21602       closestData = it;\par
21603     \}\par
21604   \}\par
21605     \par
21606   // calculate distance to graph line if there is one (if so, will probably be smaller than distance to closest data point):\par
21607   if (mLineStyle != lsNone)\par
21608   \{\par
21609     // line displayed, calculate distance to line segments:\par
21610     QVector<QPointF> lineData;\par
21611     getLines(&lineData, QCPDataRange(0, dataCount()));\par
21612     QCPVector2D p(pixelPoint);\par
21613     const int step = mLineStyle==lsImpulse ? 2 : 1; // impulse plot differs from other line styles in that the lineData points are only pairwise connected\par
21614     for (int i=0; i<lineData.size()-1; i+=step)\par
21615     \{\par
21616       const double currentDistSqr = p.distanceSquaredToLine(lineData.at(i), lineData.at(i+1));\par
21617       if (currentDistSqr < minDistSqr)\par
21618         minDistSqr = currentDistSqr;\par
21619     \}\par
21620   \}\par
21621   \par
21622   return qSqrt(minDistSqr);\par
21623 \}\par
}
}
{\xe \v realVisibility\:QCPGraph}
{\xe \v QCPGraph\:realVisibility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::realVisibility () const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable's layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.\par
If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of {\b QCPLayoutElement}), this function returns true only if this layerable has its visibility set to true and the parent layerable's {\b realVisibility} returns true. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1433 \{\par
 1434   return mVisible && (!mLayer || mLayer->visible()) && (!mParentLayerable || mParentLayerable.data()->realVisibility());\par
 1435 \}\par
}
}
{\xe \v removeFromLegend\:QCPGraph}
{\xe \v QCPGraph\:removeFromLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::removeFromLegend ({\b QCPLegend} *  {\i legend}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Removes the plottable from the specifed {\i legend} . This means the {\b QCPPlottableLegendItem} that is associated with this plottable is removed.\par
Returns true on success, i.e. if the legend exists and a legend item associated with this plottable was found and removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addToLegend}, {\b QCPLegend::removeItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11129 \{\par
11130   if (!legend)\par
11131   \{\par
11132     qDebug() << Q_FUNC_INFO << "passed legend is null";\par
11133     return false;\par
11134   \}\par
11135   \par
11136   if (QCPPlottableLegendItem *lip = legend->itemWithPlottable(this))\par
11137     return legend->removeItem(lip);\par
11138   else\par
11139     return false;\par
11140 \}\par
}
}
{\xe \v removeFromLegend\:QCPGraph}
{\xe \v QCPGraph\:removeFromLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::removeFromLegend () const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Removes the plottable from the legend of the parent {\b QCustomPlot}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addToLegend} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11149 \{\par
11150   if (!mParentPlot || !mParentPlot->legend)\par
11151     return false;\par
11152   else\par
11153     return removeFromLegend(mParentPlot->legend);\par
11154 \}\par
}
}
{\xe \v rescaleAxes\:QCPGraph}
{\xe \v QCPGraph\:rescaleAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::rescaleAxes (bool  {\i onlyEnlarge} = {\f2 false}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i.e. a range containing different signs and/or zero. Instead it will stay in the current sign domain and ignore all parts of the plottable that lie outside of that domain.\par
{\i onlyEnlarge}  makes sure the ranges are only expanded, never reduced. So it's possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has {\i onlyEnlarge}  set to false (the default), and all subsequent set to true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleKeyAxis}, {\b rescaleValueAxis}, {\b QCustomPlot::rescaleAxes}, {\b QCPAxis::rescale} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10984 \{\par
10985   rescaleKeyAxis(onlyEnlarge);\par
10986   rescaleValueAxis(onlyEnlarge);\par
10987 \}\par
}
}
{\xe \v rescaleKeyAxis\:QCPGraph}
{\xe \v QCPGraph\:rescaleKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::rescaleKeyAxis (bool  {\i onlyEnlarge} = {\f2 false}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the key axis of the plottable so the whole plottable is visible.\par
See {\b rescaleAxes} for detailed behaviour. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10995 \{\par
10996   QCPAxis *keyAxis = mKeyAxis.data();\par
10997   if (!keyAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key axis"; return; \}\par
10998   \par
10999   QCP::SignDomain signDomain = QCP::sdBoth;\par
11000   if (keyAxis->scaleType() == QCPAxis::stLogarithmic)\par
11001     signDomain = (keyAxis->range().upper < 0 ? QCP::sdNegative : QCP::sdPositive);\par
11002   \par
11003   bool foundRange;\par
11004   QCPRange newRange = getKeyRange(foundRange, signDomain);\par
11005   if (foundRange)\par
11006   \{\par
11007     if (onlyEnlarge)\par
11008       newRange.expand(keyAxis->range());\par
11009     if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable\par
11010     \{\par
11011       double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason\par
11012       if (keyAxis->scaleType() == QCPAxis::stLinear)\par
11013       \{\par
11014         newRange.lower = center-keyAxis->range().size()/2.0;\par
11015         newRange.upper = center+keyAxis->range().size()/2.0;\par
11016       \} else // scaleType() == stLogarithmic\par
11017       \{\par
11018         newRange.lower = center/qSqrt(keyAxis->range().upper/keyAxis->range().lower);\par
11019         newRange.upper = center*qSqrt(keyAxis->range().upper/keyAxis->range().lower);\par
11020       \}\par
11021     \}\par
11022     keyAxis->setRange(newRange);\par
11023   \}\par
11024 \}\par
}
}
{\xe \v rescaleValueAxis\:QCPGraph}
{\xe \v QCPGraph\:rescaleValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::rescaleValueAxis (bool  {\i onlyEnlarge} = {\f2 false}, bool  {\i inKeyRange} = {\f2 false}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the value axis of the plottable so the whole plottable is visible. If {\i inKeyRange}  is set to true, only the data points which are in the currently visible key axis range are considered.\par
Returns true if the axis was actually scaled. This might not be the case if this plottable has an invalid range, e.g. because it has no data points.\par
See {\b rescaleAxes} for detailed behaviour. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11037 \{\par
11038   QCPAxis *keyAxis = mKeyAxis.data();\par
11039   QCPAxis *valueAxis = mValueAxis.data();\par
11040   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
11041   \par
11042   QCP::SignDomain signDomain = QCP::sdBoth;\par
11043   if (valueAxis->scaleType() == QCPAxis::stLogarithmic)\par
11044     signDomain = (valueAxis->range().upper < 0 ? QCP::sdNegative : QCP::sdPositive);\par
11045   \par
11046   bool foundRange;\par
11047   QCPRange newRange = getValueRange(foundRange, signDomain, inKeyRange ? keyAxis->range() : QCPRange());\par
11048   if (foundRange)\par
11049   \{\par
11050     if (onlyEnlarge)\par
11051       newRange.expand(valueAxis->range());\par
11052     if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable\par
11053     \{\par
11054       double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason\par
11055       if (valueAxis->scaleType() == QCPAxis::stLinear)\par
11056       \{\par
11057         newRange.lower = center-valueAxis->range().size()/2.0;\par
11058         newRange.upper = center+valueAxis->range().size()/2.0;\par
11059       \} else // scaleType() == stLogarithmic\par
11060       \{\par
11061         newRange.lower = center/qSqrt(valueAxis->range().upper/valueAxis->range().lower);\par
11062         newRange.upper = center*qSqrt(valueAxis->range().upper/valueAxis->range().lower);\par
11063       \}\par
11064     \}\par
11065     valueAxis->setRange(newRange);\par
11066   \}\par
11067 \}\par
}
}
{\xe \v scatterSkip\:QCPGraph}
{\xe \v QCPGraph\:scatterSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::scatterSkip () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5185 \{ return mScatterSkip; \}\par
}
}
{\xe \v scatterStyle\:QCPGraph}
{\xe \v QCPGraph\:scatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPGraph::scatterStyle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  5184 \{ return mScatterStyle; \}\par
}
}
{\xe \v segmentsIntersect\:QCPGraph}
{\xe \v QCPGraph\:segmentsIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGraph::segmentsIntersect (double  {\i aLower}, double  {\i aUpper}, double  {\i bLower}, double  {\i bUpper}, int &  {\i bPrecedence}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21276 \{\par
21277   bPrecedence = 0;\par
21278   if (aLower > bUpper)\par
21279   \{\par
21280     bPrecedence = -1;\par
21281     return false;\par
21282   \} else if (bLower > aUpper)\par
21283   \{\par
21284     bPrecedence = 1;\par
21285     return false;\par
21286   \} else\par
21287   \{\par
21288     if (aUpper > bUpper)\par
21289       bPrecedence = -1;\par
21290     else if (aUpper < bUpper)\par
21291       bPrecedence = 1;\par
21292     \par
21293     return true;\par
21294   \}\par
21295 \}\par
}
}
{\xe \v selectable\:QCPGraph}
{\xe \v QCPGraph\:selectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionType} QCPAbstractPlottable::selectable () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3314 \{ return mSelectable; \}\par
}
}
{\xe \v selectableChanged\:QCPGraph}
{\xe \v QCPGraph\:selectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectableChanged ({\b QCP::SelectionType}  {\i selectable}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selectability of this plottable has changed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectable} \par
}}}
{\xe \v selected\:QCPGraph}
{\xe \v QCPGraph\:selected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::selected () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if there are any data points of the plottable currently selected. Use {\b selection} to retrieve the current {\b QCPDataSelection}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3315 \{ return !mSelection.isEmpty(); \}\par
}
}
{\xe \v selectEvent\:QCPGraph}
{\xe \v QCPGraph\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11225 \{\par
11226   Q_UNUSED(event)\par
11227   \par
11228   if (mSelectable != QCP::stNone)\par
11229   \{\par
11230     QCPDataSelection newSelection = details.value<QCPDataSelection>();\par
11231     QCPDataSelection selectionBefore = mSelection;\par
11232     if (additive)\par
11233     \{\par
11234       if (mSelectable == QCP::stWhole) // in whole selection mode, we toggle to no selection even if currently unselected point was hit\par
11235       \{\par
11236         if (selected())\par
11237           setSelection(QCPDataSelection());\par
11238         else\par
11239           setSelection(newSelection);\par
11240       \} else // in all other selection modes we toggle selections of homogeneously selected/unselected segments\par
11241       \{\par
11242         if (mSelection.contains(newSelection)) // if entire newSelection is already selected, toggle selection\par
11243           setSelection(mSelection-newSelection);\par
11244         else\par
11245           setSelection(mSelection+newSelection);\par
11246       \}\par
11247     \} else\par
11248       setSelection(newSelection);\par
11249     if (selectionStateChanged)\par
11250       *selectionStateChanged = mSelection != selectionBefore;\par
11251   \}\par
11252 \}\par
}
}
{\xe \v selection\:QCPGraph}
{\xe \v QCPGraph\:selection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPAbstractPlottable::selection () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPDataSelection} encompassing all the data points that are currently selected on this plottable.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selected}, {\b setSelection}, {\b setSelectable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3316 \{ return mSelection; \}\par
}
}
{\xe \v selectionCategory\:QCPGraph}
{\xe \v QCPGraph\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPAbstractPlottable::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11167 \{\par
11168   return QCP::iSelectPlottables;\par
11169 \}\par
}
}
{\xe \v selectionChanged\:QCPGraph}
{\xe \v QCPGraph\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectionChanged (bool  {\i selected}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to {\b setSelection}. The parameter {\i selected}  indicates whether there are any points selected or not.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectionChanged(const QCPDataSelection &selection)} \par
}}}
{\xe \v selectionChanged\:QCPGraph}
{\xe \v QCPGraph\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectionChanged (const {\b QCPDataSelection} &  {\i selection}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to {\b setSelection}. The parameter {\i selection}  holds the currently selected data ranges.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectionChanged(bool selected)} \par
}}}
{\xe \v selectionDecorator\:QCPGraph}
{\xe \v QCPGraph\:selectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionDecorator} * QCPAbstractPlottable::selectionDecorator () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides access to the selection decorator of this plottable. The selection decorator controls how selected data ranges are drawn (e.g. their pen color and fill), see {\b QCPSelectionDecorator} for details.\par
If you wish to use an own {\b QCPSelectionDecorator} subclass, pass an instance of it to {\b setSelectionDecorator}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3317 \{ return mSelectionDecorator; \}\par
}
}
{\xe \v selectTest\:QCPGraph}
{\xe \v QCPGraph\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double QCPGraph::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Reimplementa {\b QCPAbstractPlottable1D< QCPGraphData >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20264 \{\par
20265   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
20266     return -1;\par
20267   if (!mKeyAxis || !mValueAxis)\par
20268     return -1;\par
20269   \par
20270   if (mKeyAxis.data()->axisRect()->rect().contains(pos.toPoint()))\par
20271   \{\par
20272     QCPGraphDataContainer::const_iterator closestDataPoint = mDataContainer->constEnd();\par
20273     double result = pointDistance(pos, closestDataPoint);\par
20274     if (details)\par
20275     \{\par
20276       int pointIndex = closestDataPoint-mDataContainer->constBegin();\par
20277       details->setValue(QCPDataSelection(QCPDataRange(pointIndex, pointIndex+1)));\par
20278     \}\par
20279     return result;\par
20280   \} else\par
20281     return -1;\par
20282 \}\par
}
}
{\xe \v selectTestRect\:QCPGraph}
{\xe \v QCPGraph\:selectTestRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::selectTestRect (const QRectF &  {\i rect}, bool  {\i onlySelectable}) const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a rect-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4215 \{\par
 4216   QCPDataSelection result;\par
 4217   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
 4218     return result;\par
 4219   if (!mKeyAxis || !mValueAxis)\par
 4220     return result;\par
 4221   \par
 4222   // convert rect given in pixels to ranges given in plot coordinates:\par
 4223   double key1, value1, key2, value2;\par
 4224   pixelsToCoords(rect.topLeft(), key1, value1);\par
 4225   pixelsToCoords(rect.bottomRight(), key2, value2);\par
 4226   QCPRange keyRange(key1, key2); // QCPRange normalizes internally so we don't have to care about whether key1 < key2\par
 4227   QCPRange valueRange(value1, value2);\par
 4228   typename QCPDataContainer<DataType>::const_iterator begin = mDataContainer->constBegin();\par
 4229   typename QCPDataContainer<DataType>::const_iterator end = mDataContainer->constEnd();\par
 4230   if (DataType::sortKeyIsMainKey()) // we can assume that data is sorted by main key, so can reduce the searched key interval:\par
 4231   \{\par
 4232     begin = mDataContainer->findBegin(keyRange.lower, false);\par
 4233     end = mDataContainer->findEnd(keyRange.upper, false);\par
 4234   \}\par
 4235   if (begin == end)\par
 4236     return result;\par
 4237   \par
 4238   int currentSegmentBegin = -1; // -1 means we're currently not in a segment that's contained in rect\par
 4239   for (typename QCPDataContainer<DataType>::const_iterator it=begin; it!=end; ++it)\par
 4240   \{\par
 4241     if (currentSegmentBegin == -1)\par
 4242     \{\par
 4243       if (valueRange.contains(it->mainValue()) && keyRange.contains(it->mainKey())) // start segment\par
 4244         currentSegmentBegin = it-mDataContainer->constBegin();\par
 4245     \} else if (!valueRange.contains(it->mainValue()) || !keyRange.contains(it->mainKey())) // segment just ended\par
 4246     \{\par
 4247       result.addDataRange(QCPDataRange(currentSegmentBegin, it-mDataContainer->constBegin()), false);\par
 4248       currentSegmentBegin = -1;\par
 4249     \}\par
 4250   \}\par
 4251   // process potential last segment:\par
 4252   if (currentSegmentBegin != -1)\par
 4253     result.addDataRange(QCPDataRange(currentSegmentBegin, end-mDataContainer->constBegin()), false);\par
 4254   \par
 4255   result.simplify();\par
 4256   return result;\par
 4257 \}\par
}
}
{\xe \v setAdaptiveSampling\:QCPGraph}
{\xe \v QCPGraph\:setAdaptiveSampling}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setAdaptiveSampling (bool  {\i enabled})}}
\par
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether adaptive sampling shall be used when plotting this graph. {\b QCustomPlot}'s adaptive sampling technique can drastically improve the replot performance for graphs with a larger number of points (e.g. above 10,000), without notably changing the appearance of the graph.\par
By default, adaptive sampling is enabled. Even if enabled, {\b QCustomPlot} decides whether adaptive sampling shall actually be used on a per-graph basis. So leaving adaptive sampling enabled has no disadvantage in almost all cases.\par
 As can be seen, line plots experience no visual degradation from adaptive sampling. Outliers are reproduced reliably, as well as the overall shape of the data set. The replot time reduces dramatically though. This allows {\b QCustomPlot} to display large amounts of data in realtime.\par
 Care must be taken when using high-density scatter plots in combination with adaptive sampling. The adaptive sampling algorithm treats scatter plots more carefully than line plots which still gives a significant reduction of replot times, but not quite as much as for line plots. This is because scatter plots inherently need more data points to be preserved in order to still resemble the original, non-adaptive-sampling plot. As shown above, the results still aren't quite identical, as banding occurs for the outer data points. This is in fact intentional, such that the boundaries of the data cloud stay visible to the viewer. How strong the banding appears, depends on the point density, i.e. the number of points in the plot.\par
For some situations with scatter plots it might thus be desirable to manually turn adaptive sampling off. For example, when saving the plot to disk. This can be achieved by setting {\i enabled}  to false before issuing a command like {\b QCustomPlot::savePng}, and setting {\i enabled}  back to true afterwards. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20215 \{\par
20216   mAdaptiveSampling = enabled;\par
20217 \}\par
}
}
{\xe \v setAntialiased\:QCPGraph}
{\xe \v QCPGraph\:setAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setAntialiased (bool  {\i enabled}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this object will be drawn antialiased or not.\par
Note that antialiasing settings may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1418 \{\par
 1419   mAntialiased = enabled;\par
 1420 \}\par
}
}
{\xe \v setAntialiasedFill\:QCPGraph}
{\xe \v QCPGraph\:setAntialiasedFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setAntialiasedFill (bool  {\i enabled}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether fills of this plottable are drawn antialiased or not.\par
Note that this setting may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10736 \{\par
10737   mAntialiasedFill = enabled;\par
10738 \}\par
}
}
{\xe \v setAntialiasedScatters\:QCPGraph}
{\xe \v QCPGraph\:setAntialiasedScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setAntialiasedScatters (bool  {\i enabled}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the scatter symbols of this plottable are drawn antialiased or not.\par
Note that this setting may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10747 \{\par
10748   mAntialiasedScatters = enabled;\par
10749 \}\par
}
}
{\xe \v setBrush\:QCPGraph}
{\xe \v QCPGraph\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setBrush (const QBrush &  {\i brush}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.\par
For example, the {\b QCPGraph} subclass draws the fill under the graph with this brush, when it's not set to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10774 \{\par
10775   mBrush = brush;\par
10776 \}\par
}
}
{\xe \v setChannelFillGraph\:QCPGraph}
{\xe \v QCPGraph\:setChannelFillGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setChannelFillGraph ({\b QCPGraph} *  {\i targetGraph})}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the target graph for filling the area between this graph and {\i targetGraph}  with the current brush ({\b setBrush}).\par
When {\i targetGraph}  is set to 0, a normal graph fill to the zero-value-line will be shown. To disable any filling, set the brush to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20164 \{\par
20165   // prevent setting channel target to this graph itself:\par
20166   if (targetGraph == this)\par
20167   \{\par
20168     qDebug() << Q_FUNC_INFO << "targetGraph is this graph itself";\par
20169     mChannelFillGraph = 0;\par
20170     return;\par
20171   \}\par
20172   // prevent setting channel target to a graph not in the plot:\par
20173   if (targetGraph && targetGraph->mParentPlot != mParentPlot)\par
20174   \{\par
20175     qDebug() << Q_FUNC_INFO << "targetGraph not in same plot";\par
20176     mChannelFillGraph = 0;\par
20177     return;\par
20178   \}\par
20179   \par
20180   mChannelFillGraph = targetGraph;\par
20181 \}\par
}
}
{\xe \v setData\:QCPGraph}
{\xe \v QCPGraph\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setData (QSharedPointer< {\b QCPGraphDataContainer} >  {\i data})}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Replaces the current data container with the provided {\i data}  container.\par
Since a QSharedPointer is used, multiple QCPGraphs may share the same data container safely. Modifying the data in the container will then affect all graphs that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } If you do not wish to share containers, but create a copy from an existing container, rather use the {\b QCPDataContainer<DataType>::set} method on the graph's data container directly: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid } \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20095 \{\par
20096   mDataContainer = data;\par
20097 \}\par
}
}
{\xe \v setData\:QCPGraph}
{\xe \v QCPGraph\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setData (const QVector< double > &  {\i keys}, const QVector< double > &  {\i values}, bool  {\i alreadySorted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Replaces the current data with the provided points in {\i keys}  and {\i values} . The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.\par
If you can guarantee that the passed data points are sorted by {\i keys}  in ascending order, you can set {\i alreadySorted}  to true, to improve performance by saving a sorting run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addData} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20111 \{\par
20112   mDataContainer->clear();\par
20113   addData(keys, values, alreadySorted);\par
20114 \}\par
}
}
{\xe \v setKeyAxis\:QCPGraph}
{\xe \v QCPGraph\:setKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setKeyAxis ({\b QCPAxis} *  {\i axis}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The key axis of a plottable can be set to any axis of a {\b QCustomPlot}, as long as it is orthogonal to the plottable's value axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ({\b QCustomPlot::xAxis}) as key axis and the y-axis ({\b QCustomPlot::yAxis}) as value axis.\par
Normally, the key and value axes are set in the constructor of the plottable (or {\b QCustomPlot::addGraph} when working with QCPGraphs through the dedicated graph interface).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setValueAxis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10790 \{\par
10791   mKeyAxis = axis;\par
10792 \}\par
}
}
{\xe \v setLayer\:QCPGraph}
{\xe \v QCPGraph\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer ({\b QCPLayer} *  {\i layer}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i layer}  of this layerable object. The object will be placed on top of the other objects already on {\i layer} .\par
If {\i layer}  is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).\par
Returns true if the layer of this layerable was successfully changed to {\i layer} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1385 \{\par
 1386   return moveToLayer(layer, false);\par
 1387 \}\par
}
}
{\xe \v setLayer\:QCPGraph}
{\xe \v QCPGraph\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer (const QString &  {\i layerName}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name\par
Returns true on success, i.e. if {\i layerName}  is a valid layer name. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1395 \{\par
 1396   if (!mParentPlot)\par
 1397   \{\par
 1398     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1399     return false;\par
 1400   \}\par
 1401   if (QCPLayer *layer = mParentPlot->layer(layerName))\par
 1402   \{\par
 1403     return setLayer(layer);\par
 1404   \} else\par
 1405   \{\par
 1406     qDebug() << Q_FUNC_INFO << "there is no layer with name" << layerName;\par
 1407     return false;\par
 1408   \}\par
 1409 \}\par
}
}
{\xe \v setLineStyle\:QCPGraph}
{\xe \v QCPGraph\:setLineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setLineStyle ({\b LineStyle}  {\i ls})}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets how the single data points are connected in the plot. For scatter-only plots, set {\i ls}  to {\b lsNone} and {\b setScatterStyle} to the desired scatter style.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setScatterStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20123 \{\par
20124   mLineStyle = ls;\par
20125 \}\par
}
}
{\xe \v setName\:QCPGraph}
{\xe \v QCPGraph\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setName (const QString &  {\i name}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The name is the textual representation of this plottable as it is displayed in the legend ({\b QCPLegend}). It may contain any UTF-8 characters, including newlines. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10725 \{\par
10726   mName = name;\par
10727 \}\par
}
}
{\xe \v setParentLayerable\:QCPGraph}
{\xe \v QCPGraph\:setParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setParentLayerable ({\b QCPLayerable} *  {\i parentLayerable}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1523 \{\par
 1524   mParentLayerable = parentLayerable;\par
 1525 \}\par
}
}
{\xe \v setPen\:QCPGraph}
{\xe \v QCPGraph\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setPen (const QPen &  {\i pen}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The pen is used to draw basic lines that make up the plottable representation in the plot.\par
For example, the {\b QCPGraph} subclass draws its graph lines with this pen.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10760 \{\par
10761   mPen = pen;\par
10762 \}\par
}
}
{\xe \v setScatterSkip\:QCPGraph}
{\xe \v QCPGraph\:setScatterSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setScatterSkip (int  {\i skip})}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If scatters are displayed (scatter style not {\b QCPScatterStyle::ssNone}), {\i skip}  number of scatter points are skipped/not drawn after every drawn scatter point.\par
This can be used to make the data appear sparser while for example still having a smooth line, and to improve performance for very high density plots.\par
If {\i skip}  is set to 0 (default), all scatter points are drawn.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setScatterStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20150 \{\par
20151   mScatterSkip = qMax(0, skip);\par
20152 \}\par
}
}
{\xe \v setScatterStyle\:QCPGraph}
{\xe \v QCPGraph\:setScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPGraph::setScatterStyle (const {\b QCPScatterStyle} &  {\i style})}}
\par
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the visual appearance of single data points in the plot. If set to {\b QCPScatterStyle::ssNone}, no scatter points are drawn (e.g. for line-only-plots with appropriate line style).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b QCPScatterStyle}, {\b setLineStyle} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20134 \{\par
20135   mScatterStyle = style;\par
20136 \}\par
}
}
{\xe \v setSelectable\:QCPGraph}
{\xe \v QCPGraph\:setSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setSelectable ({\b QCP::SelectionType}  {\i selectable}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether and to which granularity this plottable can be selected.\par
A selection can happen by clicking on the {\b QCustomPlot} surface (When {\b QCustomPlot::setInteractions} contains {\b QCP::iSelectPlottables}), by dragging a selection rect (When {\b QCustomPlot::setSelectionRectMode} is {\b QCP::srmSelect}), or programmatically by calling {\b setSelection}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelection}, {\b QCP::SelectionType} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10877 \{\par
10878   if (mSelectable != selectable)\par
10879   \{\par
10880     mSelectable = selectable;\par
10881     QCPDataSelection oldSelection = mSelection;\par
10882     mSelection.enforceType(mSelectable);\par
10883     emit selectableChanged(mSelectable);\par
10884     if (mSelection != oldSelection)\par
10885     \{\par
10886       emit selectionChanged(selected());\par
10887       emit selectionChanged(mSelection);\par
10888     \}\par
10889   \}\par
10890 \}\par
}
}
{\xe \v setSelection\:QCPGraph}
{\xe \v QCPGraph\:setSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setSelection ({\b QCPDataSelection}  {\i selection}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which data ranges of this plottable are selected. Selected data ranges are drawn differently (e.g. color) in the plot. This can be controlled via the selection decorator (see {\b selectionDecorator}).\par
The entire selection mechanism for plottables is handled automatically when {\b QCustomPlot::setInteractions} contains iSelectPlottables. You only need to call this function when you wish to change the selection state programmatically.\par
Using {\b setSelectable} you can further specify for each plottable whether and to which granularity it is selectable. If {\i selection}  is not compatible with the current {\b QCP::SelectionType} set via {\b setSelectable}, the resulting selection will be adjusted accordingly (see {\b QCPDataSelection::enforceType}).\par
emits the {\b selectionChanged} signal when {\i selected}  is different from the previous selection state.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectable}, {\b selectTest} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10830 \{\par
10831   selection.enforceType(mSelectable);\par
10832   if (mSelection != selection)\par
10833   \{\par
10834     mSelection = selection;\par
10835     emit selectionChanged(selected());\par
10836     emit selectionChanged(mSelection);\par
10837   \}\par
10838 \}\par
}
}
{\xe \v setSelectionDecorator\:QCPGraph}
{\xe \v QCPGraph\:setSelectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setSelectionDecorator ({\b QCPSelectionDecorator} *  {\i decorator}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use this method to set an own {\b QCPSelectionDecorator} (subclass) instance. This allows you to customize the visual representation of selected data ranges further than by using the default {\b QCPSelectionDecorator}.\par
The plottable takes ownership of the {\i decorator} .\par
The currently set decorator can be accessed via {\b selectionDecorator}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10850 \{\par
10851   if (decorator)\par
10852   \{\par
10853     if (decorator->registerWithPlottable(this))\par
10854     \{\par
10855       if (mSelectionDecorator) // delete old decorator if necessary\par
10856         delete mSelectionDecorator;\par
10857       mSelectionDecorator = decorator;\par
10858     \}\par
10859   \} else if (mSelectionDecorator) // just clear decorator\par
10860   \{\par
10861     delete mSelectionDecorator;\par
10862     mSelectionDecorator = 0;\par
10863   \}\par
10864 \}\par
}
}
{\xe \v setValueAxis\:QCPGraph}
{\xe \v QCPGraph\:setValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setValueAxis ({\b QCPAxis} *  {\i axis}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The value axis of a plottable can be set to any axis of a {\b QCustomPlot}, as long as it is orthogonal to the plottable's key axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ({\b QCustomPlot::xAxis}) as key axis and the y-axis ({\b QCustomPlot::yAxis}) as value axis.\par
Normally, the key and value axes are set in the constructor of the plottable (or {\b QCustomPlot::addGraph} when working with QCPGraphs through the dedicated graph interface).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setKeyAxis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10806 \{\par
10807   mValueAxis = axis;\par
10808 \}\par
}
}
{\xe \v setVisible\:QCPGraph}
{\xe \v QCPGraph\:setVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setVisible (bool  {\i on}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the {\b QCustomPlot} surface, and user interaction with it (e.g. click and selection) is not possible. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1371 \{\par
 1372   mVisible = on;\par
 1373 \}\par
}
}
{\xe \v sortKeyIsMainKey\:QCPGraph}
{\xe \v QCPGraph\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::sortKeyIsMainKey () const{\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the sort key ({\b dataSortKey}) is identical to the main key ({\b dataMainKey}).\par
What the sort and main keys are, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4202 \{\par
 4203   return DataType::sortKeyIsMainKey();\par
 4204 \}\par
}
}
{\xe \v valueAxis\:QCPGraph}
{\xe \v QCPGraph\:valueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis}* QCPAbstractPlottable::valueAxis () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3313 \{ return mValueAxis.data(); \}\par
}
}
{\xe \v visible\:QCPGraph}
{\xe \v QCPGraph\:visible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::visible () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   707 \{ return mVisible; \}\par
}
}
{\xe \v wheelEvent\:QCPGraph}
{\xe \v QCPGraph\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} .\par
The {\f2 event->delta()}  indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making {\f2 event->delta()}  larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent} \par
}}{
Reimplementado por {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1800 \{\par
 1801   event->ignore();\par
 1802 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas e Funções Relacionadas\par
\pard\plain 
{\xe \v QCPLegend\:QCPGraph}
{\xe \v QCPGraph\:QCPLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCPLegend}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QCustomPlot\:QCPGraph}
{\xe \v QCPGraph\:QCustomPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b QCustomPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mAdaptiveSampling\:QCPGraph}
{\xe \v QCPGraph\:mAdaptiveSampling}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPGraph::mAdaptiveSampling{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAntialiased\:QCPGraph}
{\xe \v QCPGraph\:mAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mAntialiased{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAntialiasedFill\:QCPGraph}
{\xe \v QCPGraph\:mAntialiasedFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::mAntialiasedFill{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAntialiasedScatters\:QCPGraph}
{\xe \v QCPGraph\:mAntialiasedScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::mAntialiasedScatters{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBrush\:QCPGraph}
{\xe \v QCPGraph\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAbstractPlottable::mBrush{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mChannelFillGraph\:QCPGraph}
{\xe \v QCPGraph\:mChannelFillGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPGraph}> QCPGraph::mChannelFillGraph{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataContainer\:QCPGraph}
{\xe \v QCPGraph\:mDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSharedPointer<{\b QCPDataContainer}<{\b QCPGraphData} > > {\b QCPAbstractPlottable1D}< {\b QCPGraphData}  >::mDataContainer{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mKeyAxis\:QCPGraph}
{\xe \v QCPGraph\:mKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxis}> QCPAbstractPlottable::mKeyAxis{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLayer\:QCPGraph}
{\xe \v QCPGraph\:mLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::mLayer{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLineStyle\:QCPGraph}
{\xe \v QCPGraph\:mLineStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LineStyle} QCPGraph::mLineStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mName\:QCPGraph}
{\xe \v QCPGraph\:mName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAbstractPlottable::mName{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentLayerable\:QCPGraph}
{\xe \v QCPGraph\:mParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPLayerable}> QCPLayerable::mParentLayerable{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPGraph}
{\xe \v QCPGraph\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::mParentPlot{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPGraph}
{\xe \v QCPGraph\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAbstractPlottable::mPen{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScatterSkip\:QCPGraph}
{\xe \v QCPGraph\:mScatterSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QCPGraph::mScatterSkip{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mScatterStyle\:QCPGraph}
{\xe \v QCPGraph\:mScatterStyle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPScatterStyle} QCPGraph::mScatterStyle{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectable\:QCPGraph}
{\xe \v QCPGraph\:mSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionType} QCPAbstractPlottable::mSelectable{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelection\:QCPGraph}
{\xe \v QCPGraph\:mSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPAbstractPlottable::mSelection{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectionDecorator\:QCPGraph}
{\xe \v QCPGraph\:mSelectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionDecorator}* QCPAbstractPlottable::mSelectionDecorator{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mValueAxis\:QCPGraph}
{\xe \v QCPGraph\:mValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxis}> QCPAbstractPlottable::mValueAxis{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mVisible\:QCPGraph}
{\xe \v QCPGraph\:mVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mVisible{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documentação para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.cpp}\par
}}