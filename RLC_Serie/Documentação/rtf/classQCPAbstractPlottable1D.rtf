{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência do <em>Template</em> da Classe QCPAbstractPlottable1D< DataType >\par \pard\plain 
{\tc\tcl2 \v QCPAbstractPlottable1D< DataType >}
{\xe \v QCPAbstractPlottable1D< DataType >}
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A template base class for plottables with one-dimensional data. }}\par
{
{\f2 #include <qcustomplot.h>}}\par
Diagrama de hierarquia para QCPAbstractPlottable1D< DataType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classQCPAbstractPlottable1D__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Sinais\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (bool {\b selected})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectionChanged} (const {\b QCPDataSelection} &{\b selection})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b selectableChanged} ({\b QCP::SelectionType} {\b selectable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b layerChanged} ({\b QCPLayer} *newLayer)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Públicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAbstractPlottable1D} ({\b QCPAxis} *{\b keyAxis}, {\b QCPAxis} *{\b valueAxis})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~QCPAbstractPlottable1D} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b dataCount} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainKey} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataSortKey} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b dataMainValue} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b dataValueRange} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QPointF {\b dataPixelPosition} (int index) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b sortKeyIsMainKey} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPDataSelection} {\b selectTestRect} (const QRectF &rect, bool onlySelectable) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findBegin} (double sortKey, bool expandedRange=true) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b findEnd} (double sortKey, bool expandedRange=true) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b selectTest} (const QPointF &pos, bool onlySelectable, QVariant *details=0) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPPlottableInterface1D} * {\b interface1D} () {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b name} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiasedFill} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiasedScatters} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b pen} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b keyAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPAxis} * {\b valueAxis} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionType} {\b selectable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b selected} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b selection} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionDecorator} * {\b selectionDecorator} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (const QString &{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedFill} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiasedScatters} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPen} (const QPen &{\b pen})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBrush} (const QBrush &{\b brush})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setKeyAxis} ({\b QCPAxis} *axis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValueAxis} ({\b QCPAxis} *axis)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelectable} ({\b QCP::SelectionType} {\b selectable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT void {\b setSelection} ({\b QCPDataSelection} {\b selection})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSelectionDecorator} ({\b QCPSelectionDecorator} *decorator)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getKeyRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCPRange} {\b getValueRange} (bool &foundRange, {\b QCP::SignDomain} inSignDomain={\b QCP::sdBoth}, const {\b QCPRange} &inKeyRange={\b QCPRange}()) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b coordsToPixels} (double key, double value, double &x, double &y) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const QPointF {\b coordsToPixels} (double key, double value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsToCoords} (double x, double y, double &key, double &value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pixelsToCoords} (const QPointF &pixelPos, double &key, double &value) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleAxes} (bool onlyEnlarge=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleKeyAxis} (bool onlyEnlarge=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rescaleValueAxis} (bool onlyEnlarge=false, bool inKeyRange=false) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addToLegend} ({\b QCPLegend} *legend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addToLegend} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeFromLegend} ({\b QCPLegend} *legend) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeFromLegend} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b visible} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b parentPlot} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayerable} * {\b parentLayerable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b layer} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b antialiased} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVisible} (bool on)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Q_SLOT bool {\b setLayer} ({\b QCPLayer} *{\b layer})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setLayer} (const QString &layerName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAntialiased} (bool enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b realVisibility} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getDataSegments} (QList< {\b QCPDataRange} > &selectedSegments, QList< {\b QCPDataRange} > &unselectedSegments) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawPolyline} ({\b QCPPainter} *painter, const QVector< QPointF > &lineData) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual QRect {\b clipRect} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} ({\b QCPPainter} *painter) {\b Q_DECL_OVERRIDE}=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b QCP::Interaction} {\b selectionCategory} () const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyDefaultAntialiasingHint} ({\b QCPPainter} *painter) const {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectEvent} (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b deselectEvent} (bool *selectionStateChanged) {\b Q_DECL_OVERRIDE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b drawLegendIcon} ({\b QCPPainter} *painter, const QRectF &rect) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyFillAntialiasingHint} ({\b QCPPainter} *painter) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyScattersAntialiasingHint} ({\b QCPPainter} *painter) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b parentPlotInitialized} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *event, const QPointF &startPos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseDoubleClickEvent} (QMouseEvent *event, const QVariant &details)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b wheelEvent} (QWheelEvent *event)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initializeParentPlot} ({\b QCustomPlot} *{\b parentPlot})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setParentLayerable} ({\b QCPLayerable} *{\b parentLayerable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveToLayer} ({\b QCPLayer} *{\b layer}, bool prepend)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyAntialiasingHint} ({\b QCPPainter} *painter, bool localAntialiased, {\b QCP::AntialiasedElement} overrideElement) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSharedPointer< {\b QCPDataContainer}< DataType > > {\b mDataContainer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b mName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiasedFill}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiasedScatters}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPen {\b mPen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b mBrush}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxis} > {\b mKeyAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPAxis} > {\b mValueAxis}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCP::SelectionType} {\b mSelectable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPDataSelection} {\b mSelection}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPSelectionDecorator} * {\b mSelectionDecorator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mVisible}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCustomPlot} * {\b mParentPlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QPointer< {\b QCPLayerable} > {\b mParentLayerable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QCPLayer} * {\b mLayer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mAntialiased}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class DataType>\par
class QCPAbstractPlottable1D< DataType >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A template base class for plottables with one-dimensional data. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This template class derives from {\b QCPAbstractPlottable} and from the abstract interface {\b QCPPlottableInterface1D}. It serves as a base class for all one-dimensional data (i.e. data with one key dimension), such as {\b QCPGraph} and {\b QCPCurve}.\par
The template parameter {\i DataType}  is the type of the data points of this plottable (e.g. {\b QCPGraphData} or {\b QCPCurveData}). The main purpose of this base class is to provide the member {\i mDataContainer}  (a shared pointer to a {\b QCPDataContainer<DataType>}) and implement the according virtual methods of the {\b QCPPlottableInterface1D}, such that most subclassed plottables don't need to worry about this anymore.\par
Further, it provides a convenience method for retrieving selected/unselected data segments via {\b getDataSegments}. This is useful when subclasses implement their {\b draw} method and need to draw selected segments with a different pen/brush than unselected segments (also see {\b QCPSelectionDecorator}).\par
This class implements basic functionality of {\b QCPAbstractPlottable::selectTest} and {\b QCPPlottableInterface1D::selectTestRect}, assuming point-like data points, based on the 1D data interface. In spite of that, most plottable subclasses will want to reimplement those methods again, to provide a more accurate hit test based on their specific data visualization geometry. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v QCPAbstractPlottable1D\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:QCPAbstractPlottable1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPAbstractPlottable1D}< DataType >::{\b QCPAbstractPlottable1D} ({\b QCPAxis} *  {\i keyAxis}, {\b QCPAxis} *  {\i valueAxis})}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Forwards {\i keyAxis}  and {\i valueAxis}  to the {\b QCPAbstractPlottable} constructor and allocates the {\i mDataContainer} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4096                                                                                              :\par
 4097   QCPAbstractPlottable(keyAxis, valueAxis),\par
 4098   mDataContainer(new QCPDataContainer<DataType>)\par
 4099 \{\par
 4100 \}\par
}
}
{\xe \v ~QCPAbstractPlottable1D\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:~QCPAbstractPlottable1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPAbstractPlottable1D}< DataType >::~{\b QCPAbstractPlottable1D} (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4104 \{\par
 4105 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções membros\par
\pard\plain 
{\xe \v addToLegend\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:addToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::addToLegend ({\b QCPLegend} *  {\i legend}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Adds this plottable to the specified {\i legend} .\par
Creates a {\b QCPPlottableLegendItem} which is inserted into the legend. Returns true on success, i.e. when the legend exists and a legend item associated with this plottable isn't already in the legend.\par
If the plottable needs a more specialized representation in the legend, you can create a corresponding subclass of {\b QCPPlottableLegendItem} and add it to the legend manually instead of calling this method.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeFromLegend}, {\b QCPLegend::addItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11084 \{\par
11085   if (!legend)\par
11086   \{\par
11087     qDebug() << Q_FUNC_INFO << "passed legend is null";\par
11088     return false;\par
11089   \}\par
11090   if (legend->parentPlot() != mParentPlot)\par
11091   \{\par
11092     qDebug() << Q_FUNC_INFO << "passed legend isn't in the same QCustomPlot as this plottable";\par
11093     return false;\par
11094   \}\par
11095   \par
11096   if (!legend->hasItemWithPlottable(this))\par
11097   \{\par
11098     legend->addItem(new QCPPlottableLegendItem(legend, this));\par
11099     return true;\par
11100   \} else\par
11101     return false;\par
11102 \}\par
}
}
{\xe \v addToLegend\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:addToLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::addToLegend (){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Adds this plottable to the legend of the parent {\b QCustomPlot} ({\b QCustomPlot::legend}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b removeFromLegend} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11111 \{\par
11112   if (!mParentPlot || !mParentPlot->legend)\par
11113     return false;\par
11114   else\par
11115     return addToLegend(mParentPlot->legend);\par
11116 \}\par
}
}
{\xe \v antialiased\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:antialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::antialiased () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   711 \{ return mAntialiased; \}\par
}
}
{\xe \v antialiasedFill\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:antialiasedFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::antialiasedFill () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3308 \{ return mAntialiasedFill; \}\par
}
}
{\xe \v antialiasedScatters\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:antialiasedScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::antialiasedScatters () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3309 \{ return mAntialiasedScatters; \}\par
}
}
{\xe \v applyAntialiasingHint\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:applyAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::applyAntialiasingHint ({\b QCPPainter} *  {\i painter}, bool  {\i localAntialiased}, {\b QCP::AntialiasedElement}  {\i overrideElement}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1567 \{\par
 1568   if (mParentPlot && mParentPlot->notAntialiasedElements().testFlag(overrideElement))\par
 1569     painter->setAntialiasing(false);\par
 1570   else if (mParentPlot && mParentPlot->antialiasedElements().testFlag(overrideElement))\par
 1571     painter->setAntialiasing(true);\par
 1572   else\par
 1573     painter->setAntialiasing(localAntialiased);\par
 1574 \}\par
}
}
{\xe \v applyDefaultAntialiasingHint\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:applyDefaultAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::applyDefaultAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11187 \{\par
11188   applyAntialiasingHint(painter, mAntialiased, QCP::aePlottables);\par
11189 \}\par
}
}
{\xe \v applyFillAntialiasingHint\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:applyFillAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::applyFillAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11203 \{\par
11204   applyAntialiasingHint(painter, mAntialiasedFill, QCP::aeFills);\par
11205 \}\par
}
}
{\xe \v applyScattersAntialiasingHint\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:applyScattersAntialiasingHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::applyScattersAntialiasingHint ({\b QCPPainter} *  {\i painter}) const{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11219 \{\par
11220   applyAntialiasingHint(painter, mAntialiasedScatters, QCP::aeScatters);\par
11221 \}\par
}
}
{\xe \v brush\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAbstractPlottable::brush () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3311 \{ return mBrush; \}\par
}
}
{\xe \v clipRect\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:clipRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QRect QCPAbstractPlottable::clipRect () const{\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11158 \{\par
11159   if (mKeyAxis && mValueAxis)\par
11160     return mKeyAxis.data()->axisRect()->rect() & mValueAxis.data()->axisRect()->rect();\par
11161   else\par
11162     return QRect();\par
11163 \}\par
}
}
{\xe \v coordsToPixels\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:coordsToPixels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::coordsToPixels (double  {\i key}, double  {\i value}, double &  {\i x}, double &  {\i y}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function for transforming a key/value pair to pixels on the {\b QCustomPlot} surface, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).\par
{\i key}  and {\i value}  are transformed to the coodinates in pixels and are written to {\i x}  and {\i y} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b pixelsToCoords}, {\b QCPAxis::coordToPixel} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10903 \{\par
10904   QCPAxis *keyAxis = mKeyAxis.data();\par
10905   QCPAxis *valueAxis = mValueAxis.data();\par
10906   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
10907   \par
10908   if (keyAxis->orientation() == Qt::Horizontal)\par
10909   \{\par
10910     x = keyAxis->coordToPixel(key);\par
10911     y = valueAxis->coordToPixel(value);\par
10912   \} else\par
10913   \{\par
10914     y = keyAxis->coordToPixel(key);\par
10915     x = valueAxis->coordToPixel(value);\par
10916   \}\par
10917 \}\par
}
}
{\xe \v coordsToPixels\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:coordsToPixels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const QPointF QCPAbstractPlottable::coordsToPixels (double  {\i key}, double  {\i value}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Transforms the given {\i key}  and {\i value}  to pixel coordinates and returns them in a QPointF. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10924 \{\par
10925   QCPAxis *keyAxis = mKeyAxis.data();\par
10926   QCPAxis *valueAxis = mValueAxis.data();\par
10927   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return QPointF(); \}\par
10928   \par
10929   if (keyAxis->orientation() == Qt::Horizontal)\par
10930     return QPointF(keyAxis->coordToPixel(key), valueAxis->coordToPixel(value));\par
10931   else\par
10932     return QPointF(valueAxis->coordToPixel(value), keyAxis->coordToPixel(key));\par
10933 \}\par
}
}
{\xe \v dataCount\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > int {\b QCPAbstractPlottable1D}< DataType >::dataCount () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data points of the plottable. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4112 \{\par
 4113   return mDataContainer->size();\par
 4114 \}\par
}
}
{\xe \v dataMainKey\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > double {\b QCPAbstractPlottable1D}< DataType >::dataMainKey (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main key of the data point at the given {\i index} .\par
What the main key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4121 \{\par
 4122   if (index >= 0 && index < mDataContainer->size())\par
 4123   \{\par
 4124     return (mDataContainer->constBegin()+index)->mainKey();\par
 4125   \} else\par
 4126   \{\par
 4127     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4128     return 0;\par
 4129   \}\par
 4130 \}\par
}
}
{\xe \v dataMainValue\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataMainValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > double {\b QCPAbstractPlottable1D}< DataType >::dataMainValue (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the main value of the data point at the given {\i index} .\par
What the main value is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4153 \{\par
 4154   if (index >= 0 && index < mDataContainer->size())\par
 4155   \{\par
 4156     return (mDataContainer->constBegin()+index)->mainValue();\par
 4157   \} else\par
 4158   \{\par
 4159     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4160     return 0;\par
 4161   \}\par
 4162 \}\par
}
}
{\xe \v dataPixelPosition\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataPixelPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > QPointF {\b QCPAbstractPlottable1D}< DataType >::dataPixelPosition (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pixel position on the widget surface at which the data point at the given {\i index}  appears.\par
Usually this corresponds to the point of {\b dataMainKey}/{\b dataMainValue}, in pixel coordinates. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values. For example, {\b QCPBars} apparent data values can be shifted depending on their stacking, bar grouping or configured base value. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplementado por {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4185 \{\par
 4186   if (index >= 0 && index < mDataContainer->size())\par
 4187   \{\par
 4188     const typename QCPDataContainer<DataType>::const_iterator it = mDataContainer->constBegin()+index;\par
 4189     return coordsToPixels(it->mainKey(), it->mainValue());\par
 4190   \} else\par
 4191   \{\par
 4192     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4193     return QPointF();\par
 4194   \}\par
 4195 \}\par
}
}
{\xe \v dataSortKey\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataSortKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > double {\b QCPAbstractPlottable1D}< DataType >::dataSortKey (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the sort key of the data point at the given {\i index} .\par
What the sort key is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4137 \{\par
 4138   if (index >= 0 && index < mDataContainer->size())\par
 4139   \{\par
 4140     return (mDataContainer->constBegin()+index)->sortKey();\par
 4141   \} else\par
 4142   \{\par
 4143     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4144     return 0;\par
 4145   \}\par
 4146 \}\par
}
}
{\xe \v dataValueRange\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:dataValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPRange} {\b QCPAbstractPlottable1D}< DataType >::dataValueRange (int  {\i index}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the value range of the data point at the given {\i index} .\par
What the value range is, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAARZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4169 \{\par
 4170   if (index >= 0 && index < mDataContainer->size())\par
 4171   \{\par
 4172     return (mDataContainer->constBegin()+index)->valueRange();\par
 4173   \} else\par
 4174   \{\par
 4175     qDebug() << Q_FUNC_INFO << "Index out of bounds" << index;\par
 4176     return QCPRange(0, 0);\par
 4177   \}\par
 4178 \}\par
}
}
{\xe \v deselectEvent\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:deselectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::deselectEvent (bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11256 \{\par
11257   if (mSelectable != QCP::stNone)\par
11258   \{\par
11259     QCPDataSelection selectionBefore = mSelection;\par
11260     setSelection(QCPDataSelection());\par
11261     if (selectionStateChanged)\par
11262       *selectionStateChanged = mSelection != selectionBefore;\par
11263   \}\par
11264 \}\par
}
}
{\xe \v draw\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void QCPAbstractPlottable::draw ({\b QCPPainter} *  {\i painter}){\f2 [protected]}, {\f2 [pure virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Implementado por {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOH \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v drawLegendIcon\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:drawLegendIcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::drawLegendIcon ({\b QCPPainter} *  {\i painter}, const QRectF &  {\i rect}) const{\f2 [protected]}, {\f2 [pure virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOP \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v drawPolyline\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:drawPolyline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPAbstractPlottable1D}< DataType >::drawPolyline ({\b QCPPainter} *  {\i painter}, const QVector< QPointF > &  {\i lineData}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A helper method which draws a line with the passed {\i painter} , according to the pixel data in {\i lineData} . NaN points create gaps in the line, as expected from {\b QCustomPlot}'s plottables (this is the main difference to QPainter's regular drawPolyline, which handles NaNs by lagging or crashing).\par
Further it uses a faster line drawing technique based on {\b QCPPainter::drawLine} rather than {\f2 QPainter::drawPolyline}  if the configured {\b QCustomPlot::setPlottingHints()} and {\i painter}  style allows. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4378 \{\par
 4379   // if drawing solid line and not in PDF, use much faster line drawing instead of polyline:\par
 4380   if (mParentPlot->plottingHints().testFlag(QCP::phFastPolylines) &&\par
 4381       painter->pen().style() == Qt::SolidLine &&\par
 4382       !painter->modes().testFlag(QCPPainter::pmVectorized) &&\par
 4383       !painter->modes().testFlag(QCPPainter::pmNoCaching))\par
 4384   \{\par
 4385     int i = 0;\par
 4386     bool lastIsNan = false;\par
 4387     const int lineDataSize = lineData.size();\par
 4388     while (i < lineDataSize && (qIsNaN(lineData.at(i).y()) || qIsNaN(lineData.at(i).x()))) // make sure first point is not NaN\par
 4389       ++i;\par
 4390     ++i; // because drawing works in 1 point retrospect\par
 4391     while (i < lineDataSize)\par
 4392     \{\par
 4393       if (!qIsNaN(lineData.at(i).y()) && !qIsNaN(lineData.at(i).x())) // NaNs create a gap in the line\par
 4394       \{\par
 4395         if (!lastIsNan)\par
 4396           painter->drawLine(lineData.at(i-1), lineData.at(i));\par
 4397         else\par
 4398           lastIsNan = false;\par
 4399       \} else\par
 4400         lastIsNan = true;\par
 4401       ++i;\par
 4402     \}\par
 4403   \} else\par
 4404   \{\par
 4405     int segmentStart = 0;\par
 4406     int i = 0;\par
 4407     const int lineDataSize = lineData.size();\par
 4408     while (i < lineDataSize)\par
 4409     \{\par
 4410       if (qIsNaN(lineData.at(i).y()) || qIsNaN(lineData.at(i).x()) || qIsInf(lineData.at(i).y())) // NaNs create a gap in the line. Also filter Infs which make drawPolyline block\par
 4411       \{\par
 4412         painter->drawPolyline(lineData.constData()+segmentStart, i-segmentStart); // i, because we don't want to include the current NaN point\par
 4413         segmentStart = i+1;\par
 4414       \}\par
 4415       ++i;\par
 4416     \}\par
 4417     // draw last segment:\par
 4418     painter->drawPolyline(lineData.constData()+segmentStart, lineDataSize-segmentStart);\par
 4419   \}\par
 4420 \}\par
}
}
{\xe \v findBegin\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:findBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > int {\b QCPAbstractPlottable1D}< DataType >::findBegin (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index of the data point with a (sort-)key that is equal to, just below, or just above {\i sortKey} . If {\i expandedRange}  is true, the data point just below {\i sortKey}  will be considered, otherwise the one just above.\par
This can be used in conjunction with {\b findEnd} to iterate over data points within a given key range, including or excluding the bounding data points that are just beyond the specified range.\par
If {\i expandedRange}  is true but there are no data points below {\i sortKey} , 0 is returned.\par
If the container is empty, returns 0 (in that case, {\b findEnd} will also return 0, so a loop using these methods will not iterate over the index 0).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findEnd}, {\b QCPDataContainer::findBegin} \par
}}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4264 \{\par
 4265   return mDataContainer->findBegin(sortKey, expandedRange)-mDataContainer->constBegin();\par
 4266 \}\par
}
}
{\xe \v findEnd\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:findEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > int {\b QCPAbstractPlottable1D}< DataType >::findEnd (double  {\i sortKey}, bool  {\i expandedRange} = {\f2 true}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index one after the data point with a (sort-)key that is equal to, just above, or just below {\i sortKey} . If {\i expandedRange}  is true, the data point just above {\i sortKey}  will be considered, otherwise the one just below.\par
This can be used in conjunction with {\b findBegin} to iterate over data points within a given key range, including the bounding data points that are just below and above the specified range.\par
If {\i expandedRange}  is true but there are no data points above {\i sortKey} , the index just above the highest data point is returned.\par
If the container is empty, returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b findBegin}, {\b QCPDataContainer::findEnd} \par
}}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4273 \{\par
 4274   return mDataContainer->findEnd(sortKey, expandedRange)-mDataContainer->constBegin();\par
 4275 \}\par
}
}
{\xe \v getDataSegments\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:getDataSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > void {\b QCPAbstractPlottable1D}< DataType >::getDataSegments (QList< {\b QCPDataRange} > &  {\i selectedSegments}, QList< {\b QCPDataRange} > &  {\i unselectedSegments}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits all data into selected and unselected segments and outputs them via {\i selectedSegments}  and {\i unselectedSegments} , respectively.\par
This is useful when subclasses implement their {\b draw} method and need to draw selected segments with a different pen/brush than unselected segments (also see {\b QCPSelectionDecorator}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelection} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4348 \{\par
 4349   selectedSegments.clear();\par
 4350   unselectedSegments.clear();\par
 4351   if (mSelectable == QCP::stWhole) // stWhole selection type draws the entire plottable with selected style if mSelection isn't empty\par
 4352   \{\par
 4353     if (selected())\par
 4354       selectedSegments << QCPDataRange(0, dataCount());\par
 4355     else\par
 4356       unselectedSegments << QCPDataRange(0, dataCount());\par
 4357   \} else\par
 4358   \{\par
 4359     QCPDataSelection sel(selection());\par
 4360     sel.simplify();\par
 4361     selectedSegments = sel.dataRanges();\par
 4362     unselectedSegments = sel.inverse(QCPDataRange(0, dataCount())).dataRanges();\par
 4363   \}\par
 4364 \}\par
}
}
{\xe \v getKeyRange\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:getKeyRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPAbstractPlottable::getKeyRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}) const{\f2 [pure virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getValueRange} \par
}}{
Implementado por {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOX \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getValueRange\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:getValueRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPRange} QCPAbstractPlottable::getValueRange (bool &  {\i foundRange}, {\b QCP::SignDomain}  {\i inSignDomain} = {\f2 {\b QCP::sdBoth}}, const {\b QCPRange} &  {\i inKeyRange} = {\f2 {\b QCPRange}()}) const{\f2 [pure virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coordinate range that the data points in the specified key range ({\i inKeyRange} ) span in the value axis dimension. For logarithmic plots, one can set {\i inSignDomain}  to either {\b QCP::sdNegative} or {\b QCP::sdPositive} in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set {\i inSignDomain}  to {\b QCP::sdNegative} and all positive points will be ignored for range calculation. For no restriction, just set {\i inSignDomain}  to {\b QCP::sdBoth} (default). {\i foundRange}  is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).\par
If {\i inKeyRange}  has both lower and upper bound set to zero (is equal to {\f2 {\b QCPRange()}} ), all data points are considered, without any restriction on the keys.\par
Note that {\i foundRange}  is not the same as {\b QCPRange::validRange}, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case {\i foundRange}  would return true, but the returned range is not a valid range in terms of {\b QCPRange::validRange}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleAxes}, {\b getKeyRange} \par
}}{
Implementado por {\b QCPErrorBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPColorMap} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPF \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initializeParentPlot\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:initializeParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::initializeParentPlot ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1497 \{\par
 1498   if (mParentPlot)\par
 1499   \{\par
 1500     qDebug() << Q_FUNC_INFO << "called with mParentPlot already initialized";\par
 1501     return;\par
 1502   \}\par
 1503   \par
 1504   if (!parentPlot)\par
 1505     qDebug() << Q_FUNC_INFO << "called with parentPlot zero";\par
 1506   \par
 1507   mParentPlot = parentPlot;\par
 1508   parentPlotInitialized(mParentPlot);\par
 1509 \}\par
}
}
{\xe \v interface1D\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:interface1D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> {\b QCPPlottableInterface1D} * {\b QCPAbstractPlottable1D}< DataType >::interface1D (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPPlottableInterface1D} pointer to this plottable, providing access to its 1D interface.\par
}{
Reimplementa {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3890 \{ return this; \}\par
}
}
{\xe \v keyAxis\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:keyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis}* QCPAbstractPlottable::keyAxis () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3312 \{ return mKeyAxis.data(); \}\par
}
}
{\xe \v layer\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::layer () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   710 \{ return mLayer; \}\par
}
}
{\xe \v layerChanged\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:layerChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::layerChanged ({\b QCPLayer} *  {\i newLayer}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setLayer} \par
}}}
{\xe \v mouseDoubleClickEvent\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mouseDoubleClickEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseDoubleClickEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The {\b mouseDoubleClickEvent} is called instead of the second {\b mousePressEvent}. So in the case of a double-click, the event succession is {\i pressEvent \'96 releaseEvent \'96 doubleClickEvent \'96 releaseEvent} .\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
Similarly to {\b mousePressEvent}, once a layerable has accepted the {\b mouseDoubleClickEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} and {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1777 \{\par
 1778   Q_UNUSED(details)\par
 1779   event->ignore();\par
 1780 \}\par
}
}
{\xe \v mouseMoveEvent\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseMoveEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1727 \{\par
 1728   Q_UNUSED(startPos)\par
 1729   event->ignore();\par
 1730 \}\par
}
}
{\xe \v mousePressEvent\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mousePressEvent (QMouseEvent *  {\i event}, const QVariant &  {\i details}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i details}  contains layerable-specific details about the hit, which were generated in the previous call to {\b selectTest}. For example, One-dimensional plottables like {\b QCPGraph} or {\b QCPBars} convey the clicked data point in the {\i details}  parameter, as {\b QCPDataSelection} packed as QVariant. Multi-part objects convey the specific {\f2 SelectablePart}  that was hit (e.g. {\b QCPAxis::SelectablePart} in the case of axes).\par
{\b QCustomPlot} uses an event propagation system that works the same as Qt's system. If your layerable doesn't reimplement the {\b mousePressEvent} or explicitly calls {\f2 event->ignore()}  in its reimplementation, the event will be propagated to the next layerable in the stacking order.\par
Once a layerable has accepted the {\b mousePressEvent}, it is considered the mouse grabber and will receive all following calls to {\b mouseMoveEvent} or {\b mouseReleaseEvent} for this mouse interaction (a "mouse interaction" in this context ends with the release).\par
The default implementation does nothing except explicitly ignoring the event with {\f2 event->ignore()} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGQ \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1709 \{\par
 1710   Q_UNUSED(details)\par
 1711   event->ignore();\par
 1712 \}\par
}
}
{\xe \v mouseReleaseEvent\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::mouseReleaseEvent (QMouseEvent *  {\i event}, const QPointF &  {\i startPos}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding {\b mousePressEvent}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} . The parameter {\i startPos}  indicates the position where the initial {\b mousePressEvent} occured, that started the mouse interaction.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseDoubleClickEvent}, {\b wheelEvent} \par
}}{
Reimplementado por {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPTextElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGV \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1745 \{\par
 1746   Q_UNUSED(startPos)\par
 1747   event->ignore();\par
 1748 \}\par
}
}
{\xe \v moveToLayer\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:moveToLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::moveToLayer ({\b QCPLayer} *  {\i layer}, bool  {\i prepend}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1536 \{\par
 1537   if (layer && !mParentPlot)\par
 1538   \{\par
 1539     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1540     return false;\par
 1541   \}\par
 1542   if (layer && layer->parentPlot() != mParentPlot)\par
 1543   \{\par
 1544     qDebug() << Q_FUNC_INFO << "layer" << layer->name() << "is not in same QCustomPlot as this layerable";\par
 1545     return false;\par
 1546   \}\par
 1547   \par
 1548   QCPLayer *oldLayer = mLayer;\par
 1549   if (mLayer)\par
 1550     mLayer->removeChild(this);\par
 1551   mLayer = layer;\par
 1552   if (mLayer)\par
 1553     mLayer->addChild(this, prepend);\par
 1554   if (mLayer != oldLayer)\par
 1555     emit layerChanged(mLayer);\par
 1556   return true;\par
 1557 \}\par
}
}
{\xe \v name\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAbstractPlottable::name () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3307 \{ return mName; \}\par
}
}
{\xe \v parentLayerable\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:parentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayerable} * QCPLayerable::parentLayerable () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method {\b realVisibility}. This way, layerables only get drawn if their parent layerables are visible, too.\par
Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn't always have a parent layerable, so this function may return 0.\par
A parent layerable is set implicitly when placed inside layout elements and doesn't need to be set manually by the user. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   709 \{ return mParentLayerable.data(); \}\par
}
}
{\xe \v parentPlot\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:parentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::parentPlot () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   708 \{ return mParentPlot; \}\par
}
}
{\xe \v parentPlotInitialized\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:parentPlotInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::parentPlotInitialized ({\b QCustomPlot} *  {\i parentPlot}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b QCPLegend} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPLayoutElement} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1593 \{\par
 1594    Q_UNUSED(parentPlot)\par
 1595 \}\par
}
}
{\xe \v pen\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:pen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAbstractPlottable::pen () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3310 \{ return mPen; \}\par
}
}
{\xe \v pixelsToCoords\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:pixelsToCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::pixelsToCoords (double  {\i x}, double  {\i y}, double &  {\i key}, double &  {\i value}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convenience function for transforming a x/y pixel pair on the {\b QCustomPlot} surface to plot coordinates, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).\par
{\i x}  and {\i y}  are transformed to the plot coodinates and are written to {\i key}  and {\i value} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b coordsToPixels}, {\b QCPAxis::coordToPixel} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10945 \{\par
10946   QCPAxis *keyAxis = mKeyAxis.data();\par
10947   QCPAxis *valueAxis = mValueAxis.data();\par
10948   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
10949   \par
10950   if (keyAxis->orientation() == Qt::Horizontal)\par
10951   \{\par
10952     key = keyAxis->pixelToCoord(x);\par
10953     value = valueAxis->pixelToCoord(y);\par
10954   \} else\par
10955   \{\par
10956     key = keyAxis->pixelToCoord(y);\par
10957     value = valueAxis->pixelToCoord(x);\par
10958   \}\par
10959 \}\par
}
}
{\xe \v pixelsToCoords\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:pixelsToCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::pixelsToCoords (const QPointF &  {\i pixelPos}, double &  {\i key}, double &  {\i value}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Returns the pixel input {\i pixelPos}  as plot coordinates {\i key}  and {\i value} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10966 \{\par
10967   pixelsToCoords(pixelPos.x(), pixelPos.y(), key, value);\par
10968 \}\par
}
}
{\xe \v realVisibility\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:realVisibility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::realVisibility () const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable's layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.\par
If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of {\b QCPLayoutElement}), this function returns true only if this layerable has its visibility set to true and the parent layerable's {\b realVisibility} returns true. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1433 \{\par
 1434   return mVisible && (!mLayer || mLayer->visible()) && (!mParentLayerable || mParentLayerable.data()->realVisibility());\par
 1435 \}\par
}
}
{\xe \v removeFromLegend\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:removeFromLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::removeFromLegend ({\b QCPLegend} *  {\i legend}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Removes the plottable from the specifed {\i legend} . This means the {\b QCPPlottableLegendItem} that is associated with this plottable is removed.\par
Returns true on success, i.e. if the legend exists and a legend item associated with this plottable was found and removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addToLegend}, {\b QCPLegend::removeItem} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11129 \{\par
11130   if (!legend)\par
11131   \{\par
11132     qDebug() << Q_FUNC_INFO << "passed legend is null";\par
11133     return false;\par
11134   \}\par
11135   \par
11136   if (QCPPlottableLegendItem *lip = legend->itemWithPlottable(this))\par
11137     return legend->removeItem(lip);\par
11138   else\par
11139     return false;\par
11140 \}\par
}
}
{\xe \v removeFromLegend\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:removeFromLegend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::removeFromLegend () const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados.\par
Removes the plottable from the legend of the parent {\b QCustomPlot}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b addToLegend} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11149 \{\par
11150   if (!mParentPlot || !mParentPlot->legend)\par
11151     return false;\par
11152   else\par
11153     return removeFromLegend(mParentPlot->legend);\par
11154 \}\par
}
}
{\xe \v rescaleAxes\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:rescaleAxes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::rescaleAxes (bool  {\i onlyEnlarge} = {\f2 false}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i.e. a range containing different signs and/or zero. Instead it will stay in the current sign domain and ignore all parts of the plottable that lie outside of that domain.\par
{\i onlyEnlarge}  makes sure the ranges are only expanded, never reduced. So it's possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has {\i onlyEnlarge}  set to false (the default), and all subsequent set to true.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b rescaleKeyAxis}, {\b rescaleValueAxis}, {\b QCustomPlot::rescaleAxes}, {\b QCPAxis::rescale} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10984 \{\par
10985   rescaleKeyAxis(onlyEnlarge);\par
10986   rescaleValueAxis(onlyEnlarge);\par
10987 \}\par
}
}
{\xe \v rescaleKeyAxis\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:rescaleKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::rescaleKeyAxis (bool  {\i onlyEnlarge} = {\f2 false}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the key axis of the plottable so the whole plottable is visible.\par
See {\b rescaleAxes} for detailed behaviour. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10995 \{\par
10996   QCPAxis *keyAxis = mKeyAxis.data();\par
10997   if (!keyAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key axis"; return; \}\par
10998   \par
10999   QCP::SignDomain signDomain = QCP::sdBoth;\par
11000   if (keyAxis->scaleType() == QCPAxis::stLogarithmic)\par
11001     signDomain = (keyAxis->range().upper < 0 ? QCP::sdNegative : QCP::sdPositive);\par
11002   \par
11003   bool foundRange;\par
11004   QCPRange newRange = getKeyRange(foundRange, signDomain);\par
11005   if (foundRange)\par
11006   \{\par
11007     if (onlyEnlarge)\par
11008       newRange.expand(keyAxis->range());\par
11009     if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable\par
11010     \{\par
11011       double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason\par
11012       if (keyAxis->scaleType() == QCPAxis::stLinear)\par
11013       \{\par
11014         newRange.lower = center-keyAxis->range().size()/2.0;\par
11015         newRange.upper = center+keyAxis->range().size()/2.0;\par
11016       \} else // scaleType() == stLogarithmic\par
11017       \{\par
11018         newRange.lower = center/qSqrt(keyAxis->range().upper/keyAxis->range().lower);\par
11019         newRange.upper = center*qSqrt(keyAxis->range().upper/keyAxis->range().lower);\par
11020       \}\par
11021     \}\par
11022     keyAxis->setRange(newRange);\par
11023   \}\par
11024 \}\par
}
}
{\xe \v rescaleValueAxis\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:rescaleValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::rescaleValueAxis (bool  {\i onlyEnlarge} = {\f2 false}, bool  {\i inKeyRange} = {\f2 false}) const{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rescales the value axis of the plottable so the whole plottable is visible. If {\i inKeyRange}  is set to true, only the data points which are in the currently visible key axis range are considered.\par
Returns true if the axis was actually scaled. This might not be the case if this plottable has an invalid range, e.g. because it has no data points.\par
See {\b rescaleAxes} for detailed behaviour. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11037 \{\par
11038   QCPAxis *keyAxis = mKeyAxis.data();\par
11039   QCPAxis *valueAxis = mValueAxis.data();\par
11040   if (!keyAxis || !valueAxis) \{ qDebug() << Q_FUNC_INFO << "invalid key or value axis"; return; \}\par
11041   \par
11042   QCP::SignDomain signDomain = QCP::sdBoth;\par
11043   if (valueAxis->scaleType() == QCPAxis::stLogarithmic)\par
11044     signDomain = (valueAxis->range().upper < 0 ? QCP::sdNegative : QCP::sdPositive);\par
11045   \par
11046   bool foundRange;\par
11047   QCPRange newRange = getValueRange(foundRange, signDomain, inKeyRange ? keyAxis->range() : QCPRange());\par
11048   if (foundRange)\par
11049   \{\par
11050     if (onlyEnlarge)\par
11051       newRange.expand(valueAxis->range());\par
11052     if (!QCPRange::validRange(newRange)) // likely due to range being zero (plottable has only constant data in this axis dimension), shift current range to at least center the plottable\par
11053     \{\par
11054       double center = (newRange.lower+newRange.upper)*0.5; // upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason\par
11055       if (valueAxis->scaleType() == QCPAxis::stLinear)\par
11056       \{\par
11057         newRange.lower = center-valueAxis->range().size()/2.0;\par
11058         newRange.upper = center+valueAxis->range().size()/2.0;\par
11059       \} else // scaleType() == stLogarithmic\par
11060       \{\par
11061         newRange.lower = center/qSqrt(valueAxis->range().upper/valueAxis->range().lower);\par
11062         newRange.upper = center*qSqrt(valueAxis->range().upper/valueAxis->range().lower);\par
11063       \}\par
11064     \}\par
11065     valueAxis->setRange(newRange);\par
11066   \}\par
11067 \}\par
}
}
{\xe \v selectable\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionType} QCPAbstractPlottable::selectable () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3314 \{ return mSelectable; \}\par
}
}
{\xe \v selectableChanged\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectableChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectableChanged ({\b QCP::SelectionType}  {\i selectable}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selectability of this plottable has changed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectable} \par
}}}
{\xe \v selected\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::selected () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if there are any data points of the plottable currently selected. Use {\b selection} to retrieve the current {\b QCPDataSelection}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3315 \{ return !mSelection.isEmpty(); \}\par
}
}
{\xe \v selectEvent\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectEvent (QMouseEvent *  {\i event}, bool  {\i additive}, const QVariant &  {\i details}, bool *  {\i selectionStateChanged}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11225 \{\par
11226   Q_UNUSED(event)\par
11227   \par
11228   if (mSelectable != QCP::stNone)\par
11229   \{\par
11230     QCPDataSelection newSelection = details.value<QCPDataSelection>();\par
11231     QCPDataSelection selectionBefore = mSelection;\par
11232     if (additive)\par
11233     \{\par
11234       if (mSelectable == QCP::stWhole) // in whole selection mode, we toggle to no selection even if currently unselected point was hit\par
11235       \{\par
11236         if (selected())\par
11237           setSelection(QCPDataSelection());\par
11238         else\par
11239           setSelection(newSelection);\par
11240       \} else // in all other selection modes we toggle selections of homogeneously selected/unselected segments\par
11241       \{\par
11242         if (mSelection.contains(newSelection)) // if entire newSelection is already selected, toggle selection\par
11243           setSelection(mSelection-newSelection);\par
11244         else\par
11245           setSelection(mSelection+newSelection);\par
11246       \}\par
11247     \} else\par
11248       setSelection(newSelection);\par
11249     if (selectionStateChanged)\par
11250       *selectionStateChanged = mSelection != selectionBefore;\par
11251   \}\par
11252 \}\par
}
}
{\xe \v selection\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPAbstractPlottable::selection () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b QCPDataSelection} encompassing all the data points that are currently selected on this plottable.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selected}, {\b setSelection}, {\b setSelectable} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3316 \{ return mSelection; \}\par
}
}
{\xe \v selectionCategory\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectionCategory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::Interaction} QCPAbstractPlottable::selectionCategory () const{\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b QCPLayerable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11167 \{\par
11168   return QCP::iSelectPlottables;\par
11169 \}\par
}
}
{\xe \v selectionChanged\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectionChanged (bool  {\i selected}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to {\b setSelection}. The parameter {\i selected}  indicates whether there are any points selected or not.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectionChanged(const QCPDataSelection &selection)} \par
}}}
{\xe \v selectionChanged\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectionChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::selectionChanged (const {\b QCPDataSelection} &  {\i selection}){\f2 [signal]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to {\b setSelection}. The parameter {\i selection}  holds the currently selected data ranges.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b selectionChanged(bool selected)} \par
}}}
{\xe \v selectionDecorator\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionDecorator} * QCPAbstractPlottable::selectionDecorator () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides access to the selection decorator of this plottable. The selection decorator controls how selected data ranges are drawn (e.g. their pen color and fill), see {\b QCPSelectionDecorator} for details.\par
If you wish to use an own {\b QCPSelectionDecorator} subclass, pass an instance of it to {\b setSelectionDecorator}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3317 \{ return mSelectionDecorator; \}\par
}
}
{\xe \v selectTest\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > double {\b QCPAbstractPlottable1D}< DataType >::selectTest (const QPointF &  {\i pos}, bool  {\i onlySelectable}, QVariant *  {\i details} = {\f2 0}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Implementa {\b QCPAbstractPlottable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplementado por {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPCurve} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQJ \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4286 \{\par
 4287   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
 4288     return -1;\par
 4289   if (!mKeyAxis || !mValueAxis)\par
 4290     return -1;\par
 4291   \par
 4292   QCPDataSelection selectionResult;\par
 4293   double minDistSqr = std::numeric_limits<double>::max();\par
 4294   int minDistIndex = mDataContainer->size();\par
 4295   \par
 4296   typename QCPDataContainer<DataType>::const_iterator begin = mDataContainer->constBegin();\par
 4297   typename QCPDataContainer<DataType>::const_iterator end = mDataContainer->constEnd();\par
 4298   if (DataType::sortKeyIsMainKey()) // we can assume that data is sorted by main key, so can reduce the searched key interval:\par
 4299   \{\par
 4300     // determine which key range comes into question, taking selection tolerance around pos into account:\par
 4301     double posKeyMin, posKeyMax, dummy;\par
 4302     pixelsToCoords(pos-QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMin, dummy);\par
 4303     pixelsToCoords(pos+QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMax, dummy);\par
 4304     if (posKeyMin > posKeyMax)\par
 4305       qSwap(posKeyMin, posKeyMax);\par
 4306     begin = mDataContainer->findBegin(posKeyMin, true);\par
 4307     end = mDataContainer->findEnd(posKeyMax, true);\par
 4308   \}\par
 4309   if (begin == end)\par
 4310     return -1;\par
 4311   QCPRange keyRange(mKeyAxis->range());\par
 4312   QCPRange valueRange(mValueAxis->range());\par
 4313   for (typename QCPDataContainer<DataType>::const_iterator it=begin; it!=end; ++it)\par
 4314   \{\par
 4315     const double mainKey = it->mainKey();\par
 4316     const double mainValue = it->mainValue();\par
 4317     if (keyRange.contains(mainKey) && valueRange.contains(mainValue)) // make sure data point is inside visible range, for speedup in cases where sort key isn't main key and we iterate over all points\par
 4318     \{\par
 4319       const double currentDistSqr = QCPVector2D(coordsToPixels(mainKey, mainValue)-pos).lengthSquared();\par
 4320       if (currentDistSqr < minDistSqr)\par
 4321       \{\par
 4322         minDistSqr = currentDistSqr;\par
 4323         minDistIndex = it-mDataContainer->constBegin();\par
 4324       \}\par
 4325     \}\par
 4326   \}\par
 4327   if (minDistIndex != mDataContainer->size())\par
 4328     selectionResult.addDataRange(QCPDataRange(minDistIndex, minDistIndex+1), false);\par
 4329   \par
 4330   selectionResult.simplify();\par
 4331   if (details)\par
 4332     details->setValue(selectionResult);\par
 4333   return qSqrt(minDistSqr);\par
 4334 \}\par
}
}
{\xe \v selectTestRect\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:selectTestRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > {\b QCPDataSelection} {\b QCPAbstractPlottable1D}< DataType >::selectTestRect (const QRectF &  {\i rect}, bool  {\i onlySelectable}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a rect-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.\par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplementado por {\b QCPFinancial} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPStatisticalBox} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPBars} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4215 \{\par
 4216   QCPDataSelection result;\par
 4217   if ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
 4218     return result;\par
 4219   if (!mKeyAxis || !mValueAxis)\par
 4220     return result;\par
 4221   \par
 4222   // convert rect given in pixels to ranges given in plot coordinates:\par
 4223   double key1, value1, key2, value2;\par
 4224   pixelsToCoords(rect.topLeft(), key1, value1);\par
 4225   pixelsToCoords(rect.bottomRight(), key2, value2);\par
 4226   QCPRange keyRange(key1, key2); // QCPRange normalizes internally so we don't have to care about whether key1 < key2\par
 4227   QCPRange valueRange(value1, value2);\par
 4228   typename QCPDataContainer<DataType>::const_iterator begin = mDataContainer->constBegin();\par
 4229   typename QCPDataContainer<DataType>::const_iterator end = mDataContainer->constEnd();\par
 4230   if (DataType::sortKeyIsMainKey()) // we can assume that data is sorted by main key, so can reduce the searched key interval:\par
 4231   \{\par
 4232     begin = mDataContainer->findBegin(keyRange.lower, false);\par
 4233     end = mDataContainer->findEnd(keyRange.upper, false);\par
 4234   \}\par
 4235   if (begin == end)\par
 4236     return result;\par
 4237   \par
 4238   int currentSegmentBegin = -1; // -1 means we're currently not in a segment that's contained in rect\par
 4239   for (typename QCPDataContainer<DataType>::const_iterator it=begin; it!=end; ++it)\par
 4240   \{\par
 4241     if (currentSegmentBegin == -1)\par
 4242     \{\par
 4243       if (valueRange.contains(it->mainValue()) && keyRange.contains(it->mainKey())) // start segment\par
 4244         currentSegmentBegin = it-mDataContainer->constBegin();\par
 4245     \} else if (!valueRange.contains(it->mainValue()) || !keyRange.contains(it->mainKey())) // segment just ended\par
 4246     \{\par
 4247       result.addDataRange(QCPDataRange(currentSegmentBegin, it-mDataContainer->constBegin()), false);\par
 4248       currentSegmentBegin = -1;\par
 4249     \}\par
 4250   \}\par
 4251   // process potential last segment:\par
 4252   if (currentSegmentBegin != -1)\par
 4253     result.addDataRange(QCPDataRange(currentSegmentBegin, end-mDataContainer->constBegin()), false);\par
 4254   \par
 4255   result.simplify();\par
 4256   return result;\par
 4257 \}\par
}
}
{\xe \v setAntialiased\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setAntialiased (bool  {\i enabled}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether this object will be drawn antialiased or not.\par
Note that antialiasing settings may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1418 \{\par
 1419   mAntialiased = enabled;\par
 1420 \}\par
}
}
{\xe \v setAntialiasedFill\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setAntialiasedFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setAntialiasedFill (bool  {\i enabled}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether fills of this plottable are drawn antialiased or not.\par
Note that this setting may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10736 \{\par
10737   mAntialiasedFill = enabled;\par
10738 \}\par
}
}
{\xe \v setAntialiasedScatters\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setAntialiasedScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setAntialiasedScatters (bool  {\i enabled}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the scatter symbols of this plottable are drawn antialiased or not.\par
Note that this setting may be overridden by {\b QCustomPlot::setAntialiasedElements} and {\b QCustomPlot::setNotAntialiasedElements}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10747 \{\par
10748   mAntialiasedScatters = enabled;\par
10749 \}\par
}
}
{\xe \v setBrush\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setBrush (const QBrush &  {\i brush}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.\par
For example, the {\b QCPGraph} subclass draws the fill under the graph with this brush, when it's not set to Qt::NoBrush.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setPen} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10774 \{\par
10775   mBrush = brush;\par
10776 \}\par
}
}
{\xe \v setKeyAxis\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setKeyAxis ({\b QCPAxis} *  {\i axis}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The key axis of a plottable can be set to any axis of a {\b QCustomPlot}, as long as it is orthogonal to the plottable's value axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ({\b QCustomPlot::xAxis}) as key axis and the y-axis ({\b QCustomPlot::yAxis}) as value axis.\par
Normally, the key and value axes are set in the constructor of the plottable (or {\b QCustomPlot::addGraph} when working with QCPGraphs through the dedicated graph interface).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setValueAxis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10790 \{\par
10791   mKeyAxis = axis;\par
10792 \}\par
}
}
{\xe \v setLayer\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer ({\b QCPLayer} *  {\i layer}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the {\i layer}  of this layerable object. The object will be placed on top of the other objects already on {\i layer} .\par
If {\i layer}  is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).\par
Returns true if the layer of this layerable was successfully changed to {\i layer} . \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1385 \{\par
 1386   return moveToLayer(layer, false);\par
 1387 \}\par
}
}
{\xe \v setLayer\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::setLayer (const QString &  {\i layerName}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esse é um método provido por conveniência. Ele difere do método acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name\par
Returns true on success, i.e. if {\i layerName}  is a valid layer name. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1395 \{\par
 1396   if (!mParentPlot)\par
 1397   \{\par
 1398     qDebug() << Q_FUNC_INFO << "no parent QCustomPlot set";\par
 1399     return false;\par
 1400   \}\par
 1401   if (QCPLayer *layer = mParentPlot->layer(layerName))\par
 1402   \{\par
 1403     return setLayer(layer);\par
 1404   \} else\par
 1405   \{\par
 1406     qDebug() << Q_FUNC_INFO << "there is no layer with name" << layerName;\par
 1407     return false;\par
 1408   \}\par
 1409 \}\par
}
}
{\xe \v setName\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setName (const QString &  {\i name}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The name is the textual representation of this plottable as it is displayed in the legend ({\b QCPLegend}). It may contain any UTF-8 characters, including newlines. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10725 \{\par
10726   mName = name;\par
10727 \}\par
}
}
{\xe \v setParentLayerable\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setParentLayerable ({\b QCPLayerable} *  {\i parentLayerable}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1523 \{\par
 1524   mParentLayerable = parentLayerable;\par
 1525 \}\par
}
}
{\xe \v setPen\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setPen (const QPen &  {\i pen}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The pen is used to draw basic lines that make up the plottable representation in the plot.\par
For example, the {\b QCPGraph} subclass draws its graph lines with this pen.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setBrush} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10760 \{\par
10761   mPen = pen;\par
10762 \}\par
}
}
{\xe \v setSelectable\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setSelectable ({\b QCP::SelectionType}  {\i selectable}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether and to which granularity this plottable can be selected.\par
A selection can happen by clicking on the {\b QCustomPlot} surface (When {\b QCustomPlot::setInteractions} contains {\b QCP::iSelectPlottables}), by dragging a selection rect (When {\b QCustomPlot::setSelectionRectMode} is {\b QCP::srmSelect}), or programmatically by calling {\b setSelection}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelection}, {\b QCP::SelectionType} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10877 \{\par
10878   if (mSelectable != selectable)\par
10879   \{\par
10880     mSelectable = selectable;\par
10881     QCPDataSelection oldSelection = mSelection;\par
10882     mSelection.enforceType(mSelectable);\par
10883     emit selectableChanged(mSelectable);\par
10884     if (mSelection != oldSelection)\par
10885     \{\par
10886       emit selectionChanged(selected());\par
10887       emit selectionChanged(mSelection);\par
10888     \}\par
10889   \}\par
10890 \}\par
}
}
{\xe \v setSelection\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setSelection ({\b QCPDataSelection}  {\i selection}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets which data ranges of this plottable are selected. Selected data ranges are drawn differently (e.g. color) in the plot. This can be controlled via the selection decorator (see {\b selectionDecorator}).\par
The entire selection mechanism for plottables is handled automatically when {\b QCustomPlot::setInteractions} contains iSelectPlottables. You only need to call this function when you wish to change the selection state programmatically.\par
Using {\b setSelectable} you can further specify for each plottable whether and to which granularity it is selectable. If {\i selection}  is not compatible with the current {\b QCP::SelectionType} set via {\b setSelectable}, the resulting selection will be adjusted accordingly (see {\b QCPDataSelection::enforceType}).\par
emits the {\b selectionChanged} signal when {\i selected}  is different from the previous selection state.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setSelectable}, {\b selectTest} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10830 \{\par
10831   selection.enforceType(mSelectable);\par
10832   if (mSelection != selection)\par
10833   \{\par
10834     mSelection = selection;\par
10835     emit selectionChanged(selected());\par
10836     emit selectionChanged(mSelection);\par
10837   \}\par
10838 \}\par
}
}
{\xe \v setSelectionDecorator\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setSelectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setSelectionDecorator ({\b QCPSelectionDecorator} *  {\i decorator}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use this method to set an own {\b QCPSelectionDecorator} (subclass) instance. This allows you to customize the visual representation of selected data ranges further than by using the default {\b QCPSelectionDecorator}.\par
The plottable takes ownership of the {\i decorator} .\par
The currently set decorator can be accessed via {\b selectionDecorator}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10850 \{\par
10851   if (decorator)\par
10852   \{\par
10853     if (decorator->registerWithPlottable(this))\par
10854     \{\par
10855       if (mSelectionDecorator) // delete old decorator if necessary\par
10856         delete mSelectionDecorator;\par
10857       mSelectionDecorator = decorator;\par
10858     \}\par
10859   \} else if (mSelectionDecorator) // just clear decorator\par
10860   \{\par
10861     delete mSelectionDecorator;\par
10862     mSelectionDecorator = 0;\par
10863   \}\par
10864 \}\par
}
}
{\xe \v setValueAxis\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPAbstractPlottable::setValueAxis ({\b QCPAxis} *  {\i axis}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The value axis of a plottable can be set to any axis of a {\b QCustomPlot}, as long as it is orthogonal to the plottable's key axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ({\b QCustomPlot::xAxis}) as key axis and the y-axis ({\b QCustomPlot::yAxis}) as value axis.\par
Normally, the key and value axes are set in the constructor of the plottable (or {\b QCustomPlot::addGraph} when working with QCPGraphs through the dedicated graph interface).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b setKeyAxis} \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10806 \{\par
10807   mValueAxis = axis;\par
10808 \}\par
}
}
{\xe \v setVisible\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:setVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::setVisible (bool  {\i on}){\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the {\b QCustomPlot} surface, and user interaction with it (e.g. click and selection) is not possible. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1371 \{\par
 1372   mVisible = on;\par
 1373 \}\par
}
}
{\xe \v sortKeyIsMainKey\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:sortKeyIsMainKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType > bool {\b QCPAbstractPlottable1D}< DataType >::sortKeyIsMainKey () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the sort key ({\b dataSortKey}) is identical to the main key ({\b dataMainKey}).\par
What the sort and main keys are, is defined by the plottable's data type. See the {\b QCPDataContainer DataType} documentation for details about this naming convention. \par
}{
Implementa {\b QCPPlottableInterface1D} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4202 \{\par
 4203   return DataType::sortKeyIsMainKey();\par
 4204 \}\par
}
}
{\xe \v valueAxis\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:valueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPAxis}* QCPAbstractPlottable::valueAxis () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3313 \{ return mValueAxis.data(); \}\par
}
}
{\xe \v visible\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:visible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::visible () const{\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   707 \{ return mVisible; \}\par
}
}
{\xe \v wheelEvent\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:wheelEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void QCPLayerable::wheelEvent (QWheelEvent *  {\i event}){\f2 [protected]}, {\f2 [virtual]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to {\b selectTest}.\par
The current pixel position of the cursor on the {\b QCustomPlot} widget is accessible via {\f2 event->pos()} .\par
The {\f2 event->delta()}  indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making {\f2 event->delta()}  larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.\par
The default implementation does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Veja também:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b mousePressEvent}, {\b mouseMoveEvent}, {\b mouseReleaseEvent}, {\b mouseDoubleClickEvent} \par
}}{
Reimplementado por {\b QCPColorScale} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b QCPAxisRect} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b QCPAxis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1800 \{\par
 1801   event->ignore();\par
 1802 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mAntialiased\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mAntialiased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mAntialiased{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAntialiasedFill\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mAntialiasedFill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::mAntialiasedFill{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mAntialiasedScatters\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mAntialiasedScatters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPAbstractPlottable::mAntialiasedScatters{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mBrush\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mBrush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush QCPAbstractPlottable::mBrush{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mDataContainer\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mDataContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class DataType> QSharedPointer<{\b QCPDataContainer}<DataType> > {\b QCPAbstractPlottable1D}< DataType >::mDataContainer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mKeyAxis\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mKeyAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxis}> QCPAbstractPlottable::mKeyAxis{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mLayer\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPLayer}* QCPLayerable::mLayer{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mName\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString QCPAbstractPlottable::mName{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentLayerable\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mParentLayerable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPLayerable}> QCPLayerable::mParentLayerable{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mParentPlot\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mParentPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCustomPlot}* QCPLayerable::mParentPlot{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mPen\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mPen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPen QCPAbstractPlottable::mPen{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectable\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mSelectable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCP::SelectionType} QCPAbstractPlottable::mSelectable{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelection\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mSelection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPDataSelection} QCPAbstractPlottable::mSelection{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mSelectionDecorator\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mSelectionDecorator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QCPSelectionDecorator}* QCPAbstractPlottable::mSelectionDecorator{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mValueAxis\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mValueAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QPointer<{\b QCPAxis}> QCPAbstractPlottable::mValueAxis{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mVisible\:QCPAbstractPlottable1D}
{\xe \v QCPAbstractPlottable1D\:mVisible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool QCPLayerable::mVisible{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documentação para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b qcustomplot.h}\par
}}