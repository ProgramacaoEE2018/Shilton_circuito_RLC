<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="class_q_c_p_graph">
<title>QCPGraph class Reference</title>
<para>
    <programlisting>#include <link linkend="qcustomplot_8h">&lt;qcustomplot.h&gt;</link></programlisting>
</para>
<para>Inheritance diagram for QCPGraph</para>
<para>
    <figure>
        <title>Inheritance graph</title>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="1" fileref="class_q_c_p_graph__inherit__graph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </figure>
</para>
<para>Collaboration diagram for QCPGraph</para>
<para>
    <figure>
        <title>Collaboration graph</title>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="1" fileref="class_q_c_p_graph__coll__graph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </figure>
</para>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                            <para><literallayout>enum <link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859">LineStyle</link> {
<link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</link>,
<link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859a3c42a27b15aa3c92d399082fad8b7515">lsLine</link>,
<link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859ae10568bda57836487d9dec5eba1d6c6e">lsStepLeft</link>,
<link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859a9c37951f7d11aa070100fd16f2935c9e">lsStepRight</link>,
<link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859a5adf7b04da215a40a764c21294ea7366">lsStepCenter</link>,
<link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859aa3b358b4ae7cca94aceeb8e529c12ebb">lsImpulse</link>
}</literallayout>
</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title>Protected Attributes</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>LineStyle mLineStyle</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QCPScatterStyle mScatterStyle</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int mScatterSkip</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QPointer&lt; QCPGraph &gt; mChannelFillGraph</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool mAdaptiveSampling</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="class_q_c_p_graph_1a0393a38cf7183cbf46348eb6cf9a5a6c">QCPGraph</link> (
<link linkend="class_q_c_p_axis">QCPAxis</link> * keyAxis, <link linkend="class_q_c_p_axis">QCPAxis</link> * valueAxis)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual <link linkend="class_q_c_p_graph_1ae9998cfb9d379ac0ef3fbd6995cfbd76">~QCPGraph</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QSharedPointer&lt; <link linkend="qcustomplot_8h_1a2e5583d1ae212f0deb10537cf975a15a">QCPGraphDataContainer</link> &gt; <link linkend="class_q_c_p_graph_1a141aa31a1f19bbd0ce60f55eaeb9ea60">data</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859">LineStyle</link> <link linkend="class_q_c_p_graph_1ac3e6f4b3387338df45992b47691b2551">lineStyle</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="class_q_c_p_scatter_style">QCPScatterStyle</link> <link linkend="class_q_c_p_graph_1a36d5b641db08e27527827c212542bbbd">scatterStyle</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int <link linkend="class_q_c_p_graph_1a44487a3a706605bb9fc97ad5e05d347e">scatterSkip</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="class_q_c_p_graph">QCPGraph</link> * <link linkend="class_q_c_p_graph_1a84277b1655474453a5c83318053414d5">channelFillGraph</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool <link linkend="class_q_c_p_graph_1a1ba934b9621270b9a40fcdd2d9ba2adb">adaptiveSampling</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a1eae9429a316b008e2d99b2d65a54395">setData</link> (
QSharedPointer&lt; <link linkend="qcustomplot_8h_1a2e5583d1ae212f0deb10537cf975a15a">QCPGraphDataContainer</link> &gt; data)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a73578d786532132310a926c3cd529b29">setData</link> (
const QVector&lt; double &gt; &amp; keys, const QVector&lt; double &gt; &amp; values, bool alreadySorted)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a513fecccff5b2a50ce53f665338c60ff">setLineStyle</link> (
<link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859">LineStyle</link> ls)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a12bd17a8ba21983163ec5d8f42a9fea5">setScatterStyle</link> (
const <link linkend="class_q_c_p_scatter_style">QCPScatterStyle</link> &amp; style)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a17cebd3196f434258abb82ba6dc443f2">setScatterSkip</link> (
int skip)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a2d03156df1b64037a2e36cfa50351ca3">setChannelFillGraph</link> (
<link linkend="class_q_c_p_graph">QCPGraph</link> * targetGraph)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1ab468cd600160f327836aa0644291e64c">setAdaptiveSampling</link> (
bool enabled)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1ae0555c0d3fe0fa7cb8628f88158d420f">addData</link> (
const QVector&lt; double &gt; &amp; keys, const QVector&lt; double &gt; &amp; values, bool alreadySorted)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a0bf98b1972286cfb7b1c4b7dd6ae2012">addData</link> (
double key, double value)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual double <link linkend="class_q_c_p_graph_1a6d669d04462d272c6aa0e5f85846d673">selectTest</link> (
const QPointF &amp; pos, bool onlySelectable, QVariant * details)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual <link linkend="class_q_c_p_range">QCPRange</link> <link linkend="class_q_c_p_graph_1aac47c6189e3aea46ea46939e5d14796c">getKeyRange</link> (
bool &amp; foundRange, <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9">QCP::SignDomain</link> inSignDomain)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual <link linkend="class_q_c_p_range">QCPRange</link> <link linkend="class_q_c_p_graph_1a8f773e56f191a61c06e129e90a604d77">getValueRange</link> (
bool &amp; foundRange, <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9">QCP::SignDomain</link> inSignDomain, const <link linkend="class_q_c_p_range">QCPRange</link> &amp; inKeyRange)</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_graph_1a2b0849598f06e834b43ce18cd13bcdc3">draw</link> (
<link linkend="class_q_c_p_painter">QCPPainter</link> * painter)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_graph_1a6efbab06c400bdb15e28b2d0a4ecc18a">drawLegendIcon</link> (
<link linkend="class_q_c_p_painter">QCPPainter</link> * painter, const QRectF &amp; rect)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_graph_1a67c5ea573f604efd8bf121a0b7a380d1">drawFill</link> (
<link linkend="class_q_c_p_painter">QCPPainter</link> * painter, QVector&lt; QPointF &gt; * lines)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_graph_1abeb0bbe81026c024bf3d508d13cf5e0e">drawScatterPlot</link> (
<link linkend="class_q_c_p_painter">QCPPainter</link> * painter, const QVector&lt; QPointF &gt; &amp; scatters, const <link linkend="class_q_c_p_scatter_style">QCPScatterStyle</link> &amp; style)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_graph_1a4c3edacb2a11064bf2e16b322156aeda">drawLinePlot</link> (
<link linkend="class_q_c_p_painter">QCPPainter</link> * painter, const QVector&lt; QPointF &gt; &amp; lines)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_graph_1a217ef6bf6c5689eb1dcbe02187d2cc61">drawImpulsePlot</link> (
<link linkend="class_q_c_p_painter">QCPPainter</link> * painter, const QVector&lt; QPointF &gt; &amp; lines)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_graph_1a1fed1c9d627d9d3b49a6206cc2e60fe1">getOptimizedLineData</link> (
QVector&lt; <link linkend="class_q_c_p_graph_data">QCPGraphData</link> &gt; * lineData, const <link linkend="class_q_c_p_data_container_1ae40a91f5cb0bcac61d727427449b7d15">QCPGraphDataContainer::const_iterator</link> &amp; begin, const <link linkend="class_q_c_p_data_container_1ae40a91f5cb0bcac61d727427449b7d15">QCPGraphDataContainer::const_iterator</link> &amp; end)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_graph_1a5423245898537e375b9364cf26e89aea">getOptimizedScatterData</link> (
QVector&lt; <link linkend="class_q_c_p_graph_data">QCPGraphData</link> &gt; * scatterData, <link linkend="class_q_c_p_data_container_1ae40a91f5cb0bcac61d727427449b7d15">QCPGraphDataContainer::const_iterator</link> begin, <link linkend="class_q_c_p_data_container_1ae40a91f5cb0bcac61d727427449b7d15">QCPGraphDataContainer::const_iterator</link> end)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a8599447a7f8cbbdcf0b94edcc11df560">getVisibleDataBounds</link> (
<link linkend="class_q_c_p_data_container_1ae40a91f5cb0bcac61d727427449b7d15">QCPGraphDataContainer::const_iterator</link> &amp; begin, <link linkend="class_q_c_p_data_container_1ae40a91f5cb0bcac61d727427449b7d15">QCPGraphDataContainer::const_iterator</link> &amp; end, const <link linkend="class_q_c_p_data_range">QCPDataRange</link> &amp; rangeRestriction)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a563c6da2126300a4d9d2bdee30dad040">getLines</link> (
QVector&lt; QPointF &gt; * lines, const <link linkend="class_q_c_p_data_range">QCPDataRange</link> &amp; dataRange)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_graph_1a9d7ba5904fdcaca413222335d4b283c3">getScatters</link> (
QVector&lt; QPointF &gt; * scatters, const <link linkend="class_q_c_p_data_range">QCPDataRange</link> &amp; dataRange)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QVector&lt; QPointF &gt; <link linkend="class_q_c_p_graph_1a0085ee728fdd72a827c1e6ced4476363">dataToLines</link> (
const QVector&lt; <link linkend="class_q_c_p_graph_data">QCPGraphData</link> &gt; &amp; data)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QVector&lt; QPointF &gt; <link linkend="class_q_c_p_graph_1a1f3e9e41fc67538c4940c74665840474">dataToStepLeftLines</link> (
const QVector&lt; <link linkend="class_q_c_p_graph_data">QCPGraphData</link> &gt; &amp; data)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QVector&lt; QPointF &gt; <link linkend="class_q_c_p_graph_1ab1fb6cb91d24a854f85bf54200f6d101">dataToStepRightLines</link> (
const QVector&lt; <link linkend="class_q_c_p_graph_data">QCPGraphData</link> &gt; &amp; data)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QVector&lt; QPointF &gt; <link linkend="class_q_c_p_graph_1a238116f1898c49cb8209d61707b5b367">dataToStepCenterLines</link> (
const QVector&lt; <link linkend="class_q_c_p_graph_data">QCPGraphData</link> &gt; &amp; data)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QVector&lt; QPointF &gt; <link linkend="class_q_c_p_graph_1a2a958a5c6a6e1e4a03556be88b6fe37e">dataToImpulseLines</link> (
const QVector&lt; <link linkend="class_q_c_p_graph_data">QCPGraphData</link> &gt; &amp; data)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QVector&lt; <link linkend="class_q_c_p_data_range">QCPDataRange</link> &gt; <link linkend="class_q_c_p_graph_1a0e0886b9ec7731d8993bbb104465f3b9">getNonNanSegments</link> (
const QVector&lt; QPointF &gt; * lineData, Qt::Orientation keyOrientation)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QVector&lt; QPair&lt; <link linkend="class_q_c_p_data_range">QCPDataRange</link>, <link linkend="class_q_c_p_data_range">QCPDataRange</link> &gt; &gt; <link linkend="class_q_c_p_graph_1a334b15c43ee1855bf724daf886e8530e">getOverlappingSegments</link> (
QVector&lt; <link linkend="class_q_c_p_data_range">QCPDataRange</link> &gt; thisSegments, const QVector&lt; QPointF &gt; * thisData, QVector&lt; <link linkend="class_q_c_p_data_range">QCPDataRange</link> &gt; otherSegments, const QVector&lt; QPointF &gt; * otherData)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool <link linkend="class_q_c_p_graph_1abb9c674b207a1f6df5e083aa9f3e071a">segmentsIntersect</link> (
double aLower, double aUpper, double bLower, double bUpper, int &amp; bPrecedence)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QPointF <link linkend="class_q_c_p_graph_1a13f2c756f3114703159c2e604783e208">getFillBasePoint</link> (
QPointF matchingDataPoint)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const QPolygonF <link linkend="class_q_c_p_graph_1af73d5fe97cde966785bfd67201e44391">getFillPolygon</link> (
const QVector&lt; QPointF &gt; * lineData, <link linkend="class_q_c_p_data_range">QCPDataRange</link> segment)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const QPolygonF <link linkend="class_q_c_p_graph_1a9a5bdd5cb695d95d3eea80cfe96c5118">getChannelFillPolygon</link> (
const QVector&lt; QPointF &gt; * lineData, <link linkend="class_q_c_p_data_range">QCPDataRange</link> thisSegment, const QVector&lt; QPointF &gt; * otherData, <link linkend="class_q_c_p_data_range">QCPDataRange</link> otherSegment)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int <link linkend="class_q_c_p_graph_1a8c3f15dd5a06633011a6ef36016d308b">findIndexBelowX</link> (
const QVector&lt; QPointF &gt; * data, double x)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int <link linkend="class_q_c_p_graph_1aaabd6c6a7200a2672c44e62bd2a1cafa">findIndexAboveX</link> (
const QVector&lt; QPointF &gt; * data, double x)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int <link linkend="class_q_c_p_graph_1a5b0291f248e8ca8eaa82833ab420dcd0">findIndexBelowY</link> (
const QVector&lt; QPointF &gt; * data, double y)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int <link linkend="class_q_c_p_graph_1a8b952a5f937840dc242489585cc8000d">findIndexAboveY</link> (
const QVector&lt; QPointF &gt; * data, double y)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_q_c_p_graph_1a89acf99c0b52b8eecb2438adf7ec0170">pointDistance</link> (
const QPointF &amp; pixelPoint, <link linkend="class_q_c_p_data_container_1ae40a91f5cb0bcac61d727427449b7d15">QCPGraphDataContainer::const_iterator</link> &amp; closestData)</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    <simplesect>

<para>A plottable representing a graph in a plot. </para>
    </simplesect>
        <simplesect>
            <title>Detailed Description</title>

<para></para>

<para>Usually you create new graphs by calling <link linkend="class_q_custom_plot_1a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</link>. The resulting instance can be accessed via <link linkend="class_q_custom_plot_1a6ecae130f684b25276fb47bd3a5875c6">QCustomPlot::graph</link>.</para>

<para>To plot data, assign it with the <link linkend="class_q_c_p_graph_1a1eae9429a316b008e2d99b2d65a54395">setData</link> or <link linkend="class_q_c_p_graph_1ae0555c0d3fe0fa7cb8628f88158d420f">addData</link> functions. Alternatively, you can also access and modify the data via the <link linkend="class_q_c_p_graph_1a141aa31a1f19bbd0ce60f55eaeb9ea60">data</link> method, which returns a pointer to the internal <link linkend="qcustomplot_8h_1a2e5583d1ae212f0deb10537cf975a15a">QCPGraphDataContainer</link>.</para>

<para>Graphs are used to display single-valued data. Single-valued means that there should only be one data point per unique key coordinate. In other words, the graph can&apos;t have <emphasis>loops</emphasis>. If you do want to plot non-single-valued curves, rather use the <link linkend="class_q_c_p_curve">QCPCurve</link> plottable.</para>

<para>Gaps in the graph line can be created by adding data points with NaN as value (<computeroutput>qQNaN()</computeroutput> or <computeroutput>std::numeric_limits&lt;double&gt;::quiet_NaN()</computeroutput>) in between the two data points that shall be separated.</para>
<section xml:id="class_q_c_p_graph_1qcpgraph-appearance">
<title>Changing the appearance</title>

<para>The appearance of the graph is mainly determined by the line style, scatter style, brush and pen of the graph (<link linkend="class_q_c_p_graph_1a513fecccff5b2a50ce53f665338c60ff">setLineStyle</link>, <link linkend="class_q_c_p_graph_1a12bd17a8ba21983163ec5d8f42a9fea5">setScatterStyle</link>, <link linkend="class_q_c_p_abstract_plottable_1a7a4b92144dca6453a1f0f210e27edc74">setBrush</link>, <link linkend="class_q_c_p_abstract_plottable_1ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</link>).</para>
<section xml:id="class_q_c_p_graph_1filling">
<title>Filling under or between graphs</title>

<para><link linkend="class_q_c_p_graph">QCPGraph</link> knows two types of fills: Normal graph fills towards the zero-value-line parallel to the key axis of the graph, and fills between two graphs, called channel fills. To enable a fill, just set a brush with <link linkend="class_q_c_p_abstract_plottable_1a7a4b92144dca6453a1f0f210e27edc74">setBrush</link> which is neither Qt::NoBrush nor fully transparent.</para>

<para>By default, a normal fill towards the zero-value-line will be drawn. To set up a channel fill between this graph and another one, call <link linkend="class_q_c_p_graph_1a2d03156df1b64037a2e36cfa50351ca3">setChannelFillGraph</link> with the other graph as parameter.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_custom_plot_1a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</link>, <link linkend="class_q_custom_plot_1a6ecae130f684b25276fb47bd3a5875c6">QCustomPlot::graph</link> </para>
</formalpara>
</para>
</section>
</section>
                <para>Definition at line 5153 of file qcustomplot.h</para>
                <para>The Documentation for this struct was generated from the following file: </para>
                <para><itemizedlist><listitem><para>qcustomplot.h</para></listitem></itemizedlist></para>
        </simplesect>
            <section xml:id="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859">
               <title>enum LineStyle </title>
               
<para>Defines how the graph&apos;s line is represented visually in the plot. The line is drawn with the current pen of the graph (<link linkend="class_q_c_p_abstract_plottable_1ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</link>). <formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_graph_1a513fecccff5b2a50ce53f665338c60ff">setLineStyle</link> </para>
</formalpara>
</para>

               <formalpara>
                    <title>Enumerator:</title>
                    <variablelist>
                        <varlistentry xml:id="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">
                            <term>lsNone</term>
                            <listitem>
                                <para></para>
                            </listitem>
                        </varlistentry>
                        <varlistentry xml:id="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859a3c42a27b15aa3c92d399082fad8b7515">
                            <term>lsLine</term>
                            <listitem>
                                <para>data points are connected by a straight line</para>
                            </listitem>
                        </varlistentry>
                        <varlistentry xml:id="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859ae10568bda57836487d9dec5eba1d6c6e">
                            <term>lsStepLeft</term>
                            <listitem>
                                <para>line is drawn as steps where the step height is the value of the left data point</para>
                            </listitem>
                        </varlistentry>
                        <varlistentry xml:id="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859a9c37951f7d11aa070100fd16f2935c9e">
                            <term>lsStepRight</term>
                            <listitem>
                                <para>line is drawn as steps where the step height is the value of the right data point</para>
                            </listitem>
                        </varlistentry>
                        <varlistentry xml:id="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859a5adf7b04da215a40a764c21294ea7366">
                            <term>lsStepCenter</term>
                            <listitem>
                                <para>line is drawn as steps where the step is in between two data points</para>
                            </listitem>
                        </varlistentry>
                        <varlistentry xml:id="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859aa3b358b4ae7cca94aceeb8e529c12ebb">
                            <term>lsImpulse</term>
                            <listitem>
                                <para>each data point is represented by a line parallel to the value axis, which reaches from the data point to the zero-value-line</para>
                            </listitem>
                        </varlistentry>
                     </variablelist>
                </formalpara>
                <para>Definition at line 5168 of file qcustomplot.h
                    <computeroutput><literallayout>
{
lsNone, 
lsLine, 
lsStepLeft, 
lsStepRight, 
lsStepCenter, 
lsImpulse, 
}LineStyle;
                    </literallayout></computeroutput>
                </para>
            </section>
        <section>
            <title>Member Data Documentation</title>
        </section>
            <section xml:id="class_q_c_p_graph_1a0393a38cf7183cbf46348eb6cf9a5a6c">
                <title>QCPGraph::QCPGraph (QCPAxis *keyAxis, QCPAxis *valueAxis)</title> <emphasis></emphasis>
                
<para>Constructs a graph which uses <emphasis>keyAxis</emphasis> as its key axis (&quot;x&quot;) and <emphasis>valueAxis</emphasis> as its value axis (&quot;y&quot;). <emphasis>keyAxis</emphasis> and <emphasis>valueAxis</emphasis> must reside in the same <link linkend="class_q_custom_plot">QCustomPlot</link> instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.</para>

<para>The created <link linkend="class_q_c_p_graph">QCPGraph</link> is automatically registered with the <link linkend="class_q_custom_plot">QCustomPlot</link> instance inferred from <emphasis>keyAxis</emphasis>. This <link linkend="class_q_custom_plot">QCustomPlot</link> instance takes ownership of the <link linkend="class_q_c_p_graph">QCPGraph</link>, so do not delete it manually but use <link linkend="class_q_custom_plot_1af3dafd56884208474f311d6226513ab2">QCustomPlot::removePlottable()</link> instead.</para>

<para>To directly create a graph inside a plot, you can also use the simpler <link linkend="class_q_custom_plot_1a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</link> function. </para>

            </section>
            <section xml:id="class_q_c_p_graph_1ae9998cfb9d379ac0ef3fbd6995cfbd76">
                <title>QCPGraph::~QCPGraph ()</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a141aa31a1f19bbd0ce60f55eaeb9ea60">
                <title>QSharedPointer&lt; QCPGraphDataContainer &gt; QCPGraph::data () const</title> <emphasis></emphasis>
                
<para>Returns a shared pointer to the internal data storage of type <link linkend="qcustomplot_8h_1a2e5583d1ae212f0deb10537cf975a15a">QCPGraphDataContainer</link>. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular <link linkend="class_q_c_p_graph_1a1eae9429a316b008e2d99b2d65a54395">setData</link> or <link linkend="class_q_c_p_graph_1ae0555c0d3fe0fa7cb8628f88158d420f">addData</link> methods. </para>

            </section>
            <section xml:id="class_q_c_p_graph_1ac3e6f4b3387338df45992b47691b2551">
                <title>LineStyle QCPGraph::lineStyle () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a36d5b641db08e27527827c212542bbbd">
                <title>QCPScatterStyle QCPGraph::scatterStyle () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a44487a3a706605bb9fc97ad5e05d347e">
                <title>int QCPGraph::scatterSkip () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a84277b1655474453a5c83318053414d5">
                <title>QCPGraph* QCPGraph::channelFillGraph () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a1ba934b9621270b9a40fcdd2d9ba2adb">
                <title>bool QCPGraph::adaptiveSampling () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a1eae9429a316b008e2d99b2d65a54395">
                <title>void QCPGraph::setData (QSharedPointer&lt; QCPGraphDataContainer &gt; data)</title> <emphasis></emphasis>
                
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para>

<para>Replaces the current data container with the provided <emphasis>data</emphasis> container.</para>

<para>Since a QSharedPointer is used, multiple QCPGraphs may share the same data container safely. Modifying the data in the container will then affect all graphs that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: <literallayout><computeroutput></computeroutput></literallayout> If you do not wish to share containers, but create a copy from an existing container, rather use the <link linkend="class_q_c_p_data_container_1ae7042bd534fc3ce7befa2ce3f790b5bf">QCPDataContainer&lt;DataType&gt;::set</link> method on the graph&apos;s data container directly: <literallayout><computeroutput></computeroutput></literallayout> <formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_graph_1ae0555c0d3fe0fa7cb8628f88158d420f">addData</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_graph_1a73578d786532132310a926c3cd529b29">
                <title>void QCPGraph::setData (const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values, bool alreadySorted=false)</title> <emphasis></emphasis>
                
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para>

<para>Replaces the current data with the provided points in <emphasis>keys</emphasis> and <emphasis>values</emphasis>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.</para>

<para>If you can guarantee that the passed data points are sorted by <emphasis>keys</emphasis> in ascending order, you can set <emphasis>alreadySorted</emphasis> to true, to improve performance by saving a sorting run.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_graph_1ae0555c0d3fe0fa7cb8628f88158d420f">addData</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_graph_1a513fecccff5b2a50ce53f665338c60ff">
                <title>void QCPGraph::setLineStyle (LineStyle ls)</title> <emphasis></emphasis>
                
<para>Sets how the single data points are connected in the plot. For scatter-only plots, set <emphasis>ls</emphasis> to <link linkend="class_q_c_p_graph_1ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</link> and <link linkend="class_q_c_p_graph_1a12bd17a8ba21983163ec5d8f42a9fea5">setScatterStyle</link> to the desired scatter style.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_graph_1a12bd17a8ba21983163ec5d8f42a9fea5">setScatterStyle</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_graph_1a12bd17a8ba21983163ec5d8f42a9fea5">
                <title>void QCPGraph::setScatterStyle (const QCPScatterStyle &amp;style)</title> <emphasis></emphasis>
                
<para>Sets the visual appearance of single data points in the plot. If set to <link linkend="class_q_c_p_scatter_style_1adb31525af6b680e6f1b7472e43859349abd144c291ca274f77053ec68cab6c022">QCPScatterStyle::ssNone</link>, no scatter points are drawn (e.g. for line-only-plots with appropriate line style).</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_scatter_style">QCPScatterStyle</link>, <link linkend="class_q_c_p_graph_1a513fecccff5b2a50ce53f665338c60ff">setLineStyle</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_graph_1a17cebd3196f434258abb82ba6dc443f2">
                <title>void QCPGraph::setScatterSkip (int skip)</title> <emphasis></emphasis>
                
<para>If scatters are displayed (scatter style not <link linkend="class_q_c_p_scatter_style_1adb31525af6b680e6f1b7472e43859349abd144c291ca274f77053ec68cab6c022">QCPScatterStyle::ssNone</link>), <emphasis>skip</emphasis> number of scatter points are skipped/not drawn after every drawn scatter point.</para>

<para>This can be used to make the data appear sparser while for example still having a smooth line, and to improve performance for very high density plots.</para>

<para>If <emphasis>skip</emphasis> is set to 0 (default), all scatter points are drawn.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_graph_1a12bd17a8ba21983163ec5d8f42a9fea5">setScatterStyle</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_graph_1a2d03156df1b64037a2e36cfa50351ca3">
                <title>void QCPGraph::setChannelFillGraph (QCPGraph *targetGraph)</title> <emphasis></emphasis>
                
<para>Sets the target graph for filling the area between this graph and <emphasis>targetGraph</emphasis> with the current brush (<link linkend="class_q_c_p_abstract_plottable_1a7a4b92144dca6453a1f0f210e27edc74">setBrush</link>).</para>

<para>When <emphasis>targetGraph</emphasis> is set to 0, a normal graph fill to the zero-value-line will be shown. To disable any filling, set the brush to Qt::NoBrush.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_abstract_plottable_1a7a4b92144dca6453a1f0f210e27edc74">setBrush</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_graph_1ab468cd600160f327836aa0644291e64c">
                <title>void QCPGraph::setAdaptiveSampling (bool enabled)</title> <emphasis></emphasis>
                
<para>Sets whether adaptive sampling shall be used when plotting this graph. <link linkend="class_q_custom_plot">QCustomPlot</link>&apos;s adaptive sampling technique can drastically improve the replot performance for graphs with a larger number of points (e.g. above 10,000), without notably changing the appearance of the graph.</para>

<para>By default, adaptive sampling is enabled. Even if enabled, <link linkend="class_q_custom_plot">QCustomPlot</link> decides whether adaptive sampling shall actually be used on a per-graph basis. So leaving adaptive sampling enabled has no disadvantage in almost all cases.</para>

<para> As can be seen, line plots experience no visual degradation from adaptive sampling. Outliers are reproduced reliably, as well as the overall shape of the data set. The replot time reduces dramatically though. This allows <link linkend="class_q_custom_plot">QCustomPlot</link> to display large amounts of data in realtime.</para>

<para> Care must be taken when using high-density scatter plots in combination with adaptive sampling. The adaptive sampling algorithm treats scatter plots more carefully than line plots which still gives a significant reduction of replot times, but not quite as much as for line plots. This is because scatter plots inherently need more data points to be preserved in order to still resemble the original, non-adaptive-sampling plot. As shown above, the results still aren&apos;t quite identical, as banding occurs for the outer data points. This is in fact intentional, such that the boundaries of the data cloud stay visible to the viewer. How strong the banding appears, depends on the point density, i.e. the number of points in the plot.</para>

<para>For some situations with scatter plots it might thus be desirable to manually turn adaptive sampling off. For example, when saving the plot to disk. This can be achieved by setting <emphasis>enabled</emphasis> to false before issuing a command like <link linkend="class_q_custom_plot_1ac92cc9256d12f354b40a4be4600b5fb9">QCustomPlot::savePng</link>, and setting <emphasis>enabled</emphasis> back to true afterwards. </para>

            </section>
            <section xml:id="class_q_c_p_graph_1ae0555c0d3fe0fa7cb8628f88158d420f">
                <title>void QCPGraph::addData (const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values, bool alreadySorted=false)</title> <emphasis></emphasis>
                
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para>

<para>Adds the provided points in <emphasis>keys</emphasis> and <emphasis>values</emphasis> to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.</para>

<para>If you can guarantee that the passed data points are sorted by <emphasis>keys</emphasis> in ascending order, you can set <emphasis>alreadySorted</emphasis> to true, to improve performance by saving a sorting run.</para>

<para>Alternatively, you can also access and modify the data directly via the <link linkend="class_q_c_p_graph_1a141aa31a1f19bbd0ce60f55eaeb9ea60">data</link> method, which returns a pointer to the internal data container. </para>

            </section>
            <section xml:id="class_q_c_p_graph_1a0bf98b1972286cfb7b1c4b7dd6ae2012">
                <title>void QCPGraph::addData (double key, double value)</title> <emphasis></emphasis>
                
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para>

<para>Adds the provided data point as <emphasis>key</emphasis> and <emphasis>value</emphasis> to the current data.</para>

<para>Alternatively, you can also access and modify the data directly via the <link linkend="class_q_c_p_graph_1a141aa31a1f19bbd0ce60f55eaeb9ea60">data</link> method, which returns a pointer to the internal data container. </para>

            </section>
            <section xml:id="class_q_c_p_graph_1a6d669d04462d272c6aa0e5f85846d673">
                <title>double QCPGraph::selectTest (const QPointF &amp;pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
<para>Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.</para>

            </section>
            <section xml:id="class_q_c_p_graph_1aac47c6189e3aea46ea46939e5d14796c">
                <title>QCPRange QCPGraph::getKeyRange (bool &amp;foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) const Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
<para>Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set <emphasis>inSignDomain</emphasis> to either <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a2d18af0bc58f6528d1e82ce699fe4829">QCP::sdNegative</link> or <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a584784b75fb816abcc627cf743bb699f">QCP::sdPositive</link> in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set <emphasis>inSignDomain</emphasis> to <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a2d18af0bc58f6528d1e82ce699fe4829">QCP::sdNegative</link> and all positive points will be ignored for range calculation. For no restriction, just set <emphasis>inSignDomain</emphasis> to <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9aa38352ef02d51ddfa4399d9551566e24">QCP::sdBoth</link> (default). <emphasis>foundRange</emphasis> is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn&apos;t use the returned range (e.g. no points in data).</para>

<para>Note that <emphasis>foundRange</emphasis> is not the same as <link linkend="class_q_c_p_range_1ab38bd4841c77c7bb86c9eea0f142dcc0">QCPRange::validRange</link>, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case <emphasis>foundRange</emphasis> would return true, but the returned range is not a valid range in terms of <link linkend="class_q_c_p_range_1ab38bd4841c77c7bb86c9eea0f142dcc0">QCPRange::validRange</link>.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_abstract_plottable_1a1491c4a606bccd2d09e65e11b79eb882">rescaleAxes</link>, <link linkend="class_q_c_p_graph_1a8f773e56f191a61c06e129e90a604d77">getValueRange</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_graph_1a8f773e56f191a61c06e129e90a604d77">
                <title>QCPRange QCPGraph::getValueRange (bool &amp;foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, const QCPRange &amp;inKeyRange=QCPRange()) const Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
<para>Returns the coordinate range that the data points in the specified key range (<emphasis>inKeyRange</emphasis>) span in the value axis dimension. For logarithmic plots, one can set <emphasis>inSignDomain</emphasis> to either <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a2d18af0bc58f6528d1e82ce699fe4829">QCP::sdNegative</link> or <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a584784b75fb816abcc627cf743bb699f">QCP::sdPositive</link> in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set <emphasis>inSignDomain</emphasis> to <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a2d18af0bc58f6528d1e82ce699fe4829">QCP::sdNegative</link> and all positive points will be ignored for range calculation. For no restriction, just set <emphasis>inSignDomain</emphasis> to <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9aa38352ef02d51ddfa4399d9551566e24">QCP::sdBoth</link> (default). <emphasis>foundRange</emphasis> is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn&apos;t use the returned range (e.g. no points in data).</para>

<para>If <emphasis>inKeyRange</emphasis> has both lower and upper bound set to zero (is equal to <computeroutput><link linkend="class_q_c_p_range">QCPRange()</link></computeroutput>), all data points are considered, without any restriction on the keys.</para>

<para>Note that <emphasis>foundRange</emphasis> is not the same as <link linkend="class_q_c_p_range_1ab38bd4841c77c7bb86c9eea0f142dcc0">QCPRange::validRange</link>, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case <emphasis>foundRange</emphasis> would return true, but the returned range is not a valid range in terms of <link linkend="class_q_c_p_range_1ab38bd4841c77c7bb86c9eea0f142dcc0">QCPRange::validRange</link>.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_abstract_plottable_1a1491c4a606bccd2d09e65e11b79eb882">rescaleAxes</link>, <link linkend="class_q_c_p_graph_1aac47c6189e3aea46ea46939e5d14796c">getKeyRange</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_graph_1a2b0849598f06e834b43ce18cd13bcdc3">
                <title>void QCPGraph::draw (QCPPainter *painter) Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a6efbab06c400bdb15e28b2d0a4ecc18a">
                <title>void QCPGraph::drawLegendIcon (QCPPainter *painter, const QRectF &amp;rect) const Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a67c5ea573f604efd8bf121a0b7a380d1">
                <title>void QCPGraph::drawFill (QCPPainter *painter, QVector&lt; QPointF &gt; *lines) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1abeb0bbe81026c024bf3d508d13cf5e0e">
                <title>void QCPGraph::drawScatterPlot (QCPPainter *painter, const QVector&lt; QPointF &gt; &amp;scatters, const QCPScatterStyle &amp;style) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a4c3edacb2a11064bf2e16b322156aeda">
                <title>void QCPGraph::drawLinePlot (QCPPainter *painter, const QVector&lt; QPointF &gt; &amp;lines) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a217ef6bf6c5689eb1dcbe02187d2cc61">
                <title>void QCPGraph::drawImpulsePlot (QCPPainter *painter, const QVector&lt; QPointF &gt; &amp;lines) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a1fed1c9d627d9d3b49a6206cc2e60fe1">
                <title>void QCPGraph::getOptimizedLineData (QVector&lt; QCPGraphData &gt; *lineData, const QCPGraphDataContainer::const_iterator &amp;begin, const QCPGraphDataContainer::const_iterator &amp;end) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a5423245898537e375b9364cf26e89aea">
                <title>void QCPGraph::getOptimizedScatterData (QVector&lt; QCPGraphData &gt; *scatterData, QCPGraphDataContainer::const_iterator begin, QCPGraphDataContainer::const_iterator end) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a8599447a7f8cbbdcf0b94edcc11df560">
                <title>void QCPGraph::getVisibleDataBounds (QCPGraphDataContainer::const_iterator &amp;begin, QCPGraphDataContainer::const_iterator &amp;end, const QCPDataRange &amp;rangeRestriction) const</title> <emphasis></emphasis>
                
<para>This method outputs the currently visible data range via <emphasis>begin</emphasis> and <emphasis>end</emphasis>. The returned range will also never exceed <emphasis>rangeRestriction</emphasis>.</para>

<para>This method takes into account that the drawing of data lines at the axis rect border always requires the points just outside the visible axis range. So <emphasis>begin</emphasis> and <emphasis>end</emphasis> may actually indicate a range that contains one additional data point to the left and right of the visible axis range. </para>

            </section>
            <section xml:id="class_q_c_p_graph_1a563c6da2126300a4d9d2bdee30dad040">
                <title>void QCPGraph::getLines (QVector&lt; QPointF &gt; *lines, const QCPDataRange &amp;dataRange) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a9d7ba5904fdcaca413222335d4b283c3">
                <title>void QCPGraph::getScatters (QVector&lt; QPointF &gt; *scatters, const QCPDataRange &amp;dataRange) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a0085ee728fdd72a827c1e6ced4476363">
                <title>QVector&lt; QPointF &gt; QCPGraph::dataToLines (const QVector&lt; QCPGraphData &gt; &amp;data) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a1f3e9e41fc67538c4940c74665840474">
                <title>QVector&lt; QPointF &gt; QCPGraph::dataToStepLeftLines (const QVector&lt; QCPGraphData &gt; &amp;data) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1ab1fb6cb91d24a854f85bf54200f6d101">
                <title>QVector&lt; QPointF &gt; QCPGraph::dataToStepRightLines (const QVector&lt; QCPGraphData &gt; &amp;data) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a238116f1898c49cb8209d61707b5b367">
                <title>QVector&lt; QPointF &gt; QCPGraph::dataToStepCenterLines (const QVector&lt; QCPGraphData &gt; &amp;data) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a2a958a5c6a6e1e4a03556be88b6fe37e">
                <title>QVector&lt; QPointF &gt; QCPGraph::dataToImpulseLines (const QVector&lt; QCPGraphData &gt; &amp;data) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a0e0886b9ec7731d8993bbb104465f3b9">
                <title>QVector&lt; QCPDataRange &gt; QCPGraph::getNonNanSegments (const QVector&lt; QPointF &gt; *lineData, Qt::Orientation keyOrientation) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a334b15c43ee1855bf724daf886e8530e">
                <title>QVector&lt; QPair&lt; QCPDataRange, QCPDataRange &gt; &gt; QCPGraph::getOverlappingSegments (QVector&lt; QCPDataRange &gt; thisSegments, const QVector&lt; QPointF &gt; *thisData, QVector&lt; QCPDataRange &gt; otherSegments, const QVector&lt; QPointF &gt; *otherData) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1abb9c674b207a1f6df5e083aa9f3e071a">
                <title>bool QCPGraph::segmentsIntersect (double aLower, double aUpper, double bLower, double bUpper, int &amp;bPrecedence) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a13f2c756f3114703159c2e604783e208">
                <title>QPointF QCPGraph::getFillBasePoint (QPointF matchingDataPoint) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1af73d5fe97cde966785bfd67201e44391">
                <title>const QPolygonF QCPGraph::getFillPolygon (const QVector&lt; QPointF &gt; *lineData, QCPDataRange segment) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a9a5bdd5cb695d95d3eea80cfe96c5118">
                <title>const QPolygonF QCPGraph::getChannelFillPolygon (const QVector&lt; QPointF &gt; *lineData, QCPDataRange thisSegment, const QVector&lt; QPointF &gt; *otherData, QCPDataRange otherSegment) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a8c3f15dd5a06633011a6ef36016d308b">
                <title>int QCPGraph::findIndexBelowX (const QVector&lt; QPointF &gt; *data, double x) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1aaabd6c6a7200a2672c44e62bd2a1cafa">
                <title>int QCPGraph::findIndexAboveX (const QVector&lt; QPointF &gt; *data, double x) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a5b0291f248e8ca8eaa82833ab420dcd0">
                <title>int QCPGraph::findIndexBelowY (const QVector&lt; QPointF &gt; *data, double y) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a8b952a5f937840dc242489585cc8000d">
                <title>int QCPGraph::findIndexAboveY (const QVector&lt; QPointF &gt; *data, double y) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_graph_1a89acf99c0b52b8eecb2438adf7ec0170">
                <title>double QCPGraph::pointDistance (const QPointF &amp;pixelPoint, QCPGraphDataContainer::const_iterator &amp;closestData) const</title> <emphasis></emphasis>
                
            </section>
</section>
