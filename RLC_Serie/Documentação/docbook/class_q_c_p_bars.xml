<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="class_q_c_p_bars">
<title>QCPBars class Reference</title>
<para>
    <programlisting>#include <link linkend="qcustomplot_8h">&lt;qcustomplot.h&gt;</link></programlisting>
</para>
<para>Inheritance diagram for QCPBars</para>
<para>
    <figure>
        <title>Inheritance graph</title>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="1" fileref="class_q_c_p_bars__inherit__graph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </figure>
</para>
<para>Collaboration diagram for QCPBars</para>
<para>
    <figure>
        <title>Collaboration graph</title>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="1" fileref="class_q_c_p_bars__coll__graph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </figure>
</para>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                            <para><literallayout>enum <link linkend="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649">WidthType</link> {
<link linkend="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649ab74315c9aa77df593c58dd25dfc0de35">wtAbsolute</link>,
<link linkend="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649a90bc09899361ad3422ff277f7c790ffe">wtAxisRectRatio</link>,
<link linkend="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649aad3cc60ae1bfb1160a30237bee9eaf10">wtPlotCoords</link>
}</literallayout>
</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title>Protected Attributes</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double mWidth</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>WidthType mWidthType</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QCPBarsGroup * mBarsGroup</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double mBaseValue</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double mStackingGap</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QPointer&lt; QCPBars &gt; mBarBelow</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QPointer&lt; QCPBars &gt; mBarAbove</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="class_q_c_p_bars_1a64006999ad9dff308f40df41cef176ad">QCPBars</link> (
<link linkend="class_q_c_p_axis">QCPAxis</link> * keyAxis, <link linkend="class_q_c_p_axis">QCPAxis</link> * valueAxis)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual <link linkend="class_q_c_p_bars_1a4d880e28031ef120603f543379be2f22">~QCPBars</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_q_c_p_bars_1abe7eb3987d8711f45829db879aee2280">width</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649">WidthType</link> <link linkend="class_q_c_p_bars_1a4c103fb405a45f47853e0345f0c6e708">widthType</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="class_q_c_p_bars_group">QCPBarsGroup</link> * <link linkend="class_q_c_p_bars_1a5eef59840b68d205df4e0c3df5f97633">barsGroup</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_q_c_p_bars_1a29a7b3b86f80b2a04bd1f9ec0ebaf422">baseValue</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_q_c_p_bars_1a2e6192fa9c16df7ba94cd50c0c9ec7ce">stackingGap</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="class_q_c_p_bars">QCPBars</link> * <link linkend="class_q_c_p_bars_1a1b58664864b141f45e02044a855b3213">barBelow</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link linkend="class_q_c_p_bars">QCPBars</link> * <link linkend="class_q_c_p_bars_1ab97f2acd9f6cb40d2cc3c33d278f0e78">barAbove</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QSharedPointer&lt; <link linkend="qcustomplot_8h_1a52bf589c9fce1baa36c1d40d69785d46">QCPBarsDataContainer</link> &gt; <link linkend="class_q_c_p_bars_1a7e373a534d82e18ed27b3fafd1f08fae">data</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1a6dc562ec7120a8521e1061f2134367e4">setData</link> (
QSharedPointer&lt; <link linkend="qcustomplot_8h_1a52bf589c9fce1baa36c1d40d69785d46">QCPBarsDataContainer</link> &gt; data)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1a2a88cd5b16ec7b71e5a590f95b50c5ce">setData</link> (
const QVector&lt; double &gt; &amp; keys, const QVector&lt; double &gt; &amp; values, bool alreadySorted)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1afec6116579d44d5b706e0fa5e5332507">setWidth</link> (
double width)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1adcaa3b41281bb2c0f7949b341592fcc0">setWidthType</link> (
<link linkend="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649">WidthType</link> widthType)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1aedd1709061f0b307c47ddb45e172ef9a">setBarsGroup</link> (
<link linkend="class_q_c_p_bars_group">QCPBarsGroup</link> * barsGroup)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1a574ec7eb7537566df1a28ff085d75623">setBaseValue</link> (
double baseValue)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1aeacf7561afb1c70284b22822b57c7bb5">setStackingGap</link> (
double pixels)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1a323d6970d6d6e3166d89916a7f60f733">addData</link> (
const QVector&lt; double &gt; &amp; keys, const QVector&lt; double &gt; &amp; values, bool alreadySorted)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1a684dd105403a5497fda42f2094fecbb7">addData</link> (
double key, double value)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1a69fc371346980f19177c3d1ecdad78ee">moveBelow</link> (
<link linkend="class_q_c_p_bars">QCPBars</link> * bars)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1ac22e00a6a41509538c21b04f0a57318c">moveAbove</link> (
<link linkend="class_q_c_p_bars">QCPBars</link> * bars)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual <link linkend="class_q_c_p_data_selection">QCPDataSelection</link> <link linkend="class_q_c_p_bars_1ab03bb6125c3e983b89d694f75ce6b3d5">selectTestRect</link> (
const QRectF &amp; rect, bool onlySelectable)<para><emphasis>\copybrief QCPPlottableInterface1D::selectTestRect</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual double <link linkend="class_q_c_p_bars_1a121f899c27af3186fe93dcd0eb98f49b">selectTest</link> (
const QPointF &amp; pos, bool onlySelectable, QVariant * details)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual <link linkend="class_q_c_p_range">QCPRange</link> <link linkend="class_q_c_p_bars_1ac5a3854774d9d9cd129b1eae1426de2d">getKeyRange</link> (
bool &amp; foundRange, <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9">QCP::SignDomain</link> inSignDomain)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual <link linkend="class_q_c_p_range">QCPRange</link> <link linkend="class_q_c_p_bars_1a02cee4bf94d48a1e5f6fc185d9a10477">getValueRange</link> (
bool &amp; foundRange, <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9">QCP::SignDomain</link> inSignDomain, const <link linkend="class_q_c_p_range">QCPRange</link> &amp; inKeyRange)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual QPointF <link linkend="class_q_c_p_bars_1a55cdaf565cd3384158d1f7f89533bc2d">dataPixelPosition</link> (
int index)<para><emphasis>\copybrief QCPPlottableInterface1D::dataPixelPosition</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_bars_1aa267c20650d55084c3f47cb2f8fac9dc">draw</link> (
<link linkend="class_q_c_p_painter">QCPPainter</link> * painter)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>virtual void <link linkend="class_q_c_p_bars_1aee7c3e1763fd6b504c45baa8775be7b7">drawLegendIcon</link> (
<link linkend="class_q_c_p_painter">QCPPainter</link> * painter, const QRectF &amp; rect)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1ac8b6b514a665a7bff4fb080413ba996a">getVisibleDataBounds</link> (
<link linkend="class_q_c_p_data_container_1ae40a91f5cb0bcac61d727427449b7d15">QCPBarsDataContainer::const_iterator</link> &amp; begin, <link linkend="class_q_c_p_data_container_1ae40a91f5cb0bcac61d727427449b7d15">QCPBarsDataContainer::const_iterator</link> &amp; end)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>QRectF <link linkend="class_q_c_p_bars_1a01b87e38e5d5089d214646d2af7896ea">getBarRect</link> (
double key, double value)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_q_c_p_bars_1ad87586cc5e9806740bc0e867667da409">getPixelWidth</link> (
double key, double &amp; lower, double &amp; upper)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_q_c_p_bars_1a0ffd6e043876e13e89eaa54e9f8a04b9">getStackedBaseValue</link> (
double key, bool positive)</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>static void <link linkend="class_q_c_p_bars_1a6ea37802cd22f97235cab614b14b9f19">connectBars</link> (
<link linkend="class_q_c_p_bars">QCPBars</link> * lower, <link linkend="class_q_c_p_bars">QCPBars</link> * upper)</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    <simplesect>

<para>A plottable representing a bar chart in a plot. </para>
    </simplesect>
        <simplesect>
            <title>Detailed Description</title>

<para></para>

<para>To plot data, assign it with the <link linkend="class_q_c_p_bars_1a6dc562ec7120a8521e1061f2134367e4">setData</link> or <link linkend="class_q_c_p_bars_1a323d6970d6d6e3166d89916a7f60f733">addData</link> functions.</para>
<section xml:id="class_q_c_p_bars_1qcpbars-appearance">
<title>Changing the appearance</title>

<para>The appearance of the bars is determined by the pen and the brush (<link linkend="class_q_c_p_abstract_plottable_1ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</link>, <link linkend="class_q_c_p_abstract_plottable_1a7a4b92144dca6453a1f0f210e27edc74">setBrush</link>). The width of the individual bars can be controlled with <link linkend="class_q_c_p_bars_1adcaa3b41281bb2c0f7949b341592fcc0">setWidthType</link> and <link linkend="class_q_c_p_bars_1afec6116579d44d5b706e0fa5e5332507">setWidth</link>.</para>

<para>Bar charts are stackable. This means, two <link linkend="class_q_c_p_bars">QCPBars</link> plottables can be placed on top of each other (see <link linkend="class_q_c_p_bars_1ac22e00a6a41509538c21b04f0a57318c">QCPBars::moveAbove</link>). So when two bars are at the same key position, they will appear stacked.</para>

<para>If you would like to group multiple <link linkend="class_q_c_p_bars">QCPBars</link> plottables together so they appear side by side as shown below, use <link linkend="class_q_c_p_bars_group">QCPBarsGroup</link>.</para>

<para></para>
</section>
<section xml:id="class_q_c_p_bars_1qcpbars-usage">
<title>Usage</title>

<para>Like all data representing objects in <link linkend="class_q_custom_plot">QCustomPlot</link>, the <link linkend="class_q_c_p_bars">QCPBars</link> is a plottable (<link linkend="class_q_c_p_abstract_plottable">QCPAbstractPlottable</link>). So the plottable-interface of <link linkend="class_q_custom_plot">QCustomPlot</link> applies (<link linkend="class_q_custom_plot_1a32de81ff53e263e785b83b52ecd99d6f">QCustomPlot::plottable</link>, <link linkend="class_q_custom_plot_1af3dafd56884208474f311d6226513ab2">QCustomPlot::removePlottable</link>, etc.)</para>

<para>Usually, you first create an instance: <literallayout><computeroutput></computeroutput></literallayout>which registers it with the <link linkend="class_q_custom_plot">QCustomPlot</link> instance of the passed axes. Note that this <link linkend="class_q_custom_plot">QCustomPlot</link> instance takes ownership of the plottable, so do not delete it manually but use <link linkend="class_q_custom_plot_1af3dafd56884208474f311d6226513ab2">QCustomPlot::removePlottable()</link> instead. The newly created plottable can be modified, e.g.: <literallayout><computeroutput></computeroutput></literallayout></para>
</section>
                <para>Definition at line 5472 of file qcustomplot.h</para>
                <para>The Documentation for this struct was generated from the following file: </para>
                <para><itemizedlist><listitem><para>qcustomplot.h</para></listitem></itemizedlist></para>
        </simplesect>
            <section xml:id="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649">
               <title>enum WidthType </title>
               
<para>Defines the ways the width of the bar can be specified. Thus it defines what the number passed to <link linkend="class_q_c_p_bars_1afec6116579d44d5b706e0fa5e5332507">setWidth</link> actually means.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_bars_1adcaa3b41281bb2c0f7949b341592fcc0">setWidthType</link>, <link linkend="class_q_c_p_bars_1afec6116579d44d5b706e0fa5e5332507">setWidth</link> </para>
</formalpara>
</para>

               <formalpara>
                    <title>Enumerator:</title>
                    <variablelist>
                        <varlistentry xml:id="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649ab74315c9aa77df593c58dd25dfc0de35">
                            <term>wtAbsolute</term>
                            <listitem>
                                <para>Bar width is in absolute pixels.</para>
                            </listitem>
                        </varlistentry>
                        <varlistentry xml:id="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649a90bc09899361ad3422ff277f7c790ffe">
                            <term>wtAxisRectRatio</term>
                            <listitem>
                                <para>Bar width is given by a fraction of the axis rect size.</para>
                            </listitem>
                        </varlistentry>
                        <varlistentry xml:id="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649aad3cc60ae1bfb1160a30237bee9eaf10">
                            <term>wtPlotCoords</term>
                            <listitem>
                                <para>Bar width is in key coordinates and thus scales with the key axis range.</para>
                            </listitem>
                        </varlistentry>
                     </variablelist>
                </formalpara>
                <para>Definition at line 5490 of file qcustomplot.h
                    <computeroutput><literallayout>
{
wtAbsolute, 
wtAxisRectRatio, 
wtPlotCoords, 
}WidthType;
                    </literallayout></computeroutput>
                </para>
            </section>
        <section>
            <title>Member Data Documentation</title>
        </section>
            <section xml:id="class_q_c_p_bars_1a64006999ad9dff308f40df41cef176ad">
                <title>QCPBars::QCPBars (QCPAxis *keyAxis, QCPAxis *valueAxis)</title> <emphasis></emphasis>
                
<para>Constructs a bar chart which uses <emphasis>keyAxis</emphasis> as its key axis (&quot;x&quot;) and <emphasis>valueAxis</emphasis> as its value axis (&quot;y&quot;). <emphasis>keyAxis</emphasis> and <emphasis>valueAxis</emphasis> must reside in the same <link linkend="class_q_custom_plot">QCustomPlot</link> instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.</para>

<para>The created <link linkend="class_q_c_p_bars">QCPBars</link> is automatically registered with the <link linkend="class_q_custom_plot">QCustomPlot</link> instance inferred from <emphasis>keyAxis</emphasis>. This <link linkend="class_q_custom_plot">QCustomPlot</link> instance takes ownership of the <link linkend="class_q_c_p_bars">QCPBars</link>, so do not delete it manually but use <link linkend="class_q_custom_plot_1af3dafd56884208474f311d6226513ab2">QCustomPlot::removePlottable()</link> instead. </para>

            </section>
            <section xml:id="class_q_c_p_bars_1a4d880e28031ef120603f543379be2f22">
                <title>QCPBars::~QCPBars ()</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1abe7eb3987d8711f45829db879aee2280">
                <title>double QCPBars::width () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1a4c103fb405a45f47853e0345f0c6e708">
                <title>WidthType QCPBars::widthType () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1a5eef59840b68d205df4e0c3df5f97633">
                <title>QCPBarsGroup* QCPBars::barsGroup () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1a29a7b3b86f80b2a04bd1f9ec0ebaf422">
                <title>double QCPBars::baseValue () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1a2e6192fa9c16df7ba94cd50c0c9ec7ce">
                <title>double QCPBars::stackingGap () const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1a1b58664864b141f45e02044a855b3213">
                <title>QCPBars * QCPBars::barBelow () const</title> <emphasis></emphasis>
                
<para>Returns the bars plottable that is directly below this bars plottable. If there is no such plottable, returns 0.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_bars_1ab97f2acd9f6cb40d2cc3c33d278f0e78">barAbove</link>, <link linkend="class_q_c_p_bars_1a69fc371346980f19177c3d1ecdad78ee">moveBelow</link>, <link linkend="class_q_c_p_bars_1ac22e00a6a41509538c21b04f0a57318c">moveAbove</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1ab97f2acd9f6cb40d2cc3c33d278f0e78">
                <title>QCPBars * QCPBars::barAbove () const</title> <emphasis></emphasis>
                
<para>Returns the bars plottable that is directly above this bars plottable. If there is no such plottable, returns 0.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_bars_1a1b58664864b141f45e02044a855b3213">barBelow</link>, <link linkend="class_q_c_p_bars_1a69fc371346980f19177c3d1ecdad78ee">moveBelow</link>, <link linkend="class_q_c_p_bars_1ac22e00a6a41509538c21b04f0a57318c">moveAbove</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1a7e373a534d82e18ed27b3fafd1f08fae">
                <title>QSharedPointer&lt; QCPBarsDataContainer &gt; QCPBars::data () const</title> <emphasis></emphasis>
                
<para>Returns a shared pointer to the internal data storage of type <link linkend="qcustomplot_8h_1a52bf589c9fce1baa36c1d40d69785d46">QCPBarsDataContainer</link>. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular <link linkend="class_q_c_p_bars_1a6dc562ec7120a8521e1061f2134367e4">setData</link> or <link linkend="class_q_c_p_bars_1a323d6970d6d6e3166d89916a7f60f733">addData</link> methods. </para>

            </section>
            <section xml:id="class_q_c_p_bars_1a6dc562ec7120a8521e1061f2134367e4">
                <title>void QCPBars::setData (QSharedPointer&lt; QCPBarsDataContainer &gt; data)</title> <emphasis></emphasis>
                
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para>

<para>Replaces the current data container with the provided <emphasis>data</emphasis> container.</para>

<para>Since a QSharedPointer is used, multiple <link linkend="class_q_c_p_bars">QCPBars</link> may share the same data container safely. Modifying the data in the container will then affect all bars that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: <literallayout><computeroutput></computeroutput></literallayout> If you do not wish to share containers, but create a copy from an existing container, rather use the <link linkend="class_q_c_p_data_container_1ae7042bd534fc3ce7befa2ce3f790b5bf">QCPDataContainer&lt;DataType&gt;::set</link> method on the bar&apos;s data container directly: <literallayout><computeroutput></computeroutput></literallayout> <formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_bars_1a323d6970d6d6e3166d89916a7f60f733">addData</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1a2a88cd5b16ec7b71e5a590f95b50c5ce">
                <title>void QCPBars::setData (const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values, bool alreadySorted=false)</title> <emphasis></emphasis>
                
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para>

<para>Replaces the current data with the provided points in <emphasis>keys</emphasis> and <emphasis>values</emphasis>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.</para>

<para>If you can guarantee that the passed data points are sorted by <emphasis>keys</emphasis> in ascending order, you can set <emphasis>alreadySorted</emphasis> to true, to improve performance by saving a sorting run.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_bars_1a323d6970d6d6e3166d89916a7f60f733">addData</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1afec6116579d44d5b706e0fa5e5332507">
                <title>void QCPBars::setWidth (double width)</title> <emphasis></emphasis>
                
<para>Sets the width of the bars.</para>

<para>How the number passed as <emphasis>width</emphasis> is interpreted (e.g. screen pixels, plot coordinates,...), depends on the currently set width type, see <link linkend="class_q_c_p_bars_1adcaa3b41281bb2c0f7949b341592fcc0">setWidthType</link> and <link linkend="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649">WidthType</link>. </para>

            </section>
            <section xml:id="class_q_c_p_bars_1adcaa3b41281bb2c0f7949b341592fcc0">
                <title>void QCPBars::setWidthType (WidthType widthType)</title> <emphasis></emphasis>
                
<para>Sets how the width of the bars is defined. See the documentation of <link linkend="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649">WidthType</link> for an explanation of the possible values for <emphasis>widthType</emphasis>.</para>

<para>The default value is <link linkend="class_q_c_p_bars_1a65dbbf1ab41cbe993d71521096ed4649aad3cc60ae1bfb1160a30237bee9eaf10">wtPlotCoords</link>.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_bars_1afec6116579d44d5b706e0fa5e5332507">setWidth</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1aedd1709061f0b307c47ddb45e172ef9a">
                <title>void QCPBars::setBarsGroup (QCPBarsGroup *barsGroup)</title> <emphasis></emphasis>
                
<para>Sets to which <link linkend="class_q_c_p_bars_group">QCPBarsGroup</link> this <link linkend="class_q_c_p_bars">QCPBars</link> instance belongs to. Alternatively, you can also use <link linkend="class_q_c_p_bars_group_1a809ed63cc4ff7cd5b0b8c96b470163d3">QCPBarsGroup::append</link>.</para>

<para>To remove this <link linkend="class_q_c_p_bars">QCPBars</link> from any group, set <emphasis>barsGroup</emphasis> to 0. </para>

            </section>
            <section xml:id="class_q_c_p_bars_1a574ec7eb7537566df1a28ff085d75623">
                <title>void QCPBars::setBaseValue (double baseValue)</title> <emphasis></emphasis>
                
<para>Sets the base value of this bars plottable.</para>

<para>The base value defines where on the value coordinate the bars start. How far the bars extend from the base value is given by their individual value data. For example, if the base value is set to 1, a bar with data value 2 will have its lowest point at value coordinate 1 and highest point at 3.</para>

<para>For stacked bars, only the base value of the bottom-most <link linkend="class_q_c_p_bars">QCPBars</link> has meaning.</para>

<para>The default base value is 0. </para>

            </section>
            <section xml:id="class_q_c_p_bars_1aeacf7561afb1c70284b22822b57c7bb5">
                <title>void QCPBars::setStackingGap (double pixels)</title> <emphasis></emphasis>
                
<para>If this bars plottable is stacked on top of another bars plottable (<link linkend="class_q_c_p_bars_1ac22e00a6a41509538c21b04f0a57318c">moveAbove</link>), this method allows specifying a distance in <emphasis>pixels</emphasis>, by which the drawn bar rectangles will be separated by the bars below it. </para>

            </section>
            <section xml:id="class_q_c_p_bars_1a323d6970d6d6e3166d89916a7f60f733">
                <title>void QCPBars::addData (const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values, bool alreadySorted=false)</title> <emphasis></emphasis>
                
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para>

<para>Adds the provided points in <emphasis>keys</emphasis> and <emphasis>values</emphasis> to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.</para>

<para>If you can guarantee that the passed data points are sorted by <emphasis>keys</emphasis> in ascending order, you can set <emphasis>alreadySorted</emphasis> to true, to improve performance by saving a sorting run.</para>

<para>Alternatively, you can also access and modify the data directly via the <link linkend="class_q_c_p_bars_1a7e373a534d82e18ed27b3fafd1f08fae">data</link> method, which returns a pointer to the internal data container. </para>

            </section>
            <section xml:id="class_q_c_p_bars_1a684dd105403a5497fda42f2094fecbb7">
                <title>void QCPBars::addData (double key, double value)</title> <emphasis></emphasis>
                
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Adds the provided data point as <emphasis>key</emphasis> and <emphasis>value</emphasis> to the current data.</para>

<para>Alternatively, you can also access and modify the data directly via the <link linkend="class_q_c_p_bars_1a7e373a534d82e18ed27b3fafd1f08fae">data</link> method, which returns a pointer to the internal data container. </para>

            </section>
            <section xml:id="class_q_c_p_bars_1a69fc371346980f19177c3d1ecdad78ee">
                <title>void QCPBars::moveBelow (QCPBars *bars)</title> <emphasis></emphasis>
                
<para>Moves this bars plottable below <emphasis>bars</emphasis>. In other words, the bars of this plottable will appear below the bars of <emphasis>bars</emphasis>. The move target <emphasis>bars</emphasis> must use the same key and value axis as this plottable.</para>

<para>Inserting into and removing from existing bar stacking is handled gracefully. If <emphasis>bars</emphasis> already has a bars object below itself, this bars object is inserted between the two. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation.</para>

<para>To remove this bars plottable from any stacking, set <emphasis>bars</emphasis> to 0.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_bars_1a69fc371346980f19177c3d1ecdad78ee">moveBelow</link>, <link linkend="class_q_c_p_bars_1ab97f2acd9f6cb40d2cc3c33d278f0e78">barAbove</link>, <link linkend="class_q_c_p_bars_1a1b58664864b141f45e02044a855b3213">barBelow</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1ac22e00a6a41509538c21b04f0a57318c">
                <title>void QCPBars::moveAbove (QCPBars *bars)</title> <emphasis></emphasis>
                
<para>Moves this bars plottable above <emphasis>bars</emphasis>. In other words, the bars of this plottable will appear above the bars of <emphasis>bars</emphasis>. The move target <emphasis>bars</emphasis> must use the same key and value axis as this plottable.</para>

<para>Inserting into and removing from existing bar stacking is handled gracefully. If <emphasis>bars</emphasis> already has a bars object above itself, this bars object is inserted between the two. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation.</para>

<para>To remove this bars plottable from any stacking, set <emphasis>bars</emphasis> to 0.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_bars_1a69fc371346980f19177c3d1ecdad78ee">moveBelow</link>, <link linkend="class_q_c_p_bars_1a1b58664864b141f45e02044a855b3213">barBelow</link>, <link linkend="class_q_c_p_bars_1ab97f2acd9f6cb40d2cc3c33d278f0e78">barAbove</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1ab03bb6125c3e983b89d694f75ce6b3d5">
                <title>QCPDataSelection QCPBars::selectTestRect (const QRectF &amp;rect, bool onlySelectable) const Q_DECL_OVERRIDE</title> <emphasis>\copybrief QCPPlottableInterface1D::selectTestRect</emphasis>
                
<para>Returns a data selection containing all the data points of this plottable which are contained (or hit by) <emphasis>rect</emphasis>. This is used mainly in the selection rect interaction for data selection (data selection mechanism).</para>

<para>If <emphasis>onlySelectable</emphasis> is true, an empty <link linkend="class_q_c_p_data_selection">QCPDataSelection</link> is returned if this plottable is not selectable (i.e. if <link linkend="class_q_c_p_abstract_plottable_1ac238d6e910f976f1f30d41c2bca44ac3">QCPAbstractPlottable::setSelectable</link> is <link linkend="namespace_q_c_p_1ac6cb9db26a564b27feda362a438db038aa64628e338a2dd1e6f0dc84dec0b63fe">QCP::stNone</link>).</para>

<para><formalpara><title>Note: </title>

<para><emphasis>rect</emphasis> must be a normalized rect (positive or zero width and height). This is especially important when using the rect of <link linkend="class_q_c_p_selection_rect_1a15a43542e1f7b953a44c260b419e6d2c">QCPSelectionRect::accepted</link>, which is not necessarily normalized. Use <computeroutput>QRect::normalized()</computeroutput> when passing a rect which might not be normalized. </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1a121f899c27af3186fe93dcd0eb98f49b">
                <title>double QCPBars::selectTest (const QPointF &amp;pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
<para>Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.</para>

            </section>
            <section xml:id="class_q_c_p_bars_1ac5a3854774d9d9cd129b1eae1426de2d">
                <title>QCPRange QCPBars::getKeyRange (bool &amp;foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) const Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
<para>Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set <emphasis>inSignDomain</emphasis> to either <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a2d18af0bc58f6528d1e82ce699fe4829">QCP::sdNegative</link> or <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a584784b75fb816abcc627cf743bb699f">QCP::sdPositive</link> in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set <emphasis>inSignDomain</emphasis> to <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a2d18af0bc58f6528d1e82ce699fe4829">QCP::sdNegative</link> and all positive points will be ignored for range calculation. For no restriction, just set <emphasis>inSignDomain</emphasis> to <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9aa38352ef02d51ddfa4399d9551566e24">QCP::sdBoth</link> (default). <emphasis>foundRange</emphasis> is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn&apos;t use the returned range (e.g. no points in data).</para>

<para>Note that <emphasis>foundRange</emphasis> is not the same as <link linkend="class_q_c_p_range_1ab38bd4841c77c7bb86c9eea0f142dcc0">QCPRange::validRange</link>, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case <emphasis>foundRange</emphasis> would return true, but the returned range is not a valid range in terms of <link linkend="class_q_c_p_range_1ab38bd4841c77c7bb86c9eea0f142dcc0">QCPRange::validRange</link>.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_abstract_plottable_1a1491c4a606bccd2d09e65e11b79eb882">rescaleAxes</link>, <link linkend="class_q_c_p_bars_1a02cee4bf94d48a1e5f6fc185d9a10477">getValueRange</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1a02cee4bf94d48a1e5f6fc185d9a10477">
                <title>QCPRange QCPBars::getValueRange (bool &amp;foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, const QCPRange &amp;inKeyRange=QCPRange()) const Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
<para>Returns the coordinate range that the data points in the specified key range (<emphasis>inKeyRange</emphasis>) span in the value axis dimension. For logarithmic plots, one can set <emphasis>inSignDomain</emphasis> to either <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a2d18af0bc58f6528d1e82ce699fe4829">QCP::sdNegative</link> or <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a584784b75fb816abcc627cf743bb699f">QCP::sdPositive</link> in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set <emphasis>inSignDomain</emphasis> to <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9a2d18af0bc58f6528d1e82ce699fe4829">QCP::sdNegative</link> and all positive points will be ignored for range calculation. For no restriction, just set <emphasis>inSignDomain</emphasis> to <link linkend="namespace_q_c_p_1afd50e7cf431af385614987d8553ff8a9aa38352ef02d51ddfa4399d9551566e24">QCP::sdBoth</link> (default). <emphasis>foundRange</emphasis> is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn&apos;t use the returned range (e.g. no points in data).</para>

<para>If <emphasis>inKeyRange</emphasis> has both lower and upper bound set to zero (is equal to <computeroutput><link linkend="class_q_c_p_range">QCPRange()</link></computeroutput>), all data points are considered, without any restriction on the keys.</para>

<para>Note that <emphasis>foundRange</emphasis> is not the same as <link linkend="class_q_c_p_range_1ab38bd4841c77c7bb86c9eea0f142dcc0">QCPRange::validRange</link>, since the range returned by this function may have size zero (e.g. when there is only one data point). In this case <emphasis>foundRange</emphasis> would return true, but the returned range is not a valid range in terms of <link linkend="class_q_c_p_range_1ab38bd4841c77c7bb86c9eea0f142dcc0">QCPRange::validRange</link>.</para>

<para><formalpara><title>See also: </title>

<para><link linkend="class_q_c_p_abstract_plottable_1a1491c4a606bccd2d09e65e11b79eb882">rescaleAxes</link>, <link linkend="class_q_c_p_bars_1ac5a3854774d9d9cd129b1eae1426de2d">getKeyRange</link> </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_q_c_p_bars_1a55cdaf565cd3384158d1f7f89533bc2d">
                <title>QPointF QCPBars::dataPixelPosition (int index) const Q_DECL_OVERRIDE</title> <emphasis>\copybrief QCPPlottableInterface1D::dataPixelPosition</emphasis>
                
<para>Returns the pixel position on the widget surface at which the data point at the given <emphasis>index</emphasis> appears.</para>

<para>Usually this corresponds to the point of <link linkend="class_q_c_p_abstract_plottable1_d_1aeb156ebf5d3c8de906b428be30733ad8">dataMainKey</link>/<link linkend="class_q_c_p_abstract_plottable1_d_1a6be0f657ba85a1688336d76ad649ecf2">dataMainValue</link>, in pixel coordinates. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values. For example, <link linkend="class_q_c_p_bars">QCPBars</link> apparent data values can be shifted depending on their stacking, bar grouping or configured base value. </para>

            </section>
            <section xml:id="class_q_c_p_bars_1aa267c20650d55084c3f47cb2f8fac9dc">
                <title>void QCPBars::draw (QCPPainter *painter) Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1aee7c3e1763fd6b504c45baa8775be7b7">
                <title>void QCPBars::drawLegendIcon (QCPPainter *painter, const QRectF &amp;rect) const Q_DECL_OVERRIDE</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1ac8b6b514a665a7bff4fb080413ba996a">
                <title>void QCPBars::getVisibleDataBounds (QCPBarsDataContainer::const_iterator &amp;begin, QCPBarsDataContainer::const_iterator &amp;end) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1a01b87e38e5d5089d214646d2af7896ea">
                <title>QRectF QCPBars::getBarRect (double key, double value) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1ad87586cc5e9806740bc0e867667da409">
                <title>void QCPBars::getPixelWidth (double key, double &amp;lower, double &amp;upper) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1a0ffd6e043876e13e89eaa54e9f8a04b9">
                <title>double QCPBars::getStackedBaseValue (double key, bool positive) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_q_c_p_bars_1a6ea37802cd22f97235cab614b14b9f19">
                <title>void QCPBars::connectBars (QCPBars *lower, QCPBars *upper)</title> <emphasis></emphasis>
                
            </section>
</section>
