$doxydocs=
{
  classes => [
    {
      name => 'QCPAxisPainterPrivate::CachedLabel',
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'offset',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate::CachedLabel'
        },
        {
          name => 'pixmap',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate::CachedLabel'
        }
      ],
      public_members => {
        members => [
          {
            kind => 'variable',
            name => 'offset',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointF'
          },
          {
            kind => 'variable',
            name => 'pixmap',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPixmap'
          }
        ]
      },
      brief => {},
      detailed => {}
    },
    {
      name => 'Capacitor',
      includes => {
        local => 'no',
        name => 'Classes_cirkt.h'
      },
      all_members => [
        {
          name => 'capacit',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'Capacitor'
        },
        {
          name => 'Capacitor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Capacitor'
        },
        {
          name => 'get_capacit',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Capacitor'
        },
        {
          name => 'get_imp',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Capacitor'
        },
        {
          name => 'imp',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'Capacitor'
        },
        {
          name => 'set_imp',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Capacitor'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'Capacitor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'valor',
                type => 'float'
              }
            ]
          },
          {
            kind => 'function',
            name => 'set_imp',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 's',
                type => 'complex< double >'
              }
            ]
          },
          {
            kind => 'function',
            name => 'get_capacit',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'float',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'get_imp',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'complex< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      private_members => {
        members => [
          {
            kind => 'variable',
            name => 'capacit',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'float'
          },
          {
            kind => 'variable',
            name => 'imp',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'complex< double >'
          }
        ]
      },
      brief => {},
      detailed => {}
    },
    {
      name => 'Dialog',
      base => [
        {
          name => 'QDialog',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'dialog.h'
      },
      all_members => [
        {
          name => 'Dialog',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Dialog'
        },
        {
          name => 'ui',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'Dialog'
        },
        {
          name => '~Dialog',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Dialog'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'Dialog',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parent',
                type => 'QWidget *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => '~Dialog',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      private_members => {
        members => [
          {
            kind => 'variable',
            name => 'ui',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Ui::Dialog *'
          }
        ]
      },
      brief => {},
      detailed => {}
    },
    {
      name => 'Indutor',
      includes => {
        local => 'no',
        name => 'Classes_cirkt.h'
      },
      all_members => [
        {
          name => 'get_imp',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Indutor'
        },
        {
          name => 'get_indutor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Indutor'
        },
        {
          name => 'imp',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'Indutor'
        },
        {
          name => 'indutancia',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'Indutor'
        },
        {
          name => 'Indutor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Indutor'
        },
        {
          name => 'set_imp',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'Indutor'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'Indutor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'valor',
                type => 'float'
              }
            ]
          },
          {
            kind => 'function',
            name => 'set_imp',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 's',
                type => 'complex< double >'
              }
            ]
          },
          {
            kind => 'function',
            name => 'get_indutor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'float',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'get_imp',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'complex< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      private_members => {
        members => [
          {
            kind => 'variable',
            name => 'indutancia',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'float'
          },
          {
            kind => 'variable',
            name => 'imp',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'complex< double >'
          }
        ]
      },
      brief => {},
      detailed => {}
    },
    {
      name => 'MainWindow',
      base => [
        {
          name => 'QMainWindow',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'mainwindow.h'
      },
      all_members => [
        {
          name => 'contextMenuRequest',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'graphClicked',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'MainWindow',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'MainWindow'
        },
        {
          name => 'makePlot',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'mousePress',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'mouseWheel',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'moveLegend',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'on_actionTutorial_triggered',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'on_pushButton_2_clicked',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'on_pushButton_clicked',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'removeAllGraphs',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'removeSelectedGraph',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => 'ui',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'MainWindow'
        },
        {
          name => '~MainWindow',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'MainWindow'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'MainWindow',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parent',
                type => 'QWidget *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => '~MainWindow',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      private_members => {
        members => [
          {
            kind => 'variable',
            name => 'ui',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Ui::MainWindow *'
          }
        ]
      },
      private_slots => {
        members => [
          {
            kind => 'slot',
            name => 'on_pushButton_clicked',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'slot',
            name => 'makePlot',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'slot',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'slot',
            name => 'mousePress',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'slot',
            name => 'mouseWheel',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'slot',
            name => 'removeSelectedGraph',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'slot',
            name => 'removeAllGraphs',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'slot',
            name => 'contextMenuRequest',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'QPoint'
              }
            ]
          },
          {
            kind => 'slot',
            name => 'moveLegend',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'slot',
            name => 'graphClicked',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'plottable',
                type => 'QCPAbstractPlottable *'
              },
              {
                declaration_name => 'dataIndex',
                type => 'int'
              }
            ]
          },
          {
            kind => 'slot',
            name => 'on_pushButton_2_clicked',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'slot',
            name => 'on_actionTutorial_triggered',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {},
      detailed => {}
    },
    {
      name => 'QCPAbstractItem',
      base => [
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      derived => [
        {
          name => 'QCPItemBracket',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPItemCurve',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPItemEllipse',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPItemLine',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPItemPixmap',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPItemRect',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPItemStraightLine',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPItemText',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPItemTracer',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'anchor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'anchorPixelPosition',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'anchors',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'clipAxisRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'clipToAxisRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'createAnchor',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'createPosition',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'draw',
          virtualness => 'pure_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'hasAnchor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'mAnchors',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mClipAxisRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'mClipToAxisRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mPositions',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'mSelectable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'mSelected',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'position',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'positions',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'QCPAbstractItem',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'QCPItemAnchor',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'QCustomPlot',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'rectDistance',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'selectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'selectableChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'selected',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'selectTest',
          virtualness => 'pure_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setClipAxisRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'setClipToAxisRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setSelectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'setSelected',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPAbstractItem',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractItem'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAbstractItem',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Base class constructor which initializes base class members. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPAbstractItem',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'clipToAxisRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'clipAxisRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxisRect *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selected',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setClipToAxisRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the item shall be clipped to an axis rect or whether it shall be visible on the entire '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '. The axis rect can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setClipAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a7dc75fcbcd10206fe0b75d757ea7a347',
                      content => 'setClipAxisRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'clip',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setClipAxisRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the clip axis rect. It defines the rect that will be used to clip the item when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setClipToAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is set to true.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a39e05b9d4176b9accafc746d16ca6a06',
                      content => 'setClipToAxisRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'rect',
                type => 'QCPAxisRect *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether the user can (de-)select this item by clicking on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface. (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains QCustomPlot::iSelectItems.)However, even when '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' was set to false, it is possible to set the selection manually, by calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelected'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a203de94ad586cc44d16c9565f49d3378',
                      content => 'setSelected'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelected',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether this item is selected or not. When selected, it might use a different visual appearance (e.g. pen and brush), this depends on the specific item though.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The entire selection mechanism for items is handled automatically when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains QCustomPlot::iSelectItems. You only need to call this function when you wish to change the selection state manually.This function can change the selection state even when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' was set to false.emits the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionChanged'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' signal when '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is different from the previous selection state.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a8a8e32a55bc478b849756a78c2d87fd2',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1ae41d0349d68bb802c49104afd100ba2a',
                      content => 'selectTest'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selected',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'pure_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This function is used to decide whether a click hits a layerable object or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a point in pixel coordinates on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn\'t be determined, -1.0 is returned. Further, if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlySelectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true and the object is not selectable, -1.0 is returned, too.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the object is represented not by single lines but by an area like a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPItemText'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or the bars of a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot\'s selection tolerance. (typically the selectionTolerance multiplied by 0.99).Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The actual setting of the selection state is not done by this function. This is handled by the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' when the mouseReleaseEvent occurs, and the finally selected object is notified via the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '/'
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'deselectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' methods.'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an optional output parameter. Every layerable subclass may place any information in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This information will be passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' will carry the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This is useful for multi-part objects (like '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => '). This way, a possibly complex calculation to decide which part was clicked is only done once in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The result (i.e. the actually clicked part) can then be placed in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. So in the subsequent '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the decision which part was selected doesn\'t have to be done a second time for a single selection operation.You may pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to indicate that you are not interested in those selection details.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1aa4b969c58797f39c9c0b6c07c7869d17',
                      content => 'selectEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1af9093798cb07a861dcc73f93ca16c0c1',
                      content => 'deselectEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            },
            reimplemented_by => [
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              }
            ]
          },
          {
            kind => 'function',
            name => 'positions',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all positions of the item in a list.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a81d1ecfea3368b836cf9675a0045e659',
                      content => 'anchors'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a2589c3d298f9a576d77d9addb440a18d',
                      content => 'position'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPItemPosition * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'anchors',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all anchors of the item in a list. Note that since a position ('
                },
                {
                  type => 'url',
                  link => 'classQCPItemPosition',
                  content => 'QCPItemPosition'
                },
                {
                  type => 'text',
                  content => ') is always also an anchor, the list will also contain the positions of this item.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a709f655ac3f7f22d452714134662b454',
                      content => 'positions'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a139c255ea8831642fac91748e29a5adb',
                      content => 'anchor'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPItemAnchor * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'position',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the '
                },
                {
                  type => 'url',
                  link => 'classQCPItemPosition',
                  content => 'QCPItemPosition'
                },
                {
                  type => 'text',
                  content => ' with the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'name'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. If this item doesn\'t have a position by that name, returns 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This function provides an alternative way to access item positions. Normally, you access positions direcly by their member pointers (which typically have the same variable name as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'name'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a709f655ac3f7f22d452714134662b454',
                      content => 'positions'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a139c255ea8831642fac91748e29a5adb',
                      content => 'anchor'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPItemPosition *',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'name',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'anchor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the '
                },
                {
                  type => 'url',
                  link => 'classQCPItemAnchor',
                  content => 'QCPItemAnchor'
                },
                {
                  type => 'text',
                  content => ' with the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'name'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. If this item doesn\'t have an anchor by that name, returns 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This function provides an alternative way to access item anchors. Normally, you access anchors direcly by their member pointers (which typically have the same variable name as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'name'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a81d1ecfea3368b836cf9675a0045e659',
                      content => 'anchors'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a2589c3d298f9a576d77d9addb440a18d',
                      content => 'position'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPItemAnchor *',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'name',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'hasAnchor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether this item has an anchor with the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'name'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that you can check for positions with this function, too. This is because every position is also an anchor ('
                },
                {
                  type => 'url',
                  link => 'classQCPItemPosition',
                  content => 'QCPItemPosition'
                },
                {
                  type => 'text',
                  content => ' inherits from '
                },
                {
                  type => 'url',
                  link => 'classQCPItemAnchor',
                  content => 'QCPItemAnchor'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a139c255ea8831642fac91748e29a5adb',
                      content => 'anchor'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractItem_1a2589c3d298f9a576d77d9addb440a18d',
                      content => 'position'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'name',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this item has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelected'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selected',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectableChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'selectionCategory',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QCP::Interaction',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'selectionCategory'
            }
          },
          {
            kind => 'function',
            name => 'clipRect',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'clipRect'
            }
          },
          {
            kind => 'function',
            name => 'applyDefaultAntialiasingHint',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'applyDefaultAntialiasingHint'
            }
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'pure_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'draw'
            },
            reimplemented_by => [
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'additive',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              },
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'selectEvent'
            }
          },
          {
            kind => 'function',
            name => 'deselectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'deselectEvent'
            }
          },
          {
            kind => 'function',
            name => 'anchorPixelPosition',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QPointF',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'anchorId',
                type => 'int'
              }
            ],
            reimplemented_by => [
              {
                name => 'anchorPixelPosition'
              },
              {
                name => 'anchorPixelPosition'
              },
              {
                name => 'anchorPixelPosition'
              },
              {
                name => 'anchorPixelPosition'
              },
              {
                name => 'anchorPixelPosition'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rectDistance',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'rect',
                type => 'const QRectF &'
              },
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'filledRect',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createPosition',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPItemPosition *',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'name',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createAnchor',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPItemAnchor *',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'name',
                type => 'const QString &'
              },
              {
                declaration_name => 'anchorId',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'parentPlotInitialized',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ],
            reimplemented_by => [
              {
                name => 'parentPlotInitialized'
              },
              {
                name => 'parentPlotInitialized'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mousePressEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).'
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' uses an event propagation system that works the same as Qt\'s system. If your layerable doesn\'t reimplement the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or explicitly calls '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in its reimplementation, the event will be propagated to the next layerable in the stacking order.Once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseMoveEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseReleaseEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseDoubleClickEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called instead of the second '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. So in the case of a double-click, the event succession is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pressEvent - releaseEvent - doubleClickEvent - releaseEvent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).Similarly to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseDoubleClickEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'wheelEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QWheelEvent *'
              }
            ],
            reimplemented_by => [
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'initializeParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentLayerable',
                type => 'QCPLayerable *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveToLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              },
              {
                declaration_name => 'prepend',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'localAntialiased',
                type => 'bool'
              },
              {
                declaration_name => 'overrideElement',
                type => 'QCP::AntialiasedElement'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mClipToAxisRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mClipAxisRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxisRect >'
          },
          {
            kind => 'variable',
            name => 'mPositions',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QList< QCPItemPosition * >'
          },
          {
            kind => 'variable',
            name => 'mAnchors',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QList< QCPItemAnchor * >'
          },
          {
            kind => 'variable',
            name => 'mSelectable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mSelected',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mVisible',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPLayerable >'
          },
          {
            kind => 'variable',
            name => 'mLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *'
          },
          {
            kind => 'variable',
            name => 'mAntialiased',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCustomPlot',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'friend',
            name => 'QCPItemAnchor',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The abstract base class for all items in a plot. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'In '
          },
          {
            type => 'url',
            link => 'classQCustomPlot',
            content => 'QCustomPlot'
          },
          {
            type => 'text',
            content => ', items are supplemental graphical elements that are neither plottables ('
          },
          {
            type => 'url',
            link => 'classQCPAbstractPlottable',
            content => 'QCPAbstractPlottable'
          },
          {
            type => 'text',
            content => ') nor axes ('
          },
          {
            type => 'url',
            link => 'classQCPAxis',
            content => 'QCPAxis'
          },
          {
            type => 'text',
            content => '). While plottables are always tied to two axes and thus plot coordinates, items can also be placed in absolute coordinates independent of any axes. Each specific item has at least one '
          },
          {
            type => 'url',
            link => 'classQCPItemPosition',
            content => 'QCPItemPosition'
          },
          {
            type => 'text',
            content => ' member which controls the positioning. Some items are defined by more than one coordinate and thus have two or more '
          },
          {
            type => 'url',
            link => 'classQCPItemPosition',
            content => 'QCPItemPosition'
          },
          {
            type => 'text',
            content => ' members (For example, '
          },
          {
            type => 'url',
            link => 'classQCPItemRect',
            content => 'QCPItemRect'
          },
          {
            type => 'text',
            content => ' has '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'topLeft'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'bottomRight'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ').'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This abstract base class defines a very basic interface like visibility and clipping. Since this class is abstract, it can\'t be instantiated. Use one of the subclasses or create a subclass yourself to create new items.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The built-in items are: '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPItemLine',
            content => 'QCPItemLine'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A line defined by a start and an end point. May have different ending styles on each side (e.g. arrows). '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPItemStraightLine',
            content => 'QCPItemStraightLine'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A straight line defined by a start and a direction point. Unlike '
          },
          {
            type => 'url',
            link => 'classQCPItemLine',
            content => 'QCPItemLine'
          },
          {
            type => 'text',
            content => ', the straight line is infinitely long and has no endings. '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPItemCurve',
            content => 'QCPItemCurve'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A curve defined by start, end and two intermediate control points. May have different ending styles on each side (e.g. arrows). '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPItemRect',
            content => 'QCPItemRect'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A rectangle '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPItemEllipse',
            content => 'QCPItemEllipse'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'An ellipse '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPItemPixmap',
            content => 'QCPItemPixmap'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'An arbitrary pixmap '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPItemText',
            content => 'QCPItemText'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A text label '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPItemBracket',
            content => 'QCPItemBracket'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A bracket which may be used to reference/highlight certain parts in the plot. '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPItemTracer',
            content => 'QCPItemTracer'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'An item that can be attached to a '
          },
          {
            type => 'url',
            link => 'classQCPGraph',
            content => 'QCPGraph'
          },
          {
            type => 'text',
            content => ' and sticks to its data points, given a key coordinate. '
          },
          {
            type => 'sect1',
            title => 'Clipping',
            content => [
              {
                type => 'text',
                content => 'Items are by default clipped to the main axis rect (they are only visible inside the axis rect). To make an item visible outside that axis rect, disable clipping via '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setClipToAxisRect(false)'
                  }
                ]
              },
              {
                type => 'text',
                content => '.On the other hand if you want the item to be clipped to a different axis rect, specify it via '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setClipAxisRect'
                  }
                ]
              },
              {
                type => 'text',
                content => '. This clipAxisRect property of an item is only used for clipping behaviour, and in principle is independent of the coordinate axes the item might be tied to via its position members ('
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPItemPosition::setAxes'
                  }
                ]
              },
              {
                type => 'text',
                content => '). However, it is common that the axis rect for clipping also contains the axes used for the item positions.'
              }
            ]
          },
          {
            type => 'sect1',
            title => 'Using items',
            content => [
              {
                type => 'text',
                content => 'First you instantiate the item you want to use and add it to the plot: by default, the positions of the item are bound to the x- and y-Axis of the plot. So we can just set the plot coordinates where the line should start/end: If we don\'t want the line to be positioned in plot coordinates but a different coordinate system, e.g. absolute pixel positions on the '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ' surface, we need to change the position type like this: Then we can set the coordinates, this time in pixels: and make the line visible on the entire '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ', by disabling clipping to the axis rect:  For more advanced plots, it is even possible to set different types and parent anchors per X/Y coordinate of an item position, using for example '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPItemPosition::setTypeX'
                  }
                ]
              },
              {
                type => 'text',
                content => ' or '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPItemPosition::setParentAnchorX'
                  }
                ]
              },
              {
                type => 'text',
                content => '. For details, see the documentation of '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPItemPosition'
                  }
                ]
              },
              {
                type => 'text',
                content => '.'
              }
            ]
          },
          {
            type => 'sect1',
            title => 'Creating own items',
            content => [
              {
                type => 'text',
                content => 'To create an own item, you implement a subclass of '
              },
              {
                type => 'url',
                link => 'classQCPAbstractItem',
                content => 'QCPAbstractItem'
              },
              {
                type => 'text',
                content => '. These are the pure virtual functions, you must implement: '
              },
              {
                type => 'list',
                style => 'itemized',
                content => [
                  [
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'selectTest'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ],
                  [
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'draw'
                        }
                      ]
                    }
                  ]
                ]
              },
              {
                type => 'text',
                content => 'See the documentation of those functions for what they need to do.'
              },
              {
                type => 'sect2',
                title => 'Allowing the item to be positioned',
                content => [
                  {
                    type => 'text',
                    content => 'As mentioned, item positions are represented by '
                  },
                  {
                    type => 'url',
                    link => 'classQCPItemPosition',
                    content => 'QCPItemPosition'
                  },
                  {
                    type => 'text',
                    content => ' members. Let\'s assume the new item shall have only one point as its position (as opposed to two like a rect or multiple like a polygon). You then add a public member of type '
                  },
                  {
                    type => 'url',
                    link => 'classQCPItemPosition',
                    content => 'QCPItemPosition'
                  },
                  {
                    type => 'text',
                    content => ' like so:'
                  },
                  {
                    type => 'parbreak'
                  },
                  {
                    type => 'preformatted',
                    content => 'QCPItemPosition * const myPosition;'
                  },
                  {
                    type => 'parbreak'
                  },
                  {
                    type => 'text',
                    content => 'the const makes sure the pointer itself can\'t be modified from the user of your new item (the '
                  },
                  {
                    type => 'url',
                    link => 'classQCPItemPosition',
                    content => 'QCPItemPosition'
                  },
                  {
                    type => 'text',
                    content => ' instance it points to, can be modified, of course). The initialization of this pointer is made easy with the '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'createPosition'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => ' function. Just assign the return value of this function to each '
                  },
                  {
                    type => 'url',
                    link => 'classQCPItemPosition',
                    content => 'QCPItemPosition'
                  },
                  {
                    type => 'text',
                    content => ' in the constructor of your item. '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'createPosition'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => ' takes a string which is the name of the position, typically this is identical to the variable name. For example, the constructor of QCPItemExample could look like this:'
                  },
                  {
                    type => 'preformatted',
                    content => 'QCPItemExample::QCPItemExample(QCustomPlot *parentPlot) :
  QCPAbstractItem(parentPlot),
  myPosition(createPosition("myPosition"))
{
  // other constructor code
}'
                  }
                ]
              },
              {
                type => 'sect2',
                title => 'The draw function',
                content => [
                  {
                    type => 'text',
                    content => 'To give your item a visual representation, reimplement the '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'draw'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => ' function and use the passed '
                  },
                  {
                    type => 'url',
                    link => 'classQCPPainter',
                    content => 'QCPPainter'
                  },
                  {
                    type => 'text',
                    content => ' to draw the item. You can retrieve the item position in pixel coordinates from the position member(s) via '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'QCPItemPosition::pixelPosition'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => '.To optimize performance you should calculate a bounding rect first (don\'t forget to take the pen width into account), check whether it intersects the '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'clipRect'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => ', and only draw the item at all if this is the case.'
                  }
                ]
              },
              {
                type => 'sect2',
                title => 'The selectTest function',
                content => [
                  {
                    type => 'text',
                    content => 'Your implementation of the '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'selectTest'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => ' function may use the helpers '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'QCPVector2D::distanceSquaredToLine'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => ' and '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'rectDistance'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => '. With these, the implementation of the selection test becomes significantly simpler for most items. See the documentation of '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'selectTest'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => ' for what the function parameters mean and what the function should return.'
                  }
                ]
              },
              {
                type => 'sect2',
                title => 'Providing anchors',
                content => [
                  {
                    type => 'text',
                    content => 'Providing anchors ('
                  },
                  {
                    type => 'url',
                    link => 'classQCPItemAnchor',
                    content => 'QCPItemAnchor'
                  },
                  {
                    type => 'text',
                    content => ') starts off like adding a position. First you create a public member, e.g.'
                  },
                  {
                    type => 'parbreak'
                  },
                  {
                    type => 'preformatted',
                    content => 'QCPItemAnchor * const bottom;'
                  },
                  {
                    type => 'parbreak'
                  },
                  {
                    type => 'text',
                    content => 'and create it in the constructor with the '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'createAnchor'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => ' function, assigning it a name and an anchor id (an integer enumerating all anchors on the item, you may create an own enum for this). Since anchors can be placed anywhere, relative to the item\'s position(s), your item needs to provide the position of every anchor with the reimplementation of the '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'anchorPixelPosition'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => '(int anchorId) function.In essence the '
                  },
                  {
                    type => 'url',
                    link => 'classQCPItemAnchor',
                    content => 'QCPItemAnchor'
                  },
                  {
                    type => 'text',
                    content => ' is merely an intermediary that itself asks your item for the pixel position when anything attached to the anchor needs to know the coordinates. '
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      name => 'QCPAbstractLegendItem',
      base => [
        {
          name => 'QCPLayoutElement',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      derived => [
        {
          name => 'QCPPlottableLegendItem',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'autoMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'calculateAutoMargin',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'draw',
          virtualness => 'pure_virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'elements',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'font',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'layoutChanged',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'marginGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'marginGroups',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'margins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mAutoMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'maximumOuterSizeHint',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'maximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mFont',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'minimumMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'minimumOuterSizeHint',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'minimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mMarginGroups',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMaximumSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMinimumMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMinimumSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mOuterRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayout',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mParentLegend',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mSelectable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'mSelected',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'mSelectedFont',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'mSelectedTextColor',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'mSizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mTextColor',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'outerRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'QCPAbstractLegendItem',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'QCPLayoutElement',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'QCPLegend',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'rect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'scrInnerRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'scrOuterRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'selectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'selectableChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'selected',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'selectedFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'selectedTextColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'selectTest',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setAutoMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setMarginGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMaximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMaximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setOuterRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setSelectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'setSelected',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'setSelectedFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'setSelectedTextColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'setSizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setTextColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'sizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'SizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'textColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractLegendItem'
        },
        {
          name => 'update',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'UpdatePhase',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upLayout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upPreparation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPLayoutElement',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'UpdatePhase',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the phases of the update process, that happens just before a replot. At each phase, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'update'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called with the according UpdatePhase value. '
                }
              ]
            },
            values => [
              {
                name => 'upPreparation',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Phase used for any type of preparation that needs to be done before margin calculation and layout. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'upMargins',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Phase in which the margins are calculated and set. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'upLayout',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Final phase in which the layout system places the rects of the elements. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enum',
            name => 'SizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines to which rect of a layout element the size constraints that can be set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' apply. The outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') includes the margins (e.g. in the case of a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => ' the axis labels), whereas the inner rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') does not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a361666cdcc6fbfd37344cc44be746b0f',
                      content => 'setSizeConstraintRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'scrInnerRect',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Minimum/Maximum size constraints apply to inner rect. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'scrOuterRect',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'upPreparation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Phase used for any type of preparation that needs to be done before margin calculation and layout. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'upMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Phase in which the margins are calculated and set. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'upLayout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Final phase in which the layout system places the rects of the elements. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'scrInnerRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Minimum/Maximum size constraints apply to inner rect. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'scrOuterRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAbstractLegendItem',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a '
                },
                {
                  type => 'url',
                  link => 'classQCPAbstractLegendItem',
                  content => 'QCPAbstractLegendItem'
                },
                {
                  type => 'text',
                  content => ' and associates it with the '
                },
                {
                  type => 'url',
                  link => 'classQCPLegend',
                  content => 'QCPLegend'
                },
                {
                  type => 'text',
                  content => ' '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'parent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This does not cause the item to be added to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'parent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', so '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLegend::addItem'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' must be called separately. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parent',
                type => 'QCPLegend *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'parentLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLegend *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'font',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'textColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedTextColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selected',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the default font of this specific legend item to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'font'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractLegendItem_1a6ebace6aaffaedcdab2d74e88acc2d1e',
                      content => 'setTextColor'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1aa4cda8499e3cb0f3be415edc02984c73',
                      content => 'QCPLegend::setFont'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'font',
                type => 'const QFont &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTextColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the default text color of this specific legend item to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'color'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractLegendItem_1a409c53455d8112f71d70c0c43eb10265',
                      content => 'setFont'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1ae1eb239ff4a4632fe1b6c3e668d845c6',
                      content => 'QCPLegend::setTextColor'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'color',
                type => 'const QColor &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'When this legend item is selected, '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'font'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is used to draw generic text, instead of the normal font set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setFont'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractLegendItem_1a409c53455d8112f71d70c0c43eb10265',
                      content => 'setFont'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1ab580a01c3c0a239374ed66c29edf5ad2',
                      content => 'QCPLegend::setSelectedFont'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'font',
                type => 'const QFont &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedTextColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'When this legend item is selected, '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'color'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is used to draw generic text, instead of the normal color set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTextColor'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractLegendItem_1a6ebace6aaffaedcdab2d74e88acc2d1e',
                      content => 'setTextColor'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1a7674dfc7a1f30e1abd1018c0ed45e0bc',
                      content => 'QCPLegend::setSelectedTextColor'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'color',
                type => 'const QColor &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether this specific legend item is selectable.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'text',
                      content => 'setSelectedParts, '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelected',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether this specific legend item is selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'It is possible to set the selection state of this item by calling this function directly, even if setSelectable is set to false.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'text',
                      content => 'setSelectableParts, '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selected',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Layout elements are sensitive to events inside their outer rect. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is within the outer rect, this method returns a value corresponding to 0.99 times the parent plot\'s selection tolerance. However, layout elements are not selectable by default. So if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlySelectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, -1.0 is returned.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayerable::selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for a general explanation of this virtual method.'
                },
                {
                  type => 'url',
                  link => 'classQCPLayoutElement',
                  content => 'QCPLayoutElement'
                },
                {
                  type => 'text',
                  content => ' subclasses may reimplement this method to provide more specific selection test behaviour. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            }
          },
          {
            kind => 'function',
            name => 'layout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the parent layout of this layout element. '
                }
              ]
            },
            type => 'QCPLayout *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the inner rect of this layout element. The inner rect is the outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') shrinked by the margins ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').In some cases, the area between outer and inner rect is left blank. In other cases the margin area is used to display peripheral graphics while the main content is in the inner rect. This is where automatic margin calculation becomes interesting because it allows the layout element to adapt the margins to the peripheral graphics it wants to draw. For example, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' draws the axis labels and tick labels in the margin area, thus needs to adjust the margins (if '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is enabled) according to the space required by the labels of the axes.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a2a32a12a6161c9dffbadeb9cc585510c',
                      content => 'outerRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'outerRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the outer rect of this layout element. The outer rect is the inner rect expanded by the margins ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). The outer rect is used (and set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') by the parent '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to control the size of this layout element.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a208effccfe2cca4a0eaf9393e60f2dd4',
                      content => 'rect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'margins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'minimumMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'autoMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::MarginSides',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'minimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'maximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'sizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SizeConstraintRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'marginGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPMarginGroup *',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'side',
                type => 'QCP::MarginSide'
              }
            ]
          },
          {
            kind => 'function',
            name => 'marginGroups',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< QCP::MarginSide, QCPMarginGroup * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setOuterRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the outer rect of this layout element. If the layout element is inside a layout, the layout sets the position and size of this layout element using this function.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Calling this function externally has no effect, since the layout will overwrite any changes to the outer rect upon the next replot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The layout element will adapt its inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' by applying the margins inward to the outer rect.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a208effccfe2cca4a0eaf9393e60f2dd4',
                      content => 'rect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'rect',
                type => 'const QRect &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the margins of this layout element. If '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is disabled for some or all sides, this function is used to manually set the margin on those sides. Sides that are still set to be handled automatically are ignored and may have any value in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'margins'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The margin is the distance between the outer rect (controlled by the parent layout via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') and the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (which usually contains the main content of this layout element).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1accfda49994e3e6d51ed14504abf9d27d',
                      content => 'setAutoMargins'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'margins',
                type => 'const QMargins &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is enabled on some or all margins, this function is used to provide minimum values for those margins.The minimum values are not enforced on margin sides that were set to be under manual control via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1accfda49994e3e6d51ed14504abf9d27d',
                      content => 'setAutoMargins'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'margins',
                type => 'const QMargins &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAutoMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets on which sides the margin shall be calculated automatically. If a side is calculated automatically, a minimum margin value may be provided with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. If a side is set to be controlled manually, the value may be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Margin sides that are under automatic control may participate in a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), to synchronize (align) it with other layout elements in the plot.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a0a8a17abc16b7923159fcc7608f94673',
                      content => 'setMinimumMargins'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a8f450b1f3f992ad576fce2c63d8b79cf',
                      content => 'setMargins'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54',
                      content => 'QCP::MarginSide'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sides',
                type => 'QCP::MarginSides'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the minimum size of this layout element. A parent layout tries to respect the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' here by changing row/column sizes in the layout accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the parent layout size is not sufficient to satisfy all minimum size constraints of its child layout elements, the layout may set a size that is actually smaller than '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' propagates the layout\'s size constraints to the outside by setting its own minimum QWidget size accordingly, so violations of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' should be exceptions.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the minimum size of this layout element.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'int'
              },
              {
                declaration_name => 'height',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMaximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the maximum size of this layout element. A parent layout tries to respect the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' here by changing row/column sizes in the layout accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMaximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the maximum size of this layout element.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'int'
              },
              {
                declaration_name => 'height',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets to which rect of a layout element the size constraints apply. Size constraints can be set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') includes the margins (e.g. in the case of a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => ' the axis labels), whereas the inner rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') does not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a5dd29a3c8bc88440c97c06b67be7886b',
                      content => 'setMinimumSize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a74eb5280a737ab44833d506db65efd95',
                      content => 'setMaximumSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'constraintRect',
                type => 'SizeConstraintRect'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMarginGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the margin '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'group'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of the specified margin '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sides'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Margin groups allow synchronizing specified margins across layout elements, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.To unset the margin group of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sides'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'group'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that margin groups only work for margin sides that are set to automatic ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54',
                      content => 'QCP::MarginSide'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sides',
                type => 'QCP::MarginSides'
              },
              {
                declaration_name => 'group',
                type => 'QCPMarginGroup *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'update',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Updates the layout element and sub-elements. This function is automatically called before every replot by the parent layout element. It is called multiple times, once for every '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'UpdatePhase'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The phases are run through in the order of the enum values. For details about what happens at the different phases, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'UpdatePhase'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Layout elements that have child elements should call the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'update'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' method of their child elements, and pass the current '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'phase'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' unchanged.The default implementation executes the automatic margin mechanism in the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'upMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' phase. Subclasses should make sure to call the base class implementation. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'phase',
                type => 'UpdatePhase'
              }
            ],
            reimplemented_by => [
              {
                name => 'update'
              },
              {
                name => 'update'
              },
              {
                name => 'update'
              }
            ]
          },
          {
            kind => 'function',
            name => 'minimumOuterSizeHint',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the suggested minimum size this layout element (the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') may be compressed to, if no manual minimum size is set.if a minimum size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') was not set manually, parent layouts use the returned size (usually indirectly through '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout::getFinalMinimumOuterSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to determine the minimum allowed size of this layout element.A manual minimum size is considered set if it is non-zero.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height. Reimplementations may use their detailed knowledge about the layout element\'s content to provide size hints. '
                }
              ]
            },
            type => 'virtual QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'minimumOuterSizeHint'
              },
              {
                name => 'minimumOuterSizeHint'
              },
              {
                name => 'minimumOuterSizeHint'
              }
            ]
          },
          {
            kind => 'function',
            name => 'maximumOuterSizeHint',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the suggested maximum size this layout element (the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') may be expanded to, if no manual maximum size is set.if a maximum size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') was not set manually, parent layouts use the returned size (usually indirectly through '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout::getFinalMaximumOuterSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to determine the maximum allowed size of this layout element.A manual maximum size is considered set if it is smaller than Qt\'s '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QWIDGETSIZE_MAX'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation simply returns '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QWIDGETSIZE_MAX'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' for both width and height, implying no suggested maximum size. Reimplementations may use their detailed knowledge about the layout element\'s content to provide size hints. '
                }
              ]
            },
            type => 'virtual QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'maximumOuterSizeHint'
              },
              {
                name => 'maximumOuterSizeHint'
              }
            ]
          },
          {
            kind => 'function',
            name => 'elements',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a list of all child elements in this layout element. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'recursive'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, all sub-child elements are included in the list, too.'
                },
                {
                  type => 'parbreak'
                },
                {
                  warning => [
                    {
                      type => 'text',
                      content => 'There may be entries with value 0 in the returned list. (For example, '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutGrid',
                      content => 'QCPLayoutGrid'
                    },
                    {
                      type => 'text',
                      content => ' may have empty cells which yield 0 at the respective index.) '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QList< QCPLayoutElement * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'recursive',
                type => 'bool'
              }
            ],
            reimplemented_by => [
              {
                name => 'elements'
              },
              {
                name => 'elements'
              },
              {
                name => 'elements'
              }
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this legend item has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelected'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selected',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectableChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'selectionCategory',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QCP::Interaction',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'selectionCategory'
            }
          },
          {
            kind => 'function',
            name => 'applyDefaultAntialiasingHint',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'applyDefaultAntialiasingHint'
            }
          },
          {
            kind => 'function',
            name => 'clipRect',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'clipRect'
            }
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'pure_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'draw'
            },
            reimplemented_by => [
              {
                name => 'draw'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'additive',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              },
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'selectEvent'
            }
          },
          {
            kind => 'function',
            name => 'deselectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'deselectEvent'
            }
          },
          {
            kind => 'function',
            name => 'calculateAutoMargin',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'side',
                type => 'QCP::MarginSide'
              }
            ],
            reimplemented_by => [
              {
                name => 'calculateAutoMargin'
              }
            ]
          },
          {
            kind => 'function',
            name => 'layoutChanged',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'layoutChanged'
              }
            ]
          },
          {
            kind => 'function',
            name => 'parentPlotInitialized',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ],
            reimplements => {
              name => 'parentPlotInitialized'
            },
            reimplemented_by => [
              {
                name => 'parentPlotInitialized'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mousePressEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).'
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' uses an event propagation system that works the same as Qt\'s system. If your layerable doesn\'t reimplement the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or explicitly calls '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in its reimplementation, the event will be propagated to the next layerable in the stacking order.Once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseMoveEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseReleaseEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseDoubleClickEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called instead of the second '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. So in the case of a double-click, the event succession is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pressEvent - releaseEvent - doubleClickEvent - releaseEvent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).Similarly to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseDoubleClickEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'wheelEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QWheelEvent *'
              }
            ],
            reimplemented_by => [
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'initializeParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentLayerable',
                type => 'QCPLayerable *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveToLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              },
              {
                declaration_name => 'prepend',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'localAntialiased',
                type => 'bool'
              },
              {
                declaration_name => 'overrideElement',
                type => 'QCP::AntialiasedElement'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mParentLegend',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLegend *'
          },
          {
            kind => 'variable',
            name => 'mFont',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont'
          },
          {
            kind => 'variable',
            name => 'mTextColor',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor'
          },
          {
            kind => 'variable',
            name => 'mSelectedFont',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont'
          },
          {
            kind => 'variable',
            name => 'mSelectedTextColor',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor'
          },
          {
            kind => 'variable',
            name => 'mSelectable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mSelected',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentLayout',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayout *'
          },
          {
            kind => 'variable',
            name => 'mMinimumSize',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize'
          },
          {
            kind => 'variable',
            name => 'mMaximumSize',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize'
          },
          {
            kind => 'variable',
            name => 'mSizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SizeConstraintRect'
          },
          {
            kind => 'variable',
            name => 'mRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'mOuterRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'mMargins',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins'
          },
          {
            kind => 'variable',
            name => 'mMinimumMargins',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins'
          },
          {
            kind => 'variable',
            name => 'mAutoMargins',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::MarginSides'
          },
          {
            kind => 'variable',
            name => 'mMarginGroups',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< QCP::MarginSide, QCPMarginGroup * >'
          },
          {
            kind => 'variable',
            name => 'mVisible',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPLayerable >'
          },
          {
            kind => 'variable',
            name => 'mLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *'
          },
          {
            kind => 'variable',
            name => 'mAntialiased',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCPLegend',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'text',
            content => 'The abstract base class for all entries in a '
          },
          {
            type => 'url',
            link => 'classQCPLegend',
            content => 'QCPLegend'
          },
          {
            type => 'text',
            content => '. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'text',
            content => 'It defines a very basic interface for entries in a '
          },
          {
            type => 'url',
            link => 'classQCPLegend',
            content => 'QCPLegend'
          },
          {
            type => 'text',
            content => '. For representing plottables in the legend, the subclass '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPPlottableLegendItem'
              }
            ]
          },
          {
            type => 'text',
            content => ' is more suitable.Only derive directly from this class when you need absolute freedom (e.g. a custom legend entry that\'s not even associated with a plottable).'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'You must implement the following pure virtual functions: '
          },
          {
            type => 'list',
            style => 'itemized',
            content => [
              [
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'draw'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (from '
                },
                {
                  type => 'url',
                  link => 'classQCPLayerable',
                  content => 'QCPLayerable'
                },
                {
                  type => 'text',
                  content => ')'
                }
              ]
            ]
          },
          {
            type => 'text',
            content => 'You inherit the following members you may use: '
          },
          {
            type => 'url',
            link => 'classQCPLegend',
            content => 'QCPLegend'
          },
          {
            type => 'text',
            content => ' *'
          },
          {
            type => 'style',
            style => 'bold',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'mParentLegend'
          },
          {
            type => 'style',
            style => 'bold',
            enable => 'no'
          },
          {
            type => 'text',
            content => '  '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A pointer to the parent '
          },
          {
            type => 'url',
            link => 'classQCPLegend',
            content => 'QCPLegend'
          },
          {
            type => 'text',
            content => '. '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'QFont '
          },
          {
            type => 'style',
            style => 'bold',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'mFont'
          },
          {
            type => 'style',
            style => 'bold',
            enable => 'no'
          },
          {
            type => 'text',
            content => '  '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The generic font of the item. You should use this font for all or at least the most prominent text of the item.  '
          }
        ]
      }
    },
    {
      name => 'QCPAbstractPaintBuffer',
      derived => [
        {
          name => 'QCPPaintBufferPixmap',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'clear',
          virtualness => 'pure_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'devicePixelRatio',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'donePainting',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'draw',
          virtualness => 'pure_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'invalidated',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'mDevicePixelRatio',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'mInvalidated',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'mSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'QCPAbstractPaintBuffer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'reallocateBuffer',
          virtualness => 'pure_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'setDevicePixelRatio',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'setInvalidated',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'setSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'size',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => 'startPainting',
          virtualness => 'pure_virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        },
        {
          name => '~QCPAbstractPaintBuffer',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPaintBuffer'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAbstractPaintBuffer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Creates a paint buffer and initializes it with the provided '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'devicePixelRatio'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Subclasses must call their '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'reallocateBuffer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' implementation in their respective constructors. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              },
              {
                declaration_name => 'devicePixelRatio',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPAbstractPaintBuffer',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'size',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'invalidated',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'devicePixelRatio',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the paint buffer size.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The buffer is reallocated (by calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'reallocateBuffer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), so any painters that were obtained by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'startPainting'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' are invalidated and must not be used after calling this method.If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is already the current buffer size, this method does nothing. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setInvalidated',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the invalidated flag to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'invalidated'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This mechanism is used internally in conjunction with isolated replotting of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' instances (in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayer::lmBuffered'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' mode). If '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayer::replot'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called on a buffered layer, i.e. an isolated repaint of only that layer (and its dedicated paint buffer) is requested, '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' will decide depending on the invalidated flags of other paint buffers whether it also replots them, instead of only the layer on which the replot was called.The invalidated flag is set to true when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' association has changed, i.e. if layers were added or removed from this buffer, or if they were reordered. It is set to false as soon as all associated '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' instances are drawn onto the buffer.Under normal circumstances, it is not necessary to manually call this method. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'invalidated',
                type => 'bool',
                default_value => 'true'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setDevicePixelRatio',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the the device pixel ratio to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ratio'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This is useful to render on high-DPI output devices. The ratio is automatically set to the device pixel ratio used by the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' instance.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The buffer is reallocated (by calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'reallocateBuffer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), so any painters that were obtained by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'startPainting'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' are invalidated and must not be used after calling this method.'
                },
                {
                  note => [
                    {
                      type => 'text',
                      content => 'This method is only available for Qt versions 5.4 and higher. '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ratio',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'startPainting',
            virtualness => 'pure_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPainter'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' which is ready to draw to this buffer. The ownership and thus the responsibility to delete the painter after the painting operations are complete is given to the caller of this method.Once you are done using the painter, delete the painter and call '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'donePainting'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.While a painter generated with this method is active, you must not call '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDevicePixelRatio'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'clear'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.This method may return 0, if a painter couldn\'t be activated on the buffer. This usually indicates a problem with the respective painting backend. '
                }
              ]
            },
            type => 'virtual QCPPainter *',
            const => 'no',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'startPainting'
              }
            ]
          },
          {
            kind => 'function',
            name => 'donePainting',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If you have acquired a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPainter'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to paint onto this paint buffer via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'startPainting'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', call this method as soon as you are done with the painting operations and have deleted the painter.paint buffer subclasses may use this method to perform any type of cleanup that is necessary. The default implementation does nothing. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'pure_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Draws the contents of this buffer with the provided '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'painter'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This is the method that is used to finally join all paint buffers and draw them onto the screen. '
                }
              ]
            },
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplemented_by => [
              {
                name => 'draw'
              }
            ]
          },
          {
            kind => 'function',
            name => 'clear',
            virtualness => 'pure_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Fills the entire buffer with the provided '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'color'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. To have an empty transparent buffer, use the named color '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'Qt::transparent'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method must not be called if there is currently a painter (acquired with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'startPainting'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') active. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'color',
                type => 'const QColor &'
              }
            ],
            reimplemented_by => [
              {
                name => 'clear'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'reallocateBuffer',
            virtualness => 'pure_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Reallocates the internal buffer with the currently configured size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') and device pixel ratio, if applicable ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDevicePixelRatio'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). It is called as soon as any of those properties are changed on this paint buffer.'
                },
                {
                  note => [
                    {
                      type => 'text',
                      content => 'Subclasses of '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'QCPAbstractPaintBuffer'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' must call their reimplementation of this method in their constructor, to perform the first allocation (this can not be done by the base class because calling pure virtual methods in base class constructors is not possible). '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'reallocateBuffer'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mSize',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize'
          },
          {
            kind => 'variable',
            name => 'mDevicePixelRatio',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mInvalidated',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'text',
            content => 'The abstract base class for paint buffers, which define the rendering backend. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This abstract base class defines the basic interface that a paint buffer needs to provide in order to be usable by '
          },
          {
            type => 'url',
            link => 'classQCustomPlot',
            content => 'QCustomPlot'
          },
          {
            type => 'text',
            content => '.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A paint buffer manages both a surface to draw onto, and the matching paint device. The size of the surface can be changed via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setSize'
              }
            ]
          },
          {
            type => 'text',
            content => '. External classes ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCustomPlot'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPLayer'
              }
            ]
          },
          {
            type => 'text',
            content => ') request a painter via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'startPainting'
              }
            ]
          },
          {
            type => 'text',
            content => ' and then perform the draw calls. Once the painting is complete, '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'donePainting'
              }
            ]
          },
          {
            type => 'text',
            content => ' is called, so the paint buffer implementation can do clean up if necessary. Before rendering a frame, each paint buffer is usually filled with a color using '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'clear'
              }
            ]
          },
          {
            type => 'text',
            content => ' (usually the color is '
          },
          {
            type => 'style',
            style => 'code',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'Qt::transparent'
          },
          {
            type => 'style',
            style => 'code',
            enable => 'no'
          },
          {
            type => 'text',
            content => '), to remove the contents of the previous frame.The simplest paint buffer implementation is '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPPaintBufferPixmap'
              }
            ]
          },
          {
            type => 'text',
            content => ' which allows regular software rendering via the raster engine. Hardware accelerated rendering via pixel buffers and frame buffer objects is provided by '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPPaintBufferGlPbuffer'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPPaintBufferGlFbo'
              }
            ]
          },
          {
            type => 'text',
            content => '. They are used automatically if '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCustomPlot::setOpenGl'
              }
            ]
          },
          {
            type => 'text',
            content => ' is enabled. '
          }
        ]
      }
    },
    {
      name => 'QCPAbstractPlottable',
      base => [
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      derived => [
        {
          name => 'QCPAbstractPlottable1D< DataType >',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAbstractPlottable1D< QCPBarsData >',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAbstractPlottable1D< QCPCurveData >',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAbstractPlottable1D< QCPFinancialData >',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAbstractPlottable1D< QCPGraphData >',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAbstractPlottable1D< QCPStatisticalBoxData >',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPColorMap',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPErrorBars',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'addToLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'addToLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'antialiasedFill',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'antialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyFillAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyScattersAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'brush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'coordsToPixels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'coordsToPixels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'draw',
          virtualness => 'pure_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'drawLegendIcon',
          virtualness => 'pure_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'getKeyRange',
          virtualness => 'pure_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'getValueRange',
          virtualness => 'pure_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'interface1D',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'keyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mAntialiasedFill',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mAntialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mBrush',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mKeyAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mName',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelectable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelection',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelectionDecorator',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mValueAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'name',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'pen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'pixelsToCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'pixelsToCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCPAbstractPlottable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCPAxis',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'QCPPlottableLegendItem',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCustomPlot',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'removeFromLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'removeFromLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleKeyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleValueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectableChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selected',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selection',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionDecorator',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectTest',
          virtualness => 'pure_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setAntialiasedFill',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setAntialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setBrush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setKeyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setName',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelection',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelectionDecorator',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setValueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'valueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPAbstractPlottable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAbstractPlottable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Constructs an abstract plottable which uses '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as its key axis ("x") and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as its value axis ("y"). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' must reside in the same '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' instance and have perpendicular orientations. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Since '
                },
                {
                  type => 'url',
                  link => 'classQCPAbstractPlottable',
                  content => 'QCPAbstractPlottable'
                },
                {
                  type => 'text',
                  content => ' is an abstract class that defines the basic interface to plottables, it can\'t be directly instantiated.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'You probably want one of the subclasses like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPCurve'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' instead. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyAxis',
                type => 'QCPAxis *'
              },
              {
                declaration_name => 'valueAxis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPAbstractPlottable',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'name',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiasedFill',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'pen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'brush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'keyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'valueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::SelectionType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selected',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns true if there are any data points of the plottable currently selected. Use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to retrieve the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selection',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' encompassing all the data points that are currently selected on this plottable.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a0b3b514474fe93354fc74cfc144184b4',
                      content => 'selected'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPDataSelection',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectionDecorator',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Provides access to the selection decorator of this plottable. The selection decorator controls how selected data ranges are drawn (e.g. their pen color and fill), see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for details.If you wish to use an own '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass, pass an instance of it to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QCPSelectionDecorator *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setName',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The name is the textual representation of this plottable as it is displayed in the legend ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLegend'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). It may contain any UTF-8 characters, including newlines. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'name',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiasedFill',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether fills of this plottable are drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that this setting may be overridden by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setNotAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether the scatter symbols of this plottable are drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that this setting may be overridden by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setNotAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The pen is used to draw basic lines that make up the plottable representation in the plot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass draws its graph lines with this pen.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a7a4b92144dca6453a1f0f210e27edc74',
                      content => 'setBrush'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBrush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass draws the fill under the graph with this brush, when it\'s not set to Qt::NoBrush.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ab74b09ae4c0e7e13142fe4b5bf46cac7',
                      content => 'setPen'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'brush',
                type => 'const QBrush &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setKeyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The key axis of a plottable can be set to any axis of a '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ', as long as it is orthogonal to the plottable\'s value axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1a9a79cd0158a4c7f30cbc702f0fd800e4',
                  content => 'QCustomPlot::xAxis'
                },
                {
                  type => 'text',
                  content => ') as key axis and the y-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6fea5679725b152c14facd920b19367',
                  content => 'QCustomPlot::yAxis'
                },
                {
                  type => 'text',
                  content => ') as value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Normally, the key and value axes are set in the constructor of the plottable (or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::addGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when working with QCPGraphs through the dedicated graph interface).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a71626a07367e241ec62ad2c34baf21cb',
                      content => 'setValueAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setValueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The value axis of a plottable can be set to any axis of a '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ', as long as it is orthogonal to the plottable\'s key axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1a9a79cd0158a4c7f30cbc702f0fd800e4',
                  content => 'QCustomPlot::xAxis'
                },
                {
                  type => 'text',
                  content => ') as key axis and the y-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6fea5679725b152c14facd920b19367',
                  content => 'QCustomPlot::yAxis'
                },
                {
                  type => 'text',
                  content => ') as value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Normally, the key and value axes are set in the constructor of the plottable (or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::addGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when working with QCPGraphs through the dedicated graph interface).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a8524fa2994c63c0913ebd9bb2ffa3920',
                      content => 'setKeyAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether and to which granularity this plottable can be selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A selection can happen by clicking on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iSelectPlottables'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), by dragging a selection rect (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setSelectionRectMode'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::srmSelect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), or programmatically by calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'namespaceQCP_1ac6cb9db26a564b27feda362a438db038',
                      content => 'QCP::SelectionType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'QCP::SelectionType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelection',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets which data ranges of this plottable are selected. Selected data ranges are drawn differently (e.g. color) in the plot. This can be controlled via the selection decorator (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').The entire selection mechanism for plottables is handled automatically when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains iSelectPlottables. You only need to call this function when you wish to change the selection state programmatically.Using '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' you can further specify for each plottable whether and to which granularity it is selectable. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selection'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not compatible with the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::SelectionType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the resulting selection will be adjusted accordingly (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection::enforceType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').emits the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionChanged'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' signal when '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is different from the previous selection state.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a38efe9641d972992a3d44204bc80ec1d',
                      content => 'selectTest'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selection',
                type => 'QCPDataSelection'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectionDecorator',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Use this method to set an own '
                },
                {
                  type => 'url',
                  link => 'classQCPSelectionDecorator',
                  content => 'QCPSelectionDecorator'
                },
                {
                  type => 'text',
                  content => ' (subclass) instance. This allows you to customize the visual representation of selected data ranges further than by using the default '
                },
                {
                  type => 'url',
                  link => 'classQCPSelectionDecorator',
                  content => 'QCPSelectionDecorator'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The plottable takes ownership of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'decorator'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The currently set decorator can be accessed via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'decorator',
                type => 'QCPSelectionDecorator *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'pure_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This function is used to decide whether a click hits a layerable object or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a point in pixel coordinates on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn\'t be determined, -1.0 is returned. Further, if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlySelectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true and the object is not selectable, -1.0 is returned, too.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the object is represented not by single lines but by an area like a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPItemText'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or the bars of a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot\'s selection tolerance. (typically the selectionTolerance multiplied by 0.99).Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The actual setting of the selection state is not done by this function. This is handled by the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' when the mouseReleaseEvent occurs, and the finally selected object is notified via the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '/'
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'deselectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' methods.'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an optional output parameter. Every layerable subclass may place any information in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This information will be passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' will carry the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This is useful for multi-part objects (like '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => '). This way, a possibly complex calculation to decide which part was clicked is only done once in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The result (i.e. the actually clicked part) can then be placed in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. So in the subsequent '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the decision which part was selected doesn\'t have to be done a second time for a single selection operation.You may pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to indicate that you are not interested in those selection details.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a2d488568cf16600dd81fa23d7d439829',
                      content => 'selectEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a9b104d9da4f38f934363945c313bf82e',
                      content => 'deselectEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            },
            reimplemented_by => [
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              }
            ]
          },
          {
            kind => 'function',
            name => 'interface1D',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this plottable is a one-dimensional plottable, i.e. it implements the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableInterface1D'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', returns the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'this'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' pointer with that type. Otherwise (e.g. in the case of a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMap'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') returns zero.You can use this method to gain read access to data coordinates while holding a pointer to the abstract base class only. '
                }
              ]
            },
            type => 'virtual QCPPlottableInterface1D *',
            const => 'no',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getKeyRange',
            virtualness => 'pure_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to either '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdPositive'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and all positive points will be ignored for range calculation. For no restriction, just set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdBoth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (default). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn\'t use the returned range (e.g. no points in data).Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not the same as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', since the range returned by this function may have size zero (e.g. when there is only one data point). In this case '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' would return true, but the returned range is not a valid range in terms of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a1491c4a606bccd2d09e65e11b79eb882',
                      content => 'rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a4de773988b21ed090fddd27c6a3a3dcb',
                      content => 'getValueRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'foundRange',
                type => 'bool &'
              },
              {
                declaration_name => 'inSignDomain',
                type => 'QCP::SignDomain',
                default_value => 'QCP::sdBoth'
              }
            ],
            reimplemented_by => [
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getValueRange',
            virtualness => 'pure_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the coordinate range that the data points in the specified key range ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') span in the value axis dimension. For logarithmic plots, one can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to either '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdPositive'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and all positive points will be ignored for range calculation. For no restriction, just set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdBoth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (default). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn\'t use the returned range (e.g. no points in data).If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' has both lower and upper bound set to zero (is equal to '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'url',
                  link => 'classQCPRange',
                  content => 'QCPRange()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), all data points are considered, without any restriction on the keys.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not the same as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', since the range returned by this function may have size zero (e.g. when there is only one data point). In this case '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' would return true, but the returned range is not a valid range in terms of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a1491c4a606bccd2d09e65e11b79eb882',
                      content => 'rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a4da16d3cd4b509e1104a9b0275623c96',
                      content => 'getKeyRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'foundRange',
                type => 'bool &'
              },
              {
                declaration_name => 'inSignDomain',
                type => 'QCP::SignDomain',
                default_value => 'QCP::sdBoth'
              },
              {
                declaration_name => 'inKeyRange',
                type => 'const QCPRange &',
                default_value => 'QCPRange()'
              }
            ],
            reimplemented_by => [
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              }
            ]
          },
          {
            kind => 'function',
            name => 'coordsToPixels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Convenience function for transforming a key/value pair to pixels on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are transformed to the coodinates in pixels and are written to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'x'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'y'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3903c1120ab5c27e7fa46b597ef267bd',
                      content => 'pixelsToCoords'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                      content => 'QCPAxis::coordToPixel'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              },
              {
                declaration_name => 'x',
                type => 'double &'
              },
              {
                declaration_name => 'y',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'coordsToPixels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Transforms the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to pixel coordinates and returns them in a QPointF. '
                }
              ]
            },
            type => 'const QPointF',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pixelsToCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Convenience function for transforming a x/y pixel pair on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface to plot coordinates, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'x'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'y'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are transformed to the plot coodinates and are written to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a7ad84a36472441cf1f555c5683d0da93',
                      content => 'coordsToPixels'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                      content => 'QCPAxis::coordToPixel'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'x',
                type => 'double'
              },
              {
                declaration_name => 'y',
                type => 'double'
              },
              {
                declaration_name => 'key',
                type => 'double &'
              },
              {
                declaration_name => 'value',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pixelsToCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel input '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pixelPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as plot coordinates '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pixelPos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'key',
                type => 'double &'
              },
              {
                declaration_name => 'value',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i.e. a range containing different signs and/or zero. Instead it will stay in the current sign domain and ignore all parts of the plottable that lie outside of that domain.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlyEnlarge'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' makes sure the ranges are only expanded, never reduced. So it\'s possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlyEnlarge'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' set to false (the default), and all subsequent set to true.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ae96b83c961e257da116c6acf9c7da308',
                      content => 'rescaleKeyAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a714eaf36b12434cd71846215504db82e',
                      content => 'rescaleValueAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1ad86528f2cee6c7e446dea4a6e8839935',
                      content => 'QCustomPlot::rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a499345f02ebce4b23d8ccec96e58daa9',
                      content => 'QCPAxis::rescale'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleKeyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Rescales the key axis of the plottable so the whole plottable is visible.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for detailed behaviour. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleValueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Rescales the value axis of the plottable so the whole plottable is visible. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to true, only the data points which are in the currently visible key axis range are considered.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the axis was actually scaled. This might not be the case if this plottable has an invalid range, e.g. because it has no data points.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for detailed behaviour. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              },
              {
                declaration_name => 'inKeyRange',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addToLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds this plottable to the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'legend'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Creates a '
                },
                {
                  type => 'url',
                  link => 'classQCPPlottableLegendItem',
                  content => 'QCPPlottableLegendItem'
                },
                {
                  type => 'text',
                  content => ' which is inserted into the legend. Returns true on success, i.e. when the legend exists and a legend item associated with this plottable isn\'t already in the legend.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the plottable needs a more specialized representation in the legend, you can create a corresponding subclass of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableLegendItem'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and add it to the legend manually instead of calling this method.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3cc235007e2343a65ad4f463767e0e20',
                      content => 'removeFromLegend'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1a3ab274de52d2951faea45a6d975e6b3f',
                      content => 'QCPLegend::addItem'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'legend',
                type => 'QCPLegend *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addToLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds this plottable to the legend of the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::legend'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3cc235007e2343a65ad4f463767e0e20',
                      content => 'removeFromLegend'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'removeFromLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the plottable from the specifed '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'legend'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This means the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableLegendItem'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' that is associated with this plottable is removed.Returns true on success, i.e. if the legend exists and a legend item associated with this plottable was found and removed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1aa64e93cb5b606d8110d2cc0a349bb30f',
                      content => 'addToLegend'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1ac91595c3eaa746fe6321d2eb952c63bb',
                      content => 'QCPLegend::removeItem'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'legend',
                type => 'QCPLegend *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'removeFromLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the plottable from the legend of the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1aa64e93cb5b606d8110d2cc0a349bb30f',
                      content => 'addToLegend'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates whether there are any points selected or not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a787a9c39421059006891744b731fa473',
                      content => 'selectionChanged(const QCPDataSelection &selection)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selected',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selection'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' holds the currently selected data ranges.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3af66432b1dca93b28e00e78a8c7c1d9',
                      content => 'selectionChanged(bool selected)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selection',
                type => 'const QCPDataSelection &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectableChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the selectability of this plottable has changed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'QCP::SelectionType'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'clipRect',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'clipRect'
            }
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'pure_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'draw'
            },
            reimplemented_by => [
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectionCategory',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QCP::Interaction',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'selectionCategory'
            }
          },
          {
            kind => 'function',
            name => 'applyDefaultAntialiasingHint',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'applyDefaultAntialiasingHint'
            }
          },
          {
            kind => 'function',
            name => 'selectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'additive',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              },
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'selectEvent'
            }
          },
          {
            kind => 'function',
            name => 'deselectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'deselectEvent'
            }
          },
          {
            kind => 'function',
            name => 'drawLegendIcon',
            virtualness => 'pure_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'rect',
                type => 'const QRectF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyFillAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyScattersAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'parentPlotInitialized',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ],
            reimplemented_by => [
              {
                name => 'parentPlotInitialized'
              },
              {
                name => 'parentPlotInitialized'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mousePressEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).'
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' uses an event propagation system that works the same as Qt\'s system. If your layerable doesn\'t reimplement the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or explicitly calls '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in its reimplementation, the event will be propagated to the next layerable in the stacking order.Once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseMoveEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseReleaseEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseDoubleClickEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called instead of the second '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. So in the case of a double-click, the event succession is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pressEvent - releaseEvent - doubleClickEvent - releaseEvent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).Similarly to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseDoubleClickEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'wheelEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QWheelEvent *'
              }
            ],
            reimplemented_by => [
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'initializeParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentLayerable',
                type => 'QCPLayerable *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveToLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              },
              {
                declaration_name => 'prepend',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'localAntialiased',
                type => 'bool'
              },
              {
                declaration_name => 'overrideElement',
                type => 'QCP::AntialiasedElement'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mName',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString'
          },
          {
            kind => 'variable',
            name => 'mAntialiasedFill',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mAntialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mBrush',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush'
          },
          {
            kind => 'variable',
            name => 'mKeyAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxis >'
          },
          {
            kind => 'variable',
            name => 'mValueAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxis >'
          },
          {
            kind => 'variable',
            name => 'mSelectable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::SelectionType'
          },
          {
            kind => 'variable',
            name => 'mSelection',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPDataSelection'
          },
          {
            kind => 'variable',
            name => 'mSelectionDecorator',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPSelectionDecorator *'
          },
          {
            kind => 'variable',
            name => 'mVisible',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPLayerable >'
          },
          {
            kind => 'variable',
            name => 'mLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *'
          },
          {
            kind => 'variable',
            name => 'mAntialiased',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCustomPlot',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'friend',
            name => 'QCPAxis',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'friend',
            name => 'QCPPlottableLegendItem',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The abstract base class for all data representing objects in a plot. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'text',
            content => 'It defines a very basic interface like name, pen, brush, visibility etc. Since this class is abstract, it can\'t be instantiated. Use one of the subclasses or create a subclass yourself to create new ways of displaying data (see "Creating own plottables" below). Plottables that display one-dimensional data (i.e. data points have a single key dimension and one or multiple values at each key) are based off of the template subclass '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAbstractPlottable1D'
              }
            ]
          },
          {
            type => 'text',
            content => ', see details there.All further specifics are in the subclasses, for example: '
          },
          {
            type => 'list',
            style => 'itemized',
            content => [
              [
                {
                  type => 'text',
                  content => 'A normal graph with possibly a line and/or scatter points '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (typically created with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::addGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ],
              [
                {
                  type => 'text',
                  content => 'A parametric curve: '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPCurve'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' '
                }
              ],
              [
                {
                  type => 'text',
                  content => 'A bar chart: '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' '
                }
              ],
              [
                {
                  type => 'text',
                  content => 'A statistical box plot: '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPStatisticalBox'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' '
                }
              ],
              [
                {
                  type => 'text',
                  content => 'A color encoded two-dimensional map: '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMap'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' '
                }
              ],
              [
                {
                  type => 'text',
                  content => 'An OHLC/Candlestick chart: '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPFinancial'
                    }
                  ]
                }
              ]
            ]
          },
          {
            type => 'sect1',
            title => 'Creating own plottables',
            content => [
              {
                type => 'text',
                content => 'Subclassing directly from '
              },
              {
                type => 'url',
                link => 'classQCPAbstractPlottable',
                content => 'QCPAbstractPlottable'
              },
              {
                type => 'text',
                content => ' is only recommended if you wish to display two-dimensional data like '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPColorMap'
                  }
                ]
              },
              {
                type => 'text',
                content => ', i.e. two logical key dimensions and one (or more) data dimensions. If you want to display data with only one logical key dimension, you should rather derive from '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPAbstractPlottable1D'
                  }
                ]
              },
              {
                type => 'text',
                content => '.If subclassing '
              },
              {
                type => 'url',
                link => 'classQCPAbstractPlottable',
                content => 'QCPAbstractPlottable'
              },
              {
                type => 'text',
                content => ' directly, these are the pure virtual functions you must implement: '
              },
              {
                type => 'list',
                style => 'itemized',
                content => [
                  [
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'selectTest'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ],
                  [
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'draw'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ],
                  [
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'drawLegendIcon'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ],
                  [
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'getKeyRange'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ],
                  [
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'getValueRange'
                        }
                      ]
                    }
                  ]
                ]
              },
              {
                type => 'text',
                content => 'See the documentation of those functions for what they need to do.For drawing your plot, you can use the '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'coordsToPixels'
                  }
                ]
              },
              {
                type => 'text',
                content => ' functions to translate a point in plot coordinates to pixel coordinates. This function is quite convenient, because it takes the orientation of the key and value axes into account for you (x and y are swapped when the key axis is vertical and the value axis horizontal). If you are worried about performance (i.e. you need to translate many points in a loop like '
              },
              {
                type => 'url',
                link => 'classQCPGraph',
                content => 'QCPGraph'
              },
              {
                type => 'text',
                content => '), you can directly use '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPAxis::coordToPixel'
                  }
                ]
              },
              {
                type => 'text',
                content => '. However, you must then take care about the orientation of the axis yourself.Here are some important members you inherit from '
              },
              {
                type => 'url',
                link => 'classQCPAbstractPlottable',
                content => 'QCPAbstractPlottable'
              },
              {
                type => 'text',
                content => ': '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ' *'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'mParentPlot'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'no'
              },
              {
                type => 'text',
                content => '  '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'A pointer to the parent '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ' instance. The parent plot is inferred from the axes that are passed in the constructor. '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'QString '
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'mName'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'no'
              },
              {
                type => 'text',
                content => '  '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'The name of the plottable. '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'QPen '
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'mPen'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'no'
              },
              {
                type => 'text',
                content => '  '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'The generic pen of the plottable. You should use this pen for the most prominent data representing lines in the plottable (e.g '
              },
              {
                type => 'url',
                link => 'classQCPGraph',
                content => 'QCPGraph'
              },
              {
                type => 'text',
                content => ' uses this pen for its graph lines and scatters) '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'QBrush '
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'mBrush'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'no'
              },
              {
                type => 'text',
                content => '  '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'The generic brush of the plottable. You should use this brush for the most prominent fillable structures in the plottable (e.g. '
              },
              {
                type => 'url',
                link => 'classQCPGraph',
                content => 'QCPGraph'
              },
              {
                type => 'text',
                content => ' uses this brush to control filling under the graph) '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'QPointer<'
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPAxis'
                  }
                ]
              },
              {
                type => 'text',
                content => '> '
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'mKeyAxis'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'no'
              },
              {
                type => 'text',
                content => ', '
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'mValueAxis'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'no'
              },
              {
                type => 'text',
                content => '  The key and value axes this plottable is attached to. Call their '
              },
              {
                type => 'url',
                link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                content => 'QCPAxis::coordToPixel'
              },
              {
                type => 'text',
                content => ' functions to translate coordinates to pixels in either the key or value dimension. Make sure to check whether the pointer is null before using it. If one of the axes is null, don\'t draw the plottable. '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPSelectionDecorator'
                  }
                ]
              },
              {
                type => 'text',
                content => ' '
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'mSelectionDecorator'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'no'
              },
              {
                type => 'text',
                content => '  The currently set selection decorator which specifies how selected data of the plottable shall be drawn and decorated. When drawing your data, you must consult this decorator for the appropriate pen/brush before drawing unselected/selected data segments. Finally, you should call its '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPSelectionDecorator::drawDecoration'
                  }
                ]
              },
              {
                type => 'text',
                content => ' method at the end of your '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'draw'
                  }
                ]
              },
              {
                type => 'text',
                content => ' implementation. '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCP::SelectionType'
                  }
                ]
              },
              {
                type => 'text',
                content => ' '
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'mSelectable'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'no'
              },
              {
                type => 'text',
                content => '  In which composition, if at all, this plottable\'s data may be selected. Enforcing this setting on the data selection is done by '
              },
              {
                type => 'url',
                link => 'classQCPAbstractPlottable',
                content => 'QCPAbstractPlottable'
              },
              {
                type => 'text',
                content => ' automatically. '
              },
              {
                type => 'parbreak'
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPDataSelection'
                  }
                ]
              },
              {
                type => 'text',
                content => ' '
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'mSelection'
              },
              {
                type => 'style',
                style => 'bold',
                enable => 'no'
              },
              {
                type => 'text',
                content => '  Holds the current selection state of the plottable\'s data, i.e. the selected data ranges ('
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPDataRange'
                  }
                ]
              },
              {
                type => 'text',
                content => ').  '
              }
            ]
          }
        ]
      }
    },
    {
      name => 'QCPAbstractPlottable1D',
      base => [
        {
          name => 'QCPAbstractPlottable',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPPlottableInterface1D',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      template_parameters => [
        {
          type => 'class',
          declaration_name => 'DataType',
          definition_name => 'DataType'
        }
      ],
      all_members => [
        {
          name => 'addToLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'addToLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'antialiasedFill',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'antialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyFillAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyScattersAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'brush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'coordsToPixels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'coordsToPixels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'dataCount',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'dataMainKey',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'dataMainValue',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'dataPixelPosition',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'dataSortKey',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'dataValueRange',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'draw',
          virtualness => 'pure_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'drawLegendIcon',
          virtualness => 'pure_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'drawPolyline',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'findBegin',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'findEnd',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'getDataSegments',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'getKeyRange',
          virtualness => 'pure_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'getValueRange',
          virtualness => 'pure_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'interface1D',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'keyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mAntialiasedFill',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mAntialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mBrush',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mDataContainer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'mKeyAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mName',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelectable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelection',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelectionDecorator',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mValueAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'name',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'pen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'pixelsToCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'pixelsToCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCPAbstractPlottable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCPAbstractPlottable1D',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'removeFromLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'removeFromLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleKeyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleValueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectableChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selected',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selection',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionDecorator',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectTest',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'selectTestRect',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setAntialiasedFill',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setAntialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setBrush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setKeyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setName',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelection',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelectionDecorator',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setValueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'sortKeyIsMainKey',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => 'valueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPAbstractPlottable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => '~QCPAbstractPlottable1D',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPPlottableInterface1D',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPPlottableInterface1D'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAbstractPlottable1D',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Forwards '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAbstractPlottable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' constructor and allocates the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'mDataContainer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyAxis',
                type => 'QCPAxis *'
              },
              {
                declaration_name => 'valueAxis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPAbstractPlottable1D',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'dataCount',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the number of data points of the plottable. '
                }
              ]
            },
            type => 'virtual int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'dataCount'
            }
          },
          {
            kind => 'function',
            name => 'dataMainKey',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the main key of the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'What the main key is, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataMainKey'
            }
          },
          {
            kind => 'function',
            name => 'dataSortKey',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the sort key of the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'What the sort key is, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataSortKey'
            }
          },
          {
            kind => 'function',
            name => 'dataMainValue',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the main value of the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'What the main value is, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataMainValue'
            }
          },
          {
            kind => 'function',
            name => 'dataValueRange',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the value range of the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'What the value range is, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataValueRange'
            }
          },
          {
            kind => 'function',
            name => 'dataPixelPosition',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the pixel position on the widget surface at which the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' appears.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Usually this corresponds to the point of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'dataMainKey'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '/'
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'dataMainValue'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', in pixel coordinates. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values. For example, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' apparent data values can be shifted depending on their stacking, bar grouping or configured base value. '
                }
              ]
            },
            type => 'virtual QPointF',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataPixelPosition'
            },
            reimplemented_by => [
              {
                name => 'dataPixelPosition'
              }
            ]
          },
          {
            kind => 'function',
            name => 'sortKeyIsMainKey',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns whether the sort key ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'dataSortKey'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') is identical to the main key ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'dataMainKey'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').What the sort and main keys are, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'sortKeyIsMainKey'
            }
          },
          {
            kind => 'function',
            name => 'selectTestRect',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Implements a rect-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.'
                }
              ]
            },
            type => 'virtual QCPDataSelection',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'rect',
                type => 'const QRectF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              }
            ],
            reimplements => {
              name => 'selectTestRect'
            },
            reimplemented_by => [
              {
                name => 'selectTestRect'
              },
              {
                name => 'selectTestRect'
              },
              {
                name => 'selectTestRect'
              }
            ]
          },
          {
            kind => 'function',
            name => 'findBegin',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the index of the data point with a (sort-)key that is equal to, just below, or just above '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'expandedRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, the data point just below '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will be considered, otherwise the one just above.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This can be used in conjunction with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'findEnd'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to iterate over data points within a given key range, including or excluding the bounding data points that are just beyond the specified range.If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'expandedRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true but there are no data points below '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', 0 is returned.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the container is empty, returns 0 (in that case, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'findEnd'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' will also return 0, so a loop using these methods will not iterate over the index 0).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable1D_1a6e3ba20c9160d7361e58070390d10b1a',
                      content => 'findEnd'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPDataContainer_1a2ad8a5399072d99a242d3a6d2d7e278a',
                      content => 'QCPDataContainer::findBegin'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual int',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sortKey',
                type => 'double'
              },
              {
                declaration_name => 'expandedRange',
                type => 'bool',
                default_value => 'true'
              }
            ],
            reimplements => {
              name => 'findBegin'
            }
          },
          {
            kind => 'function',
            name => 'findEnd',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the index one after the data point with a (sort-)key that is equal to, just above, or just below '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'expandedRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, the data point just above '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will be considered, otherwise the one just below.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This can be used in conjunction with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'findBegin'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to iterate over data points within a given key range, including the bounding data points that are just below and above the specified range.If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'expandedRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true but there are no data points above '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', the index just above the highest data point is returned.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the container is empty, returns 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable1D_1ad0b46d25cde3d035b180fb8f10c056e6',
                      content => 'findBegin'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPDataContainer_1afb8b8f23cc2b7234a793a25ce79fe48f',
                      content => 'QCPDataContainer::findEnd'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual int',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sortKey',
                type => 'double'
              },
              {
                declaration_name => 'expandedRange',
                type => 'bool',
                default_value => 'true'
              }
            ],
            reimplements => {
              name => 'findEnd'
            }
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.'
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            },
            reimplemented_by => [
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              }
            ]
          },
          {
            kind => 'function',
            name => 'interface1D',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableInterface1D'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' pointer to this plottable, providing access to its 1D interface.'
                }
              ]
            },
            type => 'virtual QCPPlottableInterface1D *',
            const => 'no',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'interface1D'
            }
          },
          {
            kind => 'function',
            name => 'name',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiasedFill',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'pen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'brush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'keyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'valueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::SelectionType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selected',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if there are any data points of the plottable currently selected. Use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to retrieve the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selection',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' encompassing all the data points that are currently selected on this plottable.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a0b3b514474fe93354fc74cfc144184b4',
                      content => 'selected'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPDataSelection',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectionDecorator',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Provides access to the selection decorator of this plottable. The selection decorator controls how selected data ranges are drawn (e.g. their pen color and fill), see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for details.If you wish to use an own '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass, pass an instance of it to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QCPSelectionDecorator *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setName',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The name is the textual representation of this plottable as it is displayed in the legend ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLegend'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). It may contain any UTF-8 characters, including newlines. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'name',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiasedFill',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether fills of this plottable are drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that this setting may be overridden by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setNotAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether the scatter symbols of this plottable are drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that this setting may be overridden by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setNotAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The pen is used to draw basic lines that make up the plottable representation in the plot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass draws its graph lines with this pen.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a7a4b92144dca6453a1f0f210e27edc74',
                      content => 'setBrush'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBrush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass draws the fill under the graph with this brush, when it\'s not set to Qt::NoBrush.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ab74b09ae4c0e7e13142fe4b5bf46cac7',
                      content => 'setPen'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'brush',
                type => 'const QBrush &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setKeyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The key axis of a plottable can be set to any axis of a '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ', as long as it is orthogonal to the plottable\'s value axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1a9a79cd0158a4c7f30cbc702f0fd800e4',
                  content => 'QCustomPlot::xAxis'
                },
                {
                  type => 'text',
                  content => ') as key axis and the y-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6fea5679725b152c14facd920b19367',
                  content => 'QCustomPlot::yAxis'
                },
                {
                  type => 'text',
                  content => ') as value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Normally, the key and value axes are set in the constructor of the plottable (or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::addGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when working with QCPGraphs through the dedicated graph interface).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a71626a07367e241ec62ad2c34baf21cb',
                      content => 'setValueAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setValueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The value axis of a plottable can be set to any axis of a '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ', as long as it is orthogonal to the plottable\'s key axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1a9a79cd0158a4c7f30cbc702f0fd800e4',
                  content => 'QCustomPlot::xAxis'
                },
                {
                  type => 'text',
                  content => ') as key axis and the y-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6fea5679725b152c14facd920b19367',
                  content => 'QCustomPlot::yAxis'
                },
                {
                  type => 'text',
                  content => ') as value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Normally, the key and value axes are set in the constructor of the plottable (or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::addGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when working with QCPGraphs through the dedicated graph interface).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a8524fa2994c63c0913ebd9bb2ffa3920',
                      content => 'setKeyAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether and to which granularity this plottable can be selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A selection can happen by clicking on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iSelectPlottables'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), by dragging a selection rect (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setSelectionRectMode'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::srmSelect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), or programmatically by calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'namespaceQCP_1ac6cb9db26a564b27feda362a438db038',
                      content => 'QCP::SelectionType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'QCP::SelectionType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelection',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets which data ranges of this plottable are selected. Selected data ranges are drawn differently (e.g. color) in the plot. This can be controlled via the selection decorator (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').The entire selection mechanism for plottables is handled automatically when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains iSelectPlottables. You only need to call this function when you wish to change the selection state programmatically.Using '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' you can further specify for each plottable whether and to which granularity it is selectable. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selection'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not compatible with the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::SelectionType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the resulting selection will be adjusted accordingly (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection::enforceType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').emits the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionChanged'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' signal when '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is different from the previous selection state.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a38efe9641d972992a3d44204bc80ec1d',
                      content => 'selectTest'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selection',
                type => 'QCPDataSelection'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectionDecorator',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Use this method to set an own '
                },
                {
                  type => 'url',
                  link => 'classQCPSelectionDecorator',
                  content => 'QCPSelectionDecorator'
                },
                {
                  type => 'text',
                  content => ' (subclass) instance. This allows you to customize the visual representation of selected data ranges further than by using the default '
                },
                {
                  type => 'url',
                  link => 'classQCPSelectionDecorator',
                  content => 'QCPSelectionDecorator'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The plottable takes ownership of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'decorator'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The currently set decorator can be accessed via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'decorator',
                type => 'QCPSelectionDecorator *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getKeyRange',
            virtualness => 'pure_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to either '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdPositive'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and all positive points will be ignored for range calculation. For no restriction, just set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdBoth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (default). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn\'t use the returned range (e.g. no points in data).Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not the same as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', since the range returned by this function may have size zero (e.g. when there is only one data point). In this case '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' would return true, but the returned range is not a valid range in terms of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a1491c4a606bccd2d09e65e11b79eb882',
                      content => 'rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a4de773988b21ed090fddd27c6a3a3dcb',
                      content => 'getValueRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'foundRange',
                type => 'bool &'
              },
              {
                declaration_name => 'inSignDomain',
                type => 'QCP::SignDomain',
                default_value => 'QCP::sdBoth'
              }
            ],
            reimplemented_by => [
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              },
              {
                name => 'getKeyRange'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getValueRange',
            virtualness => 'pure_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the coordinate range that the data points in the specified key range ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') span in the value axis dimension. For logarithmic plots, one can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to either '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdPositive'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and all positive points will be ignored for range calculation. For no restriction, just set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdBoth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (default). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn\'t use the returned range (e.g. no points in data).If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' has both lower and upper bound set to zero (is equal to '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'url',
                  link => 'classQCPRange',
                  content => 'QCPRange()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), all data points are considered, without any restriction on the keys.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not the same as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', since the range returned by this function may have size zero (e.g. when there is only one data point). In this case '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' would return true, but the returned range is not a valid range in terms of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a1491c4a606bccd2d09e65e11b79eb882',
                      content => 'rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a4da16d3cd4b509e1104a9b0275623c96',
                      content => 'getKeyRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'foundRange',
                type => 'bool &'
              },
              {
                declaration_name => 'inSignDomain',
                type => 'QCP::SignDomain',
                default_value => 'QCP::sdBoth'
              },
              {
                declaration_name => 'inKeyRange',
                type => 'const QCPRange &',
                default_value => 'QCPRange()'
              }
            ],
            reimplemented_by => [
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              },
              {
                name => 'getValueRange'
              }
            ]
          },
          {
            kind => 'function',
            name => 'coordsToPixels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Convenience function for transforming a key/value pair to pixels on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are transformed to the coodinates in pixels and are written to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'x'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'y'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3903c1120ab5c27e7fa46b597ef267bd',
                      content => 'pixelsToCoords'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                      content => 'QCPAxis::coordToPixel'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              },
              {
                declaration_name => 'x',
                type => 'double &'
              },
              {
                declaration_name => 'y',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'coordsToPixels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Transforms the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to pixel coordinates and returns them in a QPointF. '
                }
              ]
            },
            type => 'const QPointF',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pixelsToCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Convenience function for transforming a x/y pixel pair on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface to plot coordinates, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'x'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'y'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are transformed to the plot coodinates and are written to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a7ad84a36472441cf1f555c5683d0da93',
                      content => 'coordsToPixels'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                      content => 'QCPAxis::coordToPixel'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'x',
                type => 'double'
              },
              {
                declaration_name => 'y',
                type => 'double'
              },
              {
                declaration_name => 'key',
                type => 'double &'
              },
              {
                declaration_name => 'value',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pixelsToCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel input '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pixelPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as plot coordinates '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pixelPos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'key',
                type => 'double &'
              },
              {
                declaration_name => 'value',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i.e. a range containing different signs and/or zero. Instead it will stay in the current sign domain and ignore all parts of the plottable that lie outside of that domain.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlyEnlarge'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' makes sure the ranges are only expanded, never reduced. So it\'s possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlyEnlarge'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' set to false (the default), and all subsequent set to true.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ae96b83c961e257da116c6acf9c7da308',
                      content => 'rescaleKeyAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a714eaf36b12434cd71846215504db82e',
                      content => 'rescaleValueAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1ad86528f2cee6c7e446dea4a6e8839935',
                      content => 'QCustomPlot::rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a499345f02ebce4b23d8ccec96e58daa9',
                      content => 'QCPAxis::rescale'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleKeyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Rescales the key axis of the plottable so the whole plottable is visible.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for detailed behaviour. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleValueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Rescales the value axis of the plottable so the whole plottable is visible. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to true, only the data points which are in the currently visible key axis range are considered.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the axis was actually scaled. This might not be the case if this plottable has an invalid range, e.g. because it has no data points.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for detailed behaviour. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              },
              {
                declaration_name => 'inKeyRange',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addToLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds this plottable to the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'legend'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Creates a '
                },
                {
                  type => 'url',
                  link => 'classQCPPlottableLegendItem',
                  content => 'QCPPlottableLegendItem'
                },
                {
                  type => 'text',
                  content => ' which is inserted into the legend. Returns true on success, i.e. when the legend exists and a legend item associated with this plottable isn\'t already in the legend.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the plottable needs a more specialized representation in the legend, you can create a corresponding subclass of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableLegendItem'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and add it to the legend manually instead of calling this method.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3cc235007e2343a65ad4f463767e0e20',
                      content => 'removeFromLegend'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1a3ab274de52d2951faea45a6d975e6b3f',
                      content => 'QCPLegend::addItem'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'legend',
                type => 'QCPLegend *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addToLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds this plottable to the legend of the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::legend'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3cc235007e2343a65ad4f463767e0e20',
                      content => 'removeFromLegend'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'removeFromLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the plottable from the specifed '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'legend'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This means the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableLegendItem'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' that is associated with this plottable is removed.Returns true on success, i.e. if the legend exists and a legend item associated with this plottable was found and removed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1aa64e93cb5b606d8110d2cc0a349bb30f',
                      content => 'addToLegend'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1ac91595c3eaa746fe6321d2eb952c63bb',
                      content => 'QCPLegend::removeItem'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'legend',
                type => 'QCPLegend *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'removeFromLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the plottable from the legend of the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1aa64e93cb5b606d8110d2cc0a349bb30f',
                      content => 'addToLegend'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates whether there are any points selected or not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a787a9c39421059006891744b731fa473',
                      content => 'selectionChanged(const QCPDataSelection &selection)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selected',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selection'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' holds the currently selected data ranges.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3af66432b1dca93b28e00e78a8c7c1d9',
                      content => 'selectionChanged(bool selected)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selection',
                type => 'const QCPDataSelection &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectableChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the selectability of this plottable has changed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'QCP::SelectionType'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'getDataSegments',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Splits all data into selected and unselected segments and outputs them via '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selectedSegments'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'unselectedSegments'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', respectively.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This is useful when subclasses implement their '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'draw'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' method and need to draw selected segments with a different pen/brush than unselected segments (also see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectedSegments',
                type => 'QList< QCPDataRange > &'
              },
              {
                declaration_name => 'unselectedSegments',
                type => 'QList< QCPDataRange > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'drawPolyline',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'A helper method which draws a line with the passed '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'painter'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', according to the pixel data in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'lineData'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. NaN points create gaps in the line, as expected from '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '\'s plottables (this is the main difference to QPainter\'s regular drawPolyline, which handles NaNs by lagging or crashing).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Further it uses a faster line drawing technique based on '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPainter::drawLine'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' rather than '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QPainter::drawPolyline'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' if the configured '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setPlottingHints()'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'painter'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' style allows. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'lineData',
                type => 'const QVector< QPointF > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'clipRect',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'clipRect'
            }
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'pure_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'draw'
            },
            reimplemented_by => [
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectionCategory',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QCP::Interaction',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'selectionCategory'
            }
          },
          {
            kind => 'function',
            name => 'applyDefaultAntialiasingHint',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'applyDefaultAntialiasingHint'
            }
          },
          {
            kind => 'function',
            name => 'selectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'additive',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              },
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'selectEvent'
            }
          },
          {
            kind => 'function',
            name => 'deselectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'deselectEvent'
            }
          },
          {
            kind => 'function',
            name => 'drawLegendIcon',
            virtualness => 'pure_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'rect',
                type => 'const QRectF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              },
              {
                name => 'drawLegendIcon'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyFillAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyScattersAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'parentPlotInitialized',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ],
            reimplemented_by => [
              {
                name => 'parentPlotInitialized'
              },
              {
                name => 'parentPlotInitialized'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mousePressEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).'
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' uses an event propagation system that works the same as Qt\'s system. If your layerable doesn\'t reimplement the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or explicitly calls '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in its reimplementation, the event will be propagated to the next layerable in the stacking order.Once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseMoveEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseReleaseEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseDoubleClickEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called instead of the second '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. So in the case of a double-click, the event succession is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pressEvent - releaseEvent - doubleClickEvent - releaseEvent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).Similarly to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseDoubleClickEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'wheelEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QWheelEvent *'
              }
            ],
            reimplemented_by => [
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'initializeParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentLayerable',
                type => 'QCPLayerable *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveToLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              },
              {
                declaration_name => 'prepend',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'localAntialiased',
                type => 'bool'
              },
              {
                declaration_name => 'overrideElement',
                type => 'QCP::AntialiasedElement'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mDataContainer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSharedPointer< QCPDataContainer< DataType > >'
          },
          {
            kind => 'variable',
            name => 'mName',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString'
          },
          {
            kind => 'variable',
            name => 'mAntialiasedFill',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mAntialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mBrush',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush'
          },
          {
            kind => 'variable',
            name => 'mKeyAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxis >'
          },
          {
            kind => 'variable',
            name => 'mValueAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxis >'
          },
          {
            kind => 'variable',
            name => 'mSelectable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::SelectionType'
          },
          {
            kind => 'variable',
            name => 'mSelection',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPDataSelection'
          },
          {
            kind => 'variable',
            name => 'mSelectionDecorator',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPSelectionDecorator *'
          },
          {
            kind => 'variable',
            name => 'mVisible',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPLayerable >'
          },
          {
            kind => 'variable',
            name => 'mLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *'
          },
          {
            kind => 'variable',
            name => 'mAntialiased',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A template base class for plottables with one-dimensional data. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This template class derives from '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAbstractPlottable'
              }
            ]
          },
          {
            type => 'text',
            content => ' and from the abstract interface '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPPlottableInterface1D'
              }
            ]
          },
          {
            type => 'text',
            content => '. It serves as a base class for all one-dimensional data (i.e. data with one key dimension), such as '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPGraph'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'url',
            link => 'classQCPCurve',
            content => 'QCPCurve'
          },
          {
            type => 'text',
            content => '.The template parameter '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'DataType'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' is the type of the data points of this plottable (e.g. '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPGraphData'
              }
            ]
          },
          {
            type => 'text',
            content => ' or '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPCurveData'
              }
            ]
          },
          {
            type => 'text',
            content => '). The main purpose of this base class is to provide the member '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'mDataContainer'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' (a shared pointer to a '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPDataContainer<DataType>'
              }
            ]
          },
          {
            type => 'text',
            content => ') and implement the according virtual methods of the '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPPlottableInterface1D'
              }
            ]
          },
          {
            type => 'text',
            content => ', such that most subclassed plottables don\'t need to worry about this anymore.Further, it provides a convenience method for retrieving selected/unselected data segments via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'getDataSegments'
              }
            ]
          },
          {
            type => 'text',
            content => '. This is useful when subclasses implement their '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'draw'
              }
            ]
          },
          {
            type => 'text',
            content => ' method and need to draw selected segments with a different pen/brush than unselected segments (also see '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPSelectionDecorator'
              }
            ]
          },
          {
            type => 'text',
            content => ').This class implements basic functionality of '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAbstractPlottable::selectTest'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPPlottableInterface1D::selectTestRect'
              }
            ]
          },
          {
            type => 'text',
            content => ', assuming point-like data points, based on the 1D data interface. In spite of that, most plottable subclasses will want to reimplement those methods again, to provide a more accurate hit test based on their specific data visualization geometry. '
          }
        ]
      }
    },
    {
      name => 'QCPAxis',
      base => [
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'atBottom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'atLeft',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'atRight',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'atTop',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'axisRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'axisType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'AxisType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'basePen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'calculateMargin',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'coordToPixel',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'draw',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'getBasePen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'getLabelColor',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'getLabelFont',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'getPartAt',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'getSubTickPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'getTickLabelColor',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'getTickLabelFont',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'getTickPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'graphs',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'grid',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'items',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'label',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'labelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'labelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'labelPadding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'LabelSide',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'lowerEnding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'lsInside',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'lsOutside',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'mAADragBackup',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'marginSideToAxisType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'mAxisPainter',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mAxisRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mAxisType',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mBasePen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mCachedMargin',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mCachedMarginValid',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mDragging',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mDragStartRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mGrid',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mLabel',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mLabelColor',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mLabelFont',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mNotAADragBackup',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mNumberBeautifulPowers',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mNumberFormatChar',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mNumberPrecision',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mOrientation',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'moveRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mPadding',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mRangeReversed',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mScaleType',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSelectableParts',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSelectedBasePen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSelectedLabelColor',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSelectedLabelFont',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSelectedParts',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSelectedSubTickPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSelectedTickLabelColor',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSelectedTickLabelFont',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSelectedTickPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSubTickPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSubTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mSubTickVector',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mTicker',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mTickLabelColor',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mTickLabelFont',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mTickLabels',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mTickPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mTickVector',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mTickVectorLabels',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'numberFormat',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'numberPrecision',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'offset',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'opposite',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'orientation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'orientation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'padding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'pixelOrientation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'pixelToCoord',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'plottables',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'QCPAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'QCPAxisRect',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAxis'
        },
        {
          name => 'QCPGrid',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAxis'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'QCustomPlot',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAxis'
        },
        {
          name => 'range',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'rangeChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'rangeChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'rangeReversed',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'rescale',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'scaleRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'scaleRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'scaleType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'ScaleType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'scaleTypeChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectableChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'SelectablePart',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectableParts',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectedBasePen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectedLabelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectedLabelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectedParts',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectedSubTickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectedTickLabelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectedTickLabelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectedTickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'selectTest',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setBasePen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setLabel',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setLabelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setLabelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setLabelPadding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLowerEnding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setNumberFormat',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setNumberPrecision',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setOffset',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setPadding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setRangeLower',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setRangeReversed',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setRangeUpper',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setScaleRatio',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setScaleType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSelectableParts',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSelectedBasePen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSelectedLabelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSelectedLabelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSelectedParts',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSelectedSubTickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSelectedTickLabelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSelectedTickLabelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSelectedTickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSubTickLength',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSubTickLengthIn',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSubTickLengthOut',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSubTickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setSubTicks',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTicker',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickLabelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickLabelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickLabelPadding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickLabelRotation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickLabels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickLabelSide',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickLength',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickLengthIn',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickLengthOut',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setTicks',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setUpperEnding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'setupTickVectors',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'spAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'spAxisLabel',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'spNone',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'spTickLabels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'stLinear',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'stLogarithmic',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'subTickLengthIn',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'subTickLengthOut',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'subTickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'subTicks',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'ticker',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickLabelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickLabelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickLabelPadding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickLabelRotation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickLabels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickLabelSide',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickLengthIn',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickLengthOut',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'ticks',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickVector',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'tickVectorLabels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'upperEnding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxis'
        },
        {
          name => '~QCPAxis',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxis'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'AxisType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines at which side of the axis rect the axis will appear. This also affects how the tick marks are drawn, on which side the labels are placed etc. '
                }
              ]
            },
            values => [
              {
                name => 'atLeft',
                initializer => '= 0x01',
                brief => {
                  doc => [
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'yes'
                    },
                    {
                      type => 'text',
                      content => '0x01'
                    },
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'no'
                    },
                    {
                      type => 'text',
                      content => ' Axis is vertical and on the left side of the axis rect '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'atRight',
                initializer => '= 0x02',
                brief => {
                  doc => [
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'yes'
                    },
                    {
                      type => 'text',
                      content => '0x02'
                    },
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'no'
                    },
                    {
                      type => 'text',
                      content => ' Axis is vertical and on the right side of the axis rect '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'atTop',
                initializer => '= 0x04',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'yes'
                    },
                    {
                      type => 'text',
                      content => '0x04'
                    },
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'no'
                    },
                    {
                      type => 'text',
                      content => ' Axis is horizontal and on the top side of the axis rect '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'atBottom',
                initializer => '= 0x08',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'yes'
                    },
                    {
                      type => 'text',
                      content => '0x08'
                    },
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'no'
                    },
                    {
                      type => 'text',
                      content => ' Axis is horizontal and on the bottom side of the axis rect '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enum',
            name => 'LabelSide',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Defines on which side of the axis the tick labels (numbers) shall appear.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a13ec644fc6e22715744c92c6dfa4f0fa',
                      content => 'setTickLabelSide'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'lsInside',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Tick labels will be displayed inside the axis rect and clipped to the inner axis rect. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'lsOutside',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Tick labels will be displayed outside the axis rect. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enum',
            name => 'ScaleType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the scale of an axis. '
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1adef29cae617af4f519f6c40d1a866ca6',
                      content => 'setScaleType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'stLinear',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Linear scaling. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'stLogarithmic',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Logarithmic scaling with correspondingly transformed axis coordinates (possibly also '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTicker'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' to a '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'QCPAxisTickerLog'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' instance). '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enum',
            name => 'SelectablePart',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the selectable parts of an axis. '
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'spNone',
                initializer => '= 0',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'None of the selectable parts. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'spAxis',
                initializer => '= 0x001',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'The axis backbone and tick marks. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'spTickLabels',
                initializer => '= 0x002',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Tick labels (numbers) of this axis (as a whole, not individually) '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'spAxisLabel',
                initializer => '= 0x004',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'The axis label. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'atLeft',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => '0x01'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' Axis is vertical and on the left side of the axis rect '
                }
              ]
            },
            detailed => {},
            type => '@',
            initializer => '= 0x01'
          },
          {
            kind => 'enumvalue',
            name => 'atRight',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => '0x02'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' Axis is vertical and on the right side of the axis rect '
                }
              ]
            },
            detailed => {},
            type => '@',
            initializer => '= 0x02'
          },
          {
            kind => 'enumvalue',
            name => 'atTop',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => '0x04'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' Axis is horizontal and on the top side of the axis rect '
                }
              ]
            },
            detailed => {},
            type => '@',
            initializer => '= 0x04'
          },
          {
            kind => 'enumvalue',
            name => 'atBottom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => '0x08'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' Axis is horizontal and on the bottom side of the axis rect '
                }
              ]
            },
            detailed => {},
            type => '@',
            initializer => '= 0x08'
          },
          {
            kind => 'enumvalue',
            name => 'lsInside',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Tick labels will be displayed inside the axis rect and clipped to the inner axis rect. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'lsOutside',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Tick labels will be displayed outside the axis rect. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'stLinear',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Linear scaling. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'stLogarithmic',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Logarithmic scaling with correspondingly transformed axis coordinates (possibly also '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTicker'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisTickerLog'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' instance). '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'spNone',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'None of the selectable parts. '
                }
              ]
            },
            detailed => {},
            type => '@',
            initializer => '= 0'
          },
          {
            kind => 'enumvalue',
            name => 'spAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The axis backbone and tick marks. '
                }
              ]
            },
            detailed => {},
            type => '@',
            initializer => '= 0x001'
          },
          {
            kind => 'enumvalue',
            name => 'spTickLabels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Tick labels (numbers) of this axis (as a whole, not individually) '
                }
              ]
            },
            detailed => {},
            type => '@',
            initializer => '= 0x002'
          },
          {
            kind => 'enumvalue',
            name => 'spAxisLabel',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The axis label. '
                }
              ]
            },
            detailed => {},
            type => '@',
            initializer => '= 0x004'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs an Axis instance of Type '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' for the axis rect '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'parent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Usually it isn\'t necessary to instantiate axes directly, because you can let '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' create them for you with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisRect::addAxis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. If you want to use own QCPAxis-subclasses however, create them manually and then inject them also via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisRect::addAxis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parent',
                type => 'QCPAxisRect *'
              },
              {
                declaration_name => 'type',
                type => 'AxisType'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPAxis',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'axisType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'AxisType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'axisRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxisRect *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'scaleType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'ScaleType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'range',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'const QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rangeReversed',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'ticker',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a modifiable shared pointer to the currently installed axis ticker. The axis ticker is responsible for generating the tick positions and tick labels of this axis. You can access the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisTicker'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' with this method and modify basic properties such as the approximate tick count ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisTicker::setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').You can gain more control over the axis ticks by setting a different '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisTicker'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass, see the documentation there. A new axis ticker can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTicker'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Since the ticker is stored in the axis as a shared pointer, multiple axes may share the same axis ticker simply by passing the same shared pointer to multiple axes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a4ee03fcd2c74d05cd1a419b9af5cfbdc',
                      content => 'setTicker'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QSharedPointer< QCPAxisTicker >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'ticks',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickLabels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickLabelPadding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickLabelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickLabelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickLabelRotation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickLabelSide',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'LabelSide',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'numberFormat',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'numberPrecision',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickVector',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QVector< double >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickVectorLabels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QVector< QString >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickLengthIn',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickLengthOut',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'subTicks',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'subTickLengthIn',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'subTickLengthOut',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'basePen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'subTickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'labelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'labelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'label',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'labelPadding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'padding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'offset',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedParts',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SelectableParts',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectableParts',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SelectableParts',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedTickLabelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedLabelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedTickLabelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedLabelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedBasePen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedTickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectedSubTickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'lowerEnding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLineEnding',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'upperEnding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLineEnding',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'grid',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGrid'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' instance belonging to this axis. Access it to set details about the way the grid is displayed. '
                }
              ]
            },
            type => 'QCPGrid *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setScaleType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether the axis uses a linear scale or a logarithmic scale.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that this method controls the coordinate transformation. You will likely also want to use a logarithmic tick spacing and labeling, which can be achieved by setting an instance of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisTickerLog'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTicker'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. See the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisTickerLog'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' about the details of logarithmic axis tick creation.'
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setNumberPrecision'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' '
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'QCPAxis::ScaleType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the range of the axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This slot may be connected with the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rangeChanged'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' signal of another axis so this axis is always synchronized with the other axis range, when it changes.To invert the direction of an axis, use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeReversed'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the lower and upper bound of the axis range.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'To invert the direction of an axis, use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeReversed'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.There is also a slot to set a range, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRange(const QCPRange &range)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'lower',
                type => 'double'
              },
              {
                declaration_name => 'upper',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the range of the axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'position'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' coordinate indicates together with the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alignment'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, where the new range will be positioned. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' defines the size of the new axis range. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alignment'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' may be Qt::AlignLeft, Qt::AlignRight or Qt::AlignCenter. This will cause the left border, right border, or center of the range to be aligned with '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'position'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. Any other values of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alignment'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will default to Qt::AlignCenter. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'position',
                type => 'double'
              },
              {
                declaration_name => 'size',
                type => 'double'
              },
              {
                declaration_name => 'alignment',
                type => 'Qt::AlignmentFlag'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeLower',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the lower bound of the axis range. The upper bound is not changed. '
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1aebdfea5d44c3a0ad2b4700cd4d25b641',
                      content => 'setRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'lower',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeUpper',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the upper bound of the axis range. The lower bound is not changed. '
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1aebdfea5d44c3a0ad2b4700cd4d25b641',
                      content => 'setRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'upper',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeReversed',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the axis range (direction) is displayed reversed. Normally, the values on horizontal axes increase left to right, on vertical axes bottom to top. When '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'reversed'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to true, the direction of increasing values is inverted.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that the range and data interface stays the same for reversed axes, e.g. the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'lower'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' part of the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' interface will still reference the mathematically smaller number than the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'upper'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' part. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'reversed',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTicker',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The axis ticker is responsible for generating the tick positions and tick labels. See the documentation of '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTicker',
                  content => 'QCPAxisTicker'
                },
                {
                  type => 'text',
                  content => ' for details on how to work with axis tickers.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'You can change the tick positioning/labeling behaviour of this axis by setting a different '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTicker',
                  content => 'QCPAxisTicker'
                },
                {
                  type => 'text',
                  content => ' subclass using this method. If you only wish to modify the currently installed axis ticker, access it via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'ticker'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Since the ticker is stored in the axis as a shared pointer, multiple axes may share the same axis ticker simply by passing the same shared pointer to multiple axes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a7b7a27151be8235059e1294f73ecf615',
                      content => 'ticker'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticker',
                type => 'QSharedPointer< QCPAxisTicker >'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTicks',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether tick marks are displayed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'show'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to false does not imply that tick labels are invisible, too. To achieve that, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickLabels'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1afa0ce8d4d0015ed23dcde01f8bc30106',
                      content => 'setSubTicks'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'show',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickLabels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether tick labels are displayed. Tick labels are the numbers drawn next to tick marks. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'show',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickLabelPadding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the distance between the axis base line (including any outward ticks) and the tick labels. '
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a4391192a766e5d20cfe5cbc17607a7a2',
                      content => 'setLabelPadding'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a5691441cb3de9e9844855d339c0db279',
                      content => 'setPadding'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'padding',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickLabelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the font of the tick labels.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a04ba16e1f6f78d70f938519576ed32c8',
                      content => 'setTickLabels'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a395e445c3fe496b935bee7b911ecfd1c',
                      content => 'setTickLabelColor'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'font',
                type => 'const QFont &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickLabelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the color of the tick labels.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a04ba16e1f6f78d70f938519576ed32c8',
                      content => 'setTickLabels'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a2b8690c4e8dbc39d9185d2b398ce7a6c',
                      content => 'setTickLabelFont'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'color',
                type => 'const QColor &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickLabelRotation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the rotation of the tick labels. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'degrees'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is zero, the labels are drawn normally. Else, the tick labels are drawn rotated by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'degrees'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' clockwise. The specified angle is bound to values from -90 to 90 degrees.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'degrees'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is exactly -90, 0 or 90, the tick labels are centered on the tick coordinate. For other angles, the label is drawn with an offset such that it seems to point toward or away from the tick mark. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'degrees',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickLabelSide',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the tick labels (numbers) shall appear inside or outside the axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The usual and default setting is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'lsOutside'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. Very compact plots sometimes require tick labels to be inside the axis rect, to save space. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'side'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'lsInside'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the tick labels appear on the inside are additionally clipped to the axis rect. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'side',
                type => 'LabelSide'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setNumberFormat',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the number format for the numbers in tick labels. This '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatCode'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an extended version of the format code used e.g. by QString::number() and QLocale::toString(). For reference about that, see the "Argument Formats" section in the detailed description of the QString class.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatCode'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a string of one, two or three characters. The first character is identical to the normal format code used by Qt. In short, this means: \'e\'/\'E\' scientific format, \'f\' fixed format, \'g\'/\'G\' scientific or fixed, whichever is shorter.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The second and third characters are optional and specific to '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ':'
                },
                {
                  type => 'linebreak'
                },
                {
                  type => 'text',
                  content => 'If the first char was \'e\' or \'g\', numbers are/might be displayed in the scientific format, e.g. "5.5e9", which is ugly in a plot. So when the second char of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatCode'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to \'b\' (for "beautiful"), those exponential numbers are formatted in a more natural way, i.e. "5.5
[multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot. If instead a cross should be shown (as is usual in the USA), the third char of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatCode'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' can be set to \'c\'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the cross and 183 (0xB7) for the dot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Examples for '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatCode:'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' '
                },
                {
                  type => 'list',
                  style => 'itemized',
                  content => [
                    [
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'yes'
                      },
                      {
                        type => 'text',
                        content => 'g'
                      },
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'no'
                      },
                      {
                        type => 'text',
                        content => ' normal format code behaviour. If number is small, fixed format is used, if number is large, normal scientific format is used '
                      }
                    ],
                    [
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'yes'
                      },
                      {
                        type => 'text',
                        content => 'gb'
                      },
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'no'
                      },
                      {
                        type => 'text',
                        content => ' If number is small, fixed format is used, if number is large, scientific format is used with beautifully typeset decimal powers and a dot as multiplication sign '
                      }
                    ],
                    [
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'yes'
                      },
                      {
                        type => 'text',
                        content => 'ebc'
                      },
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'no'
                      },
                      {
                        type => 'text',
                        content => ' All numbers are in scientific format with beautifully typeset decimal power and a cross as multiplication sign '
                      }
                    ],
                    [
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'yes'
                      },
                      {
                        type => 'text',
                        content => 'fb'
                      },
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'no'
                      },
                      {
                        type => 'text',
                        content => ' illegal format code, since fixed format doesn\'t support (or need) beautifully typeset decimal powers. Format code will be reduced to \'f\'. '
                      }
                    ],
                    [
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'yes'
                      },
                      {
                        type => 'text',
                        content => 'hello'
                      },
                      {
                        type => 'style',
                        style => 'code',
                        enable => 'no'
                      },
                      {
                        type => 'text',
                        content => ' illegal format code, since first char is not \'e\', \'E\', \'f\', \'g\' or \'G\'. Current format code will not be changed. '
                      }
                    ]
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'formatCode',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setNumberPrecision',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the precision of the tick label numbers. See QLocale::toString(double i, char f, int prec) for details. The effect of precisions are most notably for number Formats starting with \'e\', see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setNumberFormat'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickLength',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the length of the ticks in pixels. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is the length the ticks will reach inside the plot and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'outside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is the length they will reach outside the plot. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'outside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is greater than zero, the tick labels and axis label will increase their distance to the axis accordingly, so they won\'t collide with the ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab702d6fd42fc620607435339a1c2a2e1',
                      content => 'setSubTickLength'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1afae1a37a99611366275a51204d991739',
                      content => 'setTickLengthIn'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a3b8a0debd1ffedd2c22d0592dfbb4e62',
                      content => 'setTickLengthOut'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'inside',
                type => 'int'
              },
              {
                declaration_name => 'outside',
                type => 'int',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickLengthIn',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the length of the inward ticks in pixels. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is the length the ticks will reach inside the plot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a3b8a0debd1ffedd2c22d0592dfbb4e62',
                      content => 'setTickLengthOut'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a62ec40bebe3540e9c1479a8fd2be3b0d',
                      content => 'setTickLength'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab702d6fd42fc620607435339a1c2a2e1',
                      content => 'setSubTickLength'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'inside',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickLengthOut',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the length of the outward ticks in pixels. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'outside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is the length the ticks will reach outside the plot. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'outside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is greater than zero, the tick labels and axis label will increase their distance to the axis accordingly, so they won\'t collide with the ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1afae1a37a99611366275a51204d991739',
                      content => 'setTickLengthIn'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a62ec40bebe3540e9c1479a8fd2be3b0d',
                      content => 'setTickLength'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab702d6fd42fc620607435339a1c2a2e1',
                      content => 'setSubTickLength'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'outside',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSubTicks',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether sub tick marks are displayed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sub ticks are only potentially visible if (major) ticks are also visible (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTicks'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ')'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ac891409315bc379e3b1abdb162c1a011',
                      content => 'setTicks'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'show',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSubTickLength',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the length of the subticks in pixels. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is the length the subticks will reach inside the plot and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'outside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is the length they will reach outside the plot. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'outside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is greater than zero, the tick labels and axis label will increase their distance to the axis accordingly, so they won\'t collide with the ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a62ec40bebe3540e9c1479a8fd2be3b0d',
                      content => 'setTickLength'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ac46fa2a993a9f5789540977610acf1de',
                      content => 'setSubTickLengthIn'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a4c6dfc3963492ed72a77724012df5f23',
                      content => 'setSubTickLengthOut'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'inside',
                type => 'int'
              },
              {
                declaration_name => 'outside',
                type => 'int',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSubTickLengthIn',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the length of the inward subticks in pixels. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is the length the subticks will reach inside the plot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a4c6dfc3963492ed72a77724012df5f23',
                      content => 'setSubTickLengthOut'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab702d6fd42fc620607435339a1c2a2e1',
                      content => 'setSubTickLength'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a62ec40bebe3540e9c1479a8fd2be3b0d',
                      content => 'setTickLength'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'inside',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSubTickLengthOut',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the length of the outward subticks in pixels. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'outside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is the length the subticks will reach outside the plot. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'outside'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is greater than zero, the tick labels will increase their distance to the axis accordingly, so they won\'t collide with the ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ac46fa2a993a9f5789540977610acf1de',
                      content => 'setSubTickLengthIn'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab702d6fd42fc620607435339a1c2a2e1',
                      content => 'setSubTickLength'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a62ec40bebe3540e9c1479a8fd2be3b0d',
                      content => 'setTickLength'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'outside',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBasePen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the pen, the axis base line is drawn with.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ad80923bcc1c5da4c4db602c5325e797e',
                      content => 'setTickPen'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1aede4028ae7516bd51a60618a8233f9cf',
                      content => 'setSubTickPen'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the pen, tick marks will be drawn with.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a62ec40bebe3540e9c1479a8fd2be3b0d',
                      content => 'setTickLength'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a778d45fb71b3c7ab3bb7079e18b058e4',
                      content => 'setBasePen'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSubTickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the pen, subtick marks will be drawn with.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'text',
                      content => 'setSubTickCount, '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab702d6fd42fc620607435339a1c2a2e1',
                      content => 'setSubTickLength'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a778d45fb71b3c7ab3bb7079e18b058e4',
                      content => 'setBasePen'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLabelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the font of the axis label.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a6c906fe56d75f0122335b9f79b999608',
                      content => 'setLabelColor'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'font',
                type => 'const QFont &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLabelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the color of the axis label.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a71ac1a47f7547e490a8c4311d1433cf3',
                      content => 'setLabelFont'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'color',
                type => 'const QColor &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLabel',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the text of the axis label that will be shown below/above or next to the axis, depending on its orientation. To disable axis labels, pass an empty string as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'str'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'str',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLabelPadding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the distance between the tick labels and the axis label.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af302c479af9dbc2e9f0e44e07c0012ee',
                      content => 'setTickLabelPadding'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a5691441cb3de9e9844855d339c0db279',
                      content => 'setPadding'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'padding',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setPadding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the padding of the axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisRect::setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is enabled, the padding is the additional outer most space, that is left blank.The axis padding has no meaning if '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisRect::setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is disabled.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a4391192a766e5d20cfe5cbc17607a7a2',
                      content => 'setLabelPadding'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af302c479af9dbc2e9f0e44e07c0012ee',
                      content => 'setTickLabelPadding'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'padding',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setOffset',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the offset the axis has to its axis rect side.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If an axis rect side has multiple axes and automatic margin calculation is enabled for that side, only the offset of the inner most axis has meaning (even if it is set to be invisible). The offset of the other, outer axes is controlled automatically, to place them at appropriate positions. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'offset',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedTickLabelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the font that is used for tick labels when they are selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a2b8690c4e8dbc39d9185d2b398ce7a6c',
                      content => 'setTickLabelFont'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'font',
                type => 'const QFont &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedLabelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the font that is used for the axis label when it is selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a71ac1a47f7547e490a8c4311d1433cf3',
                      content => 'setLabelFont'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'font',
                type => 'const QFont &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedTickLabelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the color that is used for tick labels when they are selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a395e445c3fe496b935bee7b911ecfd1c',
                      content => 'setTickLabelColor'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'color',
                type => 'const QColor &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedLabelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the color that is used for the axis label when it is selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a6c906fe56d75f0122335b9f79b999608',
                      content => 'setLabelColor'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'color',
                type => 'const QColor &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedBasePen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the pen that is used to draw the axis base line when selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a778d45fb71b3c7ab3bb7079e18b058e4',
                      content => 'setBasePen'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedTickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the pen that is used to draw the (major) ticks when selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ad80923bcc1c5da4c4db602c5325e797e',
                      content => 'setTickPen'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedSubTickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the pen that is used to draw the subticks when selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1aede4028ae7516bd51a60618a8233f9cf',
                      content => 'setSubTickPen'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectableParts',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether the user can (de-)select the parts in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' by clicking on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface. (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains iSelectAxes.)However, even when '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to a value not allowing the selection of a specific part, it is still possible to set the selection of this part manually, by calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectedParts'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' directly.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1abee4c7a54c468b1385dfce2c898b115f',
                      content => 'SelectablePart'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectableParts',
                type => 'const QCPAxis::SelectableParts &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectedParts',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the selected state of the respective axis parts described by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. When a part is selected, it uses a different pen/font.The entire selection mechanism for axes is handled automatically when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains iSelectAxes. You only need to call this function when you wish to change the selection state manually.This function can change the selection state of a part, independent of the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectableParts'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' setting.emits the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionChanged'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' signal when '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is different from the previous selection state.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1abee4c7a54c468b1385dfce2c898b115f',
                      content => 'SelectablePart'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a63b7103c57fe9acfbce164334ea837f8',
                      content => 'selectTest'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1aeb917a909215605b95ef2be843de1ee8',
                      content => 'setSelectedBasePen'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a8360502685eb782edbf04019c9345cdc',
                      content => 'setSelectedTickPen'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a2a00a7166600155eac26843132eb9576',
                      content => 'setSelectedSubTickPen'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a845ccb560b7bc5281098a5be494145f6',
                      content => 'setSelectedTickLabelFont'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a02ec2a75d4d8401eaab834fbc6803d30',
                      content => 'setSelectedLabelFont'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a9bdbf5e63ab15187f3a1de9440129227',
                      content => 'setSelectedTickLabelColor'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a5d502dec597c634f491fdd73d151c72d',
                      content => 'setSelectedLabelColor'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectedParts',
                type => 'const QCPAxis::SelectableParts &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLowerEnding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the style for the lower axis ending. See the documentation of '
                },
                {
                  type => 'url',
                  link => 'classQCPLineEnding',
                  content => 'QCPLineEnding'
                },
                {
                  type => 'text',
                  content => ' for available styles.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For horizontal axes, this method refers to the left ending, for vertical axes the bottom ending. Note that this meaning does not change when the axis range is reversed with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeReversed'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a69119b892fc306f651763596685aa377',
                      content => 'setUpperEnding'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ending',
                type => 'const QCPLineEnding &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setUpperEnding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the style for the upper axis ending. See the documentation of '
                },
                {
                  type => 'url',
                  link => 'classQCPLineEnding',
                  content => 'QCPLineEnding'
                },
                {
                  type => 'text',
                  content => ' for available styles.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For horizontal axes, this method refers to the right ending, for vertical axes the top ending. Note that this meaning does not change when the axis range is reversed with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeReversed'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a08af1c72db9ae4dc8cb8a973d44405ab',
                      content => 'setLowerEnding'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ending',
                type => 'const QCPLineEnding &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This function is used to decide whether a click hits a layerable object or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a point in pixel coordinates on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn\'t be determined, -1.0 is returned. Further, if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlySelectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true and the object is not selectable, -1.0 is returned, too.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the object is represented not by single lines but by an area like a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPItemText'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or the bars of a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot\'s selection tolerance. (typically the selectionTolerance multiplied by 0.99).Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The actual setting of the selection state is not done by this function. This is handled by the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' when the mouseReleaseEvent occurs, and the finally selected object is notified via the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '/'
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'deselectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' methods.'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an optional output parameter. Every layerable subclass may place any information in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This information will be passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' will carry the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This is useful for multi-part objects (like '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => '). This way, a possibly complex calculation to decide which part was clicked is only done once in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The result (i.e. the actually clicked part) can then be placed in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. So in the subsequent '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the decision which part was selected doesn\'t have to be done a second time for a single selection operation.You may pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to indicate that you are not interested in those selection details.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a50c3ed18e189d48421ec2978f88e4f87',
                      content => 'selectEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a5bc1f8a8d0fbc7658eba70c80279ed31',
                      content => 'deselectEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ac89c068873ee9197a5d2af715bdc1105',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a71643d27524a843230b5ba68085b3d9b',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            }
          },
          {
            kind => 'function',
            name => 'orientation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the orientation of this axis. The axis orientation (horizontal or vertical) is deduced from the axis type (left, top, right or bottom).'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a9a68b3e45f1b1e33d4d807822342516c',
                      content => 'orientation(AxisType type)'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a45c45bed7e5666683b8d56afa66fa51f',
                      content => 'pixelOrientation'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Qt::Orientation',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'pixelOrientation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns which direction points towards higher coordinate values/keys, in pixel space.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method returns either 1 or -1. If it returns 1, then going in the positive direction along the orientation of the axis in pixels corresponds to going from lower to higher axis coordinates. On the other hand, if this method returns -1, going to smaller pixel values corresponds to going from lower to higher axis coordinates.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, this is useful to easily shift axis coordinates by a certain amount given in pixels, without having to care about reversed or vertically aligned axes:'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'preformatted',
                  content => 'double newKey = keyAxis->pixelToCoord(keyAxis->coordToPixel(oldKey)+10*keyAxis->pixelOrientation());'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'newKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will then contain a key that is ten pixels towards higher keys, starting from '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'oldKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'moveRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the scale type ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setScaleType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'stLinear'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'diff'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is added to the lower and upper bounds of the range. The range is simply moved by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'diff'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.If the scale type is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'stLogarithmic'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the range bounds are multiplied by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'diff'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This corresponds to an apparent "linear" move in logarithmic scaling by a distance of log(diff). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'diff',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'scaleRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Scales the range of this axis by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'factor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' around the center of the current axis range. For example, if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'factor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 2.0, then the axis range will double its size, and the point at the axis range center won\'t have changed its position in the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget (i.e. coordinates around the center will have moved symmetrically closer).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If you wish to scale around a different coordinate than the current axis range center, use the overload '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'scaleRange(double factor, double center)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'factor',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'scaleRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Scales the range of this axis by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'factor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' around the coordinate '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'center'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. For example, if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'factor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 2.0, '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'center'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 1.0, then the axis range will double its size, and the point at coordinate 1.0 won\'t have changed its position in the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget (i.e. coordinates around 1.0 will have moved symmetrically closer to 1.0).'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a31d18ddf3a4f21ceb077db8ae5b69856',
                      content => 'scaleRange(double factor)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'factor',
                type => 'double'
              },
              {
                declaration_name => 'center',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setScaleRatio',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Scales the range of this axis to have a certain scale '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ratio'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'otherAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The scaling will be done around the center of the current axis range.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ratio'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 1, this axis is the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'yAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'otherAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'xAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', graphs plotted with those axes will appear in a 1:1 aspect ratio, independent of the aspect ratio the axis rect has.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This is an operation that changes the range of this axis once, it doesn\'t fix the scale ratio indefinitely. Note that calling this function in the constructor of the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '\'s parent won\'t have the desired effect, since the widget dimensions aren\'t defined yet, and a resizeEvent will follow. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'otherAxis',
                type => 'const QCPAxis *'
              },
              {
                declaration_name => 'ratio',
                type => 'double',
                default_value => '1.0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescale',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Changes the axis range such that all plottables associated with this axis are fully visible in that dimension.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a1491c4a606bccd2d09e65e11b79eb882',
                      content => 'QCPAbstractPlottable::rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1ad86528f2cee6c7e446dea4a6e8839935',
                      content => 'QCustomPlot::rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyVisiblePlottables',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pixelToCoord',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Transforms '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', in pixel coordinates of the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget, to axis coordinates. '
                }
              ]
            },
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'coordToPixel',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Transforms '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', in coordinates of the axis, to pixel coordinates of the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget. '
                }
              ]
            },
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getPartAt',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the part of the axis that is hit by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' (in pixels). The return value of this function is independent of the user-selectable parts defined with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectableParts'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. Further, this function does not change the current selection state of the axis.If the axis is not visible ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setVisible'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function always returns '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'spNone'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab9d7a69277dcbed9119b3c1f25ca19c3',
                      content => 'setSelectedParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a513f9b9e326c505d9bec54880031b085',
                      content => 'setSelectableParts'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'SelectablePart',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'plottables',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all the plottables that have this axis as key or value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If you are only interested in plottables of type '
                },
                {
                  type => 'url',
                  link => 'classQCPGraph',
                  content => 'QCPGraph'
                },
                {
                  type => 'text',
                  content => ', see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'graphs'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ad590c0da223697a2727f97a520870fec',
                      content => 'graphs'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a42761bc68e2f3a9f68549d45b73f705b',
                      content => 'items'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAbstractPlottable * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'graphs',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all the graphs that have this axis as key or value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ac5e0f6f65c75efb5fd32275d6e4ef0d6',
                      content => 'plottables'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a42761bc68e2f3a9f68549d45b73f705b',
                      content => 'items'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPGraph * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'items',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all the items that are associated with this axis. An item is considered associated with an axis if at least one of its positions uses the axis as key or value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ac5e0f6f65c75efb5fd32275d6e4ef0d6',
                      content => 'plottables'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ad590c0da223697a2727f97a520870fec',
                      content => 'graphs'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAbstractItem * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'rangeChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the range of this axis has changed. You can connect it to the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' slot of another axis to communicate the new range to the other axis, in order for it to be synchronized.You may also manipulate/correct the range with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in a slot connected to this signal. This is useful if for example a maximum range span shall not be exceeded, or if the lower/upper range shouldn\'t go beyond certain values (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::bounded'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). For example, the following slot would limit the x axis to ranges between 0 and 10: '
                },
                {
                  type => 'preformatted',
                  content => 'customPlot->xAxis->setRange(newRange.bounded(0, 10))'
                },
                {
                  type => 'text',
                  content => ' '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'rangeChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Additionally to the new range, this signal also provides the previous range held by the axis as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'oldRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newRange',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'oldRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'scaleTypeChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the scale type changes, by calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setScaleType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'scaleType',
                type => 'QCPAxis::ScaleType'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this axis has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectedParts'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parts',
                type => 'const QCPAxis::SelectableParts &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectableChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the selectability changes, by calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectableParts'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parts',
                type => 'const QCPAxis::SelectableParts &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      public_static_methods => {
        members => [
          {
            kind => 'function',
            name => 'marginSideToAxisType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'yes',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Transforms a margin side to the logically corresponding axis type. ('
                },
                {
                  type => 'url',
                  link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54a9500c8bfcc9e80b9dff0a8e00e867f07',
                  content => 'QCP::msLeft'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1ae2bcc1728b382f10f064612b368bc18aaf84aa6cac6fb6099f54a2cbf7546b730',
                  content => 'QCPAxis::atLeft'
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'url',
                  link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54a93c719593bb2b94ed244d52c86d83b65',
                  content => 'QCP::msRight'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1ae2bcc1728b382f10f064612b368bc18aadf5509f7d29199ef2f263b1dd224b345',
                  content => 'QCPAxis::atRight'
                },
                {
                  type => 'text',
                  content => ', etc.) '
                }
              ]
            },
            type => 'static AxisType',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'side',
                type => 'QCP::MarginSide'
              }
            ]
          },
          {
            kind => 'function',
            name => 'orientation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'yes',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the orientation of the specified axis type'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ab988ef4538e2655bb77bd138189cd42e',
                      content => 'orientation()'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a45c45bed7e5666683b8d56afa66fa51f',
                      content => 'pixelOrientation'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'static Qt::Orientation',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'AxisType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'opposite',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'yes',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the axis type that describes the opposite axis of an axis with the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'static AxisType',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'AxisType'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'calculateMargin',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'applyDefaultAntialiasingHint',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'applyDefaultAntialiasingHint'
            }
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'draw'
            }
          },
          {
            kind => 'function',
            name => 'selectionCategory',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QCP::Interaction',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'selectionCategory'
            }
          },
          {
            kind => 'function',
            name => 'selectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'additive',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              },
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'selectEvent'
            }
          },
          {
            kind => 'function',
            name => 'deselectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'deselectEvent'
            }
          },
          {
            kind => 'function',
            name => 'mousePressEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).'
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' uses an event propagation system that works the same as Qt\'s system. If your layerable doesn\'t reimplement the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or explicitly calls '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in its reimplementation, the event will be propagated to the next layerable in the stacking order.Once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a2a89a13440eec099fc2327c2672be0cd',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a35663b938ad83e91c0b8e59dbc8c6b18',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a71643d27524a843230b5ba68085b3d9b',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplements => {
              name => 'mousePressEvent'
            }
          },
          {
            kind => 'function',
            name => 'mouseMoveEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ac89c068873ee9197a5d2af715bdc1105',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a35663b938ad83e91c0b8e59dbc8c6b18',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a71643d27524a843230b5ba68085b3d9b',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplements => {
              name => 'mouseMoveEvent'
            }
          },
          {
            kind => 'function',
            name => 'mouseReleaseEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ac89c068873ee9197a5d2af715bdc1105',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a2a89a13440eec099fc2327c2672be0cd',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a71643d27524a843230b5ba68085b3d9b',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplements => {
              name => 'mouseReleaseEvent'
            }
          },
          {
            kind => 'function',
            name => 'wheelEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxis_1ac89c068873ee9197a5d2af715bdc1105',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a2a89a13440eec099fc2327c2672be0cd',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a35663b938ad83e91c0b8e59dbc8c6b18',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QWheelEvent *'
              }
            ],
            reimplements => {
              name => 'wheelEvent'
            }
          },
          {
            kind => 'function',
            name => 'setupTickVectors',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'getBasePen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'getTickPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'getSubTickPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'getTickLabelFont',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'getLabelFont',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'getTickLabelColor',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'getLabelColor',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlotInitialized',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ],
            reimplemented_by => [
              {
                name => 'parentPlotInitialized'
              },
              {
                name => 'parentPlotInitialized'
              }
            ]
          },
          {
            kind => 'function',
            name => 'clipRect',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'clipRect'
              },
              {
                name => 'clipRect'
              },
              {
                name => 'clipRect'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseDoubleClickEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called instead of the second '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. So in the case of a double-click, the event succession is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pressEvent - releaseEvent - doubleClickEvent - releaseEvent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).Similarly to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseDoubleClickEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'initializeParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentLayerable',
                type => 'QCPLayerable *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveToLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              },
              {
                declaration_name => 'prepend',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'localAntialiased',
                type => 'bool'
              },
              {
                declaration_name => 'overrideElement',
                type => 'QCP::AntialiasedElement'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mAxisType',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'AxisType'
          },
          {
            kind => 'variable',
            name => 'mAxisRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxisRect *'
          },
          {
            kind => 'variable',
            name => 'mPadding',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mOrientation',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::Orientation'
          },
          {
            kind => 'variable',
            name => 'mSelectableParts',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SelectableParts'
          },
          {
            kind => 'variable',
            name => 'mSelectedParts',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SelectableParts'
          },
          {
            kind => 'variable',
            name => 'mBasePen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mSelectedBasePen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mLabel',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString'
          },
          {
            kind => 'variable',
            name => 'mLabelFont',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont'
          },
          {
            kind => 'variable',
            name => 'mSelectedLabelFont',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont'
          },
          {
            kind => 'variable',
            name => 'mLabelColor',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor'
          },
          {
            kind => 'variable',
            name => 'mSelectedLabelColor',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor'
          },
          {
            kind => 'variable',
            name => 'mTickLabels',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mTickLabelFont',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont'
          },
          {
            kind => 'variable',
            name => 'mSelectedTickLabelFont',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont'
          },
          {
            kind => 'variable',
            name => 'mTickLabelColor',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor'
          },
          {
            kind => 'variable',
            name => 'mSelectedTickLabelColor',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor'
          },
          {
            kind => 'variable',
            name => 'mNumberPrecision',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mNumberFormatChar',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QLatin1Char'
          },
          {
            kind => 'variable',
            name => 'mNumberBeautifulPowers',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mSubTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mTickPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mSelectedTickPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mSubTickPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mSelectedSubTickPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mRange',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange'
          },
          {
            kind => 'variable',
            name => 'mRangeReversed',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mScaleType',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'ScaleType'
          },
          {
            kind => 'variable',
            name => 'mGrid',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPGrid *'
          },
          {
            kind => 'variable',
            name => 'mAxisPainter',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxisPainterPrivate *'
          },
          {
            kind => 'variable',
            name => 'mTicker',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSharedPointer< QCPAxisTicker >'
          },
          {
            kind => 'variable',
            name => 'mTickVector',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QVector< double >'
          },
          {
            kind => 'variable',
            name => 'mTickVectorLabels',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QVector< QString >'
          },
          {
            kind => 'variable',
            name => 'mSubTickVector',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QVector< double >'
          },
          {
            kind => 'variable',
            name => 'mCachedMarginValid',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mCachedMargin',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mDragging',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mDragStartRange',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange'
          },
          {
            kind => 'variable',
            name => 'mAADragBackup',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::AntialiasedElements'
          },
          {
            kind => 'variable',
            name => 'mNotAADragBackup',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::AntialiasedElements'
          },
          {
            kind => 'variable',
            name => 'mVisible',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPLayerable >'
          },
          {
            kind => 'variable',
            name => 'mLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *'
          },
          {
            kind => 'variable',
            name => 'mAntialiased',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCustomPlot',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'friend',
            name => 'QCPGrid',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'friend',
            name => 'QCPAxisRect',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Manages a single axis inside a '
          },
          {
            type => 'url',
            link => 'classQCustomPlot',
            content => 'QCustomPlot'
          },
          {
            type => 'text',
            content => '. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Usually doesn\'t need to be instantiated externally. Access QCustomPlot\'s default four axes via '
          },
          {
            type => 'url',
            link => 'classQCustomPlot_1a9a79cd0158a4c7f30cbc702f0fd800e4',
            content => 'QCustomPlot::xAxis'
          },
          {
            type => 'text',
            content => ' (bottom), '
          },
          {
            type => 'url',
            link => 'classQCustomPlot_1af6fea5679725b152c14facd920b19367',
            content => 'QCustomPlot::yAxis'
          },
          {
            type => 'text',
            content => ' (left), '
          },
          {
            type => 'url',
            link => 'classQCustomPlot_1ada41599f22cad901c030f3dcbdd82fd9',
            content => 'QCustomPlot::xAxis2'
          },
          {
            type => 'text',
            content => ' (top) and '
          },
          {
            type => 'url',
            link => 'classQCustomPlot_1af13fdc5bce7d0fabd640f13ba805c0b7',
            content => 'QCustomPlot::yAxis2'
          },
          {
            type => 'text',
            content => ' (right).'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Axes are always part of an axis rect, see '
          },
          {
            type => 'url',
            link => 'classQCPAxisRect',
            content => 'QCPAxisRect'
          },
          {
            type => 'text',
            content => '.  '
          },
          {
            type => 'style',
            style => 'center',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'Naming convention of axis parts'
          },
          {
            type => 'style',
            style => 'center',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' '
          },
          {
            type => 'linebreak'
          },
          {
            type => 'text',
            content => '  '
          },
          {
            type => 'style',
            style => 'center',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'Overview of the spacings and paddings that define the geometry of an axis. The dashed gray line on the left represents the '
          },
          {
            type => 'url',
            link => 'classQCustomPlot',
            content => 'QCustomPlot'
          },
          {
            type => 'text',
            content => ' widget border.'
          },
          {
            type => 'style',
            style => 'center',
            enable => 'no'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Each axis holds an instance of '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => ' which is used to generate the tick coordinates and tick labels. You can access the currently installed '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'ticker'
              }
            ]
          },
          {
            type => 'text',
            content => ' or set a new one (possibly one of the specialized subclasses, or your own subclass) via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setTicker'
              }
            ]
          },
          {
            type => 'text',
            content => '. For details, see the documentation of '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => '. '
          }
        ]
      }
    },
    {
      name => 'QCPAxisPainterPrivate',
      inner => [
        {
          name => 'QCPAxisPainterPrivate::CachedLabel'
        },
        {
          name => 'QCPAxisPainterPrivate::TickLabelData'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'abbreviateDecimalPowers',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'axisRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'axisSelectionBox',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'basePen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'clearCache',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'draw',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'drawTickLabel',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'generateLabelParameterHash',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'getMaxTickLabelSize',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'getTickLabelData',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'getTickLabelDrawOffset',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'label',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'labelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'labelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'labelPadding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'labelSelectionBox',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'lowerEnding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'mAxisSelectionBox',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'mLabelCache',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'mLabelParameterHash',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'mLabelSelectionBox',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'mTickLabelsSelectionBox',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'numberMultiplyCross',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'offset',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'placeTickLabel',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'QCPAxisPainterPrivate',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'reversedEndings',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'size',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'substituteExponent',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'subTickLengthIn',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'subTickLengthOut',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'subTickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'subTickPositions',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickLabelColor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickLabelFont',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickLabelPadding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickLabelRotation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickLabels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickLabelSide',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickLabelsSelectionBox',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickLengthIn',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickLengthOut',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'tickPositions',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'type',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'upperEnding',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => 'viewportRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        },
        {
          name => '~QCPAxisPainterPrivate',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisPainterPrivate'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxisPainterPrivate',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisPainterPrivate',
                  content => 'QCPAxisPainterPrivate'
                },
                {
                  type => 'text',
                  content => ' instance. Make sure to not create a new instance on every redraw, to utilize the caching mechanisms. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPAxisPainterPrivate',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'size',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'clearCache',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'axisSelectionBox',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickLabelsSelectionBox',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'labelSelectionBox',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      public_members => {
        members => [
          {
            kind => 'variable',
            name => 'type',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis::AxisType'
          },
          {
            kind => 'variable',
            name => 'basePen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'lowerEnding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLineEnding'
          },
          {
            kind => 'variable',
            name => 'upperEnding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLineEnding'
          },
          {
            kind => 'variable',
            name => 'labelPadding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'labelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont'
          },
          {
            kind => 'variable',
            name => 'labelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor'
          },
          {
            kind => 'variable',
            name => 'label',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString'
          },
          {
            kind => 'variable',
            name => 'tickLabelPadding',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'tickLabelRotation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'tickLabelSide',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis::LabelSide'
          },
          {
            kind => 'variable',
            name => 'substituteExponent',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'numberMultiplyCross',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'tickLengthIn',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'tickLengthOut',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'subTickLengthIn',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'subTickLengthOut',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'tickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'subTickPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'tickLabelFont',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QFont'
          },
          {
            kind => 'variable',
            name => 'tickLabelColor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QColor'
          },
          {
            kind => 'variable',
            name => 'axisRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'viewportRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'offset',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'abbreviateDecimalPowers',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'reversedEndings',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'subTickPositions',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QVector< double >'
          },
          {
            kind => 'variable',
            name => 'tickPositions',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QVector< double >'
          },
          {
            kind => 'variable',
            name => 'tickLabels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QVector< QString >'
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'generateLabelParameterHash',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QByteArray',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'placeTickLabel',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'position',
                type => 'double'
              },
              {
                declaration_name => 'distanceToAxis',
                type => 'int'
              },
              {
                declaration_name => 'text',
                type => 'const QString &'
              },
              {
                declaration_name => 'tickLabelsSize',
                type => 'QSize *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'drawTickLabel',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'x',
                type => 'double'
              },
              {
                declaration_name => 'y',
                type => 'double'
              },
              {
                declaration_name => 'labelData',
                type => 'const TickLabelData &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getTickLabelData',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual TickLabelData',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'font',
                type => 'const QFont &'
              },
              {
                declaration_name => 'text',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getTickLabelDrawOffset',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QPointF',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'labelData',
                type => 'const TickLabelData &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getMaxTickLabelSize',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'font',
                type => 'const QFont &'
              },
              {
                declaration_name => 'text',
                type => 'const QString &'
              },
              {
                declaration_name => 'tickLabelsSize',
                type => 'QSize *'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mLabelParameterHash',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QByteArray'
          },
          {
            kind => 'variable',
            name => 'mLabelCache',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCache< QString, CachedLabel >'
          },
          {
            kind => 'variable',
            name => 'mAxisSelectionBox',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'mTickLabelsSelectionBox',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'mLabelSelectionBox',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          }
        ]
      },
      brief => {},
      detailed => {}
    },
    {
      name => 'QCPAxisRect',
      base => [
        {
          name => 'QCPLayoutElement',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      derived => [
        {
          name => 'QCPColorScaleAxisRectPrivate',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'addAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'addAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'autoMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'axes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'axes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'axis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'axisCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'background',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'backgroundBrush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'backgroundScaled',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'backgroundScaledMode',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'bottom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'bottomLeft',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'bottomRight',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'calculateAutoMargin',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'center',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'draw',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'drawBackground',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'elements',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'graphs',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'height',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'insetLayout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'items',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'layoutChanged',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'left',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mAADragBackup',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'marginGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'marginGroups',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'margins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mAutoMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mAxes',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'maximumOuterSizeHint',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'maximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mBackgroundBrush',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mBackgroundPixmap',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mBackgroundScaled',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mBackgroundScaledMode',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mDragging',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mDragStartHorzRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mDragStartVertRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'minimumMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'minimumOuterSizeHint',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'minimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mInsetLayout',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mMarginGroups',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMaximumSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMinimumMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMinimumSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mNotAADragBackup',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mOuterRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayout',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mRangeDrag',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeDragHorzAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeDragVertAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoom',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoomFactorHorz',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoomFactorVert',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoomHorzAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoomVertAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mScaledBackgroundPixmap',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mSizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'outerRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'plottables',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'QCPAxisRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'QCPLayoutElement',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'QCustomPlot',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeDrag',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeDragAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeDragAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeZoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeZoomAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeZoomAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeZoomFactor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'rect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'removeAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'right',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'scrInnerRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'scrOuterRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'selectTest',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setAutoMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setBackground',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setBackground',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setBackground',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setBackgroundScaled',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setBackgroundScaledMode',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setMarginGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMaximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMaximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setOuterRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setRangeDrag',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeDragAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeDragAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeDragAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomFactor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomFactor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setSizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setupFullAxesBox',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'size',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'SizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'sizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'top',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'topLeft',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'topRight',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'update',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'updateAxesOffset',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'UpdatePhase',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upLayout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upPreparation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'width',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'zoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'zoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => '~QCPAxisRect',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPLayoutElement',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'UpdatePhase',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the phases of the update process, that happens just before a replot. At each phase, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'update'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called with the according UpdatePhase value. '
                }
              ]
            },
            values => [
              {
                name => 'upPreparation',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Phase used for any type of preparation that needs to be done before margin calculation and layout. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'upMargins',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Phase in which the margins are calculated and set. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'upLayout',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Final phase in which the layout system places the rects of the elements. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enum',
            name => 'SizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines to which rect of a layout element the size constraints that can be set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' apply. The outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') includes the margins (e.g. in the case of a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => ' the axis labels), whereas the inner rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') does not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a361666cdcc6fbfd37344cc44be746b0f',
                      content => 'setSizeConstraintRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'scrInnerRect',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Minimum/Maximum size constraints apply to inner rect. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'scrOuterRect',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'upPreparation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Phase used for any type of preparation that needs to be done before margin calculation and layout. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'upMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Phase in which the margins are calculated and set. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'upLayout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Final phase in which the layout system places the rects of the elements. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'scrInnerRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Minimum/Maximum size constraints apply to inner rect. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'scrOuterRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxisRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Creates a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => ' instance and sets default values. An axis is added for each of the four sides, the top and right axes are set invisible initially. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              },
              {
                declaration_name => 'setupDefaultAxes',
                type => 'bool',
                default_value => 'true'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPAxisRect',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'background',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPixmap',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'backgroundBrush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'backgroundScaled',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'backgroundScaledMode',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::AspectRatioMode',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rangeDrag',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::Orientations',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rangeZoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::Orientations',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rangeDragAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the range drag axis of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided. If multiple axes were set, returns the first one (use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rangeDragAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to retrieve a list with all set axes).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a648cce336bd99daac4a5ca3e5743775d',
                      content => 'setRangeDragAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPAxis *',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rangeZoomAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the range zoom axis of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided. If multiple axes were set, returns the first one (use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rangeZoomAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to retrieve a list with all set axes).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9442cca2aa358405f39a64d51eca13d2',
                      content => 'setRangeZoomAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPAxis *',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rangeDragAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all range drag axes of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a679c63f2b8daccfe6ec5110dce3dd3b6',
                      content => 'rangeZoomAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9442cca2aa358405f39a64d51eca13d2',
                      content => 'setRangeZoomAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rangeZoomAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all range zoom axes of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a6d7c22cfc54fac7a3d6ef80b133a8574',
                      content => 'rangeDragAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a648cce336bd99daac4a5ca3e5743775d',
                      content => 'setRangeDragAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rangeZoomFactor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the range zoom factor of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a895d7ac745ea614e04056244b3c138ac',
                      content => 'setRangeZoomFactor'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackground',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pm'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as the axis background pixmap. The axis background pixmap will be drawn inside the axis rect. Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds are usually drawn below everything else.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For cases where the provided pixmap doesn\'t have the same size as the axis rect, scaling can be enabled with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackgroundScaled'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and the scaling mode (i.e. whether and how the aspect ratio is preserved) can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackgroundScaledMode'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. To set all these options in one call, consider using the overloaded version of this function.Below the pixmap, the axis rect may be optionally filled with a brush, if specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackground(const QBrush &brush)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1ae6d36c3e0e968ffb991170a018e7b503',
                      content => 'setBackgroundScaled'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5ef77ea829c9de7ba248e473f48f7305',
                      content => 'setBackgroundScaledMode'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a22a22b8668735438dc06f9a55fe46b33',
                      content => 'setBackground(const QBrush &brush)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pm',
                type => 'const QPixmap &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackground',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Allows setting the background pixmap of the axis rect, whether it shall be scaled and how it shall be scaled in one call.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1af615ab5e52b8e0a9a0eff415b6559db5',
                      content => 'setBackground(const QPixmap &pm)'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1ae6d36c3e0e968ffb991170a018e7b503',
                      content => 'setBackgroundScaled'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5ef77ea829c9de7ba248e473f48f7305',
                      content => 'setBackgroundScaledMode'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pm',
                type => 'const QPixmap &'
              },
              {
                declaration_name => 'scaled',
                type => 'bool'
              },
              {
                declaration_name => 'mode',
                type => 'Qt::AspectRatioMode',
                default_value => 'Qt::KeepAspectRatioByExpanding'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackground',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'brush'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as the background brush. The axis rect background will be filled with this brush. Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds are usually drawn below everything else.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The brush will be drawn before (under) any background pixmap, which may be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackground(const QPixmap &pm)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.To disable drawing of a background brush, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'brush'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to Qt::NoBrush.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1af615ab5e52b8e0a9a0eff415b6559db5',
                      content => 'setBackground(const QPixmap &pm)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'brush',
                type => 'const QBrush &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackgroundScaled',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the axis background pixmap shall be scaled to fit the axis rect or not. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'scaled'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to true, you may control whether and how the aspect ratio of the original pixmap is preserved with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackgroundScaledMode'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Note that the scaled version of the original pixmap is buffered, so there is no performance penalty on replots. (Except when the axis rect dimensions are changed continuously.)'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1af615ab5e52b8e0a9a0eff415b6559db5',
                      content => 'setBackground'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5ef77ea829c9de7ba248e473f48f7305',
                      content => 'setBackgroundScaledMode'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'scaled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackgroundScaledMode',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'If scaling of the axis background pixmap is enabled ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackgroundScaled'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), use this function to define whether and how the aspect ratio of the original pixmap passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackground'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is preserved. '
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1af615ab5e52b8e0a9a0eff415b6559db5',
                      content => 'setBackground'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1ae6d36c3e0e968ffb991170a018e7b503',
                      content => 'setBackgroundScaled'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'mode',
                type => 'Qt::AspectRatioMode'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeDrag',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets which axis orientation may be range dragged by the user with mouse interaction. What orientation corresponds to which specific axis can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. By default, the horizontal axis is the bottom axis (xAxis) and the vertical axis is the left axis (yAxis).To disable range dragging entirely, pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' or remove '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeDrag'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' from '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. To enable range dragging for both directions, pass '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'Qt::Horizontal | Qt::Vertical'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.In addition to setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to a non-zero value, make sure '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeDrag'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to enable the range dragging interaction.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a7960a9d222f1c31d558b064b60f86a31',
                      content => 'setRangeZoom'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a648cce336bd99daac4a5ca3e5743775d',
                      content => 'setRangeDragAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a775bdcb6329d44701aeaa6135b0e5265',
                      content => 'QCustomPlot::setNoAntialiasingOnDrag'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientations',
                type => 'Qt::Orientations'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets which axis orientation may be zoomed by the user with the mouse wheel. What orientation corresponds to which specific axis can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoomAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '('
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' *horizontal, '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' *vertical). By default, the horizontal axis is the bottom axis (xAxis) and the vertical axis is the left axis (yAxis).To disable range zooming entirely, pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' or remove '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeZoom'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' from '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. To enable range zooming for both directions, pass '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'Qt::Horizontal | Qt::Vertical'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.In addition to setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to a non-zero value, make sure '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeZoom'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to enable the range zooming interaction.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a895d7ac745ea614e04056244b3c138ac',
                      content => 'setRangeZoomFactor'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9442cca2aa358405f39a64d51eca13d2',
                      content => 'setRangeZoomAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1ae6aef2f7211ba6097c925dcd26008418',
                      content => 'setRangeDrag'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientations',
                type => 'Qt::Orientations'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeDragAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the axes whose range will be dragged when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeDrag'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' enables mouse range dragging on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget. Pass 0 if no axis shall be dragged in the respective orientation.Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall react to dragging interactions.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9442cca2aa358405f39a64d51eca13d2',
                      content => 'setRangeZoomAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontal',
                type => 'QCPAxis *'
              },
              {
                declaration_name => 'vertical',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeDragAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method allows to set up multiple axes to react to horizontal and vertical dragging. The drag orientation that the respective axis will react to is deduced from its orientation ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::orientation'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').In the unusual case that you wish to e.g. drag a vertically oriented axis with a horizontal drag motion, use the overload taking two separate lists for horizontal and vertical dragging. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axes',
                type => 'QList< QCPAxis *>'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeDragAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method allows to set multiple axes up to react to horizontal and vertical dragging, and define specifically which axis reacts to which drag orientation (irrespective of the axis orientation). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontal',
                type => 'QList< QCPAxis *>'
              },
              {
                declaration_name => 'vertical',
                type => 'QList< QCPAxis *>'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the axes whose range will be zoomed when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoom'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' enables mouse wheel zooming on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget. Pass 0 if no axis shall be zoomed in the respective orientation.The two axes can be zoomed with different strengths, when different factors are passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoomFactor(double horizontalFactor, double verticalFactor)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall react to zooming interactions.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a648cce336bd99daac4a5ca3e5743775d',
                      content => 'setRangeDragAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontal',
                type => 'QCPAxis *'
              },
              {
                declaration_name => 'vertical',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method allows to set up multiple axes to react to horizontal and vertical range zooming. The zoom orientation that the respective axis will react to is deduced from its orientation ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::orientation'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').In the unusual case that you wish to e.g. zoom a vertically oriented axis with a horizontal zoom interaction, use the overload taking two separate lists for horizontal and vertical zooming. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axes',
                type => 'QList< QCPAxis *>'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method allows to set multiple axes up to react to horizontal and vertical zooming, and define specifically which axis reacts to which zoom orientation (irrespective of the axis orientation). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontal',
                type => 'QList< QCPAxis *>'
              },
              {
                declaration_name => 'vertical',
                type => 'QList< QCPAxis *>'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomFactor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how strong one rotation step of the mouse wheel zooms, when range zoom was activated with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoom'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The two parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'horizontalFactor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'verticalFactor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provide a way to let the horizontal axis zoom at different rates than the vertical axis. Which axis is horizontal and which is vertical, can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoomAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.When the zoom factor is greater than one, scrolling the mouse wheel backwards (towards the user) will zoom in (make the currently visible range smaller). For zoom factors smaller than one, the same scrolling direction will zoom out. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontalFactor',
                type => 'double'
              },
              {
                declaration_name => 'verticalFactor',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomFactor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets both the horizontal and vertical zoom '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'factor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'factor',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'axisCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the number of axes on the axis rect side specified with '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a583ae4f6d78b601b732183f6cabecbe1',
                      content => 'axis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'QCPAxis::AxisType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'axis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the axis with the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' on the axis rect side specified with '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a85b321acec0f694d8b5fdeafdbff3133',
                      content => 'axisCount'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a8db4722cb93e9c4a6f0d91150c200867',
                      content => 'axes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'QCPAxis::AxisType'
              },
              {
                declaration_name => 'index',
                type => 'int',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'axes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all axes on the axis rect sides specified with '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'types'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'types'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' may be a single '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::AxisType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or an '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'or'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '-combination, to get the axes of multiple sides.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a583ae4f6d78b601b732183f6cabecbe1',
                      content => 'axis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'types',
                type => 'QCPAxis::AxisTypes'
              }
            ]
          },
          {
            kind => 'function',
            name => 'axes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all axes of this axis rect. '
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'addAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds a new axis to the axis rect side specified with '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', and returns it. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, a new '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' instance is created internally. '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' owns the returned axis, so if you want to remove an axis, use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'removeAxis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' instead of deleting it manually.You may inject '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' instances (or subclasses of '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ') by setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to an axis that was previously created outside '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '. It is important to note that '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' takes ownership of the axis, so you may not delete it afterwards. Further, the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' must have been created with this axis rect as parent and with the same axis type as specified in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. If this is not the case, a debug output is generated, the axis is not added, and the method returns 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method can not be used to move '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' between axis rects. The same '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' instance must not be added multiple times to the same or different axis rects.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If an axis rect side already contains one or more axes, the lower and upper endings of the new axis ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setLowerEnding'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setUpperEnding'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') are set to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLineEnding::esHalfBar'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a792e1f3d9cb1591fca135bb0de9b81fc',
                      content => 'addAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5fa906175447b14206954f77fc7f1ef4',
                      content => 'setupFullAxesBox'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPAxis *',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'QCPAxis::AxisType'
              },
              {
                declaration_name => 'axis',
                type => 'QCPAxis *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds a new axis with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'addAxis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to each axis rect side specified in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'types'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This may be an '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'or'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '-combination of '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1ae2bcc1728b382f10f064612b368bc18a',
                  content => 'QCPAxis::AxisType'
                },
                {
                  type => 'text',
                  content => ', so axes can be added to multiple sides at once.Returns a list of the added axes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a2dc336092ccc57d44a46194c8a23e4f4',
                      content => 'addAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5fa906175447b14206954f77fc7f1ef4',
                      content => 'setupFullAxesBox'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'types',
                type => 'QCPAxis::AxisTypes'
              }
            ]
          },
          {
            kind => 'function',
            name => 'removeAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Removes the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' from the axis rect and deletes it.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' was a valid axis in this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a2dc336092ccc57d44a46194c8a23e4f4',
                      content => 'addAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'insetLayout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the inset layout of this axis rect. It can be used to place other layout elements (or even layouts with multiple other elements) inside/on top of an axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutInset',
                      content => 'QCPLayoutInset'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPLayoutInset *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'zoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Zooms in (or out) to the passed rectangular region '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pixelRect'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', given in pixel coordinates.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'All axes of this axis rect will have their range zoomed accordingly. If you only wish to zoom specific axes, use the overloaded version of this method.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a810ef958ebe84db661c7288b526c0deb',
                      content => 'QCustomPlot::setSelectionRectMode'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pixelRect',
                type => 'const QRectF &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'zoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Zooms in (or out) to the passed rectangular region '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pixelRect'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', given in pixel coordinates.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Only the axes passed in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'affectedAxes'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will have their ranges zoomed accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a810ef958ebe84db661c7288b526c0deb',
                      content => 'QCustomPlot::setSelectionRectMode'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pixelRect',
                type => 'const QRectF &'
              },
              {
                declaration_name => 'affectedAxes',
                type => 'const QList< QCPAxis *> &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setupFullAxesBox',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Convenience function to create an axis on each side that doesn\'t have any axes yet and set their visibility to true. Further, the top/right axes are assigned the following properties of the bottom/left axes:'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'list',
                  style => 'itemized',
                  content => [
                    [
                      {
                        type => 'text',
                        content => 'range ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setRange'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'range reversed ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setRangeReversed'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'scale type ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setScaleType'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'tick visibility ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setTicks'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'number format ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setNumberFormat'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'number precision ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setNumberPrecision'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'tick count of ticker ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxisTicker::setTickCount'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'tick origin of ticker ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxisTicker::setTickOrigin'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ')'
                      }
                    ]
                  ]
                },
                {
                  type => 'text',
                  content => 'Tick label visibility ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setTickLabels'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') of the right and top axes are set to false.If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'connectRanges'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rangeChanged'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' signals of the bottom and left axes are connected to the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' slots of the top and right axes. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'connectRanges',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'plottables',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all the plottables that are associated with this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A plottable is considered associated with an axis rect if its key or value axis (or both) is in this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a2d9ded3eca97be1fcb5867949391bb88',
                      content => 'graphs'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a03c113a2175448300ee8f944e24776ba',
                      content => 'items'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAbstractPlottable * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'graphs',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all the graphs that are associated with this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A graph is considered associated with an axis rect if its key or value axis (or both) is in this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a587d073a97b27bc7293fab4b2774ad59',
                      content => 'plottables'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a03c113a2175448300ee8f944e24776ba',
                      content => 'items'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPGraph * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'items',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all the items that are associated with this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'An item is considered associated with an axis rect if any of its positions has key or value axis set to an axis that is in this axis rect, or if any of its positions has '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPItemPosition::setAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' set to the axis rect, or if the clip axis rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAbstractItem::setClipAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') is set to this axis rect.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a587d073a97b27bc7293fab4b2774ad59',
                      content => 'plottables'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a2d9ded3eca97be1fcb5867949391bb88',
                      content => 'graphs'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAbstractItem * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'left',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the pixel position of the left border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'right',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel position of the right border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'top',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the pixel position of the top border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'bottom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel position of the bottom border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'width',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel width of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'height',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel height of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'size',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel size of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'topLeft',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the top left corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'topRight',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the top right corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'bottomLeft',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the bottom left corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'bottomRight',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the bottom right corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'center',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the center of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'update',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This method is called automatically upon replot and doesn\'t need to be called by users of '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Calls the base class implementation to update the margins (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement::update'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), and finally passes the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to the inset layout ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'insetLayout'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') and calls its QCPInsetLayout::update function.'
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'phase',
                type => 'UpdatePhase'
              }
            ],
            reimplements => {
              name => 'update'
            }
          },
          {
            kind => 'function',
            name => 'elements',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all child elements in this layout element. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'recursive'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, all sub-child elements are included in the list, too.'
                },
                {
                  type => 'parbreak'
                },
                {
                  warning => [
                    {
                      type => 'text',
                      content => 'There may be entries with value 0 in the returned list. (For example, '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutGrid',
                      content => 'QCPLayoutGrid'
                    },
                    {
                      type => 'text',
                      content => ' may have empty cells which yield 0 at the respective index.) '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QList< QCPLayoutElement * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'recursive',
                type => 'bool'
              }
            ],
            reimplements => {
              name => 'elements'
            }
          },
          {
            kind => 'function',
            name => 'layout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the parent layout of this layout element. '
                }
              ]
            },
            type => 'QCPLayout *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the inner rect of this layout element. The inner rect is the outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') shrinked by the margins ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').In some cases, the area between outer and inner rect is left blank. In other cases the margin area is used to display peripheral graphics while the main content is in the inner rect. This is where automatic margin calculation becomes interesting because it allows the layout element to adapt the margins to the peripheral graphics it wants to draw. For example, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' draws the axis labels and tick labels in the margin area, thus needs to adjust the margins (if '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is enabled) according to the space required by the labels of the axes.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a2a32a12a6161c9dffbadeb9cc585510c',
                      content => 'outerRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'outerRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the outer rect of this layout element. The outer rect is the inner rect expanded by the margins ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). The outer rect is used (and set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') by the parent '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to control the size of this layout element.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a208effccfe2cca4a0eaf9393e60f2dd4',
                      content => 'rect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'margins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'minimumMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'autoMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::MarginSides',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'minimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'maximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'sizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SizeConstraintRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'marginGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPMarginGroup *',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'side',
                type => 'QCP::MarginSide'
              }
            ]
          },
          {
            kind => 'function',
            name => 'marginGroups',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< QCP::MarginSide, QCPMarginGroup * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setOuterRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the outer rect of this layout element. If the layout element is inside a layout, the layout sets the position and size of this layout element using this function.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Calling this function externally has no effect, since the layout will overwrite any changes to the outer rect upon the next replot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The layout element will adapt its inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' by applying the margins inward to the outer rect.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a208effccfe2cca4a0eaf9393e60f2dd4',
                      content => 'rect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'rect',
                type => 'const QRect &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the margins of this layout element. If '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is disabled for some or all sides, this function is used to manually set the margin on those sides. Sides that are still set to be handled automatically are ignored and may have any value in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'margins'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The margin is the distance between the outer rect (controlled by the parent layout via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') and the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (which usually contains the main content of this layout element).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1accfda49994e3e6d51ed14504abf9d27d',
                      content => 'setAutoMargins'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'margins',
                type => 'const QMargins &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is enabled on some or all margins, this function is used to provide minimum values for those margins.The minimum values are not enforced on margin sides that were set to be under manual control via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1accfda49994e3e6d51ed14504abf9d27d',
                      content => 'setAutoMargins'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'margins',
                type => 'const QMargins &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAutoMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets on which sides the margin shall be calculated automatically. If a side is calculated automatically, a minimum margin value may be provided with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. If a side is set to be controlled manually, the value may be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Margin sides that are under automatic control may participate in a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), to synchronize (align) it with other layout elements in the plot.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a0a8a17abc16b7923159fcc7608f94673',
                      content => 'setMinimumMargins'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a8f450b1f3f992ad576fce2c63d8b79cf',
                      content => 'setMargins'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54',
                      content => 'QCP::MarginSide'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sides',
                type => 'QCP::MarginSides'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the minimum size of this layout element. A parent layout tries to respect the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' here by changing row/column sizes in the layout accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the parent layout size is not sufficient to satisfy all minimum size constraints of its child layout elements, the layout may set a size that is actually smaller than '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' propagates the layout\'s size constraints to the outside by setting its own minimum QWidget size accordingly, so violations of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' should be exceptions.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the minimum size of this layout element.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'int'
              },
              {
                declaration_name => 'height',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMaximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the maximum size of this layout element. A parent layout tries to respect the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' here by changing row/column sizes in the layout accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMaximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the maximum size of this layout element.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'int'
              },
              {
                declaration_name => 'height',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets to which rect of a layout element the size constraints apply. Size constraints can be set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') includes the margins (e.g. in the case of a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => ' the axis labels), whereas the inner rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') does not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a5dd29a3c8bc88440c97c06b67be7886b',
                      content => 'setMinimumSize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a74eb5280a737ab44833d506db65efd95',
                      content => 'setMaximumSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'constraintRect',
                type => 'SizeConstraintRect'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMarginGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the margin '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'group'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of the specified margin '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sides'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Margin groups allow synchronizing specified margins across layout elements, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.To unset the margin group of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sides'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'group'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that margin groups only work for margin sides that are set to automatic ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54',
                      content => 'QCP::MarginSide'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sides',
                type => 'QCP::MarginSides'
              },
              {
                declaration_name => 'group',
                type => 'QCPMarginGroup *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'minimumOuterSizeHint',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the suggested minimum size this layout element (the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') may be compressed to, if no manual minimum size is set.if a minimum size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') was not set manually, parent layouts use the returned size (usually indirectly through '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout::getFinalMinimumOuterSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to determine the minimum allowed size of this layout element.A manual minimum size is considered set if it is non-zero.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height. Reimplementations may use their detailed knowledge about the layout element\'s content to provide size hints. '
                }
              ]
            },
            type => 'virtual QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'minimumOuterSizeHint'
              },
              {
                name => 'minimumOuterSizeHint'
              },
              {
                name => 'minimumOuterSizeHint'
              }
            ]
          },
          {
            kind => 'function',
            name => 'maximumOuterSizeHint',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the suggested maximum size this layout element (the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') may be expanded to, if no manual maximum size is set.if a maximum size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') was not set manually, parent layouts use the returned size (usually indirectly through '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout::getFinalMaximumOuterSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to determine the maximum allowed size of this layout element.A manual maximum size is considered set if it is smaller than Qt\'s '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QWIDGETSIZE_MAX'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation simply returns '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QWIDGETSIZE_MAX'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' for both width and height, implying no suggested maximum size. Reimplementations may use their detailed knowledge about the layout element\'s content to provide size hints. '
                }
              ]
            },
            type => 'virtual QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'maximumOuterSizeHint'
              },
              {
                name => 'maximumOuterSizeHint'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Layout elements are sensitive to events inside their outer rect. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is within the outer rect, this method returns a value corresponding to 0.99 times the parent plot\'s selection tolerance. However, layout elements are not selectable by default. So if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlySelectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, -1.0 is returned.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayerable::selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for a general explanation of this virtual method.'
                },
                {
                  type => 'url',
                  link => 'classQCPLayoutElement',
                  content => 'QCPLayoutElement'
                },
                {
                  type => 'text',
                  content => ' subclasses may reimplement this method to provide more specific selection test behaviour. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            },
            reimplemented_by => [
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              }
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'applyDefaultAntialiasingHint',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'applyDefaultAntialiasingHint'
            }
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'draw'
            },
            reimplemented_by => [
              {
                name => 'draw'
              }
            ]
          },
          {
            kind => 'function',
            name => 'calculateAutoMargin',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'side',
                type => 'QCP::MarginSide'
              }
            ],
            reimplements => {
              name => 'calculateAutoMargin'
            }
          },
          {
            kind => 'function',
            name => 'layoutChanged',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'layoutChanged'
            }
          },
          {
            kind => 'function',
            name => 'mousePressEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).'
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' uses an event propagation system that works the same as Qt\'s system. If your layerable doesn\'t reimplement the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or explicitly calls '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in its reimplementation, the event will be propagated to the next layerable in the stacking order.Once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9cd27ad8c5cfb49aefd9dbb30def4beb',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a6c89b988d3a0b93c0878f0ebdb5037f4',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a93eeaa0c127d6d6fe8171b2455080262',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplements => {
              name => 'mousePressEvent'
            }
          },
          {
            kind => 'function',
            name => 'mouseMoveEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1aa9a7c807eaa4666870ac94aa6abc4dde',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a6c89b988d3a0b93c0878f0ebdb5037f4',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a93eeaa0c127d6d6fe8171b2455080262',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplements => {
              name => 'mouseMoveEvent'
            }
          },
          {
            kind => 'function',
            name => 'mouseReleaseEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1aa9a7c807eaa4666870ac94aa6abc4dde',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9cd27ad8c5cfb49aefd9dbb30def4beb',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a93eeaa0c127d6d6fe8171b2455080262',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplements => {
              name => 'mouseReleaseEvent'
            }
          },
          {
            kind => 'function',
            name => 'wheelEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1aa9a7c807eaa4666870ac94aa6abc4dde',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9cd27ad8c5cfb49aefd9dbb30def4beb',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a6c89b988d3a0b93c0878f0ebdb5037f4',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QWheelEvent *'
              }
            ],
            reimplements => {
              name => 'wheelEvent'
            }
          },
          {
            kind => 'function',
            name => 'drawBackground',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'updateAxesOffset',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'QCPAxis::AxisType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'parentPlotInitialized',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ],
            reimplements => {
              name => 'parentPlotInitialized'
            },
            reimplemented_by => [
              {
                name => 'parentPlotInitialized'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectionCategory',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QCP::Interaction',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'selectionCategory'
              },
              {
                name => 'selectionCategory'
              },
              {
                name => 'selectionCategory'
              },
              {
                name => 'selectionCategory'
              },
              {
                name => 'selectionCategory'
              }
            ]
          },
          {
            kind => 'function',
            name => 'clipRect',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'clipRect'
              },
              {
                name => 'clipRect'
              },
              {
                name => 'clipRect'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'additive',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              },
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplemented_by => [
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'deselectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplemented_by => [
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseDoubleClickEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called instead of the second '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. So in the case of a double-click, the event succession is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pressEvent - releaseEvent - doubleClickEvent - releaseEvent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).Similarly to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseDoubleClickEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'initializeParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentLayerable',
                type => 'QCPLayerable *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveToLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              },
              {
                declaration_name => 'prepend',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'localAntialiased',
                type => 'bool'
              },
              {
                declaration_name => 'overrideElement',
                type => 'QCP::AntialiasedElement'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mBackgroundBrush',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush'
          },
          {
            kind => 'variable',
            name => 'mBackgroundPixmap',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPixmap'
          },
          {
            kind => 'variable',
            name => 'mScaledBackgroundPixmap',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPixmap'
          },
          {
            kind => 'variable',
            name => 'mBackgroundScaled',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mBackgroundScaledMode',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::AspectRatioMode'
          },
          {
            kind => 'variable',
            name => 'mInsetLayout',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayoutInset *'
          },
          {
            kind => 'variable',
            name => 'mRangeDrag',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::Orientations'
          },
          {
            kind => 'variable',
            name => 'mRangeZoom',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::Orientations'
          },
          {
            kind => 'variable',
            name => 'mRangeDragHorzAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QList< QPointer< QCPAxis > >'
          },
          {
            kind => 'variable',
            name => 'mRangeDragVertAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QList< QPointer< QCPAxis > >'
          },
          {
            kind => 'variable',
            name => 'mRangeZoomHorzAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QList< QPointer< QCPAxis > >'
          },
          {
            kind => 'variable',
            name => 'mRangeZoomVertAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QList< QPointer< QCPAxis > >'
          },
          {
            kind => 'variable',
            name => 'mRangeZoomFactorHorz',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mRangeZoomFactorVert',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mDragStartHorzRange',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QList< QCPRange >'
          },
          {
            kind => 'variable',
            name => 'mDragStartVertRange',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QList< QCPRange >'
          },
          {
            kind => 'variable',
            name => 'mAADragBackup',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::AntialiasedElements'
          },
          {
            kind => 'variable',
            name => 'mNotAADragBackup',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::AntialiasedElements'
          },
          {
            kind => 'variable',
            name => 'mDragging',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mAxes',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< QCPAxis::AxisType, QList< QCPAxis * > >'
          },
          {
            kind => 'variable',
            name => 'mParentLayout',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayout *'
          },
          {
            kind => 'variable',
            name => 'mMinimumSize',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize'
          },
          {
            kind => 'variable',
            name => 'mMaximumSize',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize'
          },
          {
            kind => 'variable',
            name => 'mSizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SizeConstraintRect'
          },
          {
            kind => 'variable',
            name => 'mRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'mOuterRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'mMargins',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins'
          },
          {
            kind => 'variable',
            name => 'mMinimumMargins',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins'
          },
          {
            kind => 'variable',
            name => 'mAutoMargins',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::MarginSides'
          },
          {
            kind => 'variable',
            name => 'mMarginGroups',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< QCP::MarginSide, QCPMarginGroup * >'
          },
          {
            kind => 'variable',
            name => 'mVisible',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPLayerable >'
          },
          {
            kind => 'variable',
            name => 'mLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *'
          },
          {
            kind => 'variable',
            name => 'mAntialiased',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCustomPlot',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Holds multiple axes and arranges them in a rectangular shape. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This class represents an axis rect, a rectangular area that is bounded on all sides with an arbitrary number of axes.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Initially '
          },
          {
            type => 'url',
            link => 'classQCustomPlot',
            content => 'QCustomPlot'
          },
          {
            type => 'text',
            content => ' has one axis rect, accessible via '
          },
          {
            type => 'url',
            link => 'classQCustomPlot_1ae5eefcb5f6ca26689b1fd4f6e25b42f9',
            content => 'QCustomPlot::axisRect()'
          },
          {
            type => 'text',
            content => '. However, the layout system allows to have multiple axis rects, e.g. arranged in a grid layout ('
          },
          {
            type => 'url',
            link => 'classQCustomPlot_1af1a1f1f571237deb7c2bd34a5e9f018f',
            content => 'QCustomPlot::plotLayout'
          },
          {
            type => 'text',
            content => ').'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'By default, '
          },
          {
            type => 'url',
            link => 'classQCPAxisRect',
            content => 'QCPAxisRect'
          },
          {
            type => 'text',
            content => ' comes with four axes, at bottom, top, left and right. They can be accessed via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'axis'
              }
            ]
          },
          {
            type => 'text',
            content => ' by providing the respective axis type ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxis::AxisType'
              }
            ]
          },
          {
            type => 'text',
            content => ') and index. If you need all axes in the axis rect, use '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'axes'
              }
            ]
          },
          {
            type => 'text',
            content => '. The top and right axes are set to be invisible initially ('
          },
          {
            type => 'url',
            link => 'classQCPLayerable_1a3bed99ddc396b48ce3ebfdc0418744f8',
            content => 'QCPAxis::setVisible'
          },
          {
            type => 'text',
            content => '). To add more axes to a side, use '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'addAxis'
              }
            ]
          },
          {
            type => 'text',
            content => ' or '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'addAxes'
              }
            ]
          },
          {
            type => 'text',
            content => '. To remove an axis, use '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'removeAxis'
              }
            ]
          },
          {
            type => 'text',
            content => '.The axis rect layerable itself only draws a background pixmap or color, if specified ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setBackground'
              }
            ]
          },
          {
            type => 'text',
            content => '). It is placed on the "background" layer initially (see '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPLayer'
              }
            ]
          },
          {
            type => 'text',
            content => ' for an explanation of the '
          },
          {
            type => 'url',
            link => 'classQCustomPlot',
            content => 'QCustomPlot'
          },
          {
            type => 'text',
            content => ' layer system). The axes that are held by the axis rect can be placed on other layers, independently of the axis rect.Every axis rect has a child layout of type '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPLayoutInset'
              }
            ]
          },
          {
            type => 'text',
            content => '. It is accessible via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'insetLayout'
              }
            ]
          },
          {
            type => 'text',
            content => ' and can be used to have other layout elements (or even other layouts with multiple elements) hovering inside the axis rect.If an axis rect is clicked and dragged, it processes this by moving certain axis ranges. The behaviour can be controlled with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setRangeDrag'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setRangeDragAxes'
              }
            ]
          },
          {
            type => 'text',
            content => '. If the mouse wheel is scrolled while the cursor is on the axis rect, certain axes are scaled. This is controllable via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setRangeZoom'
              }
            ]
          },
          {
            type => 'text',
            content => ', '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setRangeZoomAxes'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setRangeZoomFactor'
              }
            ]
          },
          {
            type => 'text',
            content => '. These interactions are only enabled if '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCustomPlot::setInteractions'
              }
            ]
          },
          {
            type => 'text',
            content => ' contains '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCP::iRangeDrag'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCP::iRangeZoom'
              }
            ]
          },
          {
            type => 'text',
            content => '. '
          },
          {
            type => 'style',
            style => 'center',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'Overview of the spacings and paddings that define the geometry of an axis. The dashed line on the far left indicates the viewport/widget border.'
          },
          {
            type => 'style',
            style => 'center',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' '
          }
        ]
      }
    },
    {
      name => 'QCPAxisTicker',
      derived => [
        {
          name => 'QCPAxisTickerDateTime',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAxisTickerFixed',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAxisTickerLog',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAxisTickerPi',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAxisTickerText',
          virtualness => 'non_virtual',
          protection => 'public'
        },
        {
          name => 'QCPAxisTickerTime',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'cleanMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createLabelVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createSubTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'generate',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getSubTickCount',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getTickLabel',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getTickStep',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickOrigin',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'pickClosest',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'TickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'trimTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssMeetTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssReadability',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => '~QCPAxisTicker',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'TickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the strategies that the axis ticker may follow when choosing the size of the tick step.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTicker_1a73b1d847c1a12159af6bfda4ebebe7d5',
                      content => 'setTickStepStrategy'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'tssReadability',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTickCount'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tssMeetTickCount',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'tssReadability',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tssMeetTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxisTicker',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1a4ee03fcd2c74d05cd1a419b9af5cfbdc',
                  content => 'QCPAxis::setTicker'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => '~QCPAxisTicker',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets which strategy the axis ticker follows when choosing the size of the tick step. For the available strategies, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'TickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'strategy',
                type => 'TickStepStrategy'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how many ticks this ticker shall aim to generate across the axis range. Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not guaranteed to be matched exactly, as generating readable tick intervals may conflict with the requested number of ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether the readability has priority over meeting the requested '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'count',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the mathematical coordinate (or "offset") of the zeroth tick. This tick coordinate is just a concept and doesn\'t need to be inside the currently visible axis range.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'By default '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is zero, which for example yields ticks {-5, 0, 5, 10, 15,...} when the tick step is five. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is now set to 1 instead, the correspondingly generated ticks would be {-4, 1, 6, 11, 16,...}. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'origin',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'generate',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This is the method called by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' in order to actually generate tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), tick label strings ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') and sub tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The ticks are generated for the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'range'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The generated labels typically follow the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'locale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatChar'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and number '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'precision'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', however this might be different (or even irrelevant) for certain '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTicker',
                  content => 'QCPAxisTicker'
                },
                {
                  type => 'text',
                  content => ' subclasses.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The output parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is filled with the generated tick positions in axis coordinates. The output parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are optional (set them to 0 if not needed) and are respectively filled with sub tick coordinates, and tick label strings belonging to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' by index. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'subTicks',
                type => 'QVector< double > *'
              },
              {
                declaration_name => 'tickLabels',
                type => 'QVector< QString > *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'getTickStep',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplemented_by => [
              {
                name => 'getTickStep'
              },
              {
                name => 'getTickStep'
              },
              {
                name => 'getTickStep'
              },
              {
                name => 'getTickStep'
              },
              {
                name => 'getTickStep'
              },
              {
                name => 'getTickStep'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getSubTickCount',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              }
            ],
            reimplemented_by => [
              {
                name => 'getSubTickCount'
              },
              {
                name => 'getSubTickCount'
              },
              {
                name => 'getSubTickCount'
              },
              {
                name => 'getSubTickCount'
              },
              {
                name => 'getSubTickCount'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getTickLabel',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QString',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tick',
                type => 'double'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ],
            reimplemented_by => [
              {
                name => 'getTickLabel'
              },
              {
                name => 'getTickLabel'
              },
              {
                name => 'getTickLabel'
              },
              {
                name => 'getTickLabel'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplemented_by => [
              {
                name => 'createTickVector'
              },
              {
                name => 'createTickVector'
              },
              {
                name => 'createTickVector'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createSubTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'subTickCount',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createLabelVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< QString >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'trimTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'keepOneOutlier',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pickClosest',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'target',
                type => 'double'
              },
              {
                declaration_name => 'candidates',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              },
              {
                declaration_name => 'magnitude',
                type => 'double *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'cleanMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy'
          },
          {
            kind => 'variable',
            name => 'mTickCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mTickOrigin',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The base class tick generator used by '
          },
          {
            type => 'url',
            link => 'classQCPAxis',
            content => 'QCPAxis'
          },
          {
            type => 'text',
            content => ' to create tick positions and tick labels. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'text',
            content => 'Each '
          },
          {
            type => 'url',
            link => 'classQCPAxis',
            content => 'QCPAxis'
          },
          {
            type => 'text',
            content => ' has an internal '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => ' (or a subclass) in order to generate tick positions and tick labels for the current axis range. The ticker of an axis can be set via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxis::setTicker'
              }
            ]
          },
          {
            type => 'text',
            content => '. Since that method takes a '
          },
          {
            type => 'style',
            style => 'code',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'QSharedPointer<QCPAxisTicker>'
          },
          {
            type => 'style',
            style => 'code',
            enable => 'no'
          },
          {
            type => 'text',
            content => ', multiple axes can share the same ticker instance.This base class generates normal tick coordinates and numeric labels for linear axes. It picks a reasonable tick step (the separation between ticks) which results in readable tick labels. The number of ticks that should be approximately generated can be set via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setTickCount'
              }
            ]
          },
          {
            type => 'text',
            content => '. Depending on the current tick step strategy ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setTickStepStrategy'
              }
            ]
          },
          {
            type => 'text',
            content => '), the algorithm either sacrifices readability to better match the specified tick count ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxisTicker::tssMeetTickCount'
              }
            ]
          },
          {
            type => 'text',
            content => ') or relaxes the tick count in favor of better tick steps ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxisTicker::tssReadability'
              }
            ]
          },
          {
            type => 'text',
            content => '), which is the default.The following more specialized axis ticker subclasses are available, see details in the respective class documentation:'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'style',
            style => 'center',
            enable => 'yes'
          },
          {
            type => 'text',
            content => ' '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPAxisTickerFixed',
            content => 'QCPAxisTickerFixed'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => ' '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPAxisTickerLog',
            content => 'QCPAxisTickerLog'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => ' '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPAxisTickerPi',
            content => 'QCPAxisTickerPi'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => ' '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPAxisTickerText',
            content => 'QCPAxisTickerText'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => ' '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPAxisTickerDateTime',
            content => 'QCPAxisTickerDateTime'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => ' '
          },
          {
            type => 'parbreak'
          },
          {
            type => 'url',
            link => 'classQCPAxisTickerTime',
            content => 'QCPAxisTickerTime'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => '  '
          },
          {
            type => 'style',
            style => 'center',
            enable => 'no'
          },
          {
            type => 'sect1',
            title => 'Creating own axis tickers',
            content => [
              {
                type => 'text',
                content => 'Creating own axis tickers can be achieved very easily by sublassing '
              },
              {
                type => 'url',
                link => 'classQCPAxisTicker',
                content => 'QCPAxisTicker'
              },
              {
                type => 'text',
                content => ' and reimplementing some or all of the available virtual methods.'
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'In the simplest case you might wish to just generate different tick steps than the other tickers, so you only reimplement the method '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'getTickStep'
                  }
                ]
              },
              {
                type => 'text',
                content => '. If you additionally want control over the string that will be shown as tick label, reimplement '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'getTickLabel'
                  }
                ]
              },
              {
                type => 'text',
                content => '.If you wish to have complete control, you can generate the tick vectors and tick label vectors yourself by reimplementing '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'createTickVector'
                  }
                ]
              },
              {
                type => 'text',
                content => ' and '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'createLabelVector'
                  }
                ]
              },
              {
                type => 'text',
                content => '. The default implementations use the previously mentioned virtual methods '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'getTickStep'
                  }
                ]
              },
              {
                type => 'text',
                content => ' and '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'getTickLabel'
                  }
                ]
              },
              {
                type => 'text',
                content => ', but your reimplementations don\'t necessarily need to do so. For example in the case of unequal tick steps, the method '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'getTickStep'
                  }
                ]
              },
              {
                type => 'text',
                content => ' loses its usefulness and can be ignored.The sub tick count between major ticks can be controlled with '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'getSubTickCount'
                  }
                ]
              },
              {
                type => 'text',
                content => '. Full sub tick placement control is obtained by reimplementing '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'createSubTickVector'
                  }
                ]
              },
              {
                type => 'text',
                content => '.See the documentation of all these virtual methods in '
              },
              {
                type => 'url',
                link => 'classQCPAxisTicker',
                content => 'QCPAxisTicker'
              },
              {
                type => 'text',
                content => ' for detailed information about the parameters and expected return values. '
              }
            ]
          }
        ]
      }
    },
    {
      name => 'QCPAxisTickerDateTime',
      base => [
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'cleanMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createLabelVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createSubTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'DateStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'dateTimeFormat',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'dateTimeSpec',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'dateTimeToKey',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'dateTimeToKey',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'dsNone',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'dsUniformDayInMonth',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'dsUniformTimeInDay',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'generate',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getSubTickCount',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'getTickLabel',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'getTickStep',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'keyToDateTime',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'mDateStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'mDateTimeFormat',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'mDateTimeSpec',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'mTickCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickOrigin',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'pickClosest',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTickerDateTime',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'setDateTimeFormat',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'setDateTimeSpec',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'setTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'setTickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerDateTime'
        },
        {
          name => 'setTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'TickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'trimTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssMeetTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssReadability',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => '~QCPAxisTicker',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'TickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the strategies that the axis ticker may follow when choosing the size of the tick step.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTicker_1a73b1d847c1a12159af6bfda4ebebe7d5',
                      content => 'setTickStepStrategy'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'tssReadability',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTickCount'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tssMeetTickCount',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'tssReadability',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tssMeetTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxisTickerDateTime',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1a4ee03fcd2c74d05cd1a419b9af5cfbdc',
                  content => 'QCPAxis::setTicker'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'dateTimeFormat',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'dateTimeSpec',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::TimeSpec',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setDateTimeFormat',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the format in which dates and times are displayed as tick labels. For details about the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'format'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' string, see the documentation of QDateTime::toString().'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Newlines can be inserted with "\\n".'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerDateTime_1afbd987c7197e42ab61e67fb1c38abebc',
                      content => 'setDateTimeSpec'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'format',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setDateTimeSpec',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the time spec that is used for creating the tick labels from corresponding dates/times.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default value of QDateTime objects (and also '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTickerDateTime',
                  content => 'QCPAxisTickerDateTime'
                },
                {
                  type => 'text',
                  content => ') is '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'Qt::LocalTime'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. However, if the date time values passed to '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' (e.g. in the form of axis ranges or keys of a plottable) are given in the UTC spec, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'spec'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'Qt::UTC'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to get the correct axis labels.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerDateTime_1ad52660a82f688395468674d555f6a86b',
                      content => 'setDateTimeFormat'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'spec',
                type => 'Qt::TimeSpec'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the tick origin (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisTicker::setTickOrigin'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') in seconds since Epoch (1. Jan 1970, 00:00 UTC). For the date time ticker it might be more intuitive to use the overload which directly takes a QDateTime, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickOrigin(const QDateTime &origin)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.This is useful to define the month/day/time recurring at greater tick interval steps. For example, If you pass 15. July, 9:45 to this method and the tick interval happens to be one tick per year, the ticks will end up on 15. July at 9:45 of every year. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'origin',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the tick origin (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisTicker::setTickOrigin'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') as a QDateTime '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.This is useful to define the month/day/time recurring at greater tick interval steps. For example, If you pass 15. July, 9:45 to this method and the tick interval happens to be one tick per year, the ticks will end up on 15. July at 9:45 of every year. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'origin',
                type => 'const QDateTime &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'tickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets which strategy the axis ticker follows when choosing the size of the tick step. For the available strategies, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'TickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'strategy',
                type => 'TickStepStrategy'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how many ticks this ticker shall aim to generate across the axis range. Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not guaranteed to be matched exactly, as generating readable tick intervals may conflict with the requested number of ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether the readability has priority over meeting the requested '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'count',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'generate',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This is the method called by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' in order to actually generate tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), tick label strings ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') and sub tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The ticks are generated for the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'range'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The generated labels typically follow the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'locale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatChar'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and number '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'precision'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', however this might be different (or even irrelevant) for certain '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTicker',
                  content => 'QCPAxisTicker'
                },
                {
                  type => 'text',
                  content => ' subclasses.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The output parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is filled with the generated tick positions in axis coordinates. The output parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are optional (set them to 0 if not needed) and are respectively filled with sub tick coordinates, and tick label strings belonging to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' by index. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'subTicks',
                type => 'QVector< double > *'
              },
              {
                declaration_name => 'tickLabels',
                type => 'QVector< QString > *'
              }
            ]
          }
        ]
      },
      public_static_methods => {
        members => [
          {
            kind => 'function',
            name => 'keyToDateTime',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'yes',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'A convenience method which turns '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' (in seconds since Epoch 1. Jan 1970, 00:00 UTC) into a QDateTime object. This can be used to turn axis coordinates to actual QDateTimes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The accuracy achieved by this method is one millisecond, irrespective of the used Qt version (it works around the lack of a QDateTime::fromMSecsSinceEpoch in Qt 4.6)'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerDateTime_1aa24f293f16fff0f937bf71f4140033f1',
                      content => 'dateTimeToKey'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'static QDateTime',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'dateTimeToKey',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'yes',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A convenience method which turns a QDateTime object into a double value that corresponds to seconds since Epoch (1. Jan 1970, 00:00 UTC). This is the format used as axis coordinates by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTickerDateTime',
                  content => 'QCPAxisTickerDateTime'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The accuracy achieved by this method is one millisecond, irrespective of the used Qt version (it works around the lack of a QDateTime::toMSecsSinceEpoch in Qt 4.6)'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerDateTime_1a4c1761ad057f5564804a53f942629b53',
                      content => 'keyToDateTime'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'static double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'dateTime',
                type => 'const QDateTime'
              }
            ]
          },
          {
            kind => 'function',
            name => 'dateTimeToKey',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'yes',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A convenience method which turns a QDate object into a double value that corresponds to seconds since Epoch (1. Jan 1970, 00:00 UTC). This is the format used as axis coordinates by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTickerDateTime',
                  content => 'QCPAxisTickerDateTime'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerDateTime_1a4c1761ad057f5564804a53f942629b53',
                      content => 'keyToDateTime'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'static double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'date',
                type => 'const QDate'
              }
            ]
          }
        ]
      },
      protected_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'DateStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            values => [
              {
                name => 'dsNone',
                brief => {},
                detailed => {}
              },
              {
                name => 'dsUniformTimeInDay',
                brief => {},
                detailed => {}
              },
              {
                name => 'dsUniformDayInMonth',
                brief => {},
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'dsNone',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'dsUniformTimeInDay',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'dsUniformDayInMonth',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => '@'
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'getTickStep',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplements => {
              name => 'getTickStep'
            }
          },
          {
            kind => 'function',
            name => 'getSubTickCount',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              }
            ],
            reimplements => {
              name => 'getSubTickCount'
            }
          },
          {
            kind => 'function',
            name => 'getTickLabel',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QString',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tick',
                type => 'double'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'getTickLabel'
            }
          },
          {
            kind => 'function',
            name => 'createTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplements => {
              name => 'createTickVector'
            }
          },
          {
            kind => 'function',
            name => 'createSubTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'subTickCount',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createLabelVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< QString >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'trimTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'keepOneOutlier',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pickClosest',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'target',
                type => 'double'
              },
              {
                declaration_name => 'candidates',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              },
              {
                declaration_name => 'magnitude',
                type => 'double *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'cleanMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mDateTimeFormat',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString'
          },
          {
            kind => 'variable',
            name => 'mDateTimeSpec',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::TimeSpec'
          },
          {
            kind => 'variable',
            name => 'mDateStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'enum QCPAxisTickerDateTime::DateStrategy'
          },
          {
            kind => 'variable',
            name => 'mTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy'
          },
          {
            kind => 'variable',
            name => 'mTickCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mTickOrigin',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'text',
            content => 'Specialized axis ticker for calendar dates and times as axis ticks. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => ' subclass generates ticks that correspond to real calendar dates and times. The plot axis coordinate is interpreted as Unix Time, so seconds since Epoch (January 1, 1970, 00:00 UTC). This is also used for example by QDateTime in the '
          },
          {
            type => 'style',
            style => 'code',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'toTime_t()/setTime_t()'
          },
          {
            type => 'style',
            style => 'code',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' methods with a precision of one second. Since Qt 4.7, millisecond accuracy can be obtained from QDateTime by using '
          },
          {
            type => 'style',
            style => 'code',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'QDateTime::fromMSecsSinceEpoch()/1000.0'
          },
          {
            type => 'style',
            style => 'code',
            enable => 'no'
          },
          {
            type => 'text',
            content => '. The static methods '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'dateTimeToKey'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'keyToDateTime'
              }
            ]
          },
          {
            type => 'text',
            content => ' conveniently perform this conversion achieving a precision of one millisecond on all Qt versions.The format of the date/time display in the tick labels is controlled with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setDateTimeFormat'
              }
            ]
          },
          {
            type => 'text',
            content => '. If a different time spec (time zone) shall be used, see '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setDateTimeSpec'
              }
            ]
          },
          {
            type => 'text',
            content => '.This ticker produces unequal tick spacing in order to provide intuitive date and time-of-day ticks. For example, if the axis range spans a few years such that there is one tick per year, ticks will be positioned on 1. January of every year. This is intuitive but, due to leap years, will result in slightly unequal tick intervals (visually unnoticeable). The same can be seen in the image above: even though the number of days varies month by month, this ticker generates ticks on the same day of each month.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'If you would like to change the date/time that is used as a (mathematical) starting date for the ticks, use the '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setTickOrigin(const QDateTime &origin)'
              }
            ]
          },
          {
            type => 'text',
            content => ' method overload, which takes a QDateTime. If you pass 15. July, 9:45 to this method, the yearly ticks will end up on 15. July at 9:45 of every year.The ticker can be created and assigned to an axis like this:  '
          },
          {
            note => [
              {
                type => 'text',
                content => 'If you rather wish to display relative times in terms of days, hours, minutes, seconds and milliseconds, and are not interested in the intricacies of real calendar dates with months and (leap) years, have a look at '
              },
              {
                type => 'url',
                link => 'classQCPAxisTickerTime',
                content => 'QCPAxisTickerTime'
              },
              {
                type => 'text',
                content => ' instead. '
              }
            ]
          }
        ]
      }
    },
    {
      name => 'QCPAxisTickerFixed',
      base => [
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'cleanMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createLabelVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createSubTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'generate',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getSubTickCount',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getTickLabel',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getTickStep',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'mScaleStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'mTickCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickOrigin',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickStep',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'mTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'pickClosest',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTickerFixed',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'scaleStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'ScaleStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'setScaleStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'setTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickStep',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'setTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'ssMultiples',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'ssNone',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'ssPowers',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'tickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickStep',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerFixed'
        },
        {
          name => 'tickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'TickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'trimTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssMeetTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssReadability',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => '~QCPAxisTicker',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'ScaleStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Defines how the axis ticker may modify the specified tick step ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStep'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') in order to control the number of ticks in the axis range.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerFixed_1acbc7c9bcd80b3dc3edee5f0519d301f6',
                      content => 'setScaleStrategy'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'ssNone',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Modifications are not allowed, the specified tick step is absolutely fixed. This might cause a high tick density and overlapping labels if the axis range is zoomed out. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'ssMultiples',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'An integer multiple of the specified tick step is allowed. The used factor follows the base class properties of '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTickStepStrategy'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' and '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTickCount'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => '. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'ssPowers',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'An integer power of the specified tick step is allowed. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'ssNone',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Modifications are not allowed, the specified tick step is absolutely fixed. This might cause a high tick density and overlapping labels if the axis range is zoomed out. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'ssMultiples',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'An integer multiple of the specified tick step is allowed. The used factor follows the base class properties of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'ssPowers',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'An integer power of the specified tick step is allowed. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enum',
            name => 'TickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Defines the strategies that the axis ticker may follow when choosing the size of the tick step.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTicker_1a73b1d847c1a12159af6bfda4ebebe7d5',
                      content => 'setTickStepStrategy'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'tssReadability',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTickCount'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tssMeetTickCount',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'tssReadability',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tssMeetTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxisTickerFixed',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1a4ee03fcd2c74d05cd1a419b9af5cfbdc',
                  content => 'QCPAxis::setTicker'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickStep',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'scaleStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'ScaleStrategy',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setTickStep',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the fixed tick interval to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'step'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The axis ticker will only use this tick step when generating axis ticks. This might cause a very high tick density and overlapping labels if the axis range is zoomed out. Using '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setScaleStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' it is possible to relax the fixed step and also allow multiples or powers of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'step'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This will enable the ticker to reduce the number of ticks to a reasonable amount (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'step',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setScaleStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the specified tick step ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStep'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') is absolutely fixed or whether modifications may be applied to it before calculating the finally used tick step, such as permitting multiples or powers. See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'ScaleStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for details.The default strategy is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'ssNone'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', which means the tick step is absolutely fixed. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'strategy',
                type => 'ScaleStrategy'
              }
            ]
          },
          {
            kind => 'function',
            name => 'tickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets which strategy the axis ticker follows when choosing the size of the tick step. For the available strategies, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'TickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'strategy',
                type => 'TickStepStrategy'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how many ticks this ticker shall aim to generate across the axis range. Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not guaranteed to be matched exactly, as generating readable tick intervals may conflict with the requested number of ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether the readability has priority over meeting the requested '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'count',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the mathematical coordinate (or "offset") of the zeroth tick. This tick coordinate is just a concept and doesn\'t need to be inside the currently visible axis range.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'By default '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is zero, which for example yields ticks {-5, 0, 5, 10, 15,...} when the tick step is five. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is now set to 1 instead, the correspondingly generated ticks would be {-4, 1, 6, 11, 16,...}. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'origin',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'generate',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This is the method called by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' in order to actually generate tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), tick label strings ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') and sub tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The ticks are generated for the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'range'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The generated labels typically follow the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'locale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatChar'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and number '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'precision'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', however this might be different (or even irrelevant) for certain '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTicker',
                  content => 'QCPAxisTicker'
                },
                {
                  type => 'text',
                  content => ' subclasses.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The output parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is filled with the generated tick positions in axis coordinates. The output parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are optional (set them to 0 if not needed) and are respectively filled with sub tick coordinates, and tick label strings belonging to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' by index. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'subTicks',
                type => 'QVector< double > *'
              },
              {
                declaration_name => 'tickLabels',
                type => 'QVector< QString > *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'getTickStep',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplements => {
              name => 'getTickStep'
            }
          },
          {
            kind => 'function',
            name => 'getSubTickCount',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              }
            ],
            reimplemented_by => [
              {
                name => 'getSubTickCount'
              },
              {
                name => 'getSubTickCount'
              },
              {
                name => 'getSubTickCount'
              },
              {
                name => 'getSubTickCount'
              },
              {
                name => 'getSubTickCount'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getTickLabel',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QString',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tick',
                type => 'double'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ],
            reimplemented_by => [
              {
                name => 'getTickLabel'
              },
              {
                name => 'getTickLabel'
              },
              {
                name => 'getTickLabel'
              },
              {
                name => 'getTickLabel'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplemented_by => [
              {
                name => 'createTickVector'
              },
              {
                name => 'createTickVector'
              },
              {
                name => 'createTickVector'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createSubTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'subTickCount',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createLabelVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< QString >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'trimTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'keepOneOutlier',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pickClosest',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'target',
                type => 'double'
              },
              {
                declaration_name => 'candidates',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              },
              {
                declaration_name => 'magnitude',
                type => 'double *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'cleanMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mTickStep',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mScaleStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'ScaleStrategy'
          },
          {
            kind => 'variable',
            name => 'mTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy'
          },
          {
            kind => 'variable',
            name => 'mTickCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mTickOrigin',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Specialized axis ticker with a fixed tick step. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => ' subclass generates ticks with a fixed tick step set with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setTickStep'
              }
            ]
          },
          {
            type => 'text',
            content => '. It is also possible to allow integer multiples and integer powers of the specified tick step with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setScaleStrategy'
              }
            ]
          },
          {
            type => 'text',
            content => '.A typical application of this ticker is to make an axis only display integers, by setting the tick step of the ticker to 1.0 and the scale strategy to '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'ssMultiples'
              }
            ]
          },
          {
            type => 'text',
            content => '.Another case is when a certain number has a special meaning and axis ticks should only appear at multiples of that value. In this case you might also want to consider '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxisTickerPi'
              }
            ]
          },
          {
            type => 'text',
            content => ' because despite the name it is not limited to only pi symbols/values.The ticker can be created and assigned to an axis like this: '
          }
        ]
      }
    },
    {
      name => 'QCPAxisTickerLog',
      base => [
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'cleanMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createLabelVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createSubTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'generate',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getSubTickCount',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'getTickLabel',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getTickStep',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'logBase',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'mLogBase',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'mLogBaseLnInv',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'mSubTickCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'mTickCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickOrigin',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'pickClosest',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTickerLog',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'setLogBase',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'setSubTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'setTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'subTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerLog'
        },
        {
          name => 'tickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'TickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'trimTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssMeetTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssReadability',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => '~QCPAxisTicker',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'TickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the strategies that the axis ticker may follow when choosing the size of the tick step.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTicker_1a73b1d847c1a12159af6bfda4ebebe7d5',
                      content => 'setTickStepStrategy'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'tssReadability',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTickCount'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tssMeetTickCount',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'tssReadability',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tssMeetTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxisTickerLog',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1a4ee03fcd2c74d05cd1a419b9af5cfbdc',
                  content => 'QCPAxis::setTicker'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'logBase',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'subTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setLogBase',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the logarithm base used for tick coordinate generation. The ticks will be placed at integer powers of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'base'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'base',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSubTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the number of sub ticks in a tick interval. Within each interval, the sub ticks are spaced linearly to provide a better visual guide, so the sub tick density increases toward the higher tick.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is the number of sub ticks (not sub intervals) in one tick interval. So in the case of logarithm base 10 an intuitive sub tick spacing would be achieved with eight sub ticks (the default). This means e.g. between the ticks 10 and 100 there will be eight ticks, namely at 20, 30, 40, 50, 60, 70, 80 and 90. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'subTicks',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'tickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets which strategy the axis ticker follows when choosing the size of the tick step. For the available strategies, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'TickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'strategy',
                type => 'TickStepStrategy'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how many ticks this ticker shall aim to generate across the axis range. Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not guaranteed to be matched exactly, as generating readable tick intervals may conflict with the requested number of ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether the readability has priority over meeting the requested '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'count',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the mathematical coordinate (or "offset") of the zeroth tick. This tick coordinate is just a concept and doesn\'t need to be inside the currently visible axis range.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'By default '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is zero, which for example yields ticks {-5, 0, 5, 10, 15,...} when the tick step is five. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is now set to 1 instead, the correspondingly generated ticks would be {-4, 1, 6, 11, 16,...}. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'origin',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'generate',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This is the method called by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' in order to actually generate tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), tick label strings ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') and sub tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The ticks are generated for the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'range'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The generated labels typically follow the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'locale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatChar'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and number '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'precision'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', however this might be different (or even irrelevant) for certain '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTicker',
                  content => 'QCPAxisTicker'
                },
                {
                  type => 'text',
                  content => ' subclasses.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The output parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is filled with the generated tick positions in axis coordinates. The output parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are optional (set them to 0 if not needed) and are respectively filled with sub tick coordinates, and tick label strings belonging to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' by index. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'subTicks',
                type => 'QVector< double > *'
              },
              {
                declaration_name => 'tickLabels',
                type => 'QVector< QString > *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'getTickStep',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplements => {
              name => 'getTickStep'
            }
          },
          {
            kind => 'function',
            name => 'getSubTickCount',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              }
            ],
            reimplements => {
              name => 'getSubTickCount'
            }
          },
          {
            kind => 'function',
            name => 'createTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplements => {
              name => 'createTickVector'
            }
          },
          {
            kind => 'function',
            name => 'getTickLabel',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QString',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tick',
                type => 'double'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ],
            reimplemented_by => [
              {
                name => 'getTickLabel'
              },
              {
                name => 'getTickLabel'
              },
              {
                name => 'getTickLabel'
              },
              {
                name => 'getTickLabel'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createSubTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'subTickCount',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createLabelVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< QString >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'trimTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'keepOneOutlier',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pickClosest',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'target',
                type => 'double'
              },
              {
                declaration_name => 'candidates',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              },
              {
                declaration_name => 'magnitude',
                type => 'double *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'cleanMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mLogBase',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mSubTickCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mLogBaseLnInv',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy'
          },
          {
            kind => 'variable',
            name => 'mTickCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mTickOrigin',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Specialized axis ticker suited for logarithmic axes. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => ' subclass generates ticks with unequal tick intervals suited for logarithmic axis scales. The ticks are placed at powers of the specified log base ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setLogBase'
              }
            ]
          },
          {
            type => 'text',
            content => ').Especially in the case of a log base equal to 10 (the default), it might be desirable to have tick labels in the form of powers of ten without mantissa display. To achieve this, set the number precision ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxis::setNumberPrecision'
              }
            ]
          },
          {
            type => 'text',
            content => ') to zero and the number format ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxis::setNumberFormat'
              }
            ]
          },
          {
            type => 'text',
            content => ') to scientific (exponential) display with beautifully typeset decimal powers, so a format string of '
          },
          {
            type => 'style',
            style => 'code',
            enable => 'yes'
          },
          {
            type => 'text',
            content => '"eb"'
          },
          {
            type => 'style',
            style => 'code',
            enable => 'no'
          },
          {
            type => 'text',
            content => '. This will result in the following axis tick labels:'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The ticker can be created and assigned to an axis like this: '
          }
        ]
      }
    },
    {
      name => 'QCPAxisTickerPi',
      base => [
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'cleanMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createLabelVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createSubTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'FractionStyle',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'fractionStyle',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'fractionToString',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'fsAsciiFractions',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'fsFloatingPoint',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'fsUnicodeFractions',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'generate',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getSubTickCount',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'getTickLabel',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'getTickStep',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'mFractionStyle',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'mPeriodicity',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'mPiSymbol',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'mPiTickStep',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'mPiValue',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'mTickCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickOrigin',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'periodicity',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'pickClosest',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'piSymbol',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'piValue',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTickerPi',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'setFractionStyle',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'setPeriodicity',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'setPiSymbol',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'setPiValue',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'setTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'simplifyFraction',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'tickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'TickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'trimTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssMeetTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssReadability',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'unicodeFraction',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'unicodeSubscript',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => 'unicodeSuperscript',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerPi'
        },
        {
          name => '~QCPAxisTicker',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'FractionStyle',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines how fractions should be displayed in tick labels.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerPi_1a760c8af6ca68178e607556c4e5049d71',
                      content => 'setFractionStyle'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'fsFloatingPoint',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Fractions are displayed as regular decimal floating point numbers, e.g. "0.25" or "0.125". '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'fsAsciiFractions',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Fractions are written as rationals using ASCII characters only, e.g. "1/4" or "1/8". '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'fsUnicodeFractions',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Fractions are written using sub- and superscript UTF-8 digits and the fraction symbol. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'fsFloatingPoint',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Fractions are displayed as regular decimal floating point numbers, e.g. "0.25" or "0.125". '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'fsAsciiFractions',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Fractions are written as rationals using ASCII characters only, e.g. "1/4" or "1/8". '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'fsUnicodeFractions',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Fractions are written using sub- and superscript UTF-8 digits and the fraction symbol. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enum',
            name => 'TickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the strategies that the axis ticker may follow when choosing the size of the tick step.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTicker_1a73b1d847c1a12159af6bfda4ebebe7d5',
                      content => 'setTickStepStrategy'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'tssReadability',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTickCount'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tssMeetTickCount',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'tssReadability',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tssMeetTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxisTickerPi',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1a4ee03fcd2c74d05cd1a419b9af5cfbdc',
                  content => 'QCPAxis::setTicker'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'piSymbol',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'piValue',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'periodicity',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'fractionStyle',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'FractionStyle',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setPiSymbol',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how the symbol part (which is always a suffix to the number) shall appear in the axis tick label.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If a space shall appear between the number and the symbol, make sure the space is contained in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'symbol'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'symbol',
                type => 'QString'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setPiValue',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the numerical value that the symbolic constant has.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This will be used to place the appropriate fractions of the symbol at the respective axis coordinates. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pi',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setPeriodicity',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether the axis labels shall appear periodicly and if so, at which multiplicity of the symbolic constant.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'To disable periodicity, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'multiplesOfPi'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to zero.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, an axis that identifies 0 with 2pi would set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'multiplesOfPi'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to two. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'multiplesOfPi',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setFractionStyle',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how the numerical/fractional part preceding the symbolic constant is displayed in tick labels. See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'FractionStyle'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for the various options. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'style',
                type => 'FractionStyle'
              }
            ]
          },
          {
            kind => 'function',
            name => 'tickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets which strategy the axis ticker follows when choosing the size of the tick step. For the available strategies, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'TickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'strategy',
                type => 'TickStepStrategy'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets how many ticks this ticker shall aim to generate across the axis range. Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not guaranteed to be matched exactly, as generating readable tick intervals may conflict with the requested number of ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether the readability has priority over meeting the requested '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'count',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the mathematical coordinate (or "offset") of the zeroth tick. This tick coordinate is just a concept and doesn\'t need to be inside the currently visible axis range.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'By default '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is zero, which for example yields ticks {-5, 0, 5, 10, 15,...} when the tick step is five. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is now set to 1 instead, the correspondingly generated ticks would be {-4, 1, 6, 11, 16,...}. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'origin',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'generate',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This is the method called by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' in order to actually generate tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), tick label strings ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') and sub tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The ticks are generated for the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'range'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The generated labels typically follow the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'locale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatChar'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and number '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'precision'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', however this might be different (or even irrelevant) for certain '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTicker',
                  content => 'QCPAxisTicker'
                },
                {
                  type => 'text',
                  content => ' subclasses.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The output parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is filled with the generated tick positions in axis coordinates. The output parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are optional (set them to 0 if not needed) and are respectively filled with sub tick coordinates, and tick label strings belonging to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' by index. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'subTicks',
                type => 'QVector< double > *'
              },
              {
                declaration_name => 'tickLabels',
                type => 'QVector< QString > *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'getTickStep',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplements => {
              name => 'getTickStep'
            }
          },
          {
            kind => 'function',
            name => 'getSubTickCount',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              }
            ],
            reimplements => {
              name => 'getSubTickCount'
            }
          },
          {
            kind => 'function',
            name => 'getTickLabel',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QString',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tick',
                type => 'double'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'getTickLabel'
            }
          },
          {
            kind => 'function',
            name => 'simplifyFraction',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'numerator',
                type => 'int &'
              },
              {
                declaration_name => 'denominator',
                type => 'int &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'fractionToString',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'numerator',
                type => 'int'
              },
              {
                declaration_name => 'denominator',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'unicodeFraction',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'numerator',
                type => 'int'
              },
              {
                declaration_name => 'denominator',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'unicodeSuperscript',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'number',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'unicodeSubscript',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'number',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplemented_by => [
              {
                name => 'createTickVector'
              },
              {
                name => 'createTickVector'
              },
              {
                name => 'createTickVector'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createSubTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'subTickCount',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createLabelVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< QString >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'trimTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'keepOneOutlier',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pickClosest',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'target',
                type => 'double'
              },
              {
                declaration_name => 'candidates',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              },
              {
                declaration_name => 'magnitude',
                type => 'double *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'cleanMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mPiSymbol',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString'
          },
          {
            kind => 'variable',
            name => 'mPiValue',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mPeriodicity',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mFractionStyle',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'FractionStyle'
          },
          {
            kind => 'variable',
            name => 'mPiTickStep',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy'
          },
          {
            kind => 'variable',
            name => 'mTickCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mTickOrigin',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'text',
            content => 'Specialized axis ticker to display ticks in units of an arbitrary constant, for example pi. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => ' subclass generates ticks that are expressed with respect to a given symbolic constant with a numerical value specified with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setPiValue'
              }
            ]
          },
          {
            type => 'text',
            content => ' and an appearance in the tick labels specified with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setPiSymbol'
              }
            ]
          },
          {
            type => 'text',
            content => '.Ticks may be generated at fractions of the symbolic constant. How these fractions appear in the tick label can be configured with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setFractionStyle'
              }
            ]
          },
          {
            type => 'text',
            content => '.The ticker can be created and assigned to an axis like this: '
          }
        ]
      }
    },
    {
      name => 'QCPAxisTickerText',
      base => [
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'addTick',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'addTicks',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'addTicks',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'cleanMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'clear',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'createLabelVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createSubTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'generate',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getSubTickCount',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'getTickLabel',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'getTickStep',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'mSubTickCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'mTickCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickOrigin',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'mTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'pickClosest',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTickerText',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'setSubTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'setTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTicks',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'setTicks',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'setTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'subTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'tickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'ticks',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerText'
        },
        {
          name => 'tickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'TickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'trimTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssMeetTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssReadability',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => '~QCPAxisTicker',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'TickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the strategies that the axis ticker may follow when choosing the size of the tick step.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTicker_1a73b1d847c1a12159af6bfda4ebebe7d5',
                      content => 'setTickStepStrategy'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'tssReadability',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTickCount'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tssMeetTickCount',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'tssReadability',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tssMeetTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxisTickerText',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1a4ee03fcd2c74d05cd1a419b9af5cfbdc',
                  content => 'QCPAxis::setTicker'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'ticks',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a non-const reference to the internal map which stores the tick coordinates and their labels.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'You can access the map directly in order to add, remove or manipulate ticks, as an alternative to using the methods provided by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTickerText',
                  content => 'QCPAxisTickerText'
                },
                {
                  type => 'text',
                  content => ', such as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTicks'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'addTick'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QMap< double, QString > &',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'subTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setTicks',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the ticks that shall appear on the axis. The map key of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' corresponds to the axis coordinate, and the map value is the string that will appear as tick label.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'An alternative to manipulate ticks is to directly access the internal storage with the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'ticks'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' getter.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1aba34051300eecaefbedb2df8feff2d45',
                      content => 'addTicks'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1aada3db69e5fc6585aaa4ea5d89552eb0',
                      content => 'addTick'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1a21826d2fcd9a25c194d34d4f67aa1460',
                      content => 'clear'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticks',
                type => 'const QMap< double, QString > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTicks',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the ticks that shall appear on the axis. The entries of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'positions'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' correspond to the axis coordinates, and the entries of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'labels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are the respective strings that will appear as tick labels.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1aba34051300eecaefbedb2df8feff2d45',
                      content => 'addTicks'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1aada3db69e5fc6585aaa4ea5d89552eb0',
                      content => 'addTick'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1a21826d2fcd9a25c194d34d4f67aa1460',
                      content => 'clear'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'positions',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'labels',
                type => 'const QVector< QString >'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSubTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the number of sub ticks that shall appear between ticks. For '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTickerText',
                  content => 'QCPAxisTickerText'
                },
                {
                  type => 'text',
                  content => ', there is no automatic sub tick count calculation. So if sub ticks are needed, they must be configured with this method. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'subTicks',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'clear',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Clears all ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'An alternative to manipulate ticks is to directly access the internal storage with the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'ticks'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' getter.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1a8cdf1f21940f1f53f5e3d30b2c74f5cf',
                      content => 'setTicks'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1aba34051300eecaefbedb2df8feff2d45',
                      content => 'addTicks'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1aada3db69e5fc6585aaa4ea5d89552eb0',
                      content => 'addTick'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'addTick',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds a single tick to the axis at the given axis coordinate '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'position'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', with the provided tick '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'label'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1aba34051300eecaefbedb2df8feff2d45',
                      content => 'addTicks'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1a8cdf1f21940f1f53f5e3d30b2c74f5cf',
                      content => 'setTicks'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1a21826d2fcd9a25c194d34d4f67aa1460',
                      content => 'clear'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'position',
                type => 'double'
              },
              {
                declaration_name => 'label',
                type => 'QString'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addTicks',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds the provided '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to the ones already existing. The map key of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' corresponds to the axis coordinate, and the map value is the string that will appear as tick label.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'An alternative to manipulate ticks is to directly access the internal storage with the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'ticks'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' getter.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1aada3db69e5fc6585aaa4ea5d89552eb0',
                      content => 'addTick'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1a8cdf1f21940f1f53f5e3d30b2c74f5cf',
                      content => 'setTicks'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1a21826d2fcd9a25c194d34d4f67aa1460',
                      content => 'clear'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticks',
                type => 'const QMap< double, QString > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addTicks',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds the provided ticks to the ones already existing. The entries of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'positions'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' correspond to the axis coordinates, and the entries of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'labels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are the respective strings that will appear as tick labels.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'An alternative to manipulate ticks is to directly access the internal storage with the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'ticks'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' getter.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1aada3db69e5fc6585aaa4ea5d89552eb0',
                      content => 'addTick'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1a8cdf1f21940f1f53f5e3d30b2c74f5cf',
                      content => 'setTicks'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerText_1a21826d2fcd9a25c194d34d4f67aa1460',
                      content => 'clear'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'positions',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'labels',
                type => 'const QVector< QString > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'tickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets which strategy the axis ticker follows when choosing the size of the tick step. For the available strategies, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'TickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'strategy',
                type => 'TickStepStrategy'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how many ticks this ticker shall aim to generate across the axis range. Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not guaranteed to be matched exactly, as generating readable tick intervals may conflict with the requested number of ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether the readability has priority over meeting the requested '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'count',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the mathematical coordinate (or "offset") of the zeroth tick. This tick coordinate is just a concept and doesn\'t need to be inside the currently visible axis range.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'By default '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is zero, which for example yields ticks {-5, 0, 5, 10, 15,...} when the tick step is five. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is now set to 1 instead, the correspondingly generated ticks would be {-4, 1, 6, 11, 16,...}. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'origin',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'generate',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This is the method called by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' in order to actually generate tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), tick label strings ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') and sub tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The ticks are generated for the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'range'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The generated labels typically follow the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'locale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatChar'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and number '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'precision'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', however this might be different (or even irrelevant) for certain '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTicker',
                  content => 'QCPAxisTicker'
                },
                {
                  type => 'text',
                  content => ' subclasses.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The output parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is filled with the generated tick positions in axis coordinates. The output parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are optional (set them to 0 if not needed) and are respectively filled with sub tick coordinates, and tick label strings belonging to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' by index. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'subTicks',
                type => 'QVector< double > *'
              },
              {
                declaration_name => 'tickLabels',
                type => 'QVector< QString > *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'getTickStep',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Since the tick coordinates are provided externally, this method implementation does nothing.'
                }
              ]
            },
            type => 'virtual double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplements => {
              name => 'getTickStep'
            }
          },
          {
            kind => 'function',
            name => 'getSubTickCount',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the sub tick count that was configured with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSubTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                }
              ]
            },
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              }
            ],
            reimplements => {
              name => 'getSubTickCount'
            }
          },
          {
            kind => 'function',
            name => 'getTickLabel',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the tick label which corresponds to the key '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tick'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in the internal tick storage. Since the labels are provided externally, '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'locale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatChar'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'precision'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are ignored.'
                }
              ]
            },
            type => 'virtual QString',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tick',
                type => 'double'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'getTickLabel'
            }
          },
          {
            kind => 'function',
            name => 'createTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the externally provided tick coordinates which are in the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'range'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. If available, one tick above and below the range is provided in addition, to allow possible sub tick calculation. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickStep'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is ignored.'
                }
              ]
            },
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplements => {
              name => 'createTickVector'
            }
          },
          {
            kind => 'function',
            name => 'createSubTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'subTickCount',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createLabelVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< QString >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'trimTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'keepOneOutlier',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pickClosest',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'target',
                type => 'double'
              },
              {
                declaration_name => 'candidates',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              },
              {
                declaration_name => 'magnitude',
                type => 'double *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'cleanMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMap< double, QString >'
          },
          {
            kind => 'variable',
            name => 'mSubTickCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy'
          },
          {
            kind => 'variable',
            name => 'mTickCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mTickOrigin',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Specialized axis ticker which allows arbitrary labels at specified coordinates. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => ' subclass generates ticks which can be directly specified by the user as coordinates and associated strings. They can be passed as a whole with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setTicks'
              }
            ]
          },
          {
            type => 'text',
            content => ' or one at a time with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'addTick'
              }
            ]
          },
          {
            type => 'text',
            content => '. Alternatively you can directly access the internal storage via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'ticks'
              }
            ]
          },
          {
            type => 'text',
            content => ' and modify the tick/label data there.This is useful for cases where the axis represents categories rather than numerical values.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'If you are updating the ticks of this ticker regularly and in a dynamic fasion (e.g. dependent on the axis range), it is a sign that you should probably create an own ticker by subclassing '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => ', instead of using this one.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The ticker can be created and assigned to an axis like this: '
          }
        ]
      }
    },
    {
      name => 'QCPAxisTickerTime',
      base => [
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'cleanMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createLabelVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createSubTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'createTickVector',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'fieldWidth',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'generate',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getMantissa',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'getSubTickCount',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'getTickLabel',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'getTickStep',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'mBiggestUnit',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'mFieldWidth',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'mFormatPattern',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'mSmallestUnit',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'mTickCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickOrigin',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'mTimeFormat',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'pickClosest',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTicker',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'QCPAxisTickerTime',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'replaceUnit',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'setFieldWidth',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'setTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'setTimeFormat',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'tickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickOrigin',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'TickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tickStepStrategy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'timeFormat',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'TimeUnit',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'trimTicks',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssMeetTickCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tssReadability',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        },
        {
          name => 'tuDays',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'tuHours',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'tuMilliseconds',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'tuMinutes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => 'tuSeconds',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisTickerTime'
        },
        {
          name => '~QCPAxisTicker',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisTicker'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'TimeUnit',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the logical units in which fractions of time spans can be expressed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerTime_1adc13e54fc969be98a5c0e3fa0dbaa293',
                      content => 'setFieldWidth'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerTime_1a2f30b6e5125bce4256be9ce3177088ea',
                      content => 'setTimeFormat'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'tuMilliseconds',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Milliseconds, one thousandth of a second (%z in '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTimeFormat'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tuSeconds',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Seconds (%s in '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTimeFormat'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tuMinutes',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Minutes (%m in '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTimeFormat'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tuHours',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Hours (%h in '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTimeFormat'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tuDays',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Days (%d in '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTimeFormat'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'tuMilliseconds',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Milliseconds, one thousandth of a second (%z in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTimeFormat'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tuSeconds',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Seconds (%s in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTimeFormat'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tuMinutes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Minutes (%m in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTimeFormat'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tuHours',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Hours (%h in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTimeFormat'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tuDays',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Days (%d in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTimeFormat'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enum',
            name => 'TickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Defines the strategies that the axis ticker may follow when choosing the size of the tick step.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTicker_1a73b1d847c1a12159af6bfda4ebebe7d5',
                      content => 'setTickStepStrategy'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'tssReadability',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setTickCount'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'tssMeetTickCount',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'tssReadability',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A nicely readable tick step is prioritized over matching the requested number of ticks (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickCount'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'tssMeetTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Less readable tick steps are allowed which in turn facilitates getting closer to the requested tick count. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPAxisTickerTime',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs the ticker and sets reasonable default values. Axis tickers are commonly created managed by a QSharedPointer, which then can be passed to '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1a4ee03fcd2c74d05cd1a419b9af5cfbdc',
                  content => 'QCPAxis::setTicker'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'timeFormat',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'fieldWidth',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'unit',
                type => 'TimeUnit'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTimeFormat',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the format that will be used to display time in the tick labels.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The available patterns are:'
                },
                {
                  type => 'list',
                  style => 'itemized',
                  content => [
                    [
                      {
                        type => 'text',
                        content => '%z for milliseconds'
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => '%s for seconds'
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => '%m for minutes'
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => '%h for hours'
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => '%d for days'
                      }
                    ]
                  ]
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The field width (zero padding) can be controlled for each unit with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setFieldWidth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The largest unit that appears in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'format'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will carry all the remaining time of a certain tick coordinate, even if it overflows the natural limit of the unit. For example, if %m is the largest unit it might become larger than 59 in order to consume larger time values. If on the other hand %h is available, the minutes will wrap around to zero after 59 and the time will carry to the hour digit. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'format',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setFieldWidth',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the field widh of the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'unit'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to be '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'width'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' digits, when displayed in the tick label. If the number for the specific unit is shorter than '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'width'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', it will be padded with an according number of zeros to the left in order to reach the field width.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisTickerTime_1a2f30b6e5125bce4256be9ce3177088ea',
                      content => 'setTimeFormat'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'unit',
                type => 'TimeUnit'
              },
              {
                declaration_name => 'width',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'tickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets which strategy the axis ticker follows when choosing the size of the tick step. For the available strategies, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'TickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'strategy',
                type => 'TickStepStrategy'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how many ticks this ticker shall aim to generate across the axis range. Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not guaranteed to be matched exactly, as generating readable tick intervals may conflict with the requested number of ticks.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether the readability has priority over meeting the requested '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'count'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setTickStepStrategy'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'count',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTickOrigin',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the mathematical coordinate (or "offset") of the zeroth tick. This tick coordinate is just a concept and doesn\'t need to be inside the currently visible axis range.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'By default '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is zero, which for example yields ticks {-5, 0, 5, 10, 15,...} when the tick step is five. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'origin'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is now set to 1 instead, the correspondingly generated ticks would be {-4, 1, 6, 11, 16,...}. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'origin',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'generate',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This is the method called by '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' in order to actually generate tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), tick label strings ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') and sub tick coordinates ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The ticks are generated for the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'range'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The generated labels typically follow the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'locale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'formatChar'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and number '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'precision'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', however this might be different (or even irrelevant) for certain '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisTicker',
                  content => 'QCPAxisTicker'
                },
                {
                  type => 'text',
                  content => ' subclasses.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The output parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is filled with the generated tick positions in axis coordinates. The output parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'subTicks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'tickLabels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are optional (set them to 0 if not needed) and are respectively filled with sub tick coordinates, and tick label strings belonging to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'ticks'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' by index. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'subTicks',
                type => 'QVector< double > *'
              },
              {
                declaration_name => 'tickLabels',
                type => 'QVector< QString > *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'getTickStep',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplements => {
              name => 'getTickStep'
            }
          },
          {
            kind => 'function',
            name => 'getSubTickCount',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              }
            ],
            reimplements => {
              name => 'getSubTickCount'
            }
          },
          {
            kind => 'function',
            name => 'getTickLabel',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QString',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tick',
                type => 'double'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'getTickLabel'
            }
          },
          {
            kind => 'function',
            name => 'replaceUnit',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'text',
                type => 'QString &'
              },
              {
                declaration_name => 'unit',
                type => 'TimeUnit'
              },
              {
                declaration_name => 'value',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'tickStep',
                type => 'double'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              }
            ],
            reimplemented_by => [
              {
                name => 'createTickVector'
              },
              {
                name => 'createTickVector'
              },
              {
                name => 'createTickVector'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createSubTickVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< double >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'subTickCount',
                type => 'int'
              },
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'createLabelVector',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QVector< QString >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'ticks',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'locale',
                type => 'const QLocale &'
              },
              {
                declaration_name => 'formatChar',
                type => 'QChar'
              },
              {
                declaration_name => 'precision',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'trimTicks',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'ticks',
                type => 'QVector< double > &'
              },
              {
                declaration_name => 'keepOneOutlier',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pickClosest',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'target',
                type => 'double'
              },
              {
                declaration_name => 'candidates',
                type => 'const QVector< double > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              },
              {
                declaration_name => 'magnitude',
                type => 'double *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'cleanMantissa',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'input',
                type => 'double'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mTimeFormat',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString'
          },
          {
            kind => 'variable',
            name => 'mFieldWidth',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< TimeUnit, int >'
          },
          {
            kind => 'variable',
            name => 'mSmallestUnit',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TimeUnit'
          },
          {
            kind => 'variable',
            name => 'mBiggestUnit',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TimeUnit'
          },
          {
            kind => 'variable',
            name => 'mFormatPattern',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< TimeUnit, QString >'
          },
          {
            kind => 'variable',
            name => 'mTickStepStrategy',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'TickStepStrategy'
          },
          {
            kind => 'variable',
            name => 'mTickCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mTickOrigin',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'text',
            content => 'Specialized axis ticker for time spans in units of milliseconds to days. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'This '
          },
          {
            type => 'url',
            link => 'classQCPAxisTicker',
            content => 'QCPAxisTicker'
          },
          {
            type => 'text',
            content => ' subclass generates ticks that corresponds to time intervals.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The format of the time display in the tick labels is controlled with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setTimeFormat'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setFieldWidth'
              }
            ]
          },
          {
            type => 'text',
            content => '. The time coordinate is in the unit of seconds with respect to the time coordinate zero. Unlike with '
          },
          {
            type => 'url',
            link => 'classQCPAxisTickerDateTime',
            content => 'QCPAxisTickerDateTime'
          },
          {
            type => 'text',
            content => ', the ticks don\'t correspond to a specific calendar date and time.The time can be displayed in milliseconds, seconds, minutes, hours and days. Depending on the largest available unit in the format specified with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setTimeFormat'
              }
            ]
          },
          {
            type => 'text',
            content => ', any time spans above will be carried in that largest unit. So for example if the format string is "%m:%s" and a tick at coordinate value 7815 (being 2 hours, 10 minutes and 15 seconds) is created, the resulting tick label will show "130:15" (130 minutes, 15 seconds). If the format string is "%h:%m:%s", the hour unit will be used and the label will thus be "02:10:15". Negative times with respect to the axis zero will carry a leading minus sign.The ticker can be created and assigned to an axis like this:  Here is an example of a time axis providing time information in days, hours and minutes. Due to the axis range spanning a few days and the wanted tick count ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setTickCount'
              }
            ]
          },
          {
            type => 'text',
            content => '), the ticker decided to use tick steps of 12 hours:'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The format string for this example is  '
          },
          {
            note => [
              {
                type => 'text',
                content => 'If you rather wish to display calendar dates and times, have a look at '
              },
              {
                type => 'url',
                link => 'classQCPAxisTickerDateTime',
                content => 'QCPAxisTickerDateTime'
              },
              {
                type => 'text',
                content => ' instead. '
              }
            ]
          }
        ]
      }
    },
    {
      name => 'QCPBars',
      base => [
        {
          name => 'QCPAbstractPlottable1D< QCPBarsData >',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'addData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'addData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'addToLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'addToLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'antialiasedFill',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'antialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyFillAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyScattersAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'barAbove',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'barBelow',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'barsGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'baseValue',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'brush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'connectBars',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'coordsToPixels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'coordsToPixels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'data',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'dataCount',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'dataMainKey',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'dataMainValue',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'dataPixelPosition',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'dataSortKey',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'dataValueRange',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'draw',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'drawLegendIcon',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'drawPolyline',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'findBegin',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'findEnd',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'getBarRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'getDataSegments',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'getKeyRange',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'getPixelWidth',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'getStackedBaseValue',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'getValueRange',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'getVisibleDataBounds',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'interface1D',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'keyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mAntialiasedFill',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mAntialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mBarAbove',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'mBarBelow',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'mBarsGroup',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'mBaseValue',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'mBrush',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mDataContainer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'mKeyAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mName',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'moveAbove',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'moveBelow',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelectable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelection',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelectionDecorator',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mStackingGap',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'mValueAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mWidth',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'mWidthType',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'name',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'pen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'pixelsToCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'pixelsToCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCPAbstractPlottable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCPAbstractPlottable1D',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'QCPBars',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'QCPBarsGroup',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'QCPLegend',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'QCustomPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBars'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'removeFromLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'removeFromLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleKeyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleValueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectableChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selected',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selection',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionDecorator',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectTest',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'selectTestRect',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setAntialiasedFill',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setAntialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setBarsGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'setBaseValue',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'setBrush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'setData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'setKeyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setName',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelection',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelectionDecorator',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setStackingGap',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'setValueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setWidth',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'setWidthType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'sortKeyIsMainKey',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => 'stackingGap',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'valueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'width',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'widthType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'WidthType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'wtAbsolute',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'wtAxisRectRatio',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => 'wtPlotCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => '~QCPAbstractPlottable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => '~QCPAbstractPlottable1D',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable1D< QCPBarsData >'
        },
        {
          name => '~QCPBars',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPBars'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPPlottableInterface1D',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPPlottableInterface1D'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'WidthType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Defines the ways the width of the bar can be specified. Thus it defines what the number passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setWidth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' actually means.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBars_1adcaa3b41281bb2c0f7949b341592fcc0',
                      content => 'setWidthType'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1afec6116579d44d5b706e0fa5e5332507',
                      content => 'setWidth'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'wtAbsolute',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Bar width is in absolute pixels. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'wtAxisRectRatio',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Bar width is given by a fraction of the axis rect size. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'wtPlotCoords',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Bar width is in key coordinates and thus scales with the key axis range. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'wtAbsolute',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Bar width is in absolute pixels. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'wtAxisRectRatio',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Bar width is given by a fraction of the axis rect size. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'wtPlotCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Bar width is in key coordinates and thus scales with the key axis range. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPBars',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a bar chart which uses '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as its key axis ("x") and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as its value axis ("y"). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' must reside in the same '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The created '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ' is automatically registered with the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' instance inferred from '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' instance takes ownership of the '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ', so do not delete it manually but use '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af3dafd56884208474f311d6226513ab2',
                  content => 'QCustomPlot::removePlottable()'
                },
                {
                  type => 'text',
                  content => ' instead. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyAxis',
                type => 'QCPAxis *'
              },
              {
                declaration_name => 'valueAxis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPBars',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'width',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'widthType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'WidthType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'barsGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPBarsGroup *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'baseValue',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'stackingGap',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'barBelow',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the bars plottable that is directly below this bars plottable. If there is no such plottable, returns 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBars_1ab97f2acd9f6cb40d2cc3c33d278f0e78',
                      content => 'barAbove'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1a69fc371346980f19177c3d1ecdad78ee',
                      content => 'moveBelow'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1ac22e00a6a41509538c21b04f0a57318c',
                      content => 'moveAbove'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPBars *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'barAbove',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the bars plottable that is directly above this bars plottable. If there is no such plottable, returns 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBars_1a1b58664864b141f45e02044a855b3213',
                      content => 'barBelow'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1a69fc371346980f19177c3d1ecdad78ee',
                      content => 'moveBelow'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1ac22e00a6a41509538c21b04f0a57318c',
                      content => 'moveAbove'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPBars *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'data',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a shared pointer to the internal data storage of type '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBarsDataContainer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setData'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'addData'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' methods. '
                }
              ]
            },
            type => 'QSharedPointer< QCPBarsDataContainer >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Replaces the current data container with the provided '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'data'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' container.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Since a QSharedPointer is used, multiple '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ' may share the same data container safely. Modifying the data in the container will then affect all bars that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers:  If you do not wish to share containers, but create a copy from an existing container, rather use the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer<DataType>::set'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' method on the bar\'s data container directly:  '
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBars_1a323d6970d6d6e3166d89916a7f60f733',
                      content => 'addData'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'data',
                type => 'QSharedPointer< QCPBarsDataContainer >'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Replaces the current data with the provided points in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keys'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'values'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If you can guarantee that the passed data points are sorted by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keys'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in ascending order, you can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alreadySorted'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to true, to improve performance by saving a sorting run.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBars_1a323d6970d6d6e3166d89916a7f60f733',
                      content => 'addData'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keys',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'values',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'alreadySorted',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setWidth',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the width of the bars.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'How the number passed as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'width'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is interpreted (e.g. screen pixels, plot coordinates,...), depends on the currently set width type, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setWidthType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'WidthType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setWidthType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how the width of the bars is defined. See the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'WidthType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for an explanation of the possible values for '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'widthType'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The default value is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'wtPlotCoords'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBars_1afec6116579d44d5b706e0fa5e5332507',
                      content => 'setWidth'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'widthType',
                type => 'WidthType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBarsGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets to which '
                },
                {
                  type => 'url',
                  link => 'classQCPBarsGroup',
                  content => 'QCPBarsGroup'
                },
                {
                  type => 'text',
                  content => ' this '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ' instance belongs to. Alternatively, you can also use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBarsGroup::append'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.To remove this '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ' from any group, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'barsGroup'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to 0. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'barsGroup',
                type => 'QCPBarsGroup *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBaseValue',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the base value of this bars plottable.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The base value defines where on the value coordinate the bars start. How far the bars extend from the base value is given by their individual value data. For example, if the base value is set to 1, a bar with data value 2 will have its lowest point at value coordinate 1 and highest point at 3.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For stacked bars, only the base value of the bottom-most '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ' has meaning.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default base value is 0. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'baseValue',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setStackingGap',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'If this bars plottable is stacked on top of another bars plottable ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'moveAbove'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this method allows specifying a distance in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pixels'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', by which the drawn bar rectangles will be separated by the bars below it. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pixels',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds the provided points in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keys'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'values'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to the current data. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If you can guarantee that the passed data points are sorted by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keys'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in ascending order, you can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alreadySorted'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to true, to improve performance by saving a sorting run.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Alternatively, you can also access and modify the data directly via the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'data'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' method, which returns a pointer to the internal data container. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keys',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'values',
                type => 'const QVector< double > &'
              },
              {
                declaration_name => 'alreadySorted',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Adds the provided data point as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to the current data.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Alternatively, you can also access and modify the data directly via the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'data'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' method, which returns a pointer to the internal data container. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveBelow',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Moves this bars plottable below '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. In other words, the bars of this plottable will appear below the bars of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The move target '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' must use the same key and value axis as this plottable.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Inserting into and removing from existing bar stacking is handled gracefully. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' already has a bars object below itself, this bars object is inserted between the two. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'To remove this bars plottable from any stacking, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBars_1a69fc371346980f19177c3d1ecdad78ee',
                      content => 'moveBelow'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1ab97f2acd9f6cb40d2cc3c33d278f0e78',
                      content => 'barAbove'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1a1b58664864b141f45e02044a855b3213',
                      content => 'barBelow'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'bars',
                type => 'QCPBars *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveAbove',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Moves this bars plottable above '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. In other words, the bars of this plottable will appear above the bars of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The move target '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' must use the same key and value axis as this plottable.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Inserting into and removing from existing bar stacking is handled gracefully. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' already has a bars object above itself, this bars object is inserted between the two. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'To remove this bars plottable from any stacking, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBars_1a69fc371346980f19177c3d1ecdad78ee',
                      content => 'moveBelow'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1a1b58664864b141f45e02044a855b3213',
                      content => 'barBelow'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1ab97f2acd9f6cb40d2cc3c33d278f0e78',
                      content => 'barAbove'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'bars',
                type => 'QCPBars *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectTestRect',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a data selection containing all the data points of this plottable which are contained (or hit by) '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'rect'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This is used mainly in the selection rect interaction for data selection ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'data selection mechanism'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlySelectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, an empty '
                },
                {
                  type => 'url',
                  link => 'classQCPDataSelection',
                  content => 'QCPDataSelection'
                },
                {
                  type => 'text',
                  content => ' is returned if this plottable is not selectable (i.e. if '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAbstractPlottable::setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::stNone'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  note => [
                    {
                      type => 'style',
                      style => 'italic',
                      enable => 'yes'
                    },
                    {
                      type => 'text',
                      content => 'rect'
                    },
                    {
                      type => 'style',
                      style => 'italic',
                      enable => 'no'
                    },
                    {
                      type => 'text',
                      content => ' must be a normalized rect (positive or zero width and height). This is especially important when using the rect of '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'QCPSelectionRect::accepted'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ', which is not necessarily normalized. Use '
                    },
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'yes'
                    },
                    {
                      type => 'text',
                      content => 'QRect::normalized()'
                    },
                    {
                      type => 'style',
                      style => 'code',
                      enable => 'no'
                    },
                    {
                      type => 'text',
                      content => ' when passing a rect which might not be normalized. '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QCPDataSelection',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'rect',
                type => 'const QRectF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              }
            ],
            reimplements => {
              name => 'selectTestRect'
            }
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry.'
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            }
          },
          {
            kind => 'function',
            name => 'getKeyRange',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to either '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdPositive'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and all positive points will be ignored for range calculation. For no restriction, just set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdBoth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (default). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn\'t use the returned range (e.g. no points in data).Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not the same as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', since the range returned by this function may have size zero (e.g. when there is only one data point). In this case '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' would return true, but the returned range is not a valid range in terms of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a1491c4a606bccd2d09e65e11b79eb882',
                      content => 'rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1a02cee4bf94d48a1e5f6fc185d9a10477',
                      content => 'getValueRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'foundRange',
                type => 'bool &'
              },
              {
                declaration_name => 'inSignDomain',
                type => 'QCP::SignDomain',
                default_value => 'QCP::sdBoth'
              }
            ],
            reimplements => {
              name => 'getKeyRange'
            }
          },
          {
            kind => 'function',
            name => 'getValueRange',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the coordinate range that the data points in the specified key range ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') span in the value axis dimension. For logarithmic plots, one can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to either '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdPositive'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and all positive points will be ignored for range calculation. For no restriction, just set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdBoth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (default). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn\'t use the returned range (e.g. no points in data).If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' has both lower and upper bound set to zero (is equal to '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'url',
                  link => 'classQCPRange',
                  content => 'QCPRange()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), all data points are considered, without any restriction on the keys.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not the same as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', since the range returned by this function may have size zero (e.g. when there is only one data point). In this case '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' would return true, but the returned range is not a valid range in terms of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a1491c4a606bccd2d09e65e11b79eb882',
                      content => 'rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBars_1ac5a3854774d9d9cd129b1eae1426de2d',
                      content => 'getKeyRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'foundRange',
                type => 'bool &'
              },
              {
                declaration_name => 'inSignDomain',
                type => 'QCP::SignDomain',
                default_value => 'QCP::sdBoth'
              },
              {
                declaration_name => 'inKeyRange',
                type => 'const QCPRange &',
                default_value => 'QCPRange()'
              }
            ],
            reimplements => {
              name => 'getValueRange'
            }
          },
          {
            kind => 'function',
            name => 'dataPixelPosition',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the pixel position on the widget surface at which the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' appears.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Usually this corresponds to the point of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'dataMainKey'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '/'
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'dataMainValue'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', in pixel coordinates. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values. For example, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' apparent data values can be shifted depending on their stacking, bar grouping or configured base value. '
                }
              ]
            },
            type => 'virtual QPointF',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataPixelPosition'
            }
          },
          {
            kind => 'function',
            name => 'dataCount',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the number of data points of the plottable. '
                }
              ]
            },
            type => 'virtual int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'dataCount'
            }
          },
          {
            kind => 'function',
            name => 'dataMainKey',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the main key of the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'What the main key is, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataMainKey'
            }
          },
          {
            kind => 'function',
            name => 'dataSortKey',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the sort key of the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'What the sort key is, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataSortKey'
            }
          },
          {
            kind => 'function',
            name => 'dataMainValue',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the main value of the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'What the main value is, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataMainValue'
            }
          },
          {
            kind => 'function',
            name => 'dataValueRange',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the value range of the data point at the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'What the value range is, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ],
            reimplements => {
              name => 'dataValueRange'
            }
          },
          {
            kind => 'function',
            name => 'sortKeyIsMainKey',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether the sort key ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'dataSortKey'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') is identical to the main key ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'dataMainKey'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').What the sort and main keys are, is defined by the plottable\'s data type. See the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer DataType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' documentation for details about this naming convention. '
                }
              ]
            },
            type => 'virtual bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'sortKeyIsMainKey'
            }
          },
          {
            kind => 'function',
            name => 'findBegin',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the index of the data point with a (sort-)key that is equal to, just below, or just above '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'expandedRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, the data point just below '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will be considered, otherwise the one just above.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This can be used in conjunction with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'findEnd'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to iterate over data points within a given key range, including or excluding the bounding data points that are just beyond the specified range.If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'expandedRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true but there are no data points below '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', 0 is returned.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the container is empty, returns 0 (in that case, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'findEnd'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' will also return 0, so a loop using these methods will not iterate over the index 0).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable1D_1a6e3ba20c9160d7361e58070390d10b1a',
                      content => 'findEnd'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPDataContainer_1a2ad8a5399072d99a242d3a6d2d7e278a',
                      content => 'QCPDataContainer::findBegin'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual int',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sortKey',
                type => 'double'
              },
              {
                declaration_name => 'expandedRange',
                type => 'bool',
                default_value => 'true'
              }
            ],
            reimplements => {
              name => 'findBegin'
            }
          },
          {
            kind => 'function',
            name => 'findEnd',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
              ]
            },
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the index one after the data point with a (sort-)key that is equal to, just above, or just below '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'expandedRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, the data point just above '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will be considered, otherwise the one just below.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This can be used in conjunction with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'findBegin'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to iterate over data points within a given key range, including the bounding data points that are just below and above the specified range.If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'expandedRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true but there are no data points above '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', the index just above the highest data point is returned.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the container is empty, returns 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable1D_1ad0b46d25cde3d035b180fb8f10c056e6',
                      content => 'findBegin'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPDataContainer_1afb8b8f23cc2b7234a793a25ce79fe48f',
                      content => 'QCPDataContainer::findEnd'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual int',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sortKey',
                type => 'double'
              },
              {
                declaration_name => 'expandedRange',
                type => 'bool',
                default_value => 'true'
              }
            ],
            reimplements => {
              name => 'findEnd'
            }
          },
          {
            kind => 'function',
            name => 'interface1D',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableInterface1D'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' pointer to this plottable, providing access to its 1D interface.'
                }
              ]
            },
            type => 'virtual QCPPlottableInterface1D *',
            const => 'no',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'interface1D'
            }
          },
          {
            kind => 'function',
            name => 'name',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiasedFill',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'pen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'brush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'keyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'valueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::SelectionType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selected',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns true if there are any data points of the plottable currently selected. Use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to retrieve the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selection',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' encompassing all the data points that are currently selected on this plottable.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a0b3b514474fe93354fc74cfc144184b4',
                      content => 'selected'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPDataSelection',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectionDecorator',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Provides access to the selection decorator of this plottable. The selection decorator controls how selected data ranges are drawn (e.g. their pen color and fill), see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for details.If you wish to use an own '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass, pass an instance of it to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QCPSelectionDecorator *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setName',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The name is the textual representation of this plottable as it is displayed in the legend ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLegend'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). It may contain any UTF-8 characters, including newlines. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'name',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiasedFill',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether fills of this plottable are drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that this setting may be overridden by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setNotAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether the scatter symbols of this plottable are drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that this setting may be overridden by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setNotAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The pen is used to draw basic lines that make up the plottable representation in the plot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass draws its graph lines with this pen.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a7a4b92144dca6453a1f0f210e27edc74',
                      content => 'setBrush'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBrush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass draws the fill under the graph with this brush, when it\'s not set to Qt::NoBrush.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ab74b09ae4c0e7e13142fe4b5bf46cac7',
                      content => 'setPen'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'brush',
                type => 'const QBrush &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setKeyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The key axis of a plottable can be set to any axis of a '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ', as long as it is orthogonal to the plottable\'s value axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1a9a79cd0158a4c7f30cbc702f0fd800e4',
                  content => 'QCustomPlot::xAxis'
                },
                {
                  type => 'text',
                  content => ') as key axis and the y-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6fea5679725b152c14facd920b19367',
                  content => 'QCustomPlot::yAxis'
                },
                {
                  type => 'text',
                  content => ') as value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Normally, the key and value axes are set in the constructor of the plottable (or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::addGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when working with QCPGraphs through the dedicated graph interface).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a71626a07367e241ec62ad2c34baf21cb',
                      content => 'setValueAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setValueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The value axis of a plottable can be set to any axis of a '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ', as long as it is orthogonal to the plottable\'s key axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1a9a79cd0158a4c7f30cbc702f0fd800e4',
                  content => 'QCustomPlot::xAxis'
                },
                {
                  type => 'text',
                  content => ') as key axis and the y-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6fea5679725b152c14facd920b19367',
                  content => 'QCustomPlot::yAxis'
                },
                {
                  type => 'text',
                  content => ') as value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Normally, the key and value axes are set in the constructor of the plottable (or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::addGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when working with QCPGraphs through the dedicated graph interface).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a8524fa2994c63c0913ebd9bb2ffa3920',
                      content => 'setKeyAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether and to which granularity this plottable can be selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A selection can happen by clicking on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iSelectPlottables'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), by dragging a selection rect (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setSelectionRectMode'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::srmSelect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), or programmatically by calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'namespaceQCP_1ac6cb9db26a564b27feda362a438db038',
                      content => 'QCP::SelectionType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'QCP::SelectionType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelection',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets which data ranges of this plottable are selected. Selected data ranges are drawn differently (e.g. color) in the plot. This can be controlled via the selection decorator (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').The entire selection mechanism for plottables is handled automatically when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains iSelectPlottables. You only need to call this function when you wish to change the selection state programmatically.Using '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' you can further specify for each plottable whether and to which granularity it is selectable. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selection'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not compatible with the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::SelectionType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the resulting selection will be adjusted accordingly (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection::enforceType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').emits the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionChanged'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' signal when '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is different from the previous selection state.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a38efe9641d972992a3d44204bc80ec1d',
                      content => 'selectTest'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selection',
                type => 'QCPDataSelection'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectionDecorator',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Use this method to set an own '
                },
                {
                  type => 'url',
                  link => 'classQCPSelectionDecorator',
                  content => 'QCPSelectionDecorator'
                },
                {
                  type => 'text',
                  content => ' (subclass) instance. This allows you to customize the visual representation of selected data ranges further than by using the default '
                },
                {
                  type => 'url',
                  link => 'classQCPSelectionDecorator',
                  content => 'QCPSelectionDecorator'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The plottable takes ownership of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'decorator'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The currently set decorator can be accessed via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'decorator',
                type => 'QCPSelectionDecorator *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'coordsToPixels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Convenience function for transforming a key/value pair to pixels on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are transformed to the coodinates in pixels and are written to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'x'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'y'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3903c1120ab5c27e7fa46b597ef267bd',
                      content => 'pixelsToCoords'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                      content => 'QCPAxis::coordToPixel'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              },
              {
                declaration_name => 'x',
                type => 'double &'
              },
              {
                declaration_name => 'y',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'coordsToPixels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Transforms the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to pixel coordinates and returns them in a QPointF. '
                }
              ]
            },
            type => 'const QPointF',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pixelsToCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Convenience function for transforming a x/y pixel pair on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface to plot coordinates, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'x'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'y'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are transformed to the plot coodinates and are written to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a7ad84a36472441cf1f555c5683d0da93',
                      content => 'coordsToPixels'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                      content => 'QCPAxis::coordToPixel'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'x',
                type => 'double'
              },
              {
                declaration_name => 'y',
                type => 'double'
              },
              {
                declaration_name => 'key',
                type => 'double &'
              },
              {
                declaration_name => 'value',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pixelsToCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel input '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pixelPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as plot coordinates '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pixelPos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'key',
                type => 'double &'
              },
              {
                declaration_name => 'value',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i.e. a range containing different signs and/or zero. Instead it will stay in the current sign domain and ignore all parts of the plottable that lie outside of that domain.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlyEnlarge'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' makes sure the ranges are only expanded, never reduced. So it\'s possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlyEnlarge'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' set to false (the default), and all subsequent set to true.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ae96b83c961e257da116c6acf9c7da308',
                      content => 'rescaleKeyAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a714eaf36b12434cd71846215504db82e',
                      content => 'rescaleValueAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1ad86528f2cee6c7e446dea4a6e8839935',
                      content => 'QCustomPlot::rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a499345f02ebce4b23d8ccec96e58daa9',
                      content => 'QCPAxis::rescale'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleKeyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Rescales the key axis of the plottable so the whole plottable is visible.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for detailed behaviour. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleValueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Rescales the value axis of the plottable so the whole plottable is visible. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to true, only the data points which are in the currently visible key axis range are considered.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the axis was actually scaled. This might not be the case if this plottable has an invalid range, e.g. because it has no data points.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for detailed behaviour. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              },
              {
                declaration_name => 'inKeyRange',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addToLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds this plottable to the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'legend'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Creates a '
                },
                {
                  type => 'url',
                  link => 'classQCPPlottableLegendItem',
                  content => 'QCPPlottableLegendItem'
                },
                {
                  type => 'text',
                  content => ' which is inserted into the legend. Returns true on success, i.e. when the legend exists and a legend item associated with this plottable isn\'t already in the legend.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the plottable needs a more specialized representation in the legend, you can create a corresponding subclass of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableLegendItem'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and add it to the legend manually instead of calling this method.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3cc235007e2343a65ad4f463767e0e20',
                      content => 'removeFromLegend'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1a3ab274de52d2951faea45a6d975e6b3f',
                      content => 'QCPLegend::addItem'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'legend',
                type => 'QCPLegend *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addToLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds this plottable to the legend of the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::legend'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3cc235007e2343a65ad4f463767e0e20',
                      content => 'removeFromLegend'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'removeFromLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the plottable from the specifed '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'legend'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This means the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableLegendItem'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' that is associated with this plottable is removed.Returns true on success, i.e. if the legend exists and a legend item associated with this plottable was found and removed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1aa64e93cb5b606d8110d2cc0a349bb30f',
                      content => 'addToLegend'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1ac91595c3eaa746fe6321d2eb952c63bb',
                      content => 'QCPLegend::removeItem'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'legend',
                type => 'QCPLegend *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'removeFromLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the plottable from the legend of the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1aa64e93cb5b606d8110d2cc0a349bb30f',
                      content => 'addToLegend'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates whether there are any points selected or not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a787a9c39421059006891744b731fa473',
                      content => 'selectionChanged(const QCPDataSelection &selection)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selected',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selection'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' holds the currently selected data ranges.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3af66432b1dca93b28e00e78a8c7c1d9',
                      content => 'selectionChanged(bool selected)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selection',
                type => 'const QCPDataSelection &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectableChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the selectability of this plottable has changed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'QCP::SelectionType'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'draw'
            }
          },
          {
            kind => 'function',
            name => 'drawLegendIcon',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'rect',
                type => 'const QRectF &'
              }
            ],
            reimplements => {
              name => 'drawLegendIcon'
            }
          },
          {
            kind => 'function',
            name => 'getVisibleDataBounds',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'begin',
                type => 'QCPBarsDataContainer::const_iterator &'
              },
              {
                declaration_name => 'end',
                type => 'QCPBarsDataContainer::const_iterator &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getBarRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRectF',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getPixelWidth',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'lower',
                type => 'double &'
              },
              {
                declaration_name => 'upper',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getStackedBaseValue',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'positive',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getDataSegments',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Splits all data into selected and unselected segments and outputs them via '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selectedSegments'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'unselectedSegments'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', respectively.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This is useful when subclasses implement their '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'draw'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' method and need to draw selected segments with a different pen/brush than unselected segments (also see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectedSegments',
                type => 'QList< QCPDataRange > &'
              },
              {
                declaration_name => 'unselectedSegments',
                type => 'QList< QCPDataRange > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'drawPolyline',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'A helper method which draws a line with the passed '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'painter'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', according to the pixel data in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'lineData'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. NaN points create gaps in the line, as expected from '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '\'s plottables (this is the main difference to QPainter\'s regular drawPolyline, which handles NaNs by lagging or crashing).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Further it uses a faster line drawing technique based on '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPainter::drawLine'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' rather than '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QPainter::drawPolyline'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' if the configured '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setPlottingHints()'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'painter'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' style allows. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'lineData',
                type => 'const QVector< QPointF > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'clipRect',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'clipRect'
            }
          },
          {
            kind => 'function',
            name => 'selectionCategory',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QCP::Interaction',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'selectionCategory'
            }
          },
          {
            kind => 'function',
            name => 'applyDefaultAntialiasingHint',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'applyDefaultAntialiasingHint'
            }
          },
          {
            kind => 'function',
            name => 'selectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'additive',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              },
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'selectEvent'
            }
          },
          {
            kind => 'function',
            name => 'deselectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'deselectEvent'
            }
          },
          {
            kind => 'function',
            name => 'applyFillAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyScattersAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'parentPlotInitialized',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ],
            reimplemented_by => [
              {
                name => 'parentPlotInitialized'
              },
              {
                name => 'parentPlotInitialized'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mousePressEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).'
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' uses an event propagation system that works the same as Qt\'s system. If your layerable doesn\'t reimplement the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or explicitly calls '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in its reimplementation, the event will be propagated to the next layerable in the stacking order.Once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseMoveEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseReleaseEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseDoubleClickEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called instead of the second '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. So in the case of a double-click, the event succession is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pressEvent - releaseEvent - doubleClickEvent - releaseEvent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).Similarly to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseDoubleClickEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'wheelEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QWheelEvent *'
              }
            ],
            reimplemented_by => [
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'initializeParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentLayerable',
                type => 'QCPLayerable *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveToLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              },
              {
                declaration_name => 'prepend',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'localAntialiased',
                type => 'bool'
              },
              {
                declaration_name => 'overrideElement',
                type => 'QCP::AntialiasedElement'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mWidth',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mWidthType',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'WidthType'
          },
          {
            kind => 'variable',
            name => 'mBarsGroup',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPBarsGroup *'
          },
          {
            kind => 'variable',
            name => 'mBaseValue',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mStackingGap',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mBarBelow',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPBars >'
          },
          {
            kind => 'variable',
            name => 'mBarAbove',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPBars >'
          },
          {
            kind => 'variable',
            name => 'mDataContainer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSharedPointer< QCPDataContainer< QCPBarsData > >'
          },
          {
            kind => 'variable',
            name => 'mName',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString'
          },
          {
            kind => 'variable',
            name => 'mAntialiasedFill',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mAntialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mBrush',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush'
          },
          {
            kind => 'variable',
            name => 'mKeyAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxis >'
          },
          {
            kind => 'variable',
            name => 'mValueAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxis >'
          },
          {
            kind => 'variable',
            name => 'mSelectable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::SelectionType'
          },
          {
            kind => 'variable',
            name => 'mSelection',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPDataSelection'
          },
          {
            kind => 'variable',
            name => 'mSelectionDecorator',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPSelectionDecorator *'
          },
          {
            kind => 'variable',
            name => 'mVisible',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPLayerable >'
          },
          {
            kind => 'variable',
            name => 'mLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *'
          },
          {
            kind => 'variable',
            name => 'mAntialiased',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      protected_static_methods => {
        members => [
          {
            kind => 'function',
            name => 'connectBars',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'yes',
            brief => {},
            detailed => {},
            type => 'static void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'lower',
                type => 'QCPBars *'
              },
              {
                declaration_name => 'upper',
                type => 'QCPBars *'
              }
            ]
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCustomPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'friend',
            name => 'QCPLegend',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'friend',
            name => 'QCPBarsGroup',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'text',
            content => 'A plottable representing a bar chart in a plot. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'To plot data, assign it with the '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setData'
              }
            ]
          },
          {
            type => 'text',
            content => ' or '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'addData'
              }
            ]
          },
          {
            type => 'text',
            content => ' functions.'
          },
          {
            type => 'sect1',
            title => 'Changing the appearance',
            content => [
              {
                type => 'text',
                content => 'The appearance of the bars is determined by the pen and the brush ('
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setPen'
                  }
                ]
              },
              {
                type => 'text',
                content => ', '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setBrush'
                  }
                ]
              },
              {
                type => 'text',
                content => '). The width of the individual bars can be controlled with '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setWidthType'
                  }
                ]
              },
              {
                type => 'text',
                content => ' and '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setWidth'
                  }
                ]
              },
              {
                type => 'text',
                content => '.Bar charts are stackable. This means, two '
              },
              {
                type => 'url',
                link => 'classQCPBars',
                content => 'QCPBars'
              },
              {
                type => 'text',
                content => ' plottables can be placed on top of each other (see '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPBars::moveAbove'
                  }
                ]
              },
              {
                type => 'text',
                content => '). So when two bars are at the same key position, they will appear stacked.If you would like to group multiple '
              },
              {
                type => 'url',
                link => 'classQCPBars',
                content => 'QCPBars'
              },
              {
                type => 'text',
                content => ' plottables together so they appear side by side as shown below, use '
              },
              {
                type => 'url',
                link => 'classQCPBarsGroup',
                content => 'QCPBarsGroup'
              },
              {
                type => 'text',
                content => '.'
              },
              {
                type => 'parbreak'
              }
            ]
          },
          {
            type => 'sect1',
            title => 'Usage',
            content => [
              {
                type => 'text',
                content => 'Like all data representing objects in '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ', the '
              },
              {
                type => 'url',
                link => 'classQCPBars',
                content => 'QCPBars'
              },
              {
                type => 'text',
                content => ' is a plottable ('
              },
              {
                type => 'url',
                link => 'classQCPAbstractPlottable',
                content => 'QCPAbstractPlottable'
              },
              {
                type => 'text',
                content => '). So the plottable-interface of '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ' applies ('
              },
              {
                type => 'url',
                link => 'classQCustomPlot_1a32de81ff53e263e785b83b52ecd99d6f',
                content => 'QCustomPlot::plottable'
              },
              {
                type => 'text',
                content => ', '
              },
              {
                type => 'url',
                link => 'classQCustomPlot_1af3dafd56884208474f311d6226513ab2',
                content => 'QCustomPlot::removePlottable'
              },
              {
                type => 'text',
                content => ', etc.)'
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'Usually, you first create an instance: which registers it with the '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ' instance of the passed axes. Note that this '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ' instance takes ownership of the plottable, so do not delete it manually but use '
              },
              {
                type => 'url',
                link => 'classQCustomPlot_1af3dafd56884208474f311d6226513ab2',
                content => 'QCustomPlot::removePlottable()'
              },
              {
                type => 'text',
                content => ' instead. The newly created plottable can be modified, e.g.: '
              }
            ]
          }
        ]
      }
    },
    {
      name => 'QCPBarsData',
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'fromSortKey',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        },
        {
          name => 'key',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        },
        {
          name => 'mainKey',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        },
        {
          name => 'mainValue',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        },
        {
          name => 'QCPBarsData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        },
        {
          name => 'QCPBarsData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        },
        {
          name => 'sortKey',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        },
        {
          name => 'sortKeyIsMainKey',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        },
        {
          name => 'value',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        },
        {
          name => 'valueRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsData'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPBarsData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a bar data point with key and value set to zero. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'QCPBarsData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Constructs a bar data point with the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'sortKey',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' member of this data point.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For a general explanation of what this method is good for in the context of the data container, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'mainKey',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' member of this data point.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For a general explanation of what this method is good for in the context of the data container, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'mainValue',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' member of this data point.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For a general explanation of what this method is good for in the context of the data container, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'valueRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a '
                },
                {
                  type => 'url',
                  link => 'classQCPRange',
                  content => 'QCPRange'
                },
                {
                  type => 'text',
                  content => ' with both lower and upper boundary set to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this data point.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For a general explanation of what this method is good for in the context of the data container, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      public_members => {
        members => [
          {
            kind => 'variable',
            name => 'key',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'value',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          }
        ]
      },
      public_static_methods => {
        members => [
          {
            kind => 'function',
            name => 'fromSortKey',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'yes',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a data point with the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. All other members are set to zero.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For a general explanation of what this method is good for in the context of the data container, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'static QCPBarsData',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sortKey',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'sortKeyIsMainKey',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'yes',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Since the member '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is both the data point key coordinate and the data ordering parameter, this method returns true.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For a general explanation of what this method is good for in the context of the data container, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataContainer'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'static bool',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Holds the data of one single data point (one bar) for '
          },
          {
            type => 'url',
            link => 'classQCPBars',
            content => 'QCPBars'
          },
          {
            type => 'text',
            content => '. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The stored data is: '
          },
          {
            type => 'list',
            style => 'itemized',
            content => [
              [
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key:'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' coordinate on the key axis of this bar (this is the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'mainKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sortKey'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') '
                }
              ],
              [
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value:'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' height coordinate on the value axis of this bar (this is the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'mainValue'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ')'
                }
              ]
            ]
          },
          {
            type => 'text',
            content => 'The container for storing multiple data points is '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPBarsDataContainer'
              }
            ]
          },
          {
            type => 'text',
            content => '. It is a typedef for '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPDataContainer'
              }
            ]
          },
          {
            type => 'text',
            content => ' with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPBarsData'
              }
            ]
          },
          {
            type => 'text',
            content => ' as the DataType template parameter. See the documentation there for an explanation regarding the data type\'s generic methods.'
          },
          {
            see => [
              {
                type => 'url',
                link => 'qcustomplot_8h_1a52bf589c9fce1baa36c1d40d69785d46',
                content => 'QCPBarsDataContainer'
              },
              {
                type => 'text',
                content => ' '
              }
            ]
          }
        ]
      }
    },
    {
      name => 'QCPBarsGroup',
      base => [
        {
          name => 'QObject',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'append',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'bars',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'bars',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'clear',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'contains',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'getPixelSpacing',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'insert',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'isEmpty',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'keyPixelOffset',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'mBars',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'mSpacing',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'mSpacingType',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'QCPBars',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'QCPBarsGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'registerBars',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'remove',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'setSpacing',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'setSpacingType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'size',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'spacing',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'spacingType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'SpacingType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'stAbsolute',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'stAxisRectRatio',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'stPlotCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        },
        {
          name => 'unregisterBars',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPBarsGroup'
        },
        {
          name => '~QCPBarsGroup',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPBarsGroup'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'SpacingType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the ways the spacing between bars in the group can be specified. Thus it defines what the number passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSpacing'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' actually means.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a2c7e2d61b10594a4555b615e1fcaf49e',
                      content => 'setSpacingType'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1aa553d327479d72a0c3dafcc724a190e2',
                      content => 'setSpacing'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'stAbsolute',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Bar spacing is in absolute pixels. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'stAxisRectRatio',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Bar spacing is given by a fraction of the axis rect size. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'stPlotCoords',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Bar spacing is in key coordinates and thus scales with the key axis range. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'stAbsolute',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Bar spacing is in absolute pixels. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'stAxisRectRatio',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Bar spacing is given by a fraction of the axis rect size. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'stPlotCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Bar spacing is in key coordinates and thus scales with the key axis range. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPBarsGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a new bars group for the specified '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' instance. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPBarsGroup',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'spacingType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SpacingType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'spacing',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setSpacingType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how the spacing between adjacent bars is interpreted. See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'SpacingType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The actual spacing can then be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSpacing'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1aa553d327479d72a0c3dafcc724a190e2',
                      content => 'setSpacing'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'spacingType',
                type => 'SpacingType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSpacing',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the spacing between adjacent bars. What the number passed as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'spacing'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' actually means, is defined by the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'SpacingType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', which can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSpacingType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a2c7e2d61b10594a4555b615e1fcaf49e',
                      content => 'setSpacingType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'spacing',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'bars',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all bars currently in this group.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'text',
                      content => 'bars(int index) '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPBars * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'bars',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ' instance with the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in this group. If no such '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ' exists, returns 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a6e4f4e86abbec6a9342f204ef82abef8',
                      content => 'bars()'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a3780ec77919cb00840207ec7a0f00dd5',
                      content => 'size'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPBars *',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'index',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'size',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the number of '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ' plottables that are part of this group. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'isEmpty',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns whether this bars group is empty.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a3780ec77919cb00840207ec7a0f00dd5',
                      content => 'size'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'clear',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes all '
                },
                {
                  type => 'url',
                  link => 'classQCPBars',
                  content => 'QCPBars'
                },
                {
                  type => 'text',
                  content => ' plottables from this group.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1aac959e79e852e8ef9aea6e0449ad000a',
                      content => 'isEmpty'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'contains',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns whether the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' plottable is part of this group. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'bars',
                type => 'QCPBars *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'append',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' plottable to this group. Alternatively, you can also use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars::setBarsGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' on the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' instance.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a309a5f7233db189f3ea9c2d04ece6c13',
                      content => 'insert'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a215e28a5944f1159013a0e19169220e7',
                      content => 'remove'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'bars',
                type => 'QCPBars *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'insert',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Inserts the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' plottable into this group at the specified index position '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'i'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This gives you full control over the ordering of the bars.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' may already be part of this group. In that case, '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is just moved to the new index position.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a809ed63cc4ff7cd5b0b8c96b470163d3',
                      content => 'append'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a215e28a5944f1159013a0e19169220e7',
                      content => 'remove'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'i',
                type => 'int'
              },
              {
                declaration_name => 'bars',
                type => 'QCPBars *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'remove',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'bars'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' plottable from this group.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1ae26da07a23553052a178fb3fae90d0dc',
                      content => 'contains'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPBarsGroup_1a3ddf23928c6cd89530bd34ab7ba7b177',
                      content => 'clear'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'bars',
                type => 'QCPBars *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'registerBars',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'bars',
                type => 'QCPBars *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'unregisterBars',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'bars',
                type => 'QCPBars *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'keyPixelOffset',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'bars',
                type => 'const QCPBars *'
              },
              {
                declaration_name => 'keyCoord',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'getPixelSpacing',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'bars',
                type => 'const QCPBars *'
              },
              {
                declaration_name => 'keyCoord',
                type => 'double'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mSpacingType',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SpacingType'
          },
          {
            kind => 'variable',
            name => 'mSpacing',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double'
          },
          {
            kind => 'variable',
            name => 'mBars',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QList< QCPBars * >'
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCPBars',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Groups multiple '
          },
          {
            type => 'url',
            link => 'classQCPBars',
            content => 'QCPBars'
          },
          {
            type => 'text',
            content => ' together so they appear side by side. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'When showing multiple '
          },
          {
            type => 'url',
            link => 'classQCPBars',
            content => 'QCPBars'
          },
          {
            type => 'text',
            content => ' in one plot which have bars at identical keys, it may be desirable to have them appearing next to each other at each key. This is what adding the respective '
          },
          {
            type => 'url',
            link => 'classQCPBars',
            content => 'QCPBars'
          },
          {
            type => 'text',
            content => ' plottables to a '
          },
          {
            type => 'url',
            link => 'classQCPBarsGroup',
            content => 'QCPBarsGroup'
          },
          {
            type => 'text',
            content => ' achieves. (An alternative approach is to stack them on top of each other, see '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPBars::moveAbove'
              }
            ]
          },
          {
            type => 'text',
            content => '.)'
          },
          {
            type => 'sect1',
            title => 'Usage',
            content => [
              {
                type => 'text',
                content => 'To add a '
              },
              {
                type => 'url',
                link => 'classQCPBars',
                content => 'QCPBars'
              },
              {
                type => 'text',
                content => ' plottable to the group, create a new group and then add the respective bars intances: Alternatively to appending to the group like shown above, you can also set the group on the '
              },
              {
                type => 'url',
                link => 'classQCPBars',
                content => 'QCPBars'
              },
              {
                type => 'text',
                content => ' plottable via '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPBars::setBarsGroup'
                  }
                ]
              },
              {
                type => 'text',
                content => '.The spacing between the bars can be configured via '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setSpacingType'
                  }
                ]
              },
              {
                type => 'text',
                content => ' and '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setSpacing'
                  }
                ]
              },
              {
                type => 'text',
                content => '. The bars in this group appear in the plot in the order they were appended. To insert a bars plottable at a certain index position, or to reposition a bars plottable which is already in the group, use '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'insert'
                  }
                ]
              },
              {
                type => 'text',
                content => '.To remove specific bars from the group, use either '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'remove'
                  }
                ]
              },
              {
                type => 'text',
                content => ' or call '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPBars::setBarsGroup(0)'
                  }
                ]
              },
              {
                type => 'text',
                content => ' on the respective bars plottable.To clear the entire group, call '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'clear'
                  }
                ]
              },
              {
                type => 'text',
                content => ', or simply delete the group.'
              }
            ]
          },
          {
            type => 'sect1',
            title => 'Example',
            content => [
              {
                type => 'text',
                content => 'The image above is generated with the following code: '
              }
            ]
          }
        ]
      }
    },
    {
      name => 'QCPColorGradient',
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'ciHSV',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'ciRGB',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'clearColorStops',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'color',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'ColorInterpolation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'colorInterpolation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'colorize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'colorize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'colorStops',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpCandy',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpCold',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpGeography',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpGrayscale',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpHot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpHues',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpIon',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpJet',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpNight',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpPolar',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpSpectrum',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'gpThermal',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'GradientPreset',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'inverted',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'levelCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'loadPreset',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'mColorBuffer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorGradient'
        },
        {
          name => 'mColorBufferInvalidated',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorGradient'
        },
        {
          name => 'mColorInterpolation',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorGradient'
        },
        {
          name => 'mColorStops',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorGradient'
        },
        {
          name => 'mLevelCount',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorGradient'
        },
        {
          name => 'mPeriodic',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorGradient'
        },
        {
          name => 'operator!=',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'operator==',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'periodic',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'QCPColorGradient',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'QCPColorGradient',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'setColorInterpolation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'setColorStopAt',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'setColorStops',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'setLevelCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'setPeriodic',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorGradient'
        },
        {
          name => 'stopsUseAlpha',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorGradient'
        },
        {
          name => 'updateColorBuffer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorGradient'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'ColorInterpolation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the color spaces in which color interpolation between gradient stops can be performed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorGradient_1aa13fda86406e1d896a465a409ae63b38',
                      content => 'setColorInterpolation'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'ciRGB',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Color channels red, green and blue are linearly interpolated. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'ciHSV',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Color channels hue, saturation and value are linearly interpolated (The hue is interpolated over the shortest angle distance) '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enum',
            name => 'GradientPreset',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the available presets that can be loaded with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'loadPreset'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. See the documentation there for an image of the presets. '
                }
              ]
            },
            values => [
              {
                name => 'gpGrayscale',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Continuous lightness from black to white (suited for non-biased data representation) '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpHot',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Continuous lightness from black over firey colors to white (suited for non-biased data representation) '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpCold',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Continuous lightness from black over icey colors to white (suited for non-biased data representation) '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpNight',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Continuous lightness from black over weak blueish colors to white (suited for non-biased data representation) '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpCandy',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Blue over pink to white. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpGeography',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Colors suitable to represent different elevations on geographical maps. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpIon',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Half hue spectrum from black over purple to blue and finally green (creates banding illusion but allows more precise magnitude estimates) '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpThermal',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Colors suitable for thermal imaging, ranging from dark blue over purple to orange, yellow and white. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpPolar',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Colors suitable to emphasize polarity around the center, with blue for negative, black in the middle and red for positive values. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpSpectrum',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'An approximation of the visible light spectrum (creates banding illusion but allows more precise magnitude estimates) '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpJet',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Hue variation similar to a spectrum, often used in numerical visualization (creates banding illusion but allows more precise magnitude estimates) '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'gpHues',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Full hue cycle, with highest and lowest color red (suitable for periodic data, such as angles and phases, see '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'setPeriodic'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ') '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'ciRGB',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Color channels red, green and blue are linearly interpolated. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'ciHSV',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Color channels hue, saturation and value are linearly interpolated (The hue is interpolated over the shortest angle distance) '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpGrayscale',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Continuous lightness from black to white (suited for non-biased data representation) '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpHot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Continuous lightness from black over firey colors to white (suited for non-biased data representation) '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpCold',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Continuous lightness from black over icey colors to white (suited for non-biased data representation) '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpNight',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Continuous lightness from black over weak blueish colors to white (suited for non-biased data representation) '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpCandy',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Blue over pink to white. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpGeography',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Colors suitable to represent different elevations on geographical maps. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpIon',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Half hue spectrum from black over purple to blue and finally green (creates banding illusion but allows more precise magnitude estimates) '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpThermal',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Colors suitable for thermal imaging, ranging from dark blue over purple to orange, yellow and white. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpPolar',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Colors suitable to emphasize polarity around the center, with blue for negative, black in the middle and red for positive values. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpSpectrum',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'An approximation of the visible light spectrum (creates banding illusion but allows more precise magnitude estimates) '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpJet',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Hue variation similar to a spectrum, often used in numerical visualization (creates banding illusion but allows more precise magnitude estimates) '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'gpHues',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Full hue cycle, with highest and lowest color red (suitable for periodic data, such as angles and phases, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setPeriodic'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPColorGradient',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Constructs a new, empty '
                },
                {
                  type => 'url',
                  link => 'classQCPColorGradient',
                  content => 'QCPColorGradient'
                },
                {
                  type => 'text',
                  content => ' with no predefined color stops. You can add own color stops with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setColorStopAt'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The color level count is initialized to 350. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'QCPColorGradient',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a new '
                },
                {
                  type => 'url',
                  link => 'classQCPColorGradient',
                  content => 'QCPColorGradient'
                },
                {
                  type => 'text',
                  content => ' initialized with the colors and color interpolation according to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'preset'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The color level count is initialized to 350. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'preset',
                type => 'GradientPreset'
              }
            ]
          },
          {
            kind => 'function',
            name => 'operator==',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'other',
                type => 'const QCPColorGradient &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'operator!=',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'other',
                type => 'const QCPColorGradient &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'levelCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'colorStops',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMap< double, QColor >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'colorInterpolation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'ColorInterpolation',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'periodic',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setLevelCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the number of discretization levels of the color gradient to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'n'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The default is 350 which is typically enough to create a smooth appearance. The minimum number of levels is 2.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => ' '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'n',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setColorStops',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets at which positions from 0 to 1 which color shall occur. The positions are the keys, the colors are the values of the passed QMap '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'colorStops'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. In between these color stops, the color is interpolated according to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setColorInterpolation'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.A more convenient way to create a custom gradient may be to clear all color stops with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'clearColorStops'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (or creating a new, empty '
                },
                {
                  type => 'url',
                  link => 'classQCPColorGradient',
                  content => 'QCPColorGradient'
                },
                {
                  type => 'text',
                  content => ') and then adding them one by one with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setColorStopAt'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorGradient_1a939213e85f0d1279519d555c5fcfb6ad',
                      content => 'clearColorStops'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'colorStops',
                type => 'const QMap< double, QColor > &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setColorStopAt',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'color'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' the gradient will have at the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'position'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' (from 0 to 1). In between these color stops, the color is interpolated according to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setColorInterpolation'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorGradient_1a724e828aa6f0ba5011a9392477c35d3a',
                      content => 'setColorStops'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorGradient_1a939213e85f0d1279519d555c5fcfb6ad',
                      content => 'clearColorStops'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'position',
                type => 'double'
              },
              {
                declaration_name => 'color',
                type => 'const QColor &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setColorInterpolation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the colors in between the configured color stops (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setColorStopAt'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') shall be interpolated linearly in RGB or in HSV color space.For example, a sweep in RGB space from red to green will have a muddy brown intermediate color, whereas in HSV space the intermediate color is yellow. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'interpolation',
                type => 'ColorInterpolation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setPeriodic',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether data points that are outside the configured data range (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMap::setDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') are colored by periodically repeating the color gradient or whether they all have the same color, corresponding to the respective gradient boundary color.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'As shown in the image above, gradients that have the same start and end color are especially suitable for a periodic gradient mapping, since they produce smooth color transitions throughout the color map. A preset that has this property is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'gpHues'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.In practice, using periodic color gradients makes sense when the data corresponds to a periodic dimension, such as an angle or a phase. If this is not the case, the color encoding might become ambiguous, because multiple different data values are shown as the same color. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'colorize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method is used to quickly convert a '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'data'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' array to colors. The colors will be output in the array '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'scanLine'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. Both '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'data'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'scanLine'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' must have the length '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'n'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' when passed to this function. The data range that shall be used for mapping the data value to the gradient is passed in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'range'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'logarithmic'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates whether the data values shall be mapped to colors logarithmically.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'data'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' actually contains 2D-data linearized via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => '[row*columnCount + column]'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', you can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'dataIndexFactor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'columnCount'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to convert a column instead of a row of the data array, in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'scanLine'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'scanLine'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will remain a regular (1D) array. This works because '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'data'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is addressed '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'data[i*dataIndexFactor]'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Use the overloaded method to additionally provide alpha map data.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The QRgb values that are placed in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'scanLine'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' have their r, g and b components premultiplied with alpha (see QImage::Format_ARGB32_Premultiplied). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'data',
                type => 'const double *'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'scanLine',
                type => 'QRgb *'
              },
              {
                declaration_name => 'n',
                type => 'int'
              },
              {
                declaration_name => 'dataIndexFactor',
                type => 'int',
                default_value => '1'
              },
              {
                declaration_name => 'logarithmic',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'colorize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Additionally to the other overload of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'colorize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', this method takes the array '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alpha'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', which has the same size and structure as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'data'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and encodes the alpha information per data point.The QRgb values that are placed in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'scanLine'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' have their r, g and b components premultiplied with alpha (see QImage::Format_ARGB32_Premultiplied). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'data',
                type => 'const double *'
              },
              {
                declaration_name => 'alpha',
                type => 'const unsigned char *'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'scanLine',
                type => 'QRgb *'
              },
              {
                declaration_name => 'n',
                type => 'int'
              },
              {
                declaration_name => 'dataIndexFactor',
                type => 'int',
                default_value => '1'
              },
              {
                declaration_name => 'logarithmic',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'color',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRgb',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'position',
                type => 'double'
              },
              {
                declaration_name => 'range',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'logarithmic',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'loadPreset',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Clears the current color stops and loads the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'preset'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. A preset consists of predefined color stops and the corresponding color interpolation method.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The available presets are:  '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'preset',
                type => 'GradientPreset'
              }
            ]
          },
          {
            kind => 'function',
            name => 'clearColorStops',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Clears all color stops.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorGradient_1a724e828aa6f0ba5011a9392477c35d3a',
                      content => 'setColorStops'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorGradient_1a3b48be5e78079db1bb2a1188a4c3390e',
                      content => 'setColorStopAt'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'inverted',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns an inverted gradient. The inverted gradient has all properties as this '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorGradient'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', but the order of the color stops is inverted.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorGradient_1a724e828aa6f0ba5011a9392477c35d3a',
                      content => 'setColorStops'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorGradient_1a3b48be5e78079db1bb2a1188a4c3390e',
                      content => 'setColorStopAt'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPColorGradient',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'stopsUseAlpha',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'updateColorBuffer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mLevelCount',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mColorStops',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMap< double, QColor >'
          },
          {
            kind => 'variable',
            name => 'mColorInterpolation',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'ColorInterpolation'
          },
          {
            kind => 'variable',
            name => 'mPeriodic',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mColorBuffer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QVector< QRgb >'
          },
          {
            kind => 'variable',
            name => 'mColorBufferInvalidated',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'text',
            content => 'Defines a color gradient for use with e.g. '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMap'
              }
            ]
          },
          {
            type => 'text',
            content => '. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'text',
            content => 'This class describes a color gradient which can be used to encode data with color. For example, '
          },
          {
            type => 'url',
            link => 'classQCPColorMap',
            content => 'QCPColorMap'
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'url',
            link => 'classQCPColorScale',
            content => 'QCPColorScale'
          },
          {
            type => 'text',
            content => ' have '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setGradient'
              }
            ]
          },
          {
            type => 'text',
            content => ' methods which take an instance of this class. Colors are set with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setColorStopAt(double position, const QColor &color)'
              }
            ]
          },
          {
            type => 'text',
            content => ' with a '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'position'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' from 0 to 1. In between these defined color positions, the color will be interpolated linearly either in RGB or HSV space, see '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setColorInterpolation'
              }
            ]
          },
          {
            type => 'text',
            content => '.Alternatively, load one of the preset color gradients shown in the image below, with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'loadPreset'
              }
            ]
          },
          {
            type => 'text',
            content => ', or by directly specifying the preset in the constructor.Apart from red, green and blue components, the gradient also interpolates the alpha values of the configured color stops. This allows to display some portions of the data range as transparent in the plot.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorGradient(GradientPreset preset)'
              }
            ]
          },
          {
            type => 'text',
            content => ' constructor allows directly converting a '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'GradientPreset'
              }
            ]
          },
          {
            type => 'text',
            content => ' to a '
          },
          {
            type => 'url',
            link => 'classQCPColorGradient',
            content => 'QCPColorGradient'
          },
          {
            type => 'text',
            content => '. This means that you can directly pass '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'GradientPreset'
              }
            ]
          },
          {
            type => 'text',
            content => ' to all the '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'setGradient'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' methods, e.g.:  The total number of levels used in the gradient can be set with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setLevelCount'
              }
            ]
          },
          {
            type => 'text',
            content => '. Whether the color gradient shall be applied periodically (wrapping around) to data values that lie outside the data range specified on the plottable instance can be controlled with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setPeriodic'
              }
            ]
          },
          {
            type => 'text',
            content => '. '
          }
        ]
      }
    },
    {
      name => 'QCPColorMap',
      base => [
        {
          name => 'QCPAbstractPlottable',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'addToLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'addToLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'antialiasedFill',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'antialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyFillAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'applyScattersAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'brush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'colorScale',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'coordsToPixels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'coordsToPixels',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'data',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'dataRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'dataRangeChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'dataScaleType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'dataScaleTypeChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'draw',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'drawLegendIcon',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'getKeyRange',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'getValueRange',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'gradient',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'gradientChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'interface1D',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'interpolate',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'keyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mAntialiasedFill',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mAntialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mBrush',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mColorScale',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mDataRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mDataScaleType',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mGradient',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mInterpolate',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mKeyAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mLegendIcon',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mMapData',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mMapImage',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mMapImageInvalidated',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mName',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mPen',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelectable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelection',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mSelectionDecorator',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mTightBoundary',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mUndersampledMapImage',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'mValueAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'name',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'pen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'pixelsToCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'pixelsToCoords',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCPAbstractPlottable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'QCPColorMap',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'QCPLegend',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'QCustomPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'removeFromLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'removeFromLegend',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleDataRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'rescaleKeyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'rescaleValueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectableChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selected',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selection',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectionDecorator',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'selectTest',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setAntialiasedFill',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setAntialiasedScatters',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setBrush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setColorScale',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'setData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'setDataRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'setDataScaleType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'setGradient',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'setInterpolate',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'setKeyAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setName',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setPen',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelectable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelection',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setSelectionDecorator',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setTightBoundary',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'setValueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'tightBoundary',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'updateLegendIcon',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => 'updateMapImage',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPColorMap'
        },
        {
          name => 'valueAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPAbstractPlottable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAbstractPlottable'
        },
        {
          name => '~QCPColorMap',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPColorMap'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPColorMap',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a color map with the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The created '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMap',
                  content => 'QCPColorMap'
                },
                {
                  type => 'text',
                  content => ' is automatically registered with the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' instance inferred from '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyAxis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' instance takes ownership of the '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMap',
                  content => 'QCPColorMap'
                },
                {
                  type => 'text',
                  content => ', so do not delete it manually but use '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af3dafd56884208474f311d6226513ab2',
                  content => 'QCustomPlot::removePlottable()'
                },
                {
                  type => 'text',
                  content => ' instead. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyAxis',
                type => 'QCPAxis *'
              },
              {
                declaration_name => 'valueAxis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPColorMap',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'data',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a pointer to the internal data storage of type '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMapData'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. Access this to modify data points (cells) and the color map key/value range.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMap_1a5a23e133a20c4ccad35fd32e6c0f9809',
                      content => 'setData'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPColorMapData *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'dataRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'dataScaleType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis::ScaleType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'interpolate',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'tightBoundary',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'gradient',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPColorGradient',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'colorScale',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPColorScale *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Replaces the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'data'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' with the provided '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'data'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'copy'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to true, the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'data'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' object will only be copied. if false, the color map takes ownership of the passed data and replaces the internal data pointer with it. This is significantly faster than copying for large datasets. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'data',
                type => 'QCPColorMapData *'
              },
              {
                declaration_name => 'copy',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setDataRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the data range of this color map to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'dataRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The data range defines which data values are mapped to the color gradient.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'To make the data range span the full range of the data set, use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1abe88633003a26d1e756aa74984587fef',
                      content => 'QCPColorScale::setDataRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'dataRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setDataScaleType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the data is correlated with the color gradient linearly or logarithmically.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1aeb6107d67dd7325145b2498abae67fc3',
                      content => 'QCPColorScale::setDataScaleType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'scaleType',
                type => 'QCPAxis::ScaleType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setGradient',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the color gradient that is used to represent the data. For more details on how to create an own gradient or use one of the preset gradients, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorGradient'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The colors defined by the gradient will be used to represent data values in the currently set data range, see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. Data points that are outside this data range will either be colored uniformly with the respective gradient boundary color, or the gradient will repeat, depending on '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorGradient::setPeriodic'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a1f29583bb6f1e7f473b62fb712be3940',
                      content => 'QCPColorScale::setGradient'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'gradient',
                type => 'const QCPColorGradient &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setInterpolate',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the color map image shall use bicubic interpolation when displaying the color map shrinked or expanded, and not at a 1:1 pixel-to-data scale.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A 10*10 color map, with interpolation and without interpolation enabled'
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setTightBoundary',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the outer most data rows and columns are clipped to the specified key and value range (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMapData::setKeyRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMapData::setValueRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'enabled'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to false, the data points at the border of the color map are drawn with the same width and height as all other data points. Since the data points are represented by rectangles of one color centered on the data coordinate, this means that the shown color map extends by half a data point over the specified key/value range in each direction.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A color map, with tight boundary enabled and disabled'
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setColorScale',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Associates the color scale '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'colorScale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' with this color map.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This means that both the color scale and the color map synchronize their gradient, data range and data scale type ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setGradient'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDataScaleType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). Multiple color maps can be associated with one single color scale. This causes the color maps to also synchronize those properties, via the mutual color scale.This function causes the color map to adopt the current color gradient, data range and data scale type of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'colorScale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. After this call, you may change these properties at either the color map or the color scale, and the setting will be applied to both.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'colorScale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to disconnect the color scale from this color map again. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'colorScale',
                type => 'QCPColorScale *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleDataRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the data range ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to span the minimum and maximum values that occur in the current data set. This corresponds to the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleKeyAxis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleValueAxis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' methods, only for the third data dimension of the color map.The minimum and maximum values of the data set are buffered in the internal '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMapData',
                  content => 'QCPColorMapData'
                },
                {
                  type => 'text',
                  content => ' instance ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'data'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). As data is updated via its '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMapData::setCell'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMapData::setData'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the buffered minimum and maximum values are updated, too. For performance reasons, however, they are only updated in an expanding fashion. So the buffered maximum can only increase and the buffered minimum can only decrease. In consequence, changes to the data that actually lower the maximum of the data set (by overwriting the cell holding the current maximum with a smaller value), aren\'t recognized and the buffered maximum overestimates the true maximum of the data set. The same happens for the buffered minimum. To recalculate the true minimum and maximum by explicitly looking at each cell, the method '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMapData_1ab235ade8a4d64bd3adb26a99b3dd57ee',
                  content => 'QCPColorMapData::recalculateDataBounds'
                },
                {
                  type => 'text',
                  content => ' can be used. For convenience, setting the parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'recalculateDataBounds'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' calls this method before setting the data range to the buffered minimum and maximum.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMap_1a980b42837821159786a85b4b7dcb8774',
                      content => 'setDataRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'recalculateDataBounds',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'updateLegendIcon',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Takes the current appearance of the color map and updates the legend icon, which is used to represent this color map in the legend (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLegend'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').The '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'transformMode'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' specifies whether the rescaling is done by a faster, low quality image scaling algorithm (Qt::FastTransformation) or by a slower, higher quality algorithm (Qt::SmoothTransformation).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The current color map appearance is scaled down to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'thumbSize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. Ideally, this should be equal to the size of the legend icon (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLegend::setIconSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). If it isn\'t exactly the configured legend icon size, the thumb will be rescaled during drawing of the legend item.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMap_1a980b42837821159786a85b4b7dcb8774',
                      content => 'setDataRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'transformMode',
                type => 'Qt::TransformationMode',
                default_value => 'Qt::SmoothTransformation'
              },
              {
                declaration_name => 'thumbSize',
                type => 'const QSize &',
                default_value => 'QSize(32, 18)'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This function is used to decide whether a click hits a layerable object or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a point in pixel coordinates on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn\'t be determined, -1.0 is returned. Further, if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlySelectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true and the object is not selectable, -1.0 is returned, too.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the object is represented not by single lines but by an area like a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPItemText'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or the bars of a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot\'s selection tolerance. (typically the selectionTolerance multiplied by 0.99).Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The actual setting of the selection state is not done by this function. This is handled by the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' when the mouseReleaseEvent occurs, and the finally selected object is notified via the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '/'
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'deselectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' methods.'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an optional output parameter. Every layerable subclass may place any information in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This information will be passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' will carry the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This is useful for multi-part objects (like '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => '). This way, a possibly complex calculation to decide which part was clicked is only done once in '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The result (i.e. the actually clicked part) can then be placed in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. So in the subsequent '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the decision which part was selected doesn\'t have to be done a second time for a single selection operation.You may pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to indicate that you are not interested in those selection details.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a2d488568cf16600dd81fa23d7d439829',
                      content => 'selectEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a9b104d9da4f38f934363945c313bf82e',
                      content => 'deselectEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a5ee1e2f6ae27419deca53e75907c27e5',
                      content => 'QCustomPlot::setInteractions'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            }
          },
          {
            kind => 'function',
            name => 'getKeyRange',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the coordinate range that all data in this plottable span in the key axis dimension. For logarithmic plots, one can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to either '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdPositive'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and all positive points will be ignored for range calculation. For no restriction, just set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdBoth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (default). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn\'t use the returned range (e.g. no points in data).Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not the same as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', since the range returned by this function may have size zero (e.g. when there is only one data point). In this case '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' would return true, but the returned range is not a valid range in terms of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a1491c4a606bccd2d09e65e11b79eb882',
                      content => 'rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMap_1a88134493aaf6b297af34eaab65264fff',
                      content => 'getValueRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'foundRange',
                type => 'bool &'
              },
              {
                declaration_name => 'inSignDomain',
                type => 'QCP::SignDomain',
                default_value => 'QCP::sdBoth'
              }
            ],
            reimplements => {
              name => 'getKeyRange'
            }
          },
          {
            kind => 'function',
            name => 'getValueRange',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the coordinate range that the data points in the specified key range ('
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ') span in the value axis dimension. For logarithmic plots, one can set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to either '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdPositive'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdNegative'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and all positive points will be ignored for range calculation. For no restriction, just set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inSignDomain'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::sdBoth'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (default). '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is an output parameter that indicates whether a range could be found or not. If this is false, you shouldn\'t use the returned range (e.g. no points in data).If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' has both lower and upper bound set to zero (is equal to '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'url',
                  link => 'classQCPRange',
                  content => 'QCPRange()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '), all data points are considered, without any restriction on the keys.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not the same as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', since the range returned by this function may have size zero (e.g. when there is only one data point). In this case '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'foundRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' would return true, but the returned range is not a valid range in terms of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPRange::validRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a1491c4a606bccd2d09e65e11b79eb882',
                      content => 'rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMap_1a985861974560f950af6cb7fae8c46267',
                      content => 'getKeyRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'foundRange',
                type => 'bool &'
              },
              {
                declaration_name => 'inSignDomain',
                type => 'QCP::SignDomain',
                default_value => 'QCP::sdBoth'
              },
              {
                declaration_name => 'inKeyRange',
                type => 'const QCPRange &',
                default_value => 'QCPRange()'
              }
            ],
            reimplements => {
              name => 'getValueRange'
            }
          },
          {
            kind => 'function',
            name => 'name',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiasedFill',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'pen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'brush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'keyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'valueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::SelectionType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selected',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if there are any data points of the plottable currently selected. Use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to retrieve the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selection',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' encompassing all the data points that are currently selected on this plottable.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a0b3b514474fe93354fc74cfc144184b4',
                      content => 'selected'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPDataSelection',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'selectionDecorator',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Provides access to the selection decorator of this plottable. The selection decorator controls how selected data ranges are drawn (e.g. their pen color and fill), see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for details.If you wish to use an own '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass, pass an instance of it to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QCPSelectionDecorator *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setName',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The name is the textual representation of this plottable as it is displayed in the legend ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLegend'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). It may contain any UTF-8 characters, including newlines. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'name',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiasedFill',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether fills of this plottable are drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that this setting may be overridden by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setNotAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether the scatter symbols of this plottable are drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that this setting may be overridden by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setNotAntialiasedElements'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setPen',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The pen is used to draw basic lines that make up the plottable representation in the plot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass draws its graph lines with this pen.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a7a4b92144dca6453a1f0f210e27edc74',
                      content => 'setBrush'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pen',
                type => 'const QPen &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBrush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For example, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' subclass draws the fill under the graph with this brush, when it\'s not set to Qt::NoBrush.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ab74b09ae4c0e7e13142fe4b5bf46cac7',
                      content => 'setPen'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'brush',
                type => 'const QBrush &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setKeyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The key axis of a plottable can be set to any axis of a '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ', as long as it is orthogonal to the plottable\'s value axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1a9a79cd0158a4c7f30cbc702f0fd800e4',
                  content => 'QCustomPlot::xAxis'
                },
                {
                  type => 'text',
                  content => ') as key axis and the y-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6fea5679725b152c14facd920b19367',
                  content => 'QCustomPlot::yAxis'
                },
                {
                  type => 'text',
                  content => ') as value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Normally, the key and value axes are set in the constructor of the plottable (or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::addGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when working with QCPGraphs through the dedicated graph interface).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a71626a07367e241ec62ad2c34baf21cb',
                      content => 'setValueAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setValueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'The value axis of a plottable can be set to any axis of a '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ', as long as it is orthogonal to the plottable\'s key axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1a9a79cd0158a4c7f30cbc702f0fd800e4',
                  content => 'QCustomPlot::xAxis'
                },
                {
                  type => 'text',
                  content => ') as key axis and the y-axis ('
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6fea5679725b152c14facd920b19367',
                  content => 'QCustomPlot::yAxis'
                },
                {
                  type => 'text',
                  content => ') as value axis.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Normally, the key and value axes are set in the constructor of the plottable (or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::addGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' when working with QCPGraphs through the dedicated graph interface).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a8524fa2994c63c0913ebd9bb2ffa3920',
                      content => 'setKeyAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether and to which granularity this plottable can be selected.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A selection can happen by clicking on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iSelectPlottables'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), by dragging a selection rect (When '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setSelectionRectMode'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::srmSelect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), or programmatically by calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a219bc5403a9d85d3129165ec3f5ae436',
                      content => 'setSelection'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'namespaceQCP_1ac6cb9db26a564b27feda362a438db038',
                      content => 'QCP::SelectionType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'QCP::SelectionType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelection',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets which data ranges of this plottable are selected. Selected data ranges are drawn differently (e.g. color) in the plot. This can be controlled via the selection decorator (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').The entire selection mechanism for plottables is handled automatically when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains iSelectPlottables. You only need to call this function when you wish to change the selection state programmatically.Using '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' you can further specify for each plottable whether and to which granularity it is selectable. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selection'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is not compatible with the current '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::SelectionType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelectable'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the resulting selection will be adjusted accordingly (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection::enforceType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').emits the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionChanged'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' signal when '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is different from the previous selection state.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a38efe9641d972992a3d44204bc80ec1d',
                      content => 'selectTest'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selection',
                type => 'QCPDataSelection'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSelectionDecorator',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Use this method to set an own '
                },
                {
                  type => 'url',
                  link => 'classQCPSelectionDecorator',
                  content => 'QCPSelectionDecorator'
                },
                {
                  type => 'text',
                  content => ' (subclass) instance. This allows you to customize the visual representation of selected data ranges further than by using the default '
                },
                {
                  type => 'url',
                  link => 'classQCPSelectionDecorator',
                  content => 'QCPSelectionDecorator'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The plottable takes ownership of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'decorator'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The currently set decorator can be accessed via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectionDecorator'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'decorator',
                type => 'QCPSelectionDecorator *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'interface1D',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this plottable is a one-dimensional plottable, i.e. it implements the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableInterface1D'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', returns the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'this'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' pointer with that type. Otherwise (e.g. in the case of a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMap'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') returns zero.You can use this method to gain read access to data coordinates while holding a pointer to the abstract base class only. '
                }
              ]
            },
            type => 'virtual QCPPlottableInterface1D *',
            const => 'no',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              },
              {
                name => 'interface1D'
              }
            ]
          },
          {
            kind => 'function',
            name => 'coordsToPixels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Convenience function for transforming a key/value pair to pixels on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are transformed to the coodinates in pixels and are written to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'x'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'y'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3903c1120ab5c27e7fa46b597ef267bd',
                      content => 'pixelsToCoords'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                      content => 'QCPAxis::coordToPixel'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              },
              {
                declaration_name => 'x',
                type => 'double &'
              },
              {
                declaration_name => 'y',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'coordsToPixels',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Transforms the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to pixel coordinates and returns them in a QPointF. '
                }
              ]
            },
            type => 'const QPointF',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pixelsToCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Convenience function for transforming a x/y pixel pair on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface to plot coordinates, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'x'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'y'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' are transformed to the plot coodinates and are written to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a7ad84a36472441cf1f555c5683d0da93',
                      content => 'coordsToPixels'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                      content => 'QCPAxis::coordToPixel'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'x',
                type => 'double'
              },
              {
                declaration_name => 'y',
                type => 'double'
              },
              {
                declaration_name => 'key',
                type => 'double &'
              },
              {
                declaration_name => 'value',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'pixelsToCoords',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel input '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pixelPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as plot coordinates '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pixelPos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'key',
                type => 'double &'
              },
              {
                declaration_name => 'value',
                type => 'double &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i.e. a range containing different signs and/or zero. Instead it will stay in the current sign domain and ignore all parts of the plottable that lie outside of that domain.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlyEnlarge'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' makes sure the ranges are only expanded, never reduced. So it\'s possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlyEnlarge'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' set to false (the default), and all subsequent set to true.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ae96b83c961e257da116c6acf9c7da308',
                      content => 'rescaleKeyAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a714eaf36b12434cd71846215504db82e',
                      content => 'rescaleValueAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1ad86528f2cee6c7e446dea4a6e8839935',
                      content => 'QCustomPlot::rescaleAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a499345f02ebce4b23d8ccec96e58daa9',
                      content => 'QCPAxis::rescale'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleKeyAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Rescales the key axis of the plottable so the whole plottable is visible.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for detailed behaviour. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rescaleValueAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Rescales the value axis of the plottable so the whole plottable is visible. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'inKeyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to true, only the data points which are in the currently visible key axis range are considered.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the axis was actually scaled. This might not be the case if this plottable has an invalid range, e.g. because it has no data points.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rescaleAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for detailed behaviour. '
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyEnlarge',
                type => 'bool',
                default_value => 'false'
              },
              {
                declaration_name => 'inKeyRange',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addToLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds this plottable to the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'legend'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Creates a '
                },
                {
                  type => 'url',
                  link => 'classQCPPlottableLegendItem',
                  content => 'QCPPlottableLegendItem'
                },
                {
                  type => 'text',
                  content => ' which is inserted into the legend. Returns true on success, i.e. when the legend exists and a legend item associated with this plottable isn\'t already in the legend.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the plottable needs a more specialized representation in the legend, you can create a corresponding subclass of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableLegendItem'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and add it to the legend manually instead of calling this method.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3cc235007e2343a65ad4f463767e0e20',
                      content => 'removeFromLegend'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1a3ab274de52d2951faea45a6d975e6b3f',
                      content => 'QCPLegend::addItem'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'legend',
                type => 'QCPLegend *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addToLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds this plottable to the legend of the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::legend'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3cc235007e2343a65ad4f463767e0e20',
                      content => 'removeFromLegend'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'removeFromLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the plottable from the specifed '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'legend'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This means the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPPlottableLegendItem'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' that is associated with this plottable is removed.Returns true on success, i.e. if the legend exists and a legend item associated with this plottable was found and removed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1aa64e93cb5b606d8110d2cc0a349bb30f',
                      content => 'addToLegend'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLegend_1ac91595c3eaa746fe6321d2eb952c63bb',
                      content => 'QCPLegend::removeItem'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'legend',
                type => 'QCPLegend *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'removeFromLegend',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the plottable from the legend of the parent '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1aa64e93cb5b606d8110d2cc0a349bb30f',
                      content => 'addToLegend'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'dataRangeChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the data range changes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMap_1a980b42837821159786a85b4b7dcb8774',
                      content => 'setDataRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'dataScaleTypeChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the data scale type changes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMap_1a9d20aa08e3c1f20f22908c45b9c06511',
                      content => 'setDataScaleType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'scaleType',
                type => 'QCPAxis::ScaleType'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'gradientChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the gradient changes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMap_1a7313c78360471cead3576341a2c50377',
                      content => 'setGradient'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newGradient',
                type => 'const QCPColorGradient &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selected'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates whether there are any points selected or not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a787a9c39421059006891744b731fa473',
                      content => 'selectionChanged(const QCPDataSelection &selection)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selected',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectionChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'selection'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' holds the currently selected data ranges.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1a3af66432b1dca93b28e00e78a8c7c1d9',
                      content => 'selectionChanged(bool selected)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selection',
                type => 'const QCPDataSelection &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'selectableChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the selectability of this plottable has changed.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAbstractPlottable_1ac238d6e910f976f1f30d41c2bca44ac3',
                      content => 'setSelectable'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectable',
                type => 'QCP::SelectionType'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'updateMapImage',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'draw'
            }
          },
          {
            kind => 'function',
            name => 'drawLegendIcon',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'rect',
                type => 'const QRectF &'
              }
            ],
            reimplements => {
              name => 'drawLegendIcon'
            }
          },
          {
            kind => 'function',
            name => 'clipRect',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'clipRect'
            }
          },
          {
            kind => 'function',
            name => 'selectionCategory',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QCP::Interaction',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplements => {
              name => 'selectionCategory'
            }
          },
          {
            kind => 'function',
            name => 'applyDefaultAntialiasingHint',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'applyDefaultAntialiasingHint'
            }
          },
          {
            kind => 'function',
            name => 'selectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'additive',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              },
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'selectEvent'
            }
          },
          {
            kind => 'function',
            name => 'deselectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplements => {
              name => 'deselectEvent'
            }
          },
          {
            kind => 'function',
            name => 'applyFillAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyScattersAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'parentPlotInitialized',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ],
            reimplemented_by => [
              {
                name => 'parentPlotInitialized'
              },
              {
                name => 'parentPlotInitialized'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mousePressEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).'
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' uses an event propagation system that works the same as Qt\'s system. If your layerable doesn\'t reimplement the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or explicitly calls '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in its reimplementation, the event will be propagated to the next layerable in the stacking order.Once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              },
              {
                name => 'mousePressEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseMoveEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              },
              {
                name => 'mouseMoveEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseReleaseEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              },
              {
                name => 'mouseReleaseEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseDoubleClickEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called instead of the second '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. So in the case of a double-click, the event succession is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pressEvent - releaseEvent - doubleClickEvent - releaseEvent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).Similarly to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseDoubleClickEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'wheelEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QWheelEvent *'
              }
            ],
            reimplemented_by => [
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              },
              {
                name => 'wheelEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'initializeParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentLayerable',
                type => 'QCPLayerable *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveToLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              },
              {
                declaration_name => 'prepend',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'localAntialiased',
                type => 'bool'
              },
              {
                declaration_name => 'overrideElement',
                type => 'QCP::AntialiasedElement'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mDataRange',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange'
          },
          {
            kind => 'variable',
            name => 'mDataScaleType',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis::ScaleType'
          },
          {
            kind => 'variable',
            name => 'mMapData',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPColorMapData *'
          },
          {
            kind => 'variable',
            name => 'mGradient',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPColorGradient'
          },
          {
            kind => 'variable',
            name => 'mInterpolate',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mTightBoundary',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mColorScale',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPColorScale >'
          },
          {
            kind => 'variable',
            name => 'mMapImage',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QImage'
          },
          {
            kind => 'variable',
            name => 'mUndersampledMapImage',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QImage'
          },
          {
            kind => 'variable',
            name => 'mLegendIcon',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPixmap'
          },
          {
            kind => 'variable',
            name => 'mMapImageInvalidated',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mName',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString'
          },
          {
            kind => 'variable',
            name => 'mAntialiasedFill',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mAntialiasedScatters',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mPen',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPen'
          },
          {
            kind => 'variable',
            name => 'mBrush',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush'
          },
          {
            kind => 'variable',
            name => 'mKeyAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxis >'
          },
          {
            kind => 'variable',
            name => 'mValueAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxis >'
          },
          {
            kind => 'variable',
            name => 'mSelectable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::SelectionType'
          },
          {
            kind => 'variable',
            name => 'mSelection',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPDataSelection'
          },
          {
            kind => 'variable',
            name => 'mSelectionDecorator',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPSelectionDecorator *'
          },
          {
            kind => 'variable',
            name => 'mVisible',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPLayerable >'
          },
          {
            kind => 'variable',
            name => 'mLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *'
          },
          {
            kind => 'variable',
            name => 'mAntialiased',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCustomPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'friend',
            name => 'QCPLegend',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A plottable representing a two-dimensional color map in a plot. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The data is stored in the class '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMapData'
              }
            ]
          },
          {
            type => 'text',
            content => ', which can be accessed via the '
          },
          {
            type => 'url',
            link => 'classQCPColorMap_1a047d7eb3ae657f93f2f39b5e68b79451',
            content => 'data()'
          },
          {
            type => 'text',
            content => ' method.A color map has three dimensions to represent a data point: The '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'key'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' dimension, the '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'value'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' dimension and the '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'data'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' dimension. As with other plottables such as graphs, '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'key'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'value'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' correspond to two orthogonal axes on the '
          },
          {
            type => 'url',
            link => 'classQCustomPlot',
            content => 'QCustomPlot'
          },
          {
            type => 'text',
            content => ' surface that you specify in the '
          },
          {
            type => 'url',
            link => 'classQCPColorMap',
            content => 'QCPColorMap'
          },
          {
            type => 'text',
            content => ' constructor. The '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'data'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' dimension however is encoded as the color of the point at ('
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'key'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ', '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'value'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ').'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'Set the number of points (or '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'cells'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ') in the key/value dimension via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMapData::setSize'
              }
            ]
          },
          {
            type => 'text',
            content => '. The plot coordinate range over which these points will be displayed is specified via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMapData::setRange'
              }
            ]
          },
          {
            type => 'text',
            content => '. The first cell will be centered on the lower range boundary and the last cell will be centered on the upper range boundary. The data can be set by either accessing the cells directly with '
          },
          {
            type => 'url',
            link => 'classQCPColorMapData_1a8e75eaf8746596319032a93f3d2d0683',
            content => 'QCPColorMapData::setCell'
          },
          {
            type => 'text',
            content => ' or by addressing the cells via their plot coordinates with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMapData::setData'
              }
            ]
          },
          {
            type => 'text',
            content => '. If possible, you should prefer setCell, since it doesn\'t need to do any coordinate transformation and thus performs a bit better.The cell with index (0, 0) is at the bottom left, if the color map uses normal (i.e. not reversed) key and value axes.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'To show the user which colors correspond to which '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'data'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' values, a '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorScale'
              }
            ]
          },
          {
            type => 'text',
            content => ' is typically placed to the right of the axis rect. See the documentation there for details on how to add and use a color scale.'
          },
          {
            type => 'sect1',
            title => 'Changing the appearance',
            content => [
              {
                type => 'text',
                content => 'The central part of the appearance is the color gradient, which can be specified via '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setGradient'
                  }
                ]
              },
              {
                type => 'text',
                content => '. See the documentation of '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPColorGradient'
                  }
                ]
              },
              {
                type => 'text',
                content => ' for details on configuring a color gradient.The '
              },
              {
                type => 'style',
                style => 'italic',
                enable => 'yes'
              },
              {
                type => 'text',
                content => 'data'
              },
              {
                type => 'style',
                style => 'italic',
                enable => 'no'
              },
              {
                type => 'text',
                content => ' range that is mapped to the colors of the gradient can be specified with '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'setDataRange'
                  }
                ]
              },
              {
                type => 'text',
                content => '. To make the data range encompass the whole data set minimum to maximum, call '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'rescaleDataRange'
                  }
                ]
              },
              {
                type => 'text',
                content => '.'
              }
            ]
          },
          {
            type => 'sect1',
            title => 'Transparency',
            content => [
              {
                type => 'text',
                content => 'Transparency in color maps can be achieved by two mechanisms. On one hand, you can specify alpha values for color stops of the '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPColorGradient'
                  }
                ]
              },
              {
                type => 'text',
                content => ', via the regular QColor interface. This will cause the color map data which gets mapped to colors around those color stops to appear with the accordingly interpolated transparency.On the other hand you can also directly apply an alpha value to each cell independent of its data, by using the alpha map feature of '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPColorMapData'
                  }
                ]
              },
              {
                type => 'text',
                content => '. The relevant methods are '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPColorMapData::setAlpha'
                  }
                ]
              },
              {
                type => 'text',
                content => ', '
              },
              {
                type => 'url',
                link => 'classQCPColorMapData_1a93e2a549d7702bc849cd48a585294657',
                content => 'QCPColorMapData::fillAlpha'
              },
              {
                type => 'text',
                content => ' and '
              },
              {
                type => 'ref',
                content => [
                  {
                    type => 'text',
                    content => 'QCPColorMapData::clearAlpha()'
                  }
                ]
              },
              {
                type => 'text',
                content => '.The two transparencies will be joined together in the plot and otherwise not interfere with each other. They are mixed in a multiplicative matter, so an alpha of e.g. 50% (128/255) in both modes simultaneously, will result in a total transparency of 25% (64/255).'
              }
            ]
          },
          {
            type => 'sect1',
            title => 'Usage',
            content => [
              {
                type => 'text',
                content => 'Like all data representing objects in '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ', the '
              },
              {
                type => 'url',
                link => 'classQCPColorMap',
                content => 'QCPColorMap'
              },
              {
                type => 'text',
                content => ' is a plottable ('
              },
              {
                type => 'url',
                link => 'classQCPAbstractPlottable',
                content => 'QCPAbstractPlottable'
              },
              {
                type => 'text',
                content => '). So the plottable-interface of '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ' applies ('
              },
              {
                type => 'url',
                link => 'classQCustomPlot_1a32de81ff53e263e785b83b52ecd99d6f',
                content => 'QCustomPlot::plottable'
              },
              {
                type => 'text',
                content => ', '
              },
              {
                type => 'url',
                link => 'classQCustomPlot_1af3dafd56884208474f311d6226513ab2',
                content => 'QCustomPlot::removePlottable'
              },
              {
                type => 'text',
                content => ', etc.)'
              },
              {
                type => 'parbreak'
              },
              {
                type => 'text',
                content => 'Usually, you first create an instance: which registers it with the '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ' instance of the passed axes. Note that this '
              },
              {
                type => 'url',
                link => 'classQCustomPlot',
                content => 'QCustomPlot'
              },
              {
                type => 'text',
                content => ' instance takes ownership of the plottable, so do not delete it manually but use '
              },
              {
                type => 'url',
                link => 'classQCustomPlot_1af3dafd56884208474f311d6226513ab2',
                content => 'QCustomPlot::removePlottable()'
              },
              {
                type => 'text',
                content => ' instead. The newly created plottable can be modified, e.g.:  '
              },
              {
                note => [
                  {
                    type => 'text',
                    content => 'The '
                  },
                  {
                    type => 'url',
                    link => 'classQCPColorMap',
                    content => 'QCPColorMap'
                  },
                  {
                    type => 'text',
                    content => ' always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use '
                  },
                  {
                    type => 'url',
                    link => 'classQCPColorMap',
                    content => 'QCPColorMap'
                  },
                  {
                    type => 'text',
                    content => ' with logarithmic axes, you shouldn\'t use the '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'QCPColorMapData::setData'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => ' method as it uses a linear transformation to determine the cell index. Rather directly access the cell index with '
                  },
                  {
                    type => 'ref',
                    content => [
                      {
                        type => 'text',
                        content => 'QCPColorMapData::setCell'
                      }
                    ]
                  },
                  {
                    type => 'text',
                    content => '. '
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      name => 'QCPColorMapData',
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'alpha',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'cell',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'cellToCoord',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'clear',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'clearAlpha',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'coordToCell',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'createAlpha',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'data',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'dataBounds',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'fill',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'fillAlpha',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'isEmpty',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'keyRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'keySize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'mAlpha',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'mData',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'mDataBounds',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'mDataModified',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'mIsEmpty',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'mKeyRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'mKeySize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'mValueRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'mValueSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'operator=',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'QCPColorMap',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorMapData'
        },
        {
          name => 'QCPColorMapData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'QCPColorMapData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'recalculateDataBounds',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'setAlpha',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'setCell',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'setData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'setKeyRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'setKeySize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'setRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'setSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'setValueRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'setValueSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'valueRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => 'valueSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        },
        {
          name => '~QCPColorMapData',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorMapData'
        }
      ],
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPColorMapData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a new '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMapData',
                  content => 'QCPColorMapData'
                },
                {
                  type => 'text',
                  content => ' instance. The instance has '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keySize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' cells in the key direction and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueSize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' cells in the value direction. These cells will be displayed by the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMap'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' at the coordinates '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0d9ff35c299d0478b682bfbcdd9c097e',
                      content => 'setSize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1ac7ef70e383aface34b44dbde49234b6b',
                      content => 'setKeySize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0893c9e3914513048b45e3429ffd16f2',
                      content => 'setValueSize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1aad9c1c7c703c1339489fc730517c83d4',
                      content => 'setRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0738c485f3c9df9ea1241b7a8bb6a86e',
                      content => 'setKeyRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1ada1b2680ba96a5f4175b6d341cf75d23',
                      content => 'setValueRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keySize',
                type => 'int'
              },
              {
                declaration_name => 'valueSize',
                type => 'int'
              },
              {
                declaration_name => 'keyRange',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'valueRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPColorMapData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'QCPColorMapData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a new '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMapData',
                  content => 'QCPColorMapData'
                },
                {
                  type => 'text',
                  content => ' instance copying the data and range of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'other'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'other',
                type => 'const QCPColorMapData &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'operator=',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Overwrites this color map data instance with the data stored in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'other'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The alpha map state is transferred, too. '
                }
              ]
            },
            type => 'QCPColorMapData &',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'other',
                type => 'const QCPColorMapData &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'keySize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'valueSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'keyRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'valueRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'dataBounds',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'data',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'cell',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyIndex',
                type => 'int'
              },
              {
                declaration_name => 'valueIndex',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'alpha',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the alpha map value of the cell with the indices '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this color map data doesn\'t have an alpha map (because '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAlpha'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' was never called after creation or after a call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'clearAlpha'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), returns 255, which corresponds to full opacity.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1aaf7de5b34c58f38d8f4c1ceb064a876c',
                      content => 'setAlpha'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'unsigned char',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyIndex',
                type => 'int'
              },
              {
                declaration_name => 'valueIndex',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Resizes the data array to have '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keySize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' cells in the key dimension and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueSize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' cells in the value dimension.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The current data is discarded and the map cells are set to 0, unless the map had already the requested size.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Setting at least one of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keySize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueSize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to zero frees the internal data array and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'isEmpty'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1aad9c1c7c703c1339489fc730517c83d4',
                      content => 'setRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1ac7ef70e383aface34b44dbde49234b6b',
                      content => 'setKeySize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0893c9e3914513048b45e3429ffd16f2',
                      content => 'setValueSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keySize',
                type => 'int'
              },
              {
                declaration_name => 'valueSize',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setKeySize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Resizes the data array to have '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keySize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' cells in the key dimension.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The current data is discarded and the map cells are set to 0, unless the map had already the requested size.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keySize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to zero frees the internal data array and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'isEmpty'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0738c485f3c9df9ea1241b7a8bb6a86e',
                      content => 'setKeyRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0d9ff35c299d0478b682bfbcdd9c097e',
                      content => 'setSize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0893c9e3914513048b45e3429ffd16f2',
                      content => 'setValueSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keySize',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setValueSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Resizes the data array to have '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueSize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' cells in the value dimension.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The current data is discarded and the map cells are set to 0, unless the map had already the requested size.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueSize'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to zero frees the internal data array and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'isEmpty'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1ada1b2680ba96a5f4175b6d341cf75d23',
                      content => 'setValueRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0d9ff35c299d0478b682bfbcdd9c097e',
                      content => 'setSize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1ac7ef70e383aface34b44dbde49234b6b',
                      content => 'setKeySize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'valueSize',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the coordinate ranges the data shall be distributed over. This defines the rectangular area covered by the color map in plot coordinates.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The outer cells will be centered on the range boundaries given to this function. For example, if the key size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setKeySize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') is 3 and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'url',
                  link => 'classQCPRange',
                  content => 'QCPRange(2, 3)'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' there will be cells centered on the key coordinates 2, 2.5 and 3.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0d9ff35c299d0478b682bfbcdd9c097e',
                      content => 'setSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyRange',
                type => 'const QCPRange &'
              },
              {
                declaration_name => 'valueRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setKeyRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the coordinate range the data shall be distributed over in the key dimension. Together with the value range, This defines the rectangular area covered by the color map in plot coordinates.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The outer cells will be centered on the range boundaries given to this function. For example, if the key size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setKeySize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') is 3 and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'url',
                  link => 'classQCPRange',
                  content => 'QCPRange(2, 3)'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' there will be cells centered on the key coordinates 2, 2.5 and 3.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1aad9c1c7c703c1339489fc730517c83d4',
                      content => 'setRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1ada1b2680ba96a5f4175b6d341cf75d23',
                      content => 'setValueRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0d9ff35c299d0478b682bfbcdd9c097e',
                      content => 'setSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setValueRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the coordinate range the data shall be distributed over in the value dimension. Together with the key range, This defines the rectangular area covered by the color map in plot coordinates.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The outer cells will be centered on the range boundaries given to this function. For example, if the value size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setValueSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') is 3 and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueRange'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'url',
                  link => 'classQCPRange',
                  content => 'QCPRange(2, 3)'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' there will be cells centered on the value coordinates 2, 2.5 and 3.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1aad9c1c7c703c1339489fc730517c83d4',
                      content => 'setRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0738c485f3c9df9ea1241b7a8bb6a86e',
                      content => 'setKeyRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0d9ff35c299d0478b682bfbcdd9c097e',
                      content => 'setSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'valueRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setData',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the data of the cell, which lies at the plot coordinates given by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'z'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  note => [
                    {
                      type => 'text',
                      content => 'The '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMap',
                      content => 'QCPColorMap'
                    },
                    {
                      type => 'text',
                      content => ' always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMap',
                      content => 'QCPColorMap'
                    },
                    {
                      type => 'text',
                      content => ' with logarithmic axes, you shouldn\'t use the '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'QCPColorMapData::setData'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' method as it uses a linear transformation to determine the cell index. Rather directly access the cell index with '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'QCPColorMapData::setCell'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => '.'
                    }
                  ]
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a8e75eaf8746596319032a93f3d2d0683',
                      content => 'setCell'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1aad9c1c7c703c1339489fc730517c83d4',
                      content => 'setRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              },
              {
                declaration_name => 'z',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setCell',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the data of the cell with indices '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'z'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The indices enumerate the cells starting from zero, up to the map\'s size-1 in the respective dimension (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').In the standard plot configuration (horizontal key axis and vertical value axis, both not range-reversed), the cell with indices (0, 0) is in the bottom left corner and the cell with indices (keySize-1, valueSize-1) is in the top right corner of the color map.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1afd2083ccfd6987ec94aa7ef8e91ca39a',
                      content => 'setData'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a0d9ff35c299d0478b682bfbcdd9c097e',
                      content => 'setSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyIndex',
                type => 'int'
              },
              {
                declaration_name => 'valueIndex',
                type => 'int'
              },
              {
                declaration_name => 'z',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAlpha',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the alpha of the color map cell given by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alpha'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. A value of 0 for '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alpha'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' results in a fully transparent cell, and a value of 255 results in a fully opaque cell.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If an alpha map doesn\'t exist yet for this color map data, it will be created here. If you wish to restore full opacity and free any allocated memory of the alpha map, call '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'clearAlpha'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Note that the cell-wise alpha which can be configured here is independent of any alpha configured in the color map\'s gradient ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorGradient'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). If a cell is affected both by the cell-wise and gradient alpha, the alpha values will be blended accordingly during rendering of the color map.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a93e2a549d7702bc849cd48a585294657',
                      content => 'fillAlpha'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1a14d08b9c3720cd719400079b86d3906b',
                      content => 'clearAlpha'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyIndex',
                type => 'int'
              },
              {
                declaration_name => 'valueIndex',
                type => 'int'
              },
              {
                declaration_name => 'alpha',
                type => 'unsigned char'
              }
            ]
          },
          {
            kind => 'function',
            name => 'recalculateDataBounds',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Goes through the data and updates the buffered minimum and maximum data values.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Calling this method is only advised if you are about to call '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMap::rescaleDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and can not guarantee that the cells holding the maximum or minimum data haven\'t been overwritten with a smaller or larger value respectively, since the buffered maximum/minimum values have been updated the last time. Why this is the case is explained in the class description ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMapData'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').Note that the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorMap::rescaleDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' provides a parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'recalculateDataBounds'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' for convenience. Setting this to true will call this method for you, before doing the rescale. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'clear',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Frees the internal data memory.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This is equivalent to calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSize(0, 0)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'clearAlpha',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Frees the internal alpha map. The color map will have full opacity again. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'fill',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets all cells to the value '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'z'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'z',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'fillAlpha',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the opacity of all color map cells to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alpha'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. A value of 0 for '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'alpha'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' results in a fully transparent color map, and a value of 255 results in a fully opaque color map.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If you wish to restore opacity to 100% and free any used memory for the alpha map, rather use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'clearAlpha'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1aaf7de5b34c58f38d8f4c1ceb064a876c',
                      content => 'setAlpha'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'alpha',
                type => 'unsigned char'
              }
            ]
          },
          {
            kind => 'function',
            name => 'isEmpty',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns whether this instance carries no data. This is equivalent to having a size where at least one of the dimensions is 0 (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'coordToCell',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Transforms plot coordinates given by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to cell indices of this '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMapData',
                  content => 'QCPColorMapData'
                },
                {
                  type => 'text',
                  content => ' instance. The resulting cell indices are returned via the output parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The retrieved key/value cell indices can then be used for example with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setCell'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.If you are only interested in a key or value index, you may pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  note => [
                    {
                      type => 'text',
                      content => 'The '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMap',
                      content => 'QCPColorMap'
                    },
                    {
                      type => 'text',
                      content => ' always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMap',
                      content => 'QCPColorMap'
                    },
                    {
                      type => 'text',
                      content => ' with logarithmic axes, you shouldn\'t use the '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'QCPColorMapData::coordToCell'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' method as it uses a linear transformation to determine the cell index.'
                    }
                  ]
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1af1a36385c78ab624cd617065602408b6',
                      content => 'cellToCoord'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1af15d1b3a7f7e9b53d759d3ccff1fe4b4',
                      content => 'QCPAxis::coordToPixel'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'key',
                type => 'double'
              },
              {
                declaration_name => 'value',
                type => 'double'
              },
              {
                declaration_name => 'keyIndex',
                type => 'int *'
              },
              {
                declaration_name => 'valueIndex',
                type => 'int *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'cellToCoord',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Transforms cell indices given by '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'keyIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'valueIndex'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to cell indices of this '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMapData',
                  content => 'QCPColorMapData'
                },
                {
                  type => 'text',
                  content => ' instance. The resulting coordinates are returned via the output parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If you are only interested in a key or value coordinate, you may pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'key'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'value'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  note => [
                    {
                      type => 'text',
                      content => 'The '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMap',
                      content => 'QCPColorMap'
                    },
                    {
                      type => 'text',
                      content => ' always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling. If you want to use '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorMap',
                      content => 'QCPColorMap'
                    },
                    {
                      type => 'text',
                      content => ' with logarithmic axes, you shouldn\'t use the '
                    },
                    {
                      type => 'ref',
                      content => [
                        {
                          type => 'text',
                          content => 'QCPColorMapData::cellToCoord'
                        }
                      ]
                    },
                    {
                      type => 'text',
                      content => ' method as it uses a linear transformation to determine the cell index.'
                    }
                  ]
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorMapData_1aca5b29e0ca2f299c9060fc6e1f74d0c8',
                      content => 'coordToCell'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxis_1a536ef8f624cac59b6b6fdcb495723c57',
                      content => 'QCPAxis::pixelToCoord'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'keyIndex',
                type => 'int'
              },
              {
                declaration_name => 'valueIndex',
                type => 'int'
              },
              {
                declaration_name => 'key',
                type => 'double *'
              },
              {
                declaration_name => 'value',
                type => 'double *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'createAlpha',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'initializeOpaque',
                type => 'bool',
                default_value => 'true'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mKeySize',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mValueSize',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mKeyRange',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange'
          },
          {
            kind => 'variable',
            name => 'mValueRange',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange'
          },
          {
            kind => 'variable',
            name => 'mIsEmpty',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mData',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'double *'
          },
          {
            kind => 'variable',
            name => 'mAlpha',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'unsigned char *'
          },
          {
            kind => 'variable',
            name => 'mDataBounds',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange'
          },
          {
            kind => 'variable',
            name => 'mDataModified',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCPColorMap',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'text',
            content => 'Holds the two-dimensional data of a '
          },
          {
            type => 'url',
            link => 'classQCPColorMap',
            content => 'QCPColorMap'
          },
          {
            type => 'text',
            content => ' plottable. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'text',
            content => 'This class is a data storage for '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMap'
              }
            ]
          },
          {
            type => 'text',
            content => '. It holds a two-dimensional array, which '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMap'
              }
            ]
          },
          {
            type => 'text',
            content => ' then displays as a 2D image in the plot, where the array values are represented by a color, depending on the value.The size of the array can be controlled via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setSize'
              }
            ]
          },
          {
            type => 'text',
            content => ' (or '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setKeySize'
              }
            ]
          },
          {
            type => 'text',
            content => ', '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setValueSize'
              }
            ]
          },
          {
            type => 'text',
            content => '). Which plot coordinates these cells correspond to can be configured with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setRange'
              }
            ]
          },
          {
            type => 'text',
            content => ' (or '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setKeyRange'
              }
            ]
          },
          {
            type => 'text',
            content => ', '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setValueRange'
              }
            ]
          },
          {
            type => 'text',
            content => ').The data cells can be accessed in two ways: They can be directly addressed by an integer index with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setCell'
              }
            ]
          },
          {
            type => 'text',
            content => '. This is the fastest method. Alternatively, they can be addressed by their plot coordinate with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setData'
              }
            ]
          },
          {
            type => 'text',
            content => '. plot coordinate to cell index transformations and vice versa are provided by the functions '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'coordToCell'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'cellToCoord'
              }
            ]
          },
          {
            type => 'text',
            content => '.A '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMapData'
              }
            ]
          },
          {
            type => 'text',
            content => ' also holds an on-demand two-dimensional array of alpha values which (if allocated) has the same size as the data map. It can be accessed via '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setAlpha'
              }
            ]
          },
          {
            type => 'text',
            content => ', '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'fillAlpha'
              }
            ]
          },
          {
            type => 'text',
            content => ' and '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'clearAlpha'
              }
            ]
          },
          {
            type => 'text',
            content => '. The memory for the alpha map is only allocated if needed, i.e. on the first call of '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setAlpha'
              }
            ]
          },
          {
            type => 'text',
            content => '. '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'clearAlpha'
              }
            ]
          },
          {
            type => 'text',
            content => ' restores full opacity and frees the alpha map.This class also buffers the minimum and maximum values that are in the data set, to provide '
          },
          {
            type => 'url',
            link => 'classQCPColorMap_1a856608fa3dd1cc290bcd5f29a5575774',
            content => 'QCPColorMap::rescaleDataRange'
          },
          {
            type => 'text',
            content => ' with the necessary information quickly. Setting a cell to a value that is greater than the current maximum increases this maximum to the new value. However, setting the cell that currently holds the maximum value to a smaller value doesn\'t decrease the maximum again, because finding the true new maximum would require going through the entire data array, which might be time consuming. The same holds for the data minimum. This functionality is given by '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'recalculateDataBounds'
              }
            ]
          },
          {
            type => 'text',
            content => ', such that you can decide when it is sensible to find the true current minimum and maximum. The method '
          },
          {
            type => 'url',
            link => 'classQCPColorMap_1a856608fa3dd1cc290bcd5f29a5575774',
            content => 'QCPColorMap::rescaleDataRange'
          },
          {
            type => 'text',
            content => ' offers a convenience parameter '
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'recalculateDataBounds'
          },
          {
            type => 'style',
            style => 'italic',
            enable => 'no'
          },
          {
            type => 'text',
            content => ' which may be set to true to automatically call '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'recalculateDataBounds'
              }
            ]
          },
          {
            type => 'text',
            content => ' internally. '
          }
        ]
      }
    },
    {
      name => 'QCPColorScale',
      base => [
        {
          name => 'QCPLayoutElement',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'autoMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'axis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'barWidth',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'calculateAutoMargin',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'colorMaps',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'dataRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'dataRangeChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'dataScaleType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'dataScaleTypeChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'draw',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'elements',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'gradient',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'gradientChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'label',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'layoutChanged',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'marginGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'marginGroups',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'margins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mAutoMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'maximumOuterSizeHint',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'maximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mAxisRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'mBarWidth',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'mColorAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'mDataRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'mDataScaleType',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'mGradient',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'minimumMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'minimumOuterSizeHint',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'minimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mMarginGroups',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMaximumSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMinimumMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMinimumSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'mOuterRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayout',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mSizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mType',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'outerRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'QCPColorScale',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'QCPColorScaleAxisRectPrivate',
          virtualness => 'non_virtual',
          protection => 'private',
          scope => 'QCPColorScale'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'QCPLayoutElement',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'rangeDrag',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'rangeZoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'rect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'rescaleDataRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'scrInnerRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'scrOuterRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'selectTest',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setAutoMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setBarWidth',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'setDataRange',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'setDataScaleType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'setGradient',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'setLabel',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setMarginGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMaximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMaximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setOuterRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setRangeDrag',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'setRangeZoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'setSizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setType',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'SizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'sizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'type',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'update',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => 'UpdatePhase',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upLayout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upPreparation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPColorScale'
        },
        {
          name => '~QCPColorScale',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPColorScale'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPLayoutElement',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'UpdatePhase',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines the phases of the update process, that happens just before a replot. At each phase, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'update'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called with the according UpdatePhase value. '
                }
              ]
            },
            values => [
              {
                name => 'upPreparation',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Phase used for any type of preparation that needs to be done before margin calculation and layout. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'upMargins',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Phase in which the margins are calculated and set. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'upLayout',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Final phase in which the layout system places the rects of the elements. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enum',
            name => 'SizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines to which rect of a layout element the size constraints that can be set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' apply. The outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') includes the margins (e.g. in the case of a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => ' the axis labels), whereas the inner rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') does not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a361666cdcc6fbfd37344cc44be746b0f',
                      content => 'setSizeConstraintRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'scrInnerRect',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Minimum/Maximum size constraints apply to inner rect. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'scrOuterRect',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'upPreparation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Phase used for any type of preparation that needs to be done before margin calculation and layout. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'upMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Phase in which the margins are calculated and set. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'upLayout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'text',
                  content => 'Final phase in which the layout system places the rects of the elements. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'scrInnerRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Minimum/Maximum size constraints apply to inner rect. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'scrOuterRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPColorScale',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Constructs a new '
                },
                {
                  type => 'url',
                  link => 'classQCPColorScale',
                  content => 'QCPColorScale'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => '~QCPColorScale',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'axis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the internal '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' instance of this color scale. You can access it to alter the appearance and behaviour of the axis. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPColorScale'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' duplicates some properties in its interface for convenience. Those are '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDataScaleType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setScaleType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), and the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setLabel'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setLabel'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). As they each are connected, it does not matter whether you use the method on the '
                },
                {
                  type => 'url',
                  link => 'classQCPColorScale',
                  content => 'QCPColorScale'
                },
                {
                  type => 'text',
                  content => ' or on its '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => '.If the type of the color scale is changed with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', the axis returned by this method will change, too, to either the left, right, bottom or top axis, depending on which type was set. '
                }
              ]
            },
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'type',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis::AxisType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'dataRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'dataScaleType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis::ScaleType',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'gradient',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPColorGradient',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'label',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QString',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'barWidth',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rangeDrag',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rangeZoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets at which side of the color scale the axis is placed, and thus also its orientation.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that after setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to a different value, the axis returned by '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'axis()'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' will be a different one. The new axis will adopt the following properties from the previous axis: The range, scale type, label and ticker (the latter will be shared and not copied). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'QCPAxis::AxisType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setDataRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the range spanned by the color gradient and that is shown by the axis in the color scale.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'It is equivalent to calling '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMap_1a980b42837821159786a85b4b7dcb8774',
                  content => 'QCPColorMap::setDataRange'
                },
                {
                  type => 'text',
                  content => ' on any of the connected color maps. It is also equivalent to directly accessing the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'axis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and setting its range with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1aeb6107d67dd7325145b2498abae67fc3',
                      content => 'setDataScaleType'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a1f29583bb6f1e7f473b62fb712be3940',
                      content => 'setGradient'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a425983db4478543924ddbd04ea20a356',
                      content => 'rescaleDataRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'dataRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setDataScaleType',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the scale type of the color scale, i.e. whether values are linearly associated with colors or logarithmically.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'It is equivalent to calling '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMap_1a9d20aa08e3c1f20f22908c45b9c06511',
                  content => 'QCPColorMap::setDataScaleType'
                },
                {
                  type => 'text',
                  content => ' on any of the connected color maps. It is also equivalent to directly accessing the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'axis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and setting its scale type with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setScaleType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1abe88633003a26d1e756aa74984587fef',
                      content => 'setDataRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a1f29583bb6f1e7f473b62fb712be3940',
                      content => 'setGradient'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'scaleType',
                type => 'QCPAxis::ScaleType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setGradient',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the color gradient that will be used to represent data values.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'It is equivalent to calling '
                },
                {
                  type => 'url',
                  link => 'classQCPColorMap_1a7313c78360471cead3576341a2c50377',
                  content => 'QCPColorMap::setGradient'
                },
                {
                  type => 'text',
                  content => ' on any of the connected color maps.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1abe88633003a26d1e756aa74984587fef',
                      content => 'setDataRange'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1aeb6107d67dd7325145b2498abae67fc3',
                      content => 'setDataScaleType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'Q_SLOT void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'gradient',
                type => 'const QCPColorGradient &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLabel',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the axis label of the color scale. This is equivalent to calling '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setLabel'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' on the internal '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'axis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'str',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBarWidth',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the width (or height, for horizontal color scales) the bar where the gradient is displayed will have. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeDrag',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether the user can drag the data range ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').Note that '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeDrag'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' must be in the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '\'s interactions ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to allow range dragging. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the user can zoom the data range ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setDataRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') by scrolling the mouse wheel.Note that '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeZoom'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' must be in the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '\'s interactions ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to allow range dragging. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'colorMaps',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all the color maps associated with this color scale. '
                }
              ]
            },
            type => 'QList< QCPColorMap * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rescaleDataRange',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Changes the data range such that all color maps associated with this color scale are fully mapped to the gradient in the data dimension.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1abe88633003a26d1e756aa74984587fef',
                      content => 'setDataRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'onlyVisibleMaps',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'update',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Updates the layout element and sub-elements. This function is automatically called before every replot by the parent layout element. It is called multiple times, once for every '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'UpdatePhase'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The phases are run through in the order of the enum values. For details about what happens at the different phases, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'UpdatePhase'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Layout elements that have child elements should call the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'update'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' method of their child elements, and pass the current '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'phase'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' unchanged.The default implementation executes the automatic margin mechanism in the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'upMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' phase. Subclasses should make sure to call the base class implementation. '
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'phase',
                type => 'UpdatePhase'
              }
            ],
            reimplements => {
              name => 'update'
            }
          },
          {
            kind => 'function',
            name => 'layout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the parent layout of this layout element. '
                }
              ]
            },
            type => 'QCPLayout *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the inner rect of this layout element. The inner rect is the outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') shrinked by the margins ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').In some cases, the area between outer and inner rect is left blank. In other cases the margin area is used to display peripheral graphics while the main content is in the inner rect. This is where automatic margin calculation becomes interesting because it allows the layout element to adapt the margins to the peripheral graphics it wants to draw. For example, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' draws the axis labels and tick labels in the margin area, thus needs to adjust the margins (if '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is enabled) according to the space required by the labels of the axes.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a2a32a12a6161c9dffbadeb9cc585510c',
                      content => 'outerRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'outerRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the outer rect of this layout element. The outer rect is the inner rect expanded by the margins ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). The outer rect is used (and set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') by the parent '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to control the size of this layout element.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a208effccfe2cca4a0eaf9393e60f2dd4',
                      content => 'rect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'margins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'minimumMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'autoMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::MarginSides',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'minimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'maximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'sizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SizeConstraintRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'marginGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPMarginGroup *',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'side',
                type => 'QCP::MarginSide'
              }
            ]
          },
          {
            kind => 'function',
            name => 'marginGroups',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< QCP::MarginSide, QCPMarginGroup * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setOuterRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the outer rect of this layout element. If the layout element is inside a layout, the layout sets the position and size of this layout element using this function.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Calling this function externally has no effect, since the layout will overwrite any changes to the outer rect upon the next replot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The layout element will adapt its inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' by applying the margins inward to the outer rect.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a208effccfe2cca4a0eaf9393e60f2dd4',
                      content => 'rect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'rect',
                type => 'const QRect &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the margins of this layout element. If '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is disabled for some or all sides, this function is used to manually set the margin on those sides. Sides that are still set to be handled automatically are ignored and may have any value in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'margins'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The margin is the distance between the outer rect (controlled by the parent layout via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') and the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (which usually contains the main content of this layout element).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1accfda49994e3e6d51ed14504abf9d27d',
                      content => 'setAutoMargins'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'margins',
                type => 'const QMargins &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is enabled on some or all margins, this function is used to provide minimum values for those margins.The minimum values are not enforced on margin sides that were set to be under manual control via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1accfda49994e3e6d51ed14504abf9d27d',
                      content => 'setAutoMargins'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'margins',
                type => 'const QMargins &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAutoMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets on which sides the margin shall be calculated automatically. If a side is calculated automatically, a minimum margin value may be provided with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. If a side is set to be controlled manually, the value may be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Margin sides that are under automatic control may participate in a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), to synchronize (align) it with other layout elements in the plot.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a0a8a17abc16b7923159fcc7608f94673',
                      content => 'setMinimumMargins'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a8f450b1f3f992ad576fce2c63d8b79cf',
                      content => 'setMargins'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54',
                      content => 'QCP::MarginSide'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sides',
                type => 'QCP::MarginSides'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the minimum size of this layout element. A parent layout tries to respect the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' here by changing row/column sizes in the layout accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the parent layout size is not sufficient to satisfy all minimum size constraints of its child layout elements, the layout may set a size that is actually smaller than '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' propagates the layout\'s size constraints to the outside by setting its own minimum QWidget size accordingly, so violations of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' should be exceptions.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the minimum size of this layout element.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'int'
              },
              {
                declaration_name => 'height',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMaximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the maximum size of this layout element. A parent layout tries to respect the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' here by changing row/column sizes in the layout accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMaximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the maximum size of this layout element.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'int'
              },
              {
                declaration_name => 'height',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets to which rect of a layout element the size constraints apply. Size constraints can be set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') includes the margins (e.g. in the case of a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => ' the axis labels), whereas the inner rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') does not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a5dd29a3c8bc88440c97c06b67be7886b',
                      content => 'setMinimumSize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a74eb5280a737ab44833d506db65efd95',
                      content => 'setMaximumSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'constraintRect',
                type => 'SizeConstraintRect'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMarginGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the margin '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'group'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of the specified margin '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sides'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Margin groups allow synchronizing specified margins across layout elements, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.To unset the margin group of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sides'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'group'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that margin groups only work for margin sides that are set to automatic ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54',
                      content => 'QCP::MarginSide'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sides',
                type => 'QCP::MarginSides'
              },
              {
                declaration_name => 'group',
                type => 'QCPMarginGroup *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'minimumOuterSizeHint',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the suggested minimum size this layout element (the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') may be compressed to, if no manual minimum size is set.if a minimum size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') was not set manually, parent layouts use the returned size (usually indirectly through '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout::getFinalMinimumOuterSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to determine the minimum allowed size of this layout element.A manual minimum size is considered set if it is non-zero.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height. Reimplementations may use their detailed knowledge about the layout element\'s content to provide size hints. '
                }
              ]
            },
            type => 'virtual QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'minimumOuterSizeHint'
              },
              {
                name => 'minimumOuterSizeHint'
              },
              {
                name => 'minimumOuterSizeHint'
              }
            ]
          },
          {
            kind => 'function',
            name => 'maximumOuterSizeHint',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the suggested maximum size this layout element (the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') may be expanded to, if no manual maximum size is set.if a maximum size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') was not set manually, parent layouts use the returned size (usually indirectly through '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout::getFinalMaximumOuterSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to determine the maximum allowed size of this layout element.A manual maximum size is considered set if it is smaller than Qt\'s '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QWIDGETSIZE_MAX'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation simply returns '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QWIDGETSIZE_MAX'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' for both width and height, implying no suggested maximum size. Reimplementations may use their detailed knowledge about the layout element\'s content to provide size hints. '
                }
              ]
            },
            type => 'virtual QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'maximumOuterSizeHint'
              },
              {
                name => 'maximumOuterSizeHint'
              }
            ]
          },
          {
            kind => 'function',
            name => 'elements',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a list of all child elements in this layout element. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'recursive'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, all sub-child elements are included in the list, too.'
                },
                {
                  type => 'parbreak'
                },
                {
                  warning => [
                    {
                      type => 'text',
                      content => 'There may be entries with value 0 in the returned list. (For example, '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutGrid',
                      content => 'QCPLayoutGrid'
                    },
                    {
                      type => 'text',
                      content => ' may have empty cells which yield 0 at the respective index.) '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QList< QCPLayoutElement * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'recursive',
                type => 'bool'
              }
            ],
            reimplemented_by => [
              {
                name => 'elements'
              },
              {
                name => 'elements'
              },
              {
                name => 'elements'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Layout elements are sensitive to events inside their outer rect. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is within the outer rect, this method returns a value corresponding to 0.99 times the parent plot\'s selection tolerance. However, layout elements are not selectable by default. So if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlySelectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, -1.0 is returned.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayerable::selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for a general explanation of this virtual method.'
                },
                {
                  type => 'url',
                  link => 'classQCPLayoutElement',
                  content => 'QCPLayoutElement'
                },
                {
                  type => 'text',
                  content => ' subclasses may reimplement this method to provide more specific selection test behaviour. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            },
            reimplemented_by => [
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              }
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'dataRangeChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the data range changes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1abe88633003a26d1e756aa74984587fef',
                      content => 'setDataRange'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newRange',
                type => 'const QCPRange &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'dataScaleTypeChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the data scale type changes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1aeb6107d67dd7325145b2498abae67fc3',
                      content => 'setDataScaleType'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'scaleType',
                type => 'QCPAxis::ScaleType'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'gradientChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This signal is emitted when the gradient changes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a1f29583bb6f1e7f473b62fb712be3940',
                      content => 'setGradient'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newGradient',
                type => 'const QCPColorGradient &'
              }
            ]
          },
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'applyDefaultAntialiasingHint',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'applyDefaultAntialiasingHint'
            }
          },
          {
            kind => 'function',
            name => 'mousePressEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user presses a mouse button while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).'
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' uses an event propagation system that works the same as Qt\'s system. If your layerable doesn\'t reimplement the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or explicitly calls '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' in its reimplementation, the event will be propagated to the next layerable in the stacking order.Once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a3b2bd79725aefaf2630fc76e90939442',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a6a35dd39ab4e5cb2d7b29ebb4d5b61b0',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a63cf19be184f6670c9495ad3a9a1baeb',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplements => {
              name => 'mousePressEvent'
            }
          },
          {
            kind => 'function',
            name => 'mouseMoveEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user moves the mouse while holding a mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a91f633b97ffcd57fdf8cd814974c20e6',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a6a35dd39ab4e5cb2d7b29ebb4d5b61b0',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a63cf19be184f6670c9495ad3a9a1baeb',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplements => {
              name => 'mouseMoveEvent'
            }
          },
          {
            kind => 'function',
            name => 'mouseReleaseEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user releases the mouse button, after this layerable has become the mouse grabber by accepting the preceding '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'startPos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates the position where the initial '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' occured, that started the mouse interaction.The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a91f633b97ffcd57fdf8cd814974c20e6',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a3b2bd79725aefaf2630fc76e90939442',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a63cf19be184f6670c9495ad3a9a1baeb',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'startPos',
                type => 'const QPointF &'
              }
            ],
            reimplements => {
              name => 'mouseReleaseEvent'
            }
          },
          {
            kind => 'function',
            name => 'wheelEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This event gets called when the user turns the mouse scroll wheel while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' indicates how far the mouse wheel was turned, which is usually +/- 120 for single rotation steps. However, if the mouse wheel is turned rapidly, multiple steps may accumulate to one event, making '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->delta()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' larger. On the other hand, if the wheel has very smooth steps or none at all, the delta may be smaller.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation does nothing.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a91f633b97ffcd57fdf8cd814974c20e6',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a3b2bd79725aefaf2630fc76e90939442',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPColorScale_1a6a35dd39ab4e5cb2d7b29ebb4d5b61b0',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a4171e2e823aca242dd0279f00ed2de81',
                      content => 'mouseDoubleClickEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QWheelEvent *'
              }
            ],
            reimplements => {
              name => 'wheelEvent'
            }
          },
          {
            kind => 'function',
            name => 'calculateAutoMargin',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual int',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'side',
                type => 'QCP::MarginSide'
              }
            ],
            reimplemented_by => [
              {
                name => 'calculateAutoMargin'
              }
            ]
          },
          {
            kind => 'function',
            name => 'layoutChanged',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'layoutChanged'
              }
            ]
          },
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              }
            ],
            reimplements => {
              name => 'draw'
            },
            reimplemented_by => [
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              },
              {
                name => 'draw'
              }
            ]
          },
          {
            kind => 'function',
            name => 'parentPlotInitialized',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ],
            reimplements => {
              name => 'parentPlotInitialized'
            },
            reimplemented_by => [
              {
                name => 'parentPlotInitialized'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectionCategory',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QCP::Interaction',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'selectionCategory'
              },
              {
                name => 'selectionCategory'
              },
              {
                name => 'selectionCategory'
              },
              {
                name => 'selectionCategory'
              },
              {
                name => 'selectionCategory'
              }
            ]
          },
          {
            kind => 'function',
            name => 'clipRect',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'clipRect'
              },
              {
                name => 'clipRect'
              },
              {
                name => 'clipRect'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'additive',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              },
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplemented_by => [
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              },
              {
                name => 'selectEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'deselectEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'selectionStateChanged',
                type => 'bool *'
              }
            ],
            reimplemented_by => [
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              },
              {
                name => 'deselectEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'mouseDoubleClickEvent',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This event gets called when the user presses the mouse button a second time in a double-click, while the cursor is over the layerable. Whether a cursor is over the layerable is decided by a preceding call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called instead of the second '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. So in the case of a double-click, the event succession is '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pressEvent - releaseEvent - doubleClickEvent - releaseEvent'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The current pixel position of the cursor on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget is accessible via '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->pos()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. The parameter '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' contains layerable-specific details about the hit, which were generated in the previous call to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. For example, One-dimensional plottables like '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPGraph'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPBars'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' convey the clicked data point in the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'details'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' parameter, as '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPDataSelection'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' packed as QVariant. Multi-part objects convey the specific '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'SelectablePart'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' that was hit (e.g. '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::SelectablePart'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' in the case of axes).Similarly to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mousePressEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', once a layerable has accepted the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseDoubleClickEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', it is considered the mouse grabber and will receive all following calls to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseMoveEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'mouseReleaseEvent'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for this mouse interaction (a "mouse interaction" in this context ends with the release).The default implementation does nothing except explicitly ignoring the event with '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'event->ignore()'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1af6567604818db90f4fd52822f8bc8376',
                      content => 'mousePressEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a9eee1ba47fd69be111059ca3881933e4',
                      content => 'mouseMoveEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1aa0d79b005686f668622bbe66ac03ba2c',
                      content => 'mouseReleaseEvent'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1a47dfd7b8fd99c08ca54e09c362b6f022',
                      content => 'wheelEvent'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'event',
                type => 'QMouseEvent *'
              },
              {
                declaration_name => 'details',
                type => 'const QVariant &'
              }
            ],
            reimplemented_by => [
              {
                name => 'mouseDoubleClickEvent'
              }
            ]
          },
          {
            kind => 'function',
            name => 'initializeParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentPlot',
                type => 'QCustomPlot *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentLayerable',
                type => 'QCPLayerable *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'moveToLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              },
              {
                declaration_name => 'prepend',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'applyAntialiasingHint',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'void',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'painter',
                type => 'QCPPainter *'
              },
              {
                declaration_name => 'localAntialiased',
                type => 'bool'
              },
              {
                declaration_name => 'overrideElement',
                type => 'QCP::AntialiasedElement'
              }
            ]
          }
        ]
      },
      protected_members => {
        members => [
          {
            kind => 'variable',
            name => 'mType',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis::AxisType'
          },
          {
            kind => 'variable',
            name => 'mDataRange',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPRange'
          },
          {
            kind => 'variable',
            name => 'mDataScaleType',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPAxis::ScaleType'
          },
          {
            kind => 'variable',
            name => 'mGradient',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPColorGradient'
          },
          {
            kind => 'variable',
            name => 'mBarWidth',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'int'
          },
          {
            kind => 'variable',
            name => 'mAxisRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPColorScaleAxisRectPrivate >'
          },
          {
            kind => 'variable',
            name => 'mColorAxis',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPAxis >'
          },
          {
            kind => 'variable',
            name => 'mParentLayout',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayout *'
          },
          {
            kind => 'variable',
            name => 'mMinimumSize',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize'
          },
          {
            kind => 'variable',
            name => 'mMaximumSize',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize'
          },
          {
            kind => 'variable',
            name => 'mSizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SizeConstraintRect'
          },
          {
            kind => 'variable',
            name => 'mRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'mOuterRect',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QRect'
          },
          {
            kind => 'variable',
            name => 'mMargins',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins'
          },
          {
            kind => 'variable',
            name => 'mMinimumMargins',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins'
          },
          {
            kind => 'variable',
            name => 'mAutoMargins',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::MarginSides'
          },
          {
            kind => 'variable',
            name => 'mMarginGroups',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< QCP::MarginSide, QCPMarginGroup * >'
          },
          {
            kind => 'variable',
            name => 'mVisible',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          },
          {
            kind => 'variable',
            name => 'mParentPlot',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *'
          },
          {
            kind => 'variable',
            name => 'mParentLayerable',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPointer< QCPLayerable >'
          },
          {
            kind => 'variable',
            name => 'mLayer',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *'
          },
          {
            kind => 'variable',
            name => 'mAntialiased',
            virtualness => 'non_virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool'
          }
        ]
      },
      friend_methods => {
        members => [
          {
            kind => 'friend',
            name => 'QCPColorScaleAxisRectPrivate',
            virtualness => 'non_virtual',
            protection => 'private',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'friend class',
            const => 'no',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      brief => {
        doc => [
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'A color scale for use with color coding data such as '
          },
          {
            type => 'url',
            link => 'classQCPColorMap',
            content => 'QCPColorMap'
          },
          {
            type => 'text',
            content => '. '
          }
        ]
      },
      detailed => {
        doc => [
          {
            type => 'text',
            content => 'This layout element can be placed on the plot to correlate a color gradient with data values. It is usually used in combination with one or multiple '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMaps'
              }
            ]
          },
          {
            type => 'text',
            content => '.'
          },
          {
            type => 'parbreak'
          },
          {
            type => 'text',
            content => 'The color scale can be either horizontal or vertical, as shown in the image above. The orientation and the side where the numbers appear is controlled with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setType'
              }
            ]
          },
          {
            type => 'text',
            content => '.Use '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPColorMap::setColorScale'
              }
            ]
          },
          {
            type => 'text',
            content => ' to connect a color map with a color scale. Once they are connected, they share their gradient, data range and data scale type ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setGradient'
              }
            ]
          },
          {
            type => 'text',
            content => ', '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setDataRange'
              }
            ]
          },
          {
            type => 'text',
            content => ', '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setDataScaleType'
              }
            ]
          },
          {
            type => 'text',
            content => '). Multiple color maps may be associated with a single color scale, to make them all synchronize these properties.To have finer control over the number display and axis behaviour, you can directly access the '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'axis'
              }
            ]
          },
          {
            type => 'text',
            content => '. See the documentation of '
          },
          {
            type => 'url',
            link => 'classQCPAxis',
            content => 'QCPAxis'
          },
          {
            type => 'text',
            content => ' for details about configuring axes. For example, if you want to change the number of automatically generated ticks, call  Placing a color scale next to the main axis rect works like with any other layout element: In this case we have placed it to the right of the default axis rect, so it wasn\'t necessary to call '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setType'
              }
            ]
          },
          {
            type => 'text',
            content => ', since '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxis::atRight'
              }
            ]
          },
          {
            type => 'text',
            content => ' is already the default. The text next to the color scale can be set with '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setLabel'
              }
            ]
          },
          {
            type => 'text',
            content => '.For optimum appearance (like in the image above), it may be desirable to line up the axis rect and the borders of the color scale. Use a '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPMarginGroup'
              }
            ]
          },
          {
            type => 'text',
            content => ' to achieve this:  Color scales are initialized with a non-zero minimum top and bottom margin ('
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setMinimumMargins'
              }
            ]
          },
          {
            type => 'text',
            content => '), because vertical color scales are most common and the minimum top/bottom margin makes sure it keeps some distance to the top/bottom widget border. So if you change to a horizontal color scale by setting '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'setType'
              }
            ]
          },
          {
            type => 'text',
            content => ' to '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxis::atBottom'
              }
            ]
          },
          {
            type => 'text',
            content => ' or '
          },
          {
            type => 'ref',
            content => [
              {
                type => 'text',
                content => 'QCPAxis::atTop'
              }
            ]
          },
          {
            type => 'text',
            content => ', you might want to also change the minimum margins accordingly, e.g. '
          },
          {
            type => 'style',
            style => 'code',
            enable => 'yes'
          },
          {
            type => 'text',
            content => 'setMinimumMargins(QMargins(6, 0, 6, 0))'
          },
          {
            type => 'style',
            style => 'code',
            enable => 'no'
          },
          {
            type => 'text',
            content => '. '
          }
        ]
      }
    },
    {
      name => 'QCPColorScaleAxisRectPrivate',
      base => [
        {
          name => 'QCPAxisRect',
          virtualness => 'non_virtual',
          protection => 'public'
        }
      ],
      includes => {
        local => 'no',
        name => 'qcustomplot.h'
      },
      all_members => [
        {
          name => 'addAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'addAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'antialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyAntialiasingHint',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'applyDefaultAntialiasingHint',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'autoMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'axes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'axes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'axis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'axisCount',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'axisSelectableChanged',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'axisSelectionChanged',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'background',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'backgroundBrush',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'backgroundScaled',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'backgroundScaledMode',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'bottom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'bottomLeft',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'bottomRight',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'calculateAutoMargin',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'calculateAutoMargin',
          virtualness => 'virtual',
          protection => 'protected',
          ambiguity_scope => 'QCPAxisRect::',
          scope => 'QCPAxisRect'
        },
        {
          name => 'center',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'clipRect',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'deselectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'draw',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'drawBackground',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'elements',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'graphs',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'height',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'initializeParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'insetLayout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'items',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'layer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layerChanged',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'layout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'layoutChanged',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'left',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mAADragBackup',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mAntialiased',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'marginGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'marginGroups',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'margins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mAutoMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mAxes',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'maximumOuterSizeHint',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'maximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mBackgroundBrush',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mBackgroundPixmap',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mBackgroundScaled',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mBackgroundScaledMode',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mDragging',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mDragStartHorzRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mDragStartVertRange',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mGradientImage',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'mGradientImageInvalidated',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'minimumMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'minimumOuterSizeHint',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'minimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mInsetLayout',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mMarginGroups',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMaximumSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMinimumMargins',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mMinimumSize',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mNotAADragBackup',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mouseDoubleClickEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'mouseMoveEvent',
          virtualness => 'virtual',
          protection => 'protected',
          ambiguity_scope => 'QCPAxisRect::',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'mousePressEvent',
          virtualness => 'virtual',
          protection => 'protected',
          ambiguity_scope => 'QCPAxisRect::',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'mouseReleaseEvent',
          virtualness => 'virtual',
          protection => 'protected',
          ambiguity_scope => 'QCPAxisRect::',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mOuterRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'moveToLayer',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentColorScale',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'mParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mParentLayout',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mParentPlot',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'mRangeDrag',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeDragHorzAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeDragVertAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoom',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoomFactorHorz',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoomFactorVert',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoomHorzAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRangeZoomVertAxis',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mScaledBackgroundPixmap',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'mSizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'mVisible',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'outerRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'parentLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlot',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'parentPlotInitialized',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'plottables',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'QCPAxisRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'QCPColorScale',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'QCPColorScaleAxisRectPrivate',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'QCPLayerable',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'QCPLayoutElement',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'rangeDrag',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeDragAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeDragAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeZoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeZoomAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeZoomAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'rangeZoomFactor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'realVisibility',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'rect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'removeAxis',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'right',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'scrInnerRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'scrOuterRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'selectEvent',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'selectionCategory',
          virtualness => 'virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'selectTest',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setAntialiased',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setAutoMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setBackground',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setBackground',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setBackground',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setBackgroundScaled',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setBackgroundScaledMode',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setLayer',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'setMarginGroup',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMaximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMaximumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setMinimumSize',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setOuterRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setParentLayerable',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPLayerable'
        },
        {
          name => 'setRangeDrag',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeDragAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeDragAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeDragAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomAxes',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomFactor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setRangeZoomFactor',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setSizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'setupFullAxesBox',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'setVisible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'size',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'sizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'SizeConstraintRect',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'top',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'topLeft',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'topRight',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'update',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'update',
          virtualness => 'virtual',
          protection => 'public',
          ambiguity_scope => 'QCPAxisRect::',
          scope => 'QCPAxisRect'
        },
        {
          name => 'updateAxesOffset',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPAxisRect'
        },
        {
          name => 'updateGradientImage',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'UpdatePhase',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upLayout',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upMargins',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'upPreparation',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        },
        {
          name => 'visible',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => 'wheelEvent',
          virtualness => 'non_virtual',
          protection => 'protected',
          scope => 'QCPColorScaleAxisRectPrivate'
        },
        {
          name => 'wheelEvent',
          virtualness => 'virtual',
          protection => 'protected',
          ambiguity_scope => 'QCPAxisRect::',
          scope => 'QCPAxisRect'
        },
        {
          name => 'width',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'zoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => 'zoom',
          virtualness => 'non_virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => '~QCPAxisRect',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPAxisRect'
        },
        {
          name => '~QCPLayerable',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayerable'
        },
        {
          name => '~QCPLayoutElement',
          virtualness => 'virtual',
          protection => 'public',
          scope => 'QCPLayoutElement'
        }
      ],
      public_typedefs => {
        members => [
          {
            kind => 'enum',
            name => 'UpdatePhase',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Defines the phases of the update process, that happens just before a replot. At each phase, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'update'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is called with the according UpdatePhase value. '
                }
              ]
            },
            values => [
              {
                name => 'upPreparation',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Phase used for any type of preparation that needs to be done before margin calculation and layout. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'upMargins',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Phase in which the margins are calculated and set. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'upLayout',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Final phase in which the layout system places the rects of the elements. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enum',
            name => 'SizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Defines to which rect of a layout element the size constraints that can be set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' apply. The outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') includes the margins (e.g. in the case of a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => ' the axis labels), whereas the inner rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') does not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a361666cdcc6fbfd37344cc44be746b0f',
                      content => 'setSizeConstraintRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            values => [
              {
                name => 'scrInnerRect',
                brief => {
                  doc => [
                    {
                      type => 'text',
                      content => 'Minimum/Maximum size constraints apply to inner rect. '
                    }
                  ]
                },
                detailed => {}
              },
              {
                name => 'scrOuterRect',
                brief => {
                  doc => [
                    {
                      type => 'parbreak'
                    },
                    {
                      type => 'text',
                      content => 'Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. '
                    }
                  ]
                },
                detailed => {}
              }
            ]
          },
          {
            kind => 'enumvalue',
            name => 'upPreparation',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Phase used for any type of preparation that needs to be done before margin calculation and layout. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'upMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Phase in which the margins are calculated and set. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'upLayout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Final phase in which the layout system places the rects of the elements. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'scrInnerRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Minimum/Maximum size constraints apply to inner rect. '
                }
              ]
            },
            detailed => {},
            type => '@'
          },
          {
            kind => 'enumvalue',
            name => 'scrOuterRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Minimum/Maximum size constraints apply to outer rect, thus include layout element margins. '
                }
              ]
            },
            detailed => {},
            type => '@'
          }
        ]
      },
      public_methods => {
        members => [
          {
            kind => 'function',
            name => 'QCPColorScaleAxisRectPrivate',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Creates a new instance, as a child of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'parentColorScale'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'parentColorScale',
                type => 'QCPColorScale *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'background',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QPixmap',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'backgroundBrush',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QBrush',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'backgroundScaled',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'backgroundScaledMode',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::AspectRatioMode',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rangeDrag',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::Orientations',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rangeZoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'Qt::Orientations',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rangeDragAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the range drag axis of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided. If multiple axes were set, returns the first one (use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rangeDragAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to retrieve a list with all set axes).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a648cce336bd99daac4a5ca3e5743775d',
                      content => 'setRangeDragAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPAxis *',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rangeZoomAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the range zoom axis of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided. If multiple axes were set, returns the first one (use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rangeZoomAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to retrieve a list with all set axes).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9442cca2aa358405f39a64d51eca13d2',
                      content => 'setRangeZoomAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPAxis *',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rangeDragAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all range drag axes of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a679c63f2b8daccfe6ec5110dce3dd3b6',
                      content => 'rangeZoomAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9442cca2aa358405f39a64d51eca13d2',
                      content => 'setRangeZoomAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rangeZoomAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all range zoom axes of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a6d7c22cfc54fac7a3d6ef80b133a8574',
                      content => 'rangeDragAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a648cce336bd99daac4a5ca3e5743775d',
                      content => 'setRangeDragAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'rangeZoomFactor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the range zoom factor of the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientation'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provided.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a895d7ac745ea614e04056244b3c138ac',
                      content => 'setRangeZoomFactor'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'double',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientation',
                type => 'Qt::Orientation'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackground',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pm'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as the axis background pixmap. The axis background pixmap will be drawn inside the axis rect. Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds are usually drawn below everything else.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'For cases where the provided pixmap doesn\'t have the same size as the axis rect, scaling can be enabled with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackgroundScaled'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and the scaling mode (i.e. whether and how the aspect ratio is preserved) can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackgroundScaledMode'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. To set all these options in one call, consider using the overloaded version of this function.Below the pixmap, the axis rect may be optionally filled with a brush, if specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackground(const QBrush &brush)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1ae6d36c3e0e968ffb991170a018e7b503',
                      content => 'setBackgroundScaled'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5ef77ea829c9de7ba248e473f48f7305',
                      content => 'setBackgroundScaledMode'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a22a22b8668735438dc06f9a55fe46b33',
                      content => 'setBackground(const QBrush &brush)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pm',
                type => 'const QPixmap &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackground',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Allows setting the background pixmap of the axis rect, whether it shall be scaled and how it shall be scaled in one call.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1af615ab5e52b8e0a9a0eff415b6559db5',
                      content => 'setBackground(const QPixmap &pm)'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1ae6d36c3e0e968ffb991170a018e7b503',
                      content => 'setBackgroundScaled'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5ef77ea829c9de7ba248e473f48f7305',
                      content => 'setBackgroundScaledMode'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pm',
                type => 'const QPixmap &'
              },
              {
                declaration_name => 'scaled',
                type => 'bool'
              },
              {
                declaration_name => 'mode',
                type => 'Qt::AspectRatioMode',
                default_value => 'Qt::KeepAspectRatioByExpanding'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackground',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'brush'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as the background brush. The axis rect background will be filled with this brush. Since axis rects place themselves on the "background" layer by default, the axis rect backgrounds are usually drawn below everything else.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The brush will be drawn before (under) any background pixmap, which may be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackground(const QPixmap &pm)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.To disable drawing of a background brush, set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'brush'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to Qt::NoBrush.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1af615ab5e52b8e0a9a0eff415b6559db5',
                      content => 'setBackground(const QPixmap &pm)'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'brush',
                type => 'const QBrush &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackgroundScaled',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether the axis background pixmap shall be scaled to fit the axis rect or not. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'scaled'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is set to true, you may control whether and how the aspect ratio of the original pixmap is preserved with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackgroundScaledMode'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Note that the scaled version of the original pixmap is buffered, so there is no performance penalty on replots. (Except when the axis rect dimensions are changed continuously.)'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1af615ab5e52b8e0a9a0eff415b6559db5',
                      content => 'setBackground'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5ef77ea829c9de7ba248e473f48f7305',
                      content => 'setBackgroundScaledMode'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'scaled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setBackgroundScaledMode',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'If scaling of the axis background pixmap is enabled ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackgroundScaled'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), use this function to define whether and how the aspect ratio of the original pixmap passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setBackground'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is preserved. '
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1af615ab5e52b8e0a9a0eff415b6559db5',
                      content => 'setBackground'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1ae6d36c3e0e968ffb991170a018e7b503',
                      content => 'setBackgroundScaled'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'mode',
                type => 'Qt::AspectRatioMode'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeDrag',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets which axis orientation may be range dragged by the user with mouse interaction. What orientation corresponds to which specific axis can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. By default, the horizontal axis is the bottom axis (xAxis) and the vertical axis is the left axis (yAxis).To disable range dragging entirely, pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' or remove '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeDrag'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' from '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. To enable range dragging for both directions, pass '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'Qt::Horizontal | Qt::Vertical'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.In addition to setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to a non-zero value, make sure '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeDrag'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to enable the range dragging interaction.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a7960a9d222f1c31d558b064b60f86a31',
                      content => 'setRangeZoom'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a648cce336bd99daac4a5ca3e5743775d',
                      content => 'setRangeDragAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a775bdcb6329d44701aeaa6135b0e5265',
                      content => 'QCustomPlot::setNoAntialiasingOnDrag'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientations',
                type => 'Qt::Orientations'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets which axis orientation may be zoomed by the user with the mouse wheel. What orientation corresponds to which specific axis can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoomAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '('
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' *horizontal, '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' *vertical). By default, the horizontal axis is the bottom axis (xAxis) and the vertical axis is the left axis (yAxis).To disable range zooming entirely, pass 0 as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' or remove '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeZoom'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' from '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. To enable range zooming for both directions, pass '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'Qt::Horizontal | Qt::Vertical'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' as '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.In addition to setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'orientations'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to a non-zero value, make sure '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCustomPlot::setInteractions'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' contains '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCP::iRangeZoom'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to enable the range zooming interaction.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a895d7ac745ea614e04056244b3c138ac',
                      content => 'setRangeZoomFactor'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9442cca2aa358405f39a64d51eca13d2',
                      content => 'setRangeZoomAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1ae6aef2f7211ba6097c925dcd26008418',
                      content => 'setRangeDrag'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'orientations',
                type => 'Qt::Orientations'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeDragAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the axes whose range will be dragged when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeDrag'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' enables mouse range dragging on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget. Pass 0 if no axis shall be dragged in the respective orientation.Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall react to dragging interactions.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a9442cca2aa358405f39a64d51eca13d2',
                      content => 'setRangeZoomAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontal',
                type => 'QCPAxis *'
              },
              {
                declaration_name => 'vertical',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeDragAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method allows to set up multiple axes to react to horizontal and vertical dragging. The drag orientation that the respective axis will react to is deduced from its orientation ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::orientation'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').In the unusual case that you wish to e.g. drag a vertically oriented axis with a horizontal drag motion, use the overload taking two separate lists for horizontal and vertical dragging. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axes',
                type => 'QList< QCPAxis *>'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeDragAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method allows to set multiple axes up to react to horizontal and vertical dragging, and define specifically which axis reacts to which drag orientation (irrespective of the axis orientation). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontal',
                type => 'QList< QCPAxis *>'
              },
              {
                declaration_name => 'vertical',
                type => 'QList< QCPAxis *>'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the axes whose range will be zoomed when '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoom'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' enables mouse wheel zooming on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' widget. Pass 0 if no axis shall be zoomed in the respective orientation.The two axes can be zoomed with different strengths, when different factors are passed to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoomFactor(double horizontalFactor, double verticalFactor)'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Use the overload taking a list of axes, if multiple axes (more than one per orientation) shall react to zooming interactions.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a648cce336bd99daac4a5ca3e5743775d',
                      content => 'setRangeDragAxes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontal',
                type => 'QCPAxis *'
              },
              {
                declaration_name => 'vertical',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method allows to set up multiple axes to react to horizontal and vertical range zooming. The zoom orientation that the respective axis will react to is deduced from its orientation ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::orientation'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').In the unusual case that you wish to e.g. zoom a vertically oriented axis with a horizontal zoom interaction, use the overload taking two separate lists for horizontal and vertical zooming. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axes',
                type => 'QList< QCPAxis *>'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method allows to set multiple axes up to react to horizontal and vertical zooming, and define specifically which axis reacts to which zoom orientation (irrespective of the axis orientation). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontal',
                type => 'QList< QCPAxis *>'
              },
              {
                declaration_name => 'vertical',
                type => 'QList< QCPAxis *>'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomFactor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets how strong one rotation step of the mouse wheel zooms, when range zoom was activated with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoom'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. The two parameters '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'horizontalFactor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'verticalFactor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' provide a way to let the horizontal axis zoom at different rates than the vertical axis. Which axis is horizontal and which is vertical, can be set with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setRangeZoomAxes'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.When the zoom factor is greater than one, scrolling the mouse wheel backwards (towards the user) will zoom in (make the currently visible range smaller). For zoom factors smaller than one, the same scrolling direction will zoom out. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'horizontalFactor',
                type => 'double'
              },
              {
                declaration_name => 'verticalFactor',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setRangeZoomFactor',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets both the horizontal and vertical zoom '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'factor'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'factor',
                type => 'double'
              }
            ]
          },
          {
            kind => 'function',
            name => 'axisCount',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the number of axes on the axis rect side specified with '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a583ae4f6d78b601b732183f6cabecbe1',
                      content => 'axis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'QCPAxis::AxisType'
              }
            ]
          },
          {
            kind => 'function',
            name => 'axis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the axis with the given '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'index'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' on the axis rect side specified with '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a85b321acec0f694d8b5fdeafdbff3133',
                      content => 'axisCount'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a8db4722cb93e9c4a6f0d91150c200867',
                      content => 'axes'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPAxis *',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'QCPAxis::AxisType'
              },
              {
                declaration_name => 'index',
                type => 'int',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'axes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns all axes on the axis rect sides specified with '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'types'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'types'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' may be a single '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::AxisType'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' or an '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'or'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '-combination, to get the axes of multiple sides.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a583ae4f6d78b601b732183f6cabecbe1',
                      content => 'axis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'types',
                type => 'QCPAxis::AxisTypes'
              }
            ]
          },
          {
            kind => 'function',
            name => 'axes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns all axes of this axis rect. '
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'addAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds a new axis to the axis rect side specified with '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', and returns it. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, a new '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' instance is created internally. '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' owns the returned axis, so if you want to remove an axis, use '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'removeAxis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' instead of deleting it manually.You may inject '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ' instances (or subclasses of '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis',
                  content => 'QCPAxis'
                },
                {
                  type => 'text',
                  content => ') by setting '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to an axis that was previously created outside '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => '. It is important to note that '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' takes ownership of the axis, so you may not delete it afterwards. Further, the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' must have been created with this axis rect as parent and with the same axis type as specified in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'type'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. If this is not the case, a debug output is generated, the axis is not added, and the method returns 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This method can not be used to move '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' between axis rects. The same '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' instance must not be added multiple times to the same or different axis rects.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If an axis rect side already contains one or more axes, the lower and upper endings of the new axis ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setLowerEnding'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setUpperEnding'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') are set to '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLineEnding::esHalfBar'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a792e1f3d9cb1591fca135bb0de9b81fc',
                      content => 'addAxes'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5fa906175447b14206954f77fc7f1ef4',
                      content => 'setupFullAxesBox'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPAxis *',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'type',
                type => 'QCPAxis::AxisType'
              },
              {
                declaration_name => 'axis',
                type => 'QCPAxis *',
                default_value => '0'
              }
            ]
          },
          {
            kind => 'function',
            name => 'addAxes',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Adds a new axis with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'addAxis'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to each axis rect side specified in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'types'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. This may be an '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'or'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '-combination of '
                },
                {
                  type => 'url',
                  link => 'classQCPAxis_1ae2bcc1728b382f10f064612b368bc18a',
                  content => 'QCPAxis::AxisType'
                },
                {
                  type => 'text',
                  content => ', so axes can be added to multiple sides at once.Returns a list of the added axes.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a2dc336092ccc57d44a46194c8a23e4f4',
                      content => 'addAxis'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a5fa906175447b14206954f77fc7f1ef4',
                      content => 'setupFullAxesBox'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAxis * >',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'types',
                type => 'QCPAxis::AxisTypes'
              }
            ]
          },
          {
            kind => 'function',
            name => 'removeAxis',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Removes the specified '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' from the axis rect and deletes it.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'axis'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' was a valid axis in this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a2dc336092ccc57d44a46194c8a23e4f4',
                      content => 'addAxis'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'axis',
                type => 'QCPAxis *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'insetLayout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the inset layout of this axis rect. It can be used to place other layout elements (or even layouts with multiple other elements) inside/on top of an axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutInset',
                      content => 'QCPLayoutInset'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QCPLayoutInset *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'zoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Zooms in (or out) to the passed rectangular region '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pixelRect'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', given in pixel coordinates.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'All axes of this axis rect will have their range zoomed accordingly. If you only wish to zoom specific axes, use the overloaded version of this method.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a810ef958ebe84db661c7288b526c0deb',
                      content => 'QCustomPlot::setSelectionRectMode'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pixelRect',
                type => 'const QRectF &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'zoom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Zooms in (or out) to the passed rectangular region '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pixelRect'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', given in pixel coordinates.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Only the axes passed in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'affectedAxes'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' will have their ranges zoomed accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCustomPlot_1a810ef958ebe84db661c7288b526c0deb',
                      content => 'QCustomPlot::setSelectionRectMode'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pixelRect',
                type => 'const QRectF &'
              },
              {
                declaration_name => 'affectedAxes',
                type => 'const QList< QCPAxis *> &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setupFullAxesBox',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Convenience function to create an axis on each side that doesn\'t have any axes yet and set their visibility to true. Further, the top/right axes are assigned the following properties of the bottom/left axes:'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'list',
                  style => 'itemized',
                  content => [
                    [
                      {
                        type => 'text',
                        content => 'range ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setRange'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'range reversed ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setRangeReversed'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'scale type ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setScaleType'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'tick visibility ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setTicks'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'number format ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setNumberFormat'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'number precision ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxis::setNumberPrecision'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'tick count of ticker ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxisTicker::setTickCount'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ') '
                      }
                    ],
                    [
                      {
                        type => 'text',
                        content => 'tick origin of ticker ('
                      },
                      {
                        type => 'ref',
                        content => [
                          {
                            type => 'text',
                            content => 'QCPAxisTicker::setTickOrigin'
                          }
                        ]
                      },
                      {
                        type => 'text',
                        content => ')'
                      }
                    ]
                  ]
                },
                {
                  type => 'text',
                  content => 'Tick label visibility ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setTickLabels'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') of the right and top axes are set to false.If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'connectRanges'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rangeChanged'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' signals of the bottom and left axes are connected to the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxis::setRange'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' slots of the top and right axes. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'connectRanges',
                type => 'bool',
                default_value => 'false'
              }
            ]
          },
          {
            kind => 'function',
            name => 'plottables',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all the plottables that are associated with this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A plottable is considered associated with an axis rect if its key or value axis (or both) is in this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a2d9ded3eca97be1fcb5867949391bb88',
                      content => 'graphs'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a03c113a2175448300ee8f944e24776ba',
                      content => 'items'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAbstractPlottable * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'graphs',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all the graphs that are associated with this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A graph is considered associated with an axis rect if its key or value axis (or both) is in this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a587d073a97b27bc7293fab4b2774ad59',
                      content => 'plottables'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a03c113a2175448300ee8f944e24776ba',
                      content => 'items'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPGraph * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'items',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns a list of all the items that are associated with this axis rect.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'An item is considered associated with an axis rect if any of its positions has key or value axis set to an axis that is in this axis rect, or if any of its positions has '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPItemPosition::setAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' set to the axis rect, or if the clip axis rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAbstractItem::setClipAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') is set to this axis rect.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a587d073a97b27bc7293fab4b2774ad59',
                      content => 'plottables'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPAxisRect_1a2d9ded3eca97be1fcb5867949391bb88',
                      content => 'graphs'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QList< QCPAbstractItem * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'left',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the pixel position of the left border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'right',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel position of the right border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'top',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel position of the top border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'bottom',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel position of the bottom border of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'width',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel width of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'height',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel height of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'int',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'size',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the pixel size of this axis rect. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'topLeft',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the top left corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'topRight',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the top right corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'bottomLeft',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the bottom left corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'bottomRight',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the bottom right corner of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'center',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the center of this axis rect in pixels. Margins are not taken into account here, so the returned value is with respect to the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'QPoint',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'update',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'This method is called automatically upon replot and doesn\'t need to be called by users of '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Calls the base class implementation to update the margins (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement::update'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), and finally passes the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to the inset layout ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'insetLayout'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') and calls its QCPInsetLayout::update function.'
                }
              ]
            },
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'phase',
                type => 'UpdatePhase'
              }
            ],
            reimplements => {
              name => 'update'
            }
          },
          {
            kind => 'function',
            name => 'elements',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns a list of all child elements in this layout element. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'recursive'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, all sub-child elements are included in the list, too.'
                },
                {
                  type => 'parbreak'
                },
                {
                  warning => [
                    {
                      type => 'text',
                      content => 'There may be entries with value 0 in the returned list. (For example, '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutGrid',
                      content => 'QCPLayoutGrid'
                    },
                    {
                      type => 'text',
                      content => ' may have empty cells which yield 0 at the respective index.) '
                    }
                  ]
                }
              ]
            },
            type => 'virtual QList< QCPLayoutElement * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'recursive',
                type => 'bool'
              }
            ],
            reimplements => {
              name => 'elements'
            }
          },
          {
            kind => 'function',
            name => 'layout',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the parent layout of this layout element. '
                }
              ]
            },
            type => 'QCPLayout *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'rect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the inner rect of this layout element. The inner rect is the outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') shrinked by the margins ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').In some cases, the area between outer and inner rect is left blank. In other cases the margin area is used to display peripheral graphics while the main content is in the inner rect. This is where automatic margin calculation becomes interesting because it allows the layout element to adapt the margins to the peripheral graphics it wants to draw. For example, '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPAxisRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' draws the axis labels and tick labels in the margin area, thus needs to adjust the margins (if '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is enabled) according to the space required by the labels of the axes.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a2a32a12a6161c9dffbadeb9cc585510c',
                      content => 'outerRect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'outerRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the outer rect of this layout element. The outer rect is the inner rect expanded by the margins ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ', '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). The outer rect is used (and set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') by the parent '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' to control the size of this layout element.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a208effccfe2cca4a0eaf9393e60f2dd4',
                      content => 'rect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'QRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'margins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'minimumMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QMargins',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'autoMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCP::MarginSides',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'minimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'maximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'sizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'SizeConstraintRect',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'marginGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPMarginGroup *',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'side',
                type => 'QCP::MarginSide'
              }
            ]
          },
          {
            kind => 'function',
            name => 'marginGroups',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QHash< QCP::MarginSide, QCPMarginGroup * >',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setOuterRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the outer rect of this layout element. If the layout element is inside a layout, the layout sets the position and size of this layout element using this function.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Calling this function externally has no effect, since the layout will overwrite any changes to the outer rect upon the next replot.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The layout element will adapt its inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' by applying the margins inward to the outer rect.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a208effccfe2cca4a0eaf9393e60f2dd4',
                      content => 'rect'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'rect',
                type => 'const QRect &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the margins of this layout element. If '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is disabled for some or all sides, this function is used to manually set the margin on those sides. Sides that are still set to be handled automatically are ignored and may have any value in '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'margins'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.The margin is the distance between the outer rect (controlled by the parent layout via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setOuterRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') and the inner '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (which usually contains the main content of this layout element).'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1accfda49994e3e6d51ed14504abf9d27d',
                      content => 'setAutoMargins'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'margins',
                type => 'const QMargins &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' is enabled on some or all margins, this function is used to provide minimum values for those margins.The minimum values are not enforced on margin sides that were set to be under manual control via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1accfda49994e3e6d51ed14504abf9d27d',
                      content => 'setAutoMargins'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'margins',
                type => 'const QMargins &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAutoMargins',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets on which sides the margin shall be calculated automatically. If a side is calculated automatically, a minimum margin value may be provided with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. If a side is set to be controlled manually, the value may be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.Margin sides that are under automatic control may participate in a '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), to synchronize (align) it with other layout elements in the plot.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a0a8a17abc16b7923159fcc7608f94673',
                      content => 'setMinimumMargins'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a8f450b1f3f992ad576fce2c63d8b79cf',
                      content => 'setMargins'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54',
                      content => 'QCP::MarginSide'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sides',
                type => 'QCP::MarginSides'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the minimum size of this layout element. A parent layout tries to respect the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' here by changing row/column sizes in the layout accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If the parent layout size is not sufficient to satisfy all minimum size constraints of its child layout elements, the layout may set a size that is actually smaller than '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' propagates the layout\'s size constraints to the outside by setting its own minimum QWidget size accordingly, so violations of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' should be exceptions.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMinimumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the minimum size of this layout element.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'int'
              },
              {
                declaration_name => 'height',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMaximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the maximum size of this layout element. A parent layout tries to respect the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'size'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' here by changing row/column sizes in the layout accordingly.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'size',
                type => 'const QSize &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMaximumSize',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the maximum size of this layout element.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Whether this constraint applies to the inner or the outer rect can be specified with '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setSizeConstraintRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' (see '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '). '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'width',
                type => 'int'
              },
              {
                declaration_name => 'height',
                type => 'int'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setSizeConstraintRect',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets to which rect of a layout element the size constraints apply. Size constraints can be set via '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.The outer rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') includes the margins (e.g. in the case of a '
                },
                {
                  type => 'url',
                  link => 'classQCPAxisRect',
                  content => 'QCPAxisRect'
                },
                {
                  type => 'text',
                  content => ' the axis labels), whereas the inner rect ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'rect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') does not.'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a5dd29a3c8bc88440c97c06b67be7886b',
                      content => 'setMinimumSize'
                    },
                    {
                      type => 'text',
                      content => ', '
                    },
                    {
                      type => 'url',
                      link => 'classQCPLayoutElement_1a74eb5280a737ab44833d506db65efd95',
                      content => 'setMaximumSize'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'constraintRect',
                type => 'SizeConstraintRect'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setMarginGroup',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the margin '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'group'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of the specified margin '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sides'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Margin groups allow synchronizing specified margins across layout elements, see the documentation of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPMarginGroup'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '.To unset the margin group of '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'sides'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ', set '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'group'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' to 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that margin groups only work for margin sides that are set to automatic ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setAutoMargins'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ').'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'namespaceQCP_1a7e487e3e2ccb62ab7771065bab7cae54',
                      content => 'QCP::MarginSide'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'sides',
                type => 'QCP::MarginSides'
              },
              {
                declaration_name => 'group',
                type => 'QCPMarginGroup *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'minimumOuterSizeHint',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the suggested minimum size this layout element (the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') may be compressed to, if no manual minimum size is set.if a minimum size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMinimumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') was not set manually, parent layouts use the returned size (usually indirectly through '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout::getFinalMinimumOuterSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to determine the minimum allowed size of this layout element.A manual minimum size is considered set if it is non-zero.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height. Reimplementations may use their detailed knowledge about the layout element\'s content to provide size hints. '
                }
              ]
            },
            type => 'virtual QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'minimumOuterSizeHint'
              },
              {
                name => 'minimumOuterSizeHint'
              },
              {
                name => 'minimumOuterSizeHint'
              }
            ]
          },
          {
            kind => 'function',
            name => 'maximumOuterSizeHint',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns the suggested maximum size this layout element (the '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'outerRect'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') may be expanded to, if no manual maximum size is set.if a maximum size ('
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'setMaximumSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') was not set manually, parent layouts use the returned size (usually indirectly through '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayout::getFinalMaximumOuterSize'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ') to determine the maximum allowed size of this layout element.A manual maximum size is considered set if it is smaller than Qt\'s '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QWIDGETSIZE_MAX'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'The default implementation simply returns '
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'QWIDGETSIZE_MAX'
                },
                {
                  type => 'style',
                  style => 'code',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' for both width and height, implying no suggested maximum size. Reimplementations may use their detailed knowledge about the layout element\'s content to provide size hints. '
                }
              ]
            },
            type => 'virtual QSize',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ],
            reimplemented_by => [
              {
                name => 'maximumOuterSizeHint'
              },
              {
                name => 'maximumOuterSizeHint'
              }
            ]
          },
          {
            kind => 'function',
            name => 'selectTest',
            virtualness => 'virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Layout elements are sensitive to events inside their outer rect. If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'pos'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is within the outer rect, this method returns a value corresponding to 0.99 times the parent plot\'s selection tolerance. However, layout elements are not selectable by default. So if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'onlySelectable'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is true, -1.0 is returned.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'See '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayerable::selectTest'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' for a general explanation of this virtual method.'
                },
                {
                  type => 'url',
                  link => 'classQCPLayoutElement',
                  content => 'QCPLayoutElement'
                },
                {
                  type => 'text',
                  content => ' subclasses may reimplement this method to provide more specific selection test behaviour. '
                }
              ]
            },
            type => 'virtual double',
            const => 'yes',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'pos',
                type => 'const QPointF &'
              },
              {
                declaration_name => 'onlySelectable',
                type => 'bool'
              },
              {
                declaration_name => 'details',
                type => 'QVariant *',
                default_value => '0'
              }
            ],
            reimplements => {
              name => 'selectTest'
            },
            reimplemented_by => [
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              },
              {
                name => 'selectTest'
              }
            ]
          },
          {
            kind => 'function',
            name => 'visible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentPlot',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCustomPlot *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'parentLayerable',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns the parent layerable of this layerable. The parent layerable is used to provide visibility hierarchies in conjunction with the method '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '. This way, layerables only get drawn if their parent layerables are visible, too.Note that a parent layerable is not necessarily also the QObject parent for memory management. Further, a layerable doesn\'t always have a parent layerable, so this function may return 0.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'A parent layerable is set implicitly when placed inside layout elements and doesn\'t need to be set manually by the user. '
                }
              ]
            },
            type => 'QCPLayerable *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'layer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'QCPLayer *',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'antialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          },
          {
            kind => 'function',
            name => 'setVisible',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot',
                  content => 'QCustomPlot'
                },
                {
                  type => 'text',
                  content => ' surface, and user interaction with it (e.g. click and selection) is not possible. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'on',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets the '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' of this layerable object. The object will be placed on top of the other objects already on '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is 0, this layerable will not be on any layer and thus not appear in the plot (or interact/receive events).'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true if the layer of this layerable was successfully changed to '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layer'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'Q_SLOT bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layer',
                type => 'QCPLayer *'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setLayer',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Esse  um mtodo provido por convenincia. Ele difere do mtodo acima apenas na lista de argumentos que devem ser utilizados. Sets the layer of this layerable object by name'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Returns true on success, i.e. if '
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'yes'
                },
                {
                  type => 'text',
                  content => 'layerName'
                },
                {
                  type => 'style',
                  style => 'italic',
                  enable => 'no'
                },
                {
                  type => 'text',
                  content => ' is a valid layer name. '
                }
              ]
            },
            type => 'bool',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'layerName',
                type => 'const QString &'
              }
            ]
          },
          {
            kind => 'function',
            name => 'setAntialiased',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Sets whether this object will be drawn antialiased or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'Note that antialiasing settings may be overridden by '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1af6f91e5eab1be85f67c556e98c3745e8',
                  content => 'QCustomPlot::setAntialiasedElements'
                },
                {
                  type => 'text',
                  content => ' and '
                },
                {
                  type => 'url',
                  link => 'classQCustomPlot_1ae10d685b5eabea2999fb8775ca173c24',
                  content => 'QCustomPlot::setNotAntialiasedElements'
                },
                {
                  type => 'text',
                  content => '. '
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'enabled',
                type => 'bool'
              }
            ]
          },
          {
            kind => 'function',
            name => 'realVisibility',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'text',
                  content => 'Returns whether this layerable is visible, taking the visibility of the layerable parent and the visibility of this layerable\'s layer into account. This is the method that is consulted to decide whether a layerable shall be drawn or not.'
                },
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'If this layerable has a direct layerable parent (usually set via hierarchies implemented in subclasses, like in the case of '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'QCPLayoutElement'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => '), this function returns true only if this layerable has its visibility set to true and the parent layerable\'s '
                },
                {
                  type => 'ref',
                  content => [
                    {
                      type => 'text',
                      content => 'realVisibility'
                    }
                  ]
                },
                {
                  type => 'text',
                  content => ' returns true. '
                }
              ]
            },
            type => 'bool',
            const => 'yes',
            volatile => 'no',
            parameters => [
            ]
          }
        ]
      },
      signals => {
        members => [
          {
            kind => 'signal',
            name => 'layerChanged',
            virtualness => 'non_virtual',
            protection => 'public',
            static => 'no',
            brief => {},
            detailed => {
              doc => [
                {
                  type => 'parbreak'
                },
                {
                  type => 'text',
                  content => 'This signal is emitted when the layer of this layerable changes, i.e. this layerable is moved to a different layer.'
                },
                {
                  type => 'parbreak'
                },
                {
                  see => [
                    {
                      type => 'url',
                      link => 'classQCPLayerable_1ab0d0da6d2de45a118886d2c8e16d5a54',
                      content => 'setLayer'
                    },
                    {
                      type => 'text',
                      content => ' '
                    }
                  ]
                }
              ]
            },
            type => 'void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_name => 'newLayer',
                type => 'QCPLayer *'
              }
            ]
          }
        ]
      },
      protected_methods => {
        members => [
          {
            kind => 'function',
            name => 'draw',
            virtualness => 'virtual',
            protection => 'protected',
            static => 'no',
            brief => {},
            detailed => {},
            type => 'virtual void',
            const => 'no',
            volatile => 'no',
            parameters => [
              {
                declaration_